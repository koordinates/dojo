dojo.provide("dojox.charting.plot2d.ClusteredColumns");

dojo.require("dojox.charting.plot2d.common");
dojo.require("dojox.charting.plot2d.Columns");

dojo.require("dojox.lang.functional");

(function(){
	var df = dojox.lang.functional, dc = dojox.charting.plot2d.common,
		purgeGroup = df.lambda("item.purgeGroup()");

	dojo.declare("dojox.charting.plot2d.ClusteredColumns", dojox.charting.plot2d.Columns, {
		render: function(dim, offsets){
			if(this.dirty){
				dojo.forEach(this.series, purgeGroup);
				this.cleanGroup();
				var s = this.group;
				df.forEachReversed(this.series, function(item){ item.cleanGroup(s); });
			}
			var t = this.chart.theme, color, stroke, fill, f,
				gap = this.opt.gap < this._hScaler.scale / 3 ? this.opt.gap : 0,
				thickness = (this._hScaler.scale - 2 * gap) / this.series.length;
			for(var i = 0; i < this.series.length; ++i){
				var run = this.series[i];
				if(!this.dirty && !run.dirty){ continue; }
				run.cleanGroup();
				var s = run.group;
				if(!run.fill || !run.stroke){
					// need autogenerated color
					color = new dojo.Color(t.next("color"));
				}
				stroke = run.stroke ? run.stroke : dc.augmentStroke(t.series.stroke, color);
				fill = run.fill ? run.fill : dc.augmentFill(t.series.fill, color);
				for(var j = 0; j < run.data.length; ++j){
					var v = run.data[j],
						width  = thickness,
						height = this._vScaler.scale * (v - this._vScaler.bounds.lower);
					if(width >= 1 && height >= 1){
						s.createRect({
							x: offsets.l + this._hScaler.scale * (j + 0.5 - this._hScaler.bounds.lower) + gap + thickness * i,
							y: dim.height - offsets.b - this._vScaler.scale * (v - this._vScaler.bounds.lower),
							width: width, height: height
						}).setFill(fill).setStroke(stroke);
					}
				}
				run.dirty = false;
			}
			this.dirty = false;
			return this;
		}
	});
})();
