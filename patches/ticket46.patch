Index: src/widget/Parse.js
===================================================================
--- src/widget/Parse.js	(revision 1238)
+++ src/widget/Parse.js	(working copy)
@@ -26,7 +26,7 @@
 				var ltn = dojo.text.trim(tna[x]).toLowerCase();
 				if(djTags[ltn]){
 					fragment.tagName = ltn;
-					returnValue.push(djTags[ltn](fragment, this, parentComp));
+					returnValue.push(djTags[ltn](fragment, this, parentComp, count++));
 				}else{
 					if(ltn.substr(0, 5)=="dojo:"){
 						dj_debug("no tag handler registed for type: ", ltn);
@@ -35,6 +35,7 @@
 			}
 		}*/
 		for(var item in fragment){
+			var count = 0;
 			var built = false;
 			// if we have items to parse/create at this level, do it!
 			try{
@@ -50,7 +51,7 @@
 							built = true;
 							// var tic = new Date();
 							fragment[item].tagName = ltn;
-							returnValue.push(djTags[ltn](fragment[item], this, parentComp));
+							returnValue.push(djTags[ltn](fragment[item], this, parentComp, count++));
 						}else{
 							if(ltn.substr(0, 5)=="dojo:"){
 								dj_debug("no tag handler registed for type: ", ltn);
Index: src/widget/DomWidget.js
===================================================================
--- src/widget/DomWidget.js	(revision 1238)
+++ src/widget/DomWidget.js	(working copy)
@@ -233,7 +233,7 @@
 
 	// FIXME: should we support addition at an index in the children arr and
 	// order the display accordingly? Right now we always append.
-	addChild: function(widget, overrideContainerNode, pos, ref){ 
+	addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){ 
 		// var start = new Date();
 		if(!this.isContainer){ // we aren't allowed to contain other widgets, it seems
 			dj_debug("dojo.widget.DomWidget.addChild() attempted on non-container widget");
@@ -245,10 +245,11 @@
 			var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
 			if(!pos){ pos = "after"; }
 			if(!ref){ ref = cn.lastChild; }
+			if(!insertIndex) { insertIndex = 0; }
 			if(!ref){
 				cn.appendChild(widget.domNode);
 			}else{
-				dojo.xml.domUtil[pos](widget.domNode, ref);
+				dojo.xml.domUtil[pos](widget.domNode, ref, insertIndex);
 			}
 			// dj_debug(this.widgetId, "added", widget.widgetId, "as a child");
 			this.children.push(widget);
@@ -272,7 +273,10 @@
 	
 	postInitialize: function(args, frag, parentComp){
 		if(parentComp){
-			parentComp.addChild(this);
+			if(args["locationIndex"]) {
+				
+			}
+			parentComp.addChild(this, "", "insertAtIndex", "",  args["dojoinsertionindex"]);
 		}else{
 			if(!frag){ return; }
 			var sourceNodeRef = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
Index: src/widget/Widget.js
===================================================================
--- src/widget/Widget.js	(revision 1238)
+++ src/widget/Widget.js	(working copy)
@@ -345,8 +345,8 @@
 dojo.widget.tags = {};
 dojo.widget.tags.addParseTreeHandler = function(type){
 	var ltype = type.toLowerCase();
-	this[ltype] = function(fragment, widgetParser, parentComp){ 
-		return dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp);
+	this[ltype] = function(fragment, widgetParser, parentComp, insertionIndex){ 
+		return dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp, insertionIndex);
 	}
 }
 
@@ -362,7 +362,7 @@
 	var properties = widgetParser.parseProperties(fragment["dojo:connect"]);
 }
 
-dojo.widget.buildWidgetFromParseTree = function(type, frag, parser, parentComp){
+dojo.widget.buildWidgetFromParseTree = function(type, frag, parser, parentComp, insertionIndex){
 	var stype = type.split(":");
 	stype = (stype.length == 2) ? stype[1] : type;
 	// outputObjectInfo(frag["dojo:"+stype]);
@@ -378,5 +378,6 @@
 	} else if (!twidget.create) {
 		throw new Error("\"" + stype + "\" widget object does not appear to implement *Widget");
 	}
+	localProperties["dojoinsertionindex"] = insertionIndex;
 	return twidget.create(localProperties, frag, parentComp);
 }
Index: src/xml/domUtil.js
===================================================================
--- src/xml/domUtil.js	(revision 1238)
+++ src/xml/domUtil.js	(working copy)
@@ -291,6 +291,17 @@
 				ref.appendChild(node);
 				break;
 		}
+		
+		this.insertAtIndex = function(node, ref, insertionIndex) {
+			var pn = ref.parentNode;
+			var siblingNodes = pn.childNodes;
+			for(var i=0; i<siblingNodes.length; i++) {
+				if(siblingNodes.item(i).getAttribute("dojoinsertionindex") > insertionIndex) {
+					this.insertBefore(node, ref);
+					break;
+				}
+			}
+		}
 	}
 	
 	/**
