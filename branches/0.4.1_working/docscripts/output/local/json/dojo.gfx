{"dojo.gfx.Colorspace":{"meta":{"requires":{"common":["dojo.lang.common","dojo.math.matrix"]},"functions":{"dojo.gfx.Colorspace":{"meta":{"summary":"An object for dealing with colorspace conversions.","src":" this.whitePoint = 'D65';\n\tthis.stdObserver = '10';\n\tthis.chromaticAdaptationAlg = 'bradford';\n\tthis.RGBWorkingSpace = 's_rgb';\n\tthis.useApproxCIELabMapping = 1; \/\/ see http:\/\/www.brucelindbloom.com\/LContinuity.html\n\tthis.chainMaps = {\n\t\t'RGB_to_xyY'  : ['XYZ'],\n\t\t'xyY_to_RGB'  : ['XYZ'],\n\t\t'RGB_to_Lab'  : ['XYZ'],\n\t\t'Lab_to_RGB'  : ['XYZ'],\n\t\t'RGB_to_LCHab': ['XYZ', 'Lab'],\n\t\t'LCHab_to_RGB': ['Lab'],\n\t\t'xyY_to_Lab'  : ['XYZ'],\n\t\t'Lab_to_xyY'  : ['XYZ'],\n\t\t'XYZ_to_LCHab': ['Lab'],\n\t\t'LCHab_to_XYZ': ['Lab'],\n\t\t'xyY_to_LCHab': ['XYZ', 'Lab'],\n\t\t'LCHab_to_xyY': ['Lab', 'XYZ'],\n\t\t'RGB_to_Luv'  : ['XYZ'],\n\t\t'Luv_to_RGB'  : ['XYZ'],\n\t\t'xyY_to_Luv'  : ['XYZ'],\n\t\t'Luv_to_xyY'  : ['XYZ'],\n\t\t'Lab_to_Luv'  : ['XYZ'],\n\t\t'Luv_to_Lab'  : ['XYZ'],\n\t\t'LCHab_to_Luv': ['Lab', 'XYZ'],\n\t\t'Luv_to_LCHab': ['XYZ', 'Lab'],\n\t\t'RGB_to_LCHuv'  : ['XYZ', 'Luv'],\n\t\t'LCHuv_to_RGB'  : ['Luv', 'XYZ'],\n\t\t'XYZ_to_LCHuv'  : ['Luv'],\n\t\t'LCHuv_to_XYZ'  : ['Luv'],\n\t\t'xyY_to_LCHuv'  : ['XYZ', 'Luv'],\n\t\t'LCHuv_to_xyY'  : ['Luv', 'XYZ'],\n\t\t'Lab_to_LCHuv'  : ['XYZ', 'Luv'],\n\t\t'LCHuv_to_Lab'  : ['Luv', 'XYZ'],\n\t\t'LCHab_to_LCHuv': ['Lab', 'XYZ', 'Luv'],\n\t\t'LCHuv_to_LCHab': ['Luv', 'XYZ', 'Lab'],\n\t\t'XYZ_to_CMY'    : ['RGB'],\n\t\t'CMY_to_XYZ'    : ['RGB'],\n\t\t'xyY_to_CMY'    : ['RGB'],\n\t\t'CMY_to_xyY'    : ['RGB'],\n\t\t'Lab_to_CMY'    : ['RGB'],\n\t\t'CMY_to_Lab'    : ['RGB'],\n\t\t'LCHab_to_CMY'  : ['RGB'],\n\t\t'CMY_to_LCHab'  : ['RGB'],\n\t\t'Luv_to_CMY'    : ['RGB'],\n\t\t'CMY_to_Luv'    : ['RGB'],\n\t\t'LCHuv_to_CMY'  : ['RGB'],\n\t\t'CMY_to_LCHuv'  : ['RGB'],\n\t\t'XYZ_to_HSL'    : ['RGB'],\n\t\t'HSL_to_XYZ'    : ['RGB'],\n\t\t'xyY_to_HSL'    : ['RGB'],\n\t\t'HSL_to_xyY'    : ['RGB'],\n\t\t'Lab_to_HSL'    : ['RGB'],\n\t\t'HSL_to_Lab'    : ['RGB'],\n\t\t'LCHab_to_HSL'  : ['RGB'],\n\t\t'HSL_to_LCHab'  : ['RGB'],\n\t\t'Luv_to_HSL'    : ['RGB'],\n\t\t'HSL_to_Luv'    : ['RGB'],\n\t\t'LCHuv_to_HSL'  : ['RGB'],\n\t\t'HSL_to_LCHuv'  : ['RGB'],\n\t\t'CMY_to_HSL'    : ['RGB'],\n\t\t'HSL_to_CMY'    : ['RGB'],\n\t\t'CMYK_to_HSL'   : ['RGB'],\n\t\t'HSL_to_CMYK'   : ['RGB'],\n\t\t'XYZ_to_HSV'    : ['RGB'],\n\t\t'HSV_to_XYZ'    : ['RGB'],\n\t\t'xyY_to_HSV'    : ['RGB'],\n\t\t'HSV_to_xyY'    : ['RGB'],\n\t\t'Lab_to_HSV'    : ['RGB'],\n\t\t'HSV_to_Lab'    : ['RGB'],\n\t\t'LCHab_to_HSV'  : ['RGB'],\n\t\t'HSV_to_LCHab'  : ['RGB'],\n\t\t'Luv_to_HSV'    : ['RGB'],\n\t\t'HSV_to_Luv'    : ['RGB'],\n\t\t'LCHuv_to_HSV'  : ['RGB'],\n\t\t'HSV_to_LCHuv'  : ['RGB'],\n\t\t'CMY_to_HSV'    : ['RGB'],\n\t\t'HSV_to_CMY'    : ['RGB'],\n\t\t'CMYK_to_HSV'   : ['RGB'],\n\t\t'HSV_to_CMYK'   : ['RGB'],\n\t\t'HSL_to_HSV'    : ['RGB'],\n\t\t'HSV_to_HSL'    : ['RGB'],\n\t\t'XYZ_to_CMYK'   : ['RGB'],\n\t\t'CMYK_to_XYZ'   : ['RGB'],\n\t\t'xyY_to_CMYK'   : ['RGB'],\n\t\t'CMYK_to_xyY'   : ['RGB'],\n\t\t'Lab_to_CMYK'   : ['RGB'],\n\t\t'CMYK_to_Lab'   : ['RGB'],\n\t\t'LCHab_to_CMYK' : ['RGB'],\n\t\t'CMYK_to_LCHab' : ['RGB'],\n\t\t'Luv_to_CMYK'   : ['RGB'],\n\t\t'CMYK_to_Luv'   : ['RGB'],\n\t\t'LCHuv_to_CMYK' : ['RGB'],\n\t\t'CMYK_to_LCHuv' : ['RGB']\n\t};\n\treturn this;","instance_variables":["whitePoint","stdObserver","chromaticAdaptationAlg","RGBWorkingSpace","useApproxCIELabMapping","chainMaps"]}},"dojo.gfx.Colorspace.convert":{"meta":{"summary":"","parameters":{"col":{"type":""},"model_from":{"type":""},"model_to":{"type":""}},"src":" var k = model_from+'_to_'+model_to;\n\tif (this[k]){\n\t\treturn this[k](col);\n\t}else{\n\t\tif (this.chainMaps[k]){\n\t\t\tvar cur = model_from;\n\t\t\tvar models = this.chainMaps[k].concat();\n\t\t\tmodels.push(model_to);\n\t\t\tfor(var i=0; i<models.length; i++){\n\t\t\t\tcol = this.convert(col, cur, models[i]);\n\t\t\t\tcur = models[i];\n\t\t\t}\n\t\t\treturn col;\n\t\t}else{\n\t\t\tdojo.debug(\"Can't convert from \"+model_from+' to '+model_to);\n\t\t}\n\t}","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.munge":{"meta":{"summary":"","parameters":{"keys":{"type":""},"args":{"type":""}},"src":" if (dojo.lang.isArray(args[0])){\n\t\targs = args[0];\n\t}\n\tvar out = new Array();\n\tfor (var i=0; i<keys.length; i++){\n\t\tout[keys.charAt(i)] = args[i];\n\t}\n\treturn out;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.getWhitePoint":{"meta":{"summary":"","src":" var x = 0;\n\tvar y = 0;\n\tvar t = 0;\n\t\/\/ ref: http:\/\/en.wikipedia.org\/wiki\/White_point\n\t\/\/ TODO: i need some good\/better white point values\n\tswitch(this.stdObserver){\n\t\tcase '2' :\n\t\t\tswitch(this.whitePoint){\n\t\t\t\tcase 'E'   : x=1\/3    ; y=1\/3    ; t=5400; break; \/\/Equal energy\n\t\t\t\tcase 'D50' : x=0.34567; y=0.35850; t=5000; break;\n\t\t\t\tcase 'D55' : x=0.33242; y=0.34743; t=5500; break;\n\t\t\t\tcase 'D65' : x=0.31271; y=0.32902; t=6500; break;\n\t\t\t\tcase 'D75' : x=0.29902; y=0.31485; t=7500; break;\n\t\t\t\tcase 'A'   : x=0.44757; y=0.40745; t=2856; break; \/\/Incandescent tungsten\n\t\t\t\tcase 'B'   : x=0.34842; y=0.35161; t=4874; break;\n\t\t\t\tcase 'C'   : x=0.31006; y=0.31616; t=6774; break;\n\t\t\t\tcase '9300': x=0.28480; y=0.29320; t=9300; break; \/\/Blue phosphor monitors\n\t\t\t\tcase 'F2'  : x=0.37207; y=0.37512; t=4200; break; \/\/Cool White Fluorescent\n\t\t\t\tcase 'F7'  : x=0.31285; y=0.32918; t=6500; break; \/\/Narrow Band Daylight Fluorescent\n\t\t\t\tcase 'F11' : x=0.38054; y=0.37691; t=4000; break; \/\/Narrow Band White Fluorescent\n\t\t\t\tdefault: dojo.debug('White point '+this.whitePoint+\" isn't defined for Std. Observer \"+this.strObserver);\n\t\t\t};\n\t\t\tbreak;\n\t\tcase '10' :\n\t\t\tswitch(this.whitePoint){\n\t\t\t\tcase 'E'   : x=1\/3    ; y=1\/3    ; t=5400; break; \/\/Equal energy\n\t\t\t\tcase 'D50' : x=0.34773; y=0.35952; t=5000; break;\n\t\t\t\tcase 'D55' : x=0.33411; y=0.34877; t=5500; break;\n\t\t\t\tcase 'D65' : x=0.31382; y=0.33100; t=6500; break;\n\t\t\t\tcase 'D75' : x=0.29968; y=0.31740; t=7500; break;\n\t\t\t\tcase 'A'   : x=0.45117; y=0.40594; t=2856; break; \/\/Incandescent tungsten\n\t\t\t\tcase 'B'   : x=0.3498 ; y=0.3527 ; t=4874; break;\n\t\t\t\tcase 'C'   : x=0.31039; y=0.31905; t=6774; break;\n\t\t\t\tcase 'F2'  : x=0.37928; y=0.36723; t=4200; break; \/\/Cool White Fluorescent\n\t\t\t\tcase 'F7'  : x=0.31565; y=0.32951; t=6500; break; \/\/Narrow Band Daylight Fluorescent\n\t\t\t\tcase 'F11' : x=0.38543; y=0.37110; t=4000; break; \/\/Narrow Band White Fluorescent\n\t\t\t\tdefault: dojo.debug('White point '+this.whitePoint+\" isn't defined for Std. Observer \"+this.strObserver);\n\t\t\t};\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdojo.debug(\"Std. Observer \"+this.strObserver+\" isn't defined\");\n\t}\n\tvar z = 1 - x - y;\n\tvar wp = {'x':x, 'y':y, 'z':z, 't':t};\n\twp.Y = 1;\n\tvar XYZ = this.xyY_to_XYZ([wp.x, wp.y, wp.Y]);\n\twp.X = XYZ[0];\n\twp.Y = XYZ[1];\n\twp.Z = XYZ[2];\n\treturn wp;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.getPrimaries":{"meta":{"summary":"","src":" var m = [];\n\tswitch(this.RGBWorkingSpace){\n\t\tcase 'adobe_rgb_1998'\t: m = [2.2, 'D65', 0.6400, 0.3300, 0.297361, 0.2100, 0.7100, 0.627355, 0.1500, 0.0600, 0.075285]; break;\n\t\tcase 'apple_rgb'\t: m = [1.8, 'D65', 0.6250, 0.3400, 0.244634, 0.2800, 0.5950, 0.672034, 0.1550, 0.0700, 0.083332]; break;\n\t\tcase 'best_rgb'\t\t: m = [2.2, 'D50', 0.7347, 0.2653, 0.228457, 0.2150, 0.7750, 0.737352, 0.1300, 0.0350, 0.034191]; break;\n\t\tcase 'beta_rgb'\t\t: m = [2.2, 'D50', 0.6888, 0.3112, 0.303273, 0.1986, 0.7551, 0.663786, 0.1265, 0.0352, 0.032941]; break;\n\t\tcase 'bruce_rgb'\t: m = [2.2, 'D65', 0.6400, 0.3300, 0.240995, 0.2800, 0.6500, 0.683554, 0.1500, 0.0600, 0.075452]; break;\n\t\tcase 'cie_rgb'\t\t: m = [2.2, 'E'  , 0.7350, 0.2650, 0.176204, 0.2740, 0.7170, 0.812985, 0.1670, 0.0090, 0.010811]; break;\n\t\tcase 'color_match_rgb'\t: m = [1.8, 'D50', 0.6300, 0.3400, 0.274884, 0.2950, 0.6050, 0.658132, 0.1500, 0.0750, 0.066985]; break;\n\t\tcase 'don_rgb_4'\t: m = [2.2, 'D50', 0.6960, 0.3000, 0.278350, 0.2150, 0.7650, 0.687970, 0.1300, 0.0350, 0.033680]; break;\n\t\tcase 'eci_rgb'\t\t: m = [1.8, 'D50', 0.6700, 0.3300, 0.320250, 0.2100, 0.7100, 0.602071, 0.1400, 0.0800, 0.077679]; break;\n\t\tcase 'ekta_space_ps5'\t: m = [2.2, 'D50', 0.6950, 0.3050, 0.260629, 0.2600, 0.7000, 0.734946, 0.1100, 0.0050, 0.004425]; break;\n\t\tcase 'ntsc_rgb'\t\t: m = [2.2, 'C'  , 0.6700, 0.3300, 0.298839, 0.2100, 0.7100, 0.586811, 0.1400, 0.0800, 0.114350]; break;\n\t\tcase 'pal_secam_rgb'\t: m = [2.2, 'D65', 0.6400, 0.3300, 0.222021, 0.2900, 0.6000, 0.706645, 0.1500, 0.0600, 0.071334]; break;\n\t\tcase 'pro_photo_rgb'\t: m = [1.8, 'D50', 0.7347, 0.2653, 0.288040, 0.1596, 0.8404, 0.711874, 0.0366, 0.0001, 0.000086]; break;\n\t\tcase 'smpte-c_rgb'\t: m = [2.2, 'D65', 0.6300, 0.3400, 0.212395, 0.3100, 0.5950, 0.701049, 0.1550, 0.0700, 0.086556]; break;\n\t\tcase 's_rgb'\t\t: m = [2.2, 'D65', 0.6400, 0.3300, 0.212656, 0.3000, 0.6000, 0.715158, 0.1500, 0.0600, 0.072186]; break;\n\t\tcase 'wide_gamut_rgb'\t: m = [2.2, 'D50', 0.7350, 0.2650, 0.258187, 0.1150, 0.8260, 0.724938, 0.1570, 0.0180, 0.016875]; break;\n\t\tdefault: dojo.debug(\"RGB working space \"+this.RGBWorkingSpace+\" isn't defined\");\n\t}\n\tvar p = {\n\t\tname: this.RGBWorkingSpace,\n\t\tgamma:m[0],\n\t\twp:m[1],\n\t\txr:m[2],\n\t\tyr:m[3],\n\t\tYr:m[4],\n\t\txg:m[5],\n\t\tyg:m[6],\n\t\tYg:m[7],\n\t\txb:m[8],\n\t\tyb:m[9],\n\t\tYb:m[10]\n\t};\n\t\/\/ if WP doesn't match current WP, convert the primaries over\n\tif (p.wp != this.whitePoint){\n\t\tvar r = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xr, p.yr, p.Yr]), p.wp, this.whitePoint ) );\n\t\tvar g = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xg, p.yg, p.Yg]), p.wp, this.whitePoint ) );\n\t\tvar b = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xb, p.yb, p.Yb]), p.wp, this.whitePoint ) );\n\t\tp.xr = r[0];\n\t\tp.yr = r[1];\n\t\tp.Yr = r[2];\n\t\tp.xg = g[0];\n\t\tp.yg = g[1];\n\t\tp.Yg = g[2];\n\t\tp.xb = b[0];\n\t\tp.yb = b[1];\n\t\tp.Yb = b[2];\n\t\tp.wp = this.whitePoint;\n\t}\n\tp.zr = 1 - p.xr - p.yr;\n\tp.zg = 1 - p.xg - p.yg;\n\tp.zb = 1 - p.xb - p.yb;\n\treturn p;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.epsilon":{"meta":{"summary":"","src":" return this.useApproxCIELabMapping ? 0.008856 : 216 \/ 24289;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.kappa":{"meta":{"summary":"","src":" return this.useApproxCIELabMapping ? 903.3 : 24389 \/ 27;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.XYZ_to_xyY":{"meta":{"summary":"","src":" var src = this.munge('XYZ', arguments);\n\tvar sum = src.X + src.Y + src.Z;\n\tif (sum == 0){\n\t\tvar wp = this.getWhitePoint();\n\t\tvar x = wp.x;\n\t\tvar y = wp.y;\n\t}else{\n\t\tvar x = src.X \/ sum;\n\t\tvar y = src.Y \/ sum;\n\t}\n\tvar Y = src.Y;\n\treturn [x, y, Y];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.xyY_to_XYZ":{"meta":{"summary":"","src":" var src = this.munge('xyY', arguments);\n\tif (src.y == 0){\n\t\tvar X = 0;\n\t\tvar Y = 0;\n\t\tvar Z = 0;\n\t}else{\n\t\tvar X = (src.x * src.Y) \/ src.y;\n\t\tvar Y = src.Y;\n\t\tvar Z = ((1 - src.x - src.y) * src.Y) \/ src.y;\n\t}\n\treturn [X, Y, Z];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.RGB_to_XYZ":{"meta":{"summary":"","src":" var src = this.munge('RGB', arguments);\n\tvar m = this.getRGB_XYZ_Matrix();\n\tvar pr = this.getPrimaries();\n\tif (this.RGBWorkingSpace == 's_rgb'){\n\t\tvar r = (src.R > 0.04045) ? Math.pow(((src.R + 0.055) \/ 1.055), 2.4) : src.R \/ 12.92;\n\t\tvar g = (src.G > 0.04045) ? Math.pow(((src.G + 0.055) \/ 1.055), 2.4) : src.G \/ 12.92;\n\t\tvar b = (src.B > 0.04045) ? Math.pow(((src.B + 0.055) \/ 1.055), 2.4) : src.B \/ 12.92;\n\t}else{\n\t\tvar r = Math.pow(src.R, pr.gamma);\n\t\tvar g = Math.pow(src.G, pr.gamma);\n\t\tvar b = Math.pow(src.B, pr.gamma);\n\t}\n\tvar XYZ = dojo.math.matrix.multiply([[r, g, b]], m);\n\treturn [XYZ[0][0], XYZ[0][1], XYZ[0][2]];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.XYZ_to_RGB":{"meta":{"summary":"","src":" var src = this.munge('XYZ', arguments);\n\tvar mi = this.getXYZ_RGB_Matrix();\n\tvar pr = this.getPrimaries();\n\tvar rgb = dojo.math.matrix.multiply([[src.X, src.Y, src.Z]], mi);\n\tvar r = rgb[0][0];\n\tvar g = rgb[0][1];\n\tvar b = rgb[0][2];\n\tif (this.RGBWorkingSpace == 's_rgb'){\n\t\tvar R = (r > 0.0031308) ? (1.055 * Math.pow(r, 1.0\/2.4)) - 0.055 : 12.92 * r;\n\t\tvar G = (g > 0.0031308) ? (1.055 * Math.pow(g, 1.0\/2.4)) - 0.055 : 12.92 * g;\n\t\tvar B = (b > 0.0031308) ? (1.055 * Math.pow(b, 1.0\/2.4)) - 0.055 : 12.92 * b;\n\t}else{\n\t\tvar R = Math.pow(r, 1\/pr.gamma);\n\t\tvar G = Math.pow(g, 1\/pr.gamma);\n\t\tvar B = Math.pow(b, 1\/pr.gamma);\n\t}\n\treturn [R, G, B];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.XYZ_to_Lab":{"meta":{"summary":"","src":" var src = this.munge('XYZ', arguments);\n\tvar wp = this.getWhitePoint();\n\tvar xr = src.X \/ wp.X;\n\tvar yr = src.Y \/ wp.Y;\n\tvar zr = src.Z \/ wp.Z;\n\tvar fx = (xr > this.epsilon()) ? Math.pow(xr, 1\/3) : (this.kappa() * xr + 16) \/ 116;\n\tvar fy = (yr > this.epsilon()) ? Math.pow(yr, 1\/3) : (this.kappa() * yr + 16) \/ 116;\n\tvar fz = (zr > this.epsilon()) ? Math.pow(zr, 1\/3) : (this.kappa() * zr + 16) \/ 116;\n\tvar L = 116 * fy - 16;\n\tvar a = 500 * (fx - fy);\n\tvar b = 200 * (fy - fz);\n\treturn [L, a, b];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.Lab_to_XYZ":{"meta":{"summary":"","src":" var src = this.munge('Lab', arguments);\n\tvar wp = this.getWhitePoint();\n\tvar yr = (src.L > (this.kappa() * this.epsilon())) ? Math.pow((src.L + 16) \/ 116, 3) : src.L \/ this.kappa();\n\tvar fy = (yr > this.epsilon()) ? (src.L + 16) \/ 116 : (this.kappa() * yr + 16) \/ 116;\n\tvar fx = (src.a \/ 500) + fy;\n\tvar fz = fy - (src.b \/ 200);\n\tvar fxcube = Math.pow(fx, 3);\n\tvar fzcube = Math.pow(fz, 3);\n\tvar xr = (fxcube > this.epsilon()) ? fxcube : (116 * fx - 16) \/ this.kappa();\n\tvar zr = (fzcube > this.epsilon()) ? fzcube : (116 * fz - 16) \/ this.kappa();\n\tvar X = xr * wp.X;\n\tvar Y = yr * wp.Y;\n\tvar Z = zr * wp.Z;\n\treturn [X, Y, Z];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.Lab_to_LCHab":{"meta":{"summary":"","src":" var src = this.munge('Lab', arguments);\n\tvar L = src.L;\n\tvar C = Math.pow(src.a * src.a + src.b * src.b, 0.5);\n\tvar H = Math.atan2(src.b, src.a) * (180 \/ Math.PI);\n\tif (H < 0){ H += 360; }\n\tif (H > 360){ H -= 360; }\n\treturn [L, C, H];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.LCHab_to_Lab":{"meta":{"summary":"","src":" var src = this.munge('LCH', arguments);\n\tvar H_rad = src.H * (Math.PI \/ 180);\n\tvar L = src.L;\n\tvar a = src.C \/ Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);\n\tif ((90 < src.H) && (src.H < 270)){ a= -a; }\n\tvar b = Math.pow(Math.pow(src.C, 2) - Math.pow(a, 2), 0.5);\n\tif (src.H > 180){ b = -b; }\n\treturn [L, a, b];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.chromaticAdaptation":{"meta":{"summary":"","parameters":{"col":{"type":""},"src_w":{"type":""},"dst_w":{"type":""}},"src":" col = this.munge('XYZ', [col]);\n\tvar old_wp = this.whitePoint;\n\tthis.whitePoint = src_w;\n\tvar wp_src = this.getWhitePoint();\n\tthis.whitePoint = dst_w;\n\tvar wp_dst = this.getWhitePoint();\n\tthis.whitePoint = old_wp;\n\tswitch(this.chromaticAdaptationAlg){\n\t\tcase 'xyz_scaling':\n\t\t\tvar ma = [[1,0,0],[0,1,0],[0,0,1]];\n\t\t\tvar mai = [[1,0,0],[0,1,0],[0,0,1]];\n\t\t\tbreak;\n\t\tcase 'bradford':\n\t\t\tvar ma = [[0.8951, -0.7502, 0.0389],[0.2664, 1.7135, -0.0685],[-0.1614, 0.0367, 1.0296]];\n\t\t\tvar mai = [[0.986993, 0.432305, -0.008529],[-0.147054, 0.518360, 0.040043],[0.159963, 0.049291, 0.968487]];\n\t\t\tbreak;\n\t\tcase 'von_kries':\n\t\t\tvar ma = [[0.40024, -0.22630, 0.00000],[0.70760, 1.16532, 0.00000],[-0.08081, 0.04570, 0.91822]]\n\t\t\tvar mai = [[1.859936, 0.361191, 0.000000],[-1.129382, 0.638812, 0.000000],[0.219897, -0.000006, 1.089064]]\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdojo.debug(\"The \"+this.chromaticAdaptationAlg+\" chromatic adaptation algorithm matricies are not defined\");\n\t}\n\tvar domain_src = dojo.math.matrix.multiply( [[wp_src.x, wp_src.y, wp_src.z]], ma);\n\tvar domain_dst = dojo.math.matrix.multiply( [[wp_dst.x, wp_dst.y, wp_dst.z]], ma);\n\tvar centre = [\n\t\t[domain_dst[0][0]\/domain_src[0][0], 0, 0],\n\t\t[0, domain_dst[0][1]\/domain_src[0][1], 0],\n\t\t[0, 0, domain_dst[0][2]\/domain_src[0][2]]\n\t];\n\tvar m = dojo.math.matrix.multiply( dojo.math.matrix.multiply( ma, centre ), mai );\n\tvar dst = dojo.math.matrix.multiply( [[ col.X, col.Y, col.Z ]], m );\n\treturn dst[0];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.getRGB_XYZ_Matrix":{"meta":{"summary":"","src":" var wp = this.getWhitePoint();\n\tvar pr = this.getPrimaries();\n\tvar Xr = pr.xr \/ pr.yr;\n\tvar Yr = 1;\n\tvar Zr = (1 - pr.xr - pr.yr) \/ pr.yr;\n\tvar Xg = pr.xg \/ pr.yg;\n\tvar Yg = 1;\n\tvar Zg = (1 - pr.xg - pr.yg) \/ pr.yg;\n\tvar Xb = pr.xb \/ pr.yb;\n\tvar Yb = 1;\n\tvar Zb = (1 - pr.xb - pr.yb) \/ pr.yb;\n\tvar m1 = [[Xr, Yr, Zr],[Xg, Yg, Zg],[Xb, Yb, Zb]];\n\tvar m2 = [[wp.X, wp.Y, wp.Z]];\n\tvar sm = dojo.math.matrix.multiply(m2, dojo.math.matrix.inverse(m1));\n\tvar Sr = sm[0][0];\n\tvar Sg = sm[0][1];\n\tvar Sb = sm[0][2];\n\tvar m4 = [[Sr*Xr, Sr*Yr, Sr*Zr],\n\t\t  [Sg*Xg, Sg*Yg, Sg*Zg],\n\t\t  [Sb*Xb, Sb*Yb, Sb*Zb]];\n\treturn m4;","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.getXYZ_RGB_Matrix":{"meta":{"summary":"","src":" var m = this.getRGB_XYZ_Matrix();\n\treturn dojo.math.matrix.inverse(m);","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.XYZ_to_Luv":{"meta":{"summary":"","src":" var src = this.munge('XYZ', arguments);\n\tvar wp = this.getWhitePoint();\n\tvar ud = (4 * src.X) \/ (src.X + 15 * src.Y + 3 * src.Z);\n\tvar vd = (9 * src.Y) \/ (src.X + 15 * src.Y + 3 * src.Z);\n\tvar udr = (4 * wp.X) \/ (wp.X + 15 * wp.Y + 3 * wp.Z);\n\tvar vdr = (9 * wp.Y) \/ (wp.X + 15 * wp.Y + 3 * wp.Z);\n\tvar yr = src.Y \/ wp.Y;\n\tvar L = (yr > this.epsilon()) ? 116 * Math.pow(yr, 1\/3) - 16 : this.kappa() * yr;\n\tvar u = 13 * L * (ud-udr);\n\tvar v = 13 * L * (vd-vdr);\n\treturn [L, u, v];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.Luv_to_XYZ":{"meta":{"summary":"","src":" var src = this.munge('Luv', arguments);\n\tvar wp = this.getWhitePoint();\n\tvar uz = (4 * wp.X) \/ (wp.X + 15 * wp.Y + 3 * wp.Z);\n\tvar vz = (9 * wp.Y) \/ (wp.X + 15 * wp.Y + 3 * wp.Z);\n\tvar Y = (src.L > this.kappa() * this.epsilon()) ? Math.pow((src.L + 16) \/ 116, 3) : src.L \/ this.kappa();\n\tvar a = (1 \/ 3) * (((52 * src.L) \/ (src.u + 13 * src.L * uz)) - 1);\n\tvar b = -5 * Y;\n\tvar c = - (1 \/ 3);\n\tvar d = Y * (((39 * src.L) \/ (src.v + 13 * src.L * vz)) - 5);\n\tvar X = (d - b) \/ (a - c);\n\tvar Z = X * a + b;\n\treturn [X, Y, Z];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.Luv_to_LCHuv":{"meta":{"summary":"","src":" var src = this.munge('Luv', arguments);\n\tvar L = src.L;\n\tvar C = Math.pow(src.u * src.u + src.v * src.v, 0.5);\n\tvar H = Math.atan2(src.v, src.u) * (180 \/ Math.PI);\n\tif (H < 0){ H += 360; }\n\tif (H > 360){ H -= 360; }\n\treturn [L, C, H];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.LCHuv_to_Luv":{"meta":{"summary":"","src":" var src = this.munge('LCH', arguments);\n\tvar H_rad = src.H * (Math.PI \/ 180);\n\tvar L = src.L;\n\tvar u = src.C \/ Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);\n\tvar v = Math.pow(src.C * src.C - u * u, 0.5);\n\tif ((90 < src.H) && (src.H < 270)){ u *= -1; }\n\tif (src.H > 180){ v *= -1; }\n\treturn [L, u, v];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.colorTemp_to_whitePoint":{"meta":{"summary":"","parameters":{"T":{"type":""}},"src":" if (T < 4000){\n\t\tdojo.debug(\"Can't find a white point for temperatures under 4000K\");\n\t\treturn [0,0];\n\t}\n\tif (T > 25000){\n\t\tdojo.debug(\"Can't find a white point for temperatures over 25000K\");\n\t\treturn [0,0];\n\t}\n\tvar T1 = T;\n\tvar T2 = T * T;\n\tvar T3 = T2 * T;\n\tvar ten9 = Math.pow(10, 9);\n\tvar ten6 = Math.pow(10, 6);\n\tvar ten3 = Math.pow(10, 3);\n\tif (T <= 7000){\n\t\tvar x = (-4.6070 * ten9 \/ T3) + (2.9678 * ten6 \/ T2) + (0.09911 * ten3 \/ T) + 0.244063;\n\t}else{\n\t\tvar x = (-2.0064 * ten9 \/ T3) + (1.9018 * ten6 \/ T2) + (0.24748 * ten3 \/ T) + 0.237040;\n\t}\n\tvar y = -3.000 * x * x + 2.870 * x - 0.275;\n\treturn [x, y];"}},"dojo.gfx.Colorspace.RGB_to_CMY":{"meta":{"summary":"","src":" var src = this.munge('RGB', arguments);\n\tvar C = 1 - src.R;\n\tvar M = 1 - src.G;\n\tvar Y = 1 - src.B;\n\treturn [C, M, Y];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.CMY_to_RGB":{"meta":{"summary":"","src":" var src = this.munge('CMY', arguments);\n\tvar R = 1 - src.C;\n\tvar G = 1 - src.M;\n\tvar B = 1 - src.Y;\n\treturn [R, G, B];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.RGB_to_CMYK":{"meta":{"summary":"","src":" var src = this.munge('RGB', arguments);\n\tvar K = Math.min(1-src.R, 1-src.G, 1-src.B);\n\tvar C = (1 - src.R - K) \/ (1 - K);\n\tvar M = (1 - src.G - K) \/ (1 - K);\n\tvar Y = (1 - src.B - K) \/ (1 - K);\n\treturn [C, M, Y, K];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.CMYK_to_RGB":{"meta":{"summary":"","src":" var src = this.munge('CMYK', arguments);\n\tvar R = 1 - Math.min(1, src.C * (1-src.K) + src.K);\n\tvar G = 1 - Math.min(1, src.M * (1-src.K) + src.K);\n\tvar B = 1 - Math.min(1, src.Y * (1-src.K) + src.K);\n\treturn [R, G, B];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.CMY_to_CMYK":{"meta":{"summary":"","src":" var src = this.munge('CMY', arguments);\n\tvar K = Math.min(src.C, src.M, src.Y);\n\tvar C = (src.C - K) \/ (1 - K);\n\tvar M = (src.M - K) \/ (1 - K);\n\tvar Y = (src.Y - K) \/ (1 - K);\n\treturn [C, M, Y, K];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.CMYK_to_CMY":{"meta":{"summary":"","src":" var src = this.munge('CMYK', arguments);\n\tvar C = Math.min(1, src.C * (1-src.K) + src.K);\n\tvar M = Math.min(1, src.M * (1-src.K) + src.K);\n\tvar Y = Math.min(1, src.Y * (1-src.K) + src.K);\n\treturn [C, M, Y];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.RGB_to_HSV":{"meta":{"summary":"","src":" var src = this.munge('RGB', arguments);\n\t\/\/ Based on C Code in \"Computer Graphics -- Principles and Practice,\"\n\t\/\/ Foley et al, 1996, p. 592. \n\tvar min = Math.min(src.R, src.G, src.B);\n\tvar V = Math.max(src.R, src.G, src.B);\n\tvar delta = V - min;\n\tvar H = null;\n\tvar S = (V == 0) ? 0 : delta \/ V;\n\tif (S == 0){\n\t\tH = 0;\n\t}else{\n\t\tif (src.R == V){\n\t\t\tH = 60 * (src.G - src.B) \/ delta;\n\t\t}else{\n\t\t\tif (src.G == V){\n\t\t\t\tH = 120 + 60 * (src.B - src.R) \/ delta;\n\t\t\t}else{\n\t\t\t\tif (src.B == V){\n\t\t\t\t\t\/\/ between magenta and cyan\n\t\t\t\t\tH = 240 + 60 * (src.R - src.G) \/ delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (H < 0){\n\t\t\tH += 360;\n\t\t}\n\t}\n\tH = (H == 0) ? 360 : H;\n\treturn [H, S, V];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.HSV_to_RGB":{"meta":{"summary":"","src":" var src = this.munge('HSV', arguments);\n\tif (src.H == 360){ src.H = 0;}\n\t\/\/ Based on C Code in \"Computer Graphics -- Principles and Practice,\"\n\t\/\/ Foley et al, 1996, p. 593.\n\tvar r = null;\n\tvar g = null;\n\tvar b = null;\n\tif (src.S == 0){\n\t\t\/\/ color is on black-and-white center line\n\t\t\/\/ achromatic: shades of gray\n\t\tvar R = src.V;\n\t\tvar G = src.V;\n\t\tvar B = src.V;\n\t}else{\n\t\t\/\/ chromatic color\n\t\tvar hTemp = src.H \/ 60;\t\t\/\/ h is now IN [0,6]\n\t\tvar i = Math.floor(hTemp);\t\/\/ largest integer <= h\n\t\tvar f = hTemp - i;\t\t\/\/ fractional part of h\n\t\tvar p = src.V * (1 - src.S);\n\t\tvar q = src.V * (1 - (src.S * f));\n\t\tvar t = src.V * (1 - (src.S * (1 - f)));\n\t\tswitch(i){\n\t\t\tcase 0: R = src.V; G = t    ; B = p    ; break;\n\t\t\tcase 1: R = q    ; G = src.V; B = p    ; break;\n\t\t\tcase 2: R = p    ; G = src.V; B = t    ; break;\n\t\t\tcase 3: R = p    ; G = q    ; B = src.V; break;\n\t\t\tcase 4: R = t    ; G = p    ; B = src.V; break;\n\t\t\tcase 5: R = src.V; G = p    ; B = q    ; break;\n\t\t}\n\t}\n\treturn [R, G, B];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.RGB_to_HSL":{"meta":{"summary":"","src":" var src = this.munge('RGB', arguments);\n\t\/\/ based on C code from http:\/\/astronomy.swin.edu.au\/~pbourke\/colour\/hsl\/\n\tvar min = Math.min(src.R, src.G, src.B);\n\tvar max = Math.max(src.R, src.G, src.B);\n\tvar delta = max - min;\n\tvar H = 0;\n\tvar S = 0;\n\tvar L = (min + max) \/ 2;\n\tif ((L > 0) && (L < 1)){\n\t\tS = delta \/ ((L < 0.5) ? (2 * L) : (2 - 2 * L));\n\t}\n\tif (delta > 0) {\n\t\tif ((max == src.R) && (max != src.G)){\n\t\t\tH += (src.G - src.B) \/ delta;\n\t\t}\n\t\tif ((max == src.G) && (max != src.B)){\n\t\t\tH += (2 + (src.B - src.R) \/ delta);\n\t\t}\n\t\tif ((max == src.B) && (max != src.R)){\n\t\t\tH += (4 + (src.R - src.G) \/ delta);\n\t\t}\n\t\tH *= 60;\n\t}\n\tH = (H == 0) ? 360 : H;\n\treturn [H, S, L];","prototype":"dojo.gfx.Colorspace"}},"dojo.gfx.Colorspace.HSL_to_RGB":{"meta":{"summary":"","src":" var src = this.munge('HSL', arguments);\n\t\/\/ based on C code from http:\/\/astronomy.swin.edu.au\/~pbourke\/colour\/hsl\/\n\twhile (src.H < 0){ src.H += 360; }\n\twhile (src.H >= 360){ src.H -= 360; }\n\tvar R = 0;\n\tvar G = 0;\n\tvar B = 0;\n\tif (src.H < 120){\n\t\tR = (120 - src.H) \/ 60;\n\t\tG = src.H \/ 60;\n\t\tB = 0;\n\t}else if (src.H < 240){\n\t\tR = 0;\n\t\tG = (240 - src.H) \/ 60;\n\t\tB = (src.H - 120) \/ 60;\n\t}else{\n\t\tR = (src.H - 240) \/ 60;\n\t\tG = 0;\n\t\tB = (360 - src.H) \/ 60;\n\t}\n\tR = 2 * src.S * Math.min(R, 1) + (1 - src.S);\n\tG = 2 * src.S * Math.min(G, 1) + (1 - src.S);\n\tB = 2 * src.S * Math.min(B, 1) + (1 - src.S);\n\tif (src.L < 0.5){\n\t\tR = src.L * R;\n\t\tG = src.L * G;\n\t\tB = src.L * B;\n\t}else{\n\t\tR = (1 - src.L) * R + 2 * src.L - 1;\n\t\tG = (1 - src.L) * G + 2 * src.L - 1;\n\t\tB = (1 - src.L) * B + 2 * src.L - 1;\n\t}\n\treturn [R, G, B];","prototype":"dojo.gfx.Colorspace"}}}}},"dojo.gfx._":{"meta":{"requires":{"common":["dojo.gfx.color","dojo.gfx.matrix","dojo.gfx.common"]}}},"dojo.gfx.color.hsl":{"meta":{"requires":{"common":["dojo.lang.array"]},"functions":{"dojo.gfx.color.rgb2hsl":{"meta":{"summary":"","parameters":{"r":{"type":""},"g":{"type":""},"b":{"type":""}},"src":" if (dojo.lang.isArray(r)) {\n\t\tb = r[2] || 0;\n\t\tg = r[1] || 0;\n\t\tr = r[0] || 0;\n\t}\n\tr \/= 255;\n\tg \/= 255;\n\tb \/= 255;\n\t\/\/\n\t\/\/ based on C code from http:\/\/astronomy.swin.edu.au\/~pbourke\/colour\/hsl\/\n\t\/\/\n\tvar h = null;\n\tvar s = null;\n\tvar l = null;\n\tvar min = Math.min(r, g, b);\n\tvar max = Math.max(r, g, b);\n\tvar delta = max - min;\n\tl = (min + max) \/ 2;\n\ts = 0;\n\tif ((l > 0) && (l < 1)){\n\t\ts = delta \/ ((l < 0.5) ? (2 * l) : (2 - 2 * l));\n\t}\n\th = 0;\n\tif (delta > 0) {\n\t\tif ((max == r) && (max != g)){\n\t\t\th += (g - b) \/ delta;\n\t\t}\n\t\tif ((max == g) && (max != b)){\n\t\t\th += (2 + (b - r) \/ delta);\n\t\t}\n\t\tif ((max == b) && (max != r)){\n\t\t\th += (4 + (r - g) \/ delta);\n\t\t}\n\t\th *= 60;\n\t}\n\th = (h == 0) ? 360 : Math.ceil((h \/ 360) * 255);\n\ts = Math.ceil(s * 255);\n\tl = Math.ceil(l * 255);\n\treturn [h, s, l];"}},"dojo.gfx.color.hsl2rgb":{"meta":{"summary":"","parameters":{"h":{"type":""},"s":{"type":""},"l":{"type":""}},"src":" if (dojo.lang.isArray(h)) {\n\t\tl = h[2] || 0;\n\t\ts = h[1] || 0;\n\t\th = h[0] || 0;\n\t}\n\th = (h \/ 255) * 360;\n\tif (h == 360){ h = 0;}\n\ts = s \/ 255;\n\tl = l \/ 255;\n\t\/\/\n\t\/\/ based on C code from http:\/\/astronomy.swin.edu.au\/~pbourke\/colour\/hsl\/\n\t\/\/\n\twhile (h < 0){ h += 360; }\n\twhile (h > 360){ h -= 360; }\n\tvar r, g, b;\n\tif (h < 120){\n\t\tr = (120 - h) \/ 60;\n\t\tg = h \/ 60;\n\t\tb = 0;\n\t}else if (h < 240){\n\t\tr = 0;\n\t\tg = (240 - h) \/ 60;\n\t\tb = (h - 120) \/ 60;\n\t}else{\n\t\tr = (h - 240) \/ 60;\n\t\tg = 0;\n\t\tb = (360 - h) \/ 60;\n\t}\n\tr = Math.min(r, 1);\n\tg = Math.min(g, 1);\n\tb = Math.min(b, 1);\n\tr = 2 * s * r + (1 - s);\n\tg = 2 * s * g + (1 - s);\n\tb = 2 * s * b + (1 - s);\n\tif (l < 0.5){\n\t\tr = l * r;\n\t\tg = l * g;\n\t\tb = l * b;\n\t}else{\n\t\tr = (1 - l) * r + 2 * l - 1;\n\t\tg = (1 - l) * g + 2 * l - 1;\n\t\tb = (1 - l) * b + 2 * l - 1;\n\t}\n\tr = Math.ceil(r * 255);\n\tg = Math.ceil(g * 255);\n\tb = Math.ceil(b * 255);\n\treturn [r, g, b];"}},"dojo.gfx.color.hsl2hex":{"meta":{"summary":"","parameters":{"h":{"type":""},"s":{"type":""},"l":{"type":""}},"src":" var rgb = dojo.gfx.color.hsl2rgb(h, s, l);\n\treturn dojo.gfx.color.rgb2hex(rgb[0], rgb[1], rgb[2]);"}},"dojo.gfx.color.hex2hsl":{"meta":{"summary":"","parameters":{"hex":{"type":""}},"src":" var rgb = dojo.gfx.color.hex2rgb(hex);\n\treturn dojo.gfx.color.rgb2hsl(rgb[0], rgb[1], rgb[2]);"}},"dojo.gfx.color.Color.toHsl":{"meta":{"summary":"","src":" \treturn dojo.gfx.color.rgb2hsl(this.toRgb());","prototype":"dojo.gfx.color.Color"}}}}},"dojo.gfx.color.hsv":{"meta":{"requires":{"common":["dojo.lang.array","dojo.math"]},"functions":{"dojo.gfx.color.rgb2hsv":{"meta":{"summary":"converts an RGB value set to HSV, ranges depending on optional options object. patch for options by Matthew Eernisse","parameters":{"r":{"type":"int || Array"},"g":{"type":"int"},"b":{"type":"int"},"options":{"type":"Object?"}},"src":" if (dojo.lang.isArray(r)) {\n\t\tif(g) {\n\t\t\toptions = g;\n\t\t}\n\t\tb = r[2] || 0;\n\t\tg = r[1] || 0;\n\t\tr = r[0] || 0;\n\t}\n\tvar opt = {\n\t\tinputRange:  (options && options.inputRange)  ? options.inputRange : 255,\n\t\toutputRange: (options && options.outputRange) ? options.outputRange : [255, 255, 255]\n\t};\n\t\/\/ r,g,b, each 0 to 255, to HSV.\n\t\/\/ h = 0.0 to 360.0 (corresponding to 0..360.0 degrees around hexcone)\n\t\/\/ s = 0.0 (shade of gray) to 1.0 (pure color)\n\t\/\/ v = 0.0 (black) to 1.0 {white)\n\t\/\/\n\t\/\/ Based on C Code in \"Computer Graphics -- Principles and Practice,\"\n\t\/\/ Foley et al, 1996, p. 592. \n\t\/\/\n\t\/\/ our calculatuions are based on 'regular' values (0-360, 0-1, 0-1) \n\t\/\/ but we return bytes values (0-255, 0-255, 0-255)\n\tvar h = null;\n\tvar s = null;\n\tvar v = null;\n\tswitch(opt.inputRange) { \n\t\t\/\/ 0.0-1.0 \n\t\tcase 1:\n\t\t\tr = (r * 255);\n\t\t\tg = (g * 255);\n\t\t\tb = (b * 255);\n\t\t\tbreak;\n\t\t\/\/ 0-100 \n\t\tcase 100:\n\t\t\tr = (r \/ 100) * 255;\n\t\t\tg = (g \/ 100) * 255;\n\t\t\tb = (b \/ 100) * 255;\n\t\t\tbreak;\n\t\t\/\/ 0-255\n\t\tdefault:\n\t\t\t\/\/ Do nothing\n\t\t\tbreak;\n\t} \n\tvar min = Math.min(r, g, b);\n\tv = Math.max(r, g, b);\n\tvar delta = v - min;\n\t\/\/ calculate saturation (0 if r, g and b are all 0)\n\ts = (v == 0) ? 0 : delta\/v;\n\tif (s == 0){\n\t\t\/\/ achromatic: when saturation is, hue is undefined\n\t\th = 0;\n\t}else{\n\t\t\/\/ chromatic\n\t\tif (r == v){\n\t\t\t\/\/ between yellow and magenta\n\t\t\th = 60 * (g - b) \/ delta;\n\t\t}else{\n\t\t\tif (g == v){\n\t\t\t\t\/\/ between cyan and yellow\n\t\t\t\th = 120 + 60 * (b - r) \/ delta;\n\t\t\t}else{\n\t\t\t\tif (b == v){\n\t\t\t\t\t\/\/ between magenta and cyan\n\t\t\t\t\th = 240 + 60 * (r - g) \/ delta;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (h <= 0){\n\t\t\th += 360;\n\t\t}\n\t}\n\t\/\/ Hue\n\tswitch (opt.outputRange[0]) {\n\t\tcase 360:\n\t\t\t\/\/ Do nothing\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\th = (h \/ 360) * 100;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\th = (h \/ 360);\n\t\t\tbreak;\n\t\tdefault: \/\/ 255\n\t\t\th = (h \/ 360) * 255;\n\t\t\tbreak;\n\t}\n\t\/\/ Saturation\n\tswitch (opt.outputRange[1]) {\n\t\tcase 100:\n\t\t\ts = s * 100;\n\t\tcase 1:\n\t\t\t\/\/ Do nothing\n\t\t\tbreak;\n\t\tdefault: \/\/ 255\n\t\t\ts = s * 255;\n\t\t\tbreak;\n\t}\n\t\/\/ Value\n\tswitch (opt.outputRange[2]) {\n\t\tcase 100:\n\t\t\tv = (v \/ 255) * 100;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tv = (v \/ 255);\n\t\t\tbreak;\n\t\tdefault: \/\/ 255\n\t\t\t\/\/ Do nothing\n\t\t\tbreak;\n\t}\n\th = dojo.math.round(h);\n\ts = dojo.math.round(s);\n\tv = dojo.math.round(v);\n\treturn [h, s, v];"}},"dojo.gfx.color.hsv2rgb":{"meta":{"summary":"converts an HSV value set to RGB, ranges depending on optional options object. patch for options by Matthew Eernisse","parameters":{"h":{"type":"int || Array"},"s":{"type":"int"},"v":{"type":"int"},"options":{"type":"Object?"}},"src":" if (dojo.lang.isArray(h)) {\n\t\tif(s){\n\t\t\toptions = s;\n\t\t}\n\t\tv = h[2] || 0;\n\t\ts = h[1] || 0;\n\t\th = h[0] || 0;\n\t}\n\tvar opt = {\n\t\tinputRange:  (options && options.inputRange)  ? options.inputRange : [255, 255, 255],\n\t\toutputRange: (options && options.outputRange) ? options.outputRange : 255\n\t};\n    switch(opt.inputRange[0]) { \n\t\t\/\/ 0.0-1.0 \n\t\tcase 1: h = h * 360; break; \n\t\t\/\/ 0-100 \n\t\tcase 100: h = (h \/ 100) * 360; break; \n\t\t\/\/ 0-360 \n\t\tcase 360: h = h; break; \n\t\t\/\/ 0-255 \n\t\tdefault: h = (h \/ 255) * 360; \n\t} \n\tif (h == 360){ h = 0;}\n\t\/\/\tno need to alter if inputRange[1] = 1\n\tswitch(opt.inputRange[1]){\n\t\tcase 100: s \/= 100; break;\n\t\tcase 255: s \/= 255;\n\t}\n\t\/\/\tno need to alter if inputRange[1] = 1\n\tswitch(opt.inputRange[2]){\n\t\tcase 100: v \/= 100; break;\n\t\tcase 255: v \/= 255;\n\t}\n\tvar r = null;\n\tvar g = null;\n\tvar b = null;\n\tif (s == 0){\n\t\t\/\/ color is on black-and-white center line\n\t\t\/\/ achromatic: shades of gray\n\t\tr = v;\n\t\tg = v;\n\t\tb = v;\n\t}else{\n\t\t\/\/ chromatic color\n\t\tvar hTemp = h \/ 60;\t\t\/\/ h is now IN [0,6]\n\t\tvar i = Math.floor(hTemp);\t\/\/ largest integer <= h\n\t\tvar f = hTemp - i;\t\t\/\/ fractional part of h\n\t\tvar p = v * (1 - s);\n\t\tvar q = v * (1 - (s * f));\n\t\tvar t = v * (1 - (s * (1 - f)));\n\t\tswitch(i){\n\t\t\tcase 0: r = v; g = t; b = p; break;\n\t\t\tcase 1: r = q; g = v; b = p; break;\n\t\t\tcase 2: r = p; g = v; b = t; break;\n\t\t\tcase 3: r = p; g = q; b = v; break;\n\t\t\tcase 4: r = t; g = p; b = v; break;\n\t\t\tcase 5: r = v; g = p; b = q; break;\n\t\t}\n\t}\n\tswitch(opt.outputRange){\n\t\tcase 1:\n\t\t\tr = dojo.math.round(r, 2);\n\t\t\tg = dojo.math.round(g, 2);\n\t\t\tb = dojo.math.round(b, 2);\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tr = Math.round(r * 100);\n\t\t\tg = Math.round(g * 100);\n\t\t\tb = Math.round(b * 100);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr = Math.round(r * 255);\n\t\t\tg = Math.round(g * 255);\n\t\t\tb = Math.round(b * 255);\n\t}\n\treturn [r, g, b];"}},"dojo.gfx.color.Color.toHsv":{"meta":{"summary":"","src":" \treturn dojo.gfx.color.rgb2hsv(this.toRgb());","prototype":"dojo.gfx.color.Color"}}}}},"dojo.gfx.color":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.array"]},"functions":{"dojo.gfx.color.Color":{"meta":{"summary":"","parameters":{"r":{"type":""},"g":{"type":""},"b":{"type":""},"a":{"type":""}},"src":" if(dojo.lang.isArray(r)){\n\t\tthis.r = r[0];\n\t\tthis.g = r[1];\n\t\tthis.b = r[2];\n\t\tthis.a = r[3]||1.0;\n\t}else if(dojo.lang.isString(r)){\n\t\tvar rgb = dojo.gfx.color.extractRGB(r);\n\t\tthis.r = rgb[0];\n\t\tthis.g = rgb[1];\n\t\tthis.b = rgb[2];\n\t\tthis.a = g||1.0;\n\t}else if(r instanceof dojo.gfx.color.Color){\n\t\t\/\/ why does this create a new instance if we were passed one?\n\t\tthis.r = r.r;\n\t\tthis.b = r.b;\n\t\tthis.g = r.g;\n\t\tthis.a = r.a;\n\t}else{\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t}","instance_variables":["r","g","b","a"]}},"dojo.gfx.color.Color.fromArray":{"meta":{"summary":"","parameters":{"arr":{"type":""}},"src":" return new dojo.gfx.color.Color(arr[0], arr[1], arr[2], arr[3]);"}},"dojo.gfx.color.blend":{"meta":{"summary":"blend colors a and b (both as RGB array or hex strings) with weight from -1 to +1, 0 being a 50\/50 blend","parameters":{"a":{"type":""},"b":{"type":""},"weight":{"type":""}},"src":" if(typeof a == \"string\"){\n\t\treturn dojo.gfx.color.blendHex(a, b, weight);\n\t}\n\tif(!weight){\n\t\tweight = 0;\n\t}\n\tweight = Math.min(Math.max(-1, weight), 1);\n\t\/\/ alex: this interface blows.\n\t\/\/ map -1 to 1 to the range 0 to 1\n\tweight = ((weight + 1)\/2);\n\tvar c = [];\n\t\/\/ var stop = (1000*weight);\n\tfor(var x = 0; x < 3; x++){\n\t\tc[x] = parseInt( b[x] + ( (a[x] - b[x]) * weight) );\n\t}\n\treturn c;"}},"dojo.gfx.color.blendHex":{"meta":{"summary":"","parameters":{"a":{"type":""},"b":{"type":""},"weight":{"type":""}},"src":" return dojo.gfx.color.rgb2hex(dojo.gfx.color.blend(dojo.gfx.color.hex2rgb(a), dojo.gfx.color.hex2rgb(b), weight));"}},"dojo.gfx.color.extractRGB":{"meta":{"summary":"","parameters":{"color":{"type":""}},"src":" var hex = \"0123456789abcdef\";\n\tcolor = color.toLowerCase();\n\tif( color.indexOf(\"rgb\") == 0 ) {\n\t\tvar matches = color.match(\/rgba*\\((\\d+), *(\\d+), *(\\d+)\/i);\n\t\tvar ret = matches.splice(1, 3);\n\t\treturn ret;\n\t} else {\n\t\tvar colors = dojo.gfx.color.hex2rgb(color);\n\t\tif(colors) {\n\t\t\treturn colors;\n\t\t} else {\n\t\t\t\/\/ named color (how many do we support?)\n\t\t\treturn dojo.gfx.color.named[color] || [255, 255, 255];\n\t\t}\n\t}"}},"dojo.gfx.color.hex2rgb":{"meta":{"summary":"","parameters":{"hex":{"type":""}},"src":" var hexNum = \"0123456789ABCDEF\";\n\tvar rgb = new Array(3);\n\tif( hex.indexOf(\"#\") == 0 ) { hex = hex.substring(1); }\n\thex = hex.toUpperCase();\n\tif(hex.replace(new RegExp(\"[\"+hexNum+\"]\", \"g\"), \"\") != \"\") {\n\t\treturn null;\n\t}\n\tif( hex.length == 3 ) {\n\t\trgb[0] = hex.charAt(0) + hex.charAt(0)\n\t\trgb[1] = hex.charAt(1) + hex.charAt(1)\n\t\trgb[2] = hex.charAt(2) + hex.charAt(2);\n\t} else {\n\t\trgb[0] = hex.substring(0, 2);\n\t\trgb[1] = hex.substring(2, 4);\n\t\trgb[2] = hex.substring(4);\n\t}\n\tfor(var i = 0; i < rgb.length; i++) {\n\t\trgb[i] = hexNum.indexOf(rgb[i].charAt(0)) * 16 + hexNum.indexOf(rgb[i].charAt(1));\n\t}\n\treturn rgb;"}},"dojo.gfx.color.rgb2hex":{"meta":{"summary":"","parameters":{"r":{"type":""},"g":{"type":""},"b":{"type":""}},"src":" if(dojo.lang.isArray(r)) {\n\t\tg = r[1] || 0;\n\t\tb = r[2] || 0;\n\t\tr = r[0] || 0;\n\t}\n\tvar ret = dojo.lang.map([r, g, b], function(x) {\n\t\tx = new Number(x);\n\t\tvar s = x.toString(16);\n\t\twhile(s.length < 2) { s = \"0\" + s; }\n\t\treturn s;\n\t});\n\tret.unshift(\"#\");\n\treturn ret.join(\"\");"}},"dojo.gfx.color.Color.toRgb":{"meta":{"summary":"","parameters":{"includeAlpha":{"type":""}},"src":" \tif(includeAlpha) {\n\t\t\treturn this.toRgba();\n\t\t} else {\n\t\t\treturn [this.r, this.g, this.b];\n\t\t}"}},"dojo.gfx.color.Color.toRgba":{"meta":{"summary":"","src":" \treturn [this.r, this.g, this.b, this.a];"}},"dojo.gfx.color.Color.toHex":{"meta":{"summary":"","src":" \treturn dojo.gfx.color.rgb2hex(this.toRgb());"}},"dojo.gfx.color.Color.toCss":{"meta":{"summary":"","src":" \treturn \"rgb(\" + this.toRgb().join() + \")\";"}},"dojo.gfx.color.Color.toString":{"meta":{"summary":"","src":" \treturn this.toHex(); \/\/ decent default?","returns":"decent default?"}},"dojo.gfx.color.Color.blend":{"meta":{"summary":"","parameters":{"color":{"type":""},"weight":{"type":""}},"src":" \tvar rgb = null;\n\t\tif(dojo.lang.isArray(color)){\n\t\t\trgb = color;\n\t\t}else if(color instanceof dojo.gfx.color.Color){\n\t\t\trgb = color.toRgb();\n\t\t}else{\n\t\t\trgb = new dojo.gfx.color.Color(color).toRgb();\n\t\t}\n\t\treturn dojo.gfx.color.blend(this.toRgb(), rgb, weight);"}}},"objects":{"dojo.gfx.color.named":{"meta":{"variables":["white","black","red","green","lime","blue","navy","gray","silver"]}}}}},"dojo.gfx.common":{"meta":{"requires":{"common":["dojo.gfx.color","dojo.lang.declare","dojo.lang.extras","dojo.dom"]},"functions":{"dojo.gfx":{"meta":{"variables":["defaultPath","defaultPolyline","defaultRect","defaultEllipse","defaultCircle","defaultLine","defaultImage","defaultStroke","defaultLinearGradient","defaultRadialGradient","defaultPattern","pathRegExp"]}},"dojo.gfx.normalizeColor":{"meta":{"summary":"converts any legal color representation to normalized dojo.gfx.color.Color object","parameters":{"color":{"type":"Color"}},"src":" \treturn (color instanceof dojo.gfx.color.Color) ? color : new dojo.gfx.color.Color(color); \/\/ dojo.gfx.color.Color","returns":"dojo.gfx.color.Color"}},"dojo.gfx.normalizeParameters":{"meta":{"summary":"updates an existing object with properties from an \"update\" object","parameters":{"existed":{"type":""},"update":{"type":""}},"src":" \tif(update){\n\t\t\tvar empty = {};\n\t\t\tfor(var x in existed){\n\t\t\t\tif(x in update && !(x in empty)){\n\t\t\t\t\texisted[x] = update[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn existed;\t\/\/ Object","returns":"Object"},"extra":{"parameters":{"existed":{"type":"Object","summary":"the \"target\" object to be updated"},"update":{"type":"Object","summary":"the \"update\" object, whose properties will be used to update the existed object"}}}},"dojo.gfx.makeParameters":{"meta":{"summary":"copies the original object, and all copied properties from the \"update\" object","parameters":{"defaults":{"type":""},"update":{"type":""}},"src":" \tif(!update) return dojo.lang.shallowCopy(defaults, true);\n\t\tvar result = {};\n\t\tfor(var i in defaults){\n\t\t\tif(!(i in result)){\n\t\t\t\tresult[i] = dojo.lang.shallowCopy((i in update) ? update[i] : defaults[i], true);\n\t\t\t}\n\t\t}\n\t\treturn result; \/\/ Object","returns":"Object"},"extra":{"parameters":{"defaults":{"type":"Object","summary":"the object to be cloned before updating"},"update":{"type":"Object","summary":"the object, which properties are to be cloned during updating"}}}},"dojo.gfx.formatNumber":{"meta":{"summary":"converts a number to a string using a fixed notation","parameters":{"x":{"type":""},"addSpace":{"type":""}},"src":" \tvar val = x.toString();\n\t\tif(val.indexOf(\"e\") >= 0){\n\t\t\tval = x.toFixed(4);\n\t\t}else{\n\t\t\tvar point = val.indexOf(\".\");\n\t\t\tif(point >= 0 && val.length - point > 5){\n\t\t\t\tval = x.toFixed(4);\n\t\t\t}\n\t\t}\n\t\tif(x < 0){\n\t\t\treturn val; \/\/ String\n\t\t}\n\t\treturn addSpace ? \" \" + val : val; \/\/ String","returns":"String"},"extra":{"parameters":{"x":{"type":"Number","summary":"number to be converted"},"addSpace":{"type":"Boolean?","summary":"if it is true, add a space before a positive number"}}}}}}},"dojo.gfx.matrix":{"meta":{"requires":{"common":["dojo.lang.common","dojo.math.*"]},"functions":{"dojo.gfx.matrix.Matrix2D":{"meta":{"summary":"a 2D matrix object","parameters":{"arg":{"type":""}},"src":" if(arg){\n\t\tif(arg instanceof Array){\n\t\t\tif(arg.length > 0){\n\t\t\t\tvar m = dojo.gfx.matrix.normalize(arg[0]);\n\t\t\t\t\/\/ combine matrices\n\t\t\t\tfor(var i = 1; i < arg.length; ++i){\n\t\t\t\t\tvar l = m;\n\t\t\t\t\tvar r = dojo.gfx.matrix.normalize(arg[i]);\n\t\t\t\t\tm = new dojo.gfx.matrix.Matrix2D();\n\t\t\t\t\tm.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\t\t\tm.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\t\t\tm.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\t\t\tm.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\t\t\tm.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\t\t\tm.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t\t\t}\n\t\t\t\tdojo.mixin(this, m);\n\t\t\t}\n\t\t}else{\n\t\t\tdojo.mixin(this, arg);\n\t\t}\n\t}","description":"Normalizes a 2D matrix-like object. If arrays is passed, all objects of the array are normalized and multiplied sequentially.","prototype_variables":["xx","xy","yx","yy","dx","dy"]},"extra":{"parameters":{"arg":{"type":"Object","summary":"a 2D matrix-like object, or an array of such objects"}}}},"dojo.gfx.matrix":{"meta":{"variables":["identity","flipX","flipY","flipXY"]}},"dojo.gfx.matrix.translate":{"meta":{"summary":"forms a translation matrix","parameters":{"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 1){\n\t\t\treturn new dojo.gfx.matrix.Matrix2D({dx: a, dy: b}); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ a: dojo.gfx.Point: a point-like object, which specifies offsets for both dimensions\n\t\t\/\/ b: null\n\t\treturn new dojo.gfx.matrix.Matrix2D({dx: a.x, dy: a.y}); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to translate (move) points by specified offsets.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"a":{"type":"Number","summary":"an x coordinate value"},"b":{"type":"Number","summary":"a y coordinate value"}}}},"dojo.gfx.matrix.scale":{"meta":{"summary":"forms a scaling matrix","parameters":{"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 1){\n\t\t\treturn new dojo.gfx.matrix.Matrix2D({xx: a, yy: b}); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\tif(typeof a == \"number\"){\n\t\t\t\/\/ branch\n\t\t\t\/\/ a: Number: a uniform scaling factor used for the both coordinates\n\t\t\t\/\/ b: null\n\t\t\treturn new dojo.gfx.matrix.Matrix2D({xx: a, yy: a}); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ a: dojo.gfx.Point: a point-like object, which specifies scale factors for both dimensions\n\t\t\/\/ b: null\n\t\treturn new dojo.gfx.matrix.Matrix2D({xx: a.x, yy: a.y}); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to scale (magnify) points by specified offsets.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"a":{"type":"Number","summary":"a scaling factor used for the x coordinate"},"b":{"type":"Number","summary":"a scaling factor used for the y coordinate"}}}},"dojo.gfx.matrix.rotate":{"meta":{"summary":"forms a rotating matrix","parameters":{"angle":{"type":""}},"src":" \tvar c = Math.cos(angle);\n\t\tvar s = Math.sin(angle);\n\t\treturn new dojo.gfx.matrix.Matrix2D({xx: c, xy: s, yx: -s, yy: c}); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to rotate points around the origin of coordinates (0, 0) by specified angle.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an angle of rotation in radians (>0 for CCW)"}}}},"dojo.gfx.matrix.rotateg":{"meta":{"summary":"forms a rotating matrix","parameters":{"degree":{"type":""}},"src":" \treturn dojo.gfx.matrix.rotate(dojo.math.degToRad(degree)); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to rotate points around the origin of coordinates (0, 0) by specified degree. See dojo.gfx.matrix.rotate() for comparison.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an angle of rotation in degrees (>0 for CCW)"}}}},"dojo.gfx.matrix.skewX":{"meta":{"summary":"forms an x skewing matrix","parameters":{"angle":{"type":""}},"src":" \treturn new dojo.gfx.matrix.Matrix2D({xy: Math.tan(angle)}); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to skew points in the x dimension around the origin of coordinates (0, 0) by specified angle.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an skewing angle in radians"}}}},"dojo.gfx.matrix.skewXg":{"meta":{"summary":"forms an x skewing matrix","parameters":{"degree":{"type":""}},"src":" \treturn dojo.gfx.matrix.skewX(dojo.math.degToRad(degree)); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to skew points in the x dimension around the origin of coordinates (0, 0) by specified degree. See dojo.gfx.matrix.skewX() for comparison.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an skewing angle in degrees"}}}},"dojo.gfx.matrix.skewY":{"meta":{"summary":"forms a y skewing matrix","parameters":{"angle":{"type":""}},"src":" \treturn new dojo.gfx.matrix.Matrix2D({yx: -Math.tan(angle)}); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to skew points in the y dimension around the origin of coordinates (0, 0) by specified angle.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an skewing angle in radians"}}}},"dojo.gfx.matrix.skewYg":{"meta":{"summary":"forms a y skewing matrix","parameters":{"degree":{"type":""}},"src":" \treturn dojo.gfx.matrix.skewY(dojo.math.degToRad(degree)); \/\/ dojo.gfx.matrix.Matrix2D","description":"The resulting matrix is used to skew points in the y dimension around the origin of coordinates (0, 0) by specified degree. See dojo.gfx.matrix.skewY() for comparison.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an skewing angle in degrees"}}}},"dojo.gfx.matrix.normalize":{"meta":{"summary":"converts an object to a matrix, if necessary","parameters":{"matrix":{"type":""}},"src":" \treturn (matrix instanceof dojo.gfx.matrix.Matrix2D) ? matrix : new dojo.gfx.matrix.Matrix2D(matrix); \/\/ dojo.gfx.matrix.Matrix2D","description":"Converts any 2D matrix-like object or an array of such objects to a valid dojo.gfx.matrix.Matrix2D object.","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"matrix":{"type":"Object","summary":"an object, which is converted to a matrix, if necessary"}}}},"dojo.gfx.matrix.clone":{"meta":{"summary":"creates a copy of a 2D matrix","parameters":{"matrix":{"type":""}},"src":" \tvar obj = new dojo.gfx.matrix.Matrix2D();\n\t\tfor(var i in matrix){\n\t\t\tif(typeof(matrix[i]) == \"number\" && typeof(obj[i]) == \"number\" && obj[i] != matrix[i]) obj[i] = matrix[i];\n\t\t}\n\t\treturn obj; \/\/ dojo.gfx.matrix.Matrix2D","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"matrix":{"type":"dojo.gfx.matrix.Matrix2D","summary":"a 2D matrix-like object to be cloned"}}}},"dojo.gfx.matrix.invert":{"meta":{"summary":"inverts a 2D matrix","parameters":{"matrix":{"type":""}},"src":" \tvar m = dojo.gfx.matrix.normalize(matrix);\n\t\tvar D = m.xx * m.yy - m.xy * m.yx;\n\t\tvar M = new dojo.gfx.matrix.Matrix2D({\n\t\t\txx: m.yy\/D, xy: -m.xy\/D, \n\t\t\tyx: -m.yx\/D, yy: m.xx\/D, \n\t\t\tdx: (m.yx * m.dy - m.yy * m.dx) \/ D, \n\t\t\tdy: (m.xy * m.dx - m.xx * m.dy) \/ D\n\t\t});\n\t\treturn M; \/\/ dojo.gfx.matrix.Matrix2D","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"matrix":{"type":"dojo.gfx.matrix.Matrix2D","summary":"a 2D matrix-like object to be inverted"}}}},"dojo.gfx.matrix._multiplyPoint":{"meta":{"summary":"applies a matrix to a point matrix: dojo.gfx.matrix.Matrix2D: a 2D matrix object to be applied","parameters":{"m":{"type":""},"x":{"type":""},"y":{"type":""}},"src":" \treturn {x: m.xx * x + m.xy * y + m.dx, y: m.yx * x + m.yy * y + m.dy}; \/\/ dojo.gfx.Point","returns":"dojo.gfx.Point"},"extra":{"parameters":{"x":{"type":"Number","summary":"an x coordinate of a point"},"y":{"type":"Number","summary":"a y coordinate of a point"}}}},"dojo.gfx.matrix.multiplyPoint":{"meta":{"summary":"applies a matrix to a point","parameters":{"matrix":{"type":""},"a":{"type":"Number||Point"},"b":{"type":"Number, optional"}},"src":" \tvar m = dojo.gfx.matrix.normalize(matrix);\n\t\tif(typeof a == \"number\" && typeof b == \"number\"){\n\t\t\treturn dojo.gfx.matrix._multiplyPoint(m, a, b); \/\/ dojo.gfx.Point\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ matrix: dojo.gfx.matrix.Matrix2D: a 2D matrix object to be applied\n\t\t\/\/ a: dojo.gfx.Point: a point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._multiplyPoint(m, a.x, a.y); \/\/ dojo.gfx.Point","returns":"dojo.gfx.Point"},"extra":{"parameters":{"matrix":{"type":"dojo.gfx.matrix.Matrix2D","summary":"a 2D matrix object to be applied"},"a":{"type":"Number","summary":"an x coordinate of a point"},"b":{"type":"Number","summary":"a y coordinate of a point"}}}},"dojo.gfx.matrix.multiply":{"meta":{"summary":"combines matrices by multiplying them sequentially in the given order","parameters":{"matrix":{"type":""}},"src":" \tvar m = dojo.gfx.matrix.normalize(matrix);\n\t\t\/\/ combine matrices\n\t\tfor(var i = 1; i < arguments.length; ++i){\n\t\t\tvar l = m;\n\t\t\tvar r = dojo.gfx.matrix.normalize(arguments[i]);\n\t\t\tm = new dojo.gfx.matrix.Matrix2D();\n\t\t\tm.xx = l.xx * r.xx + l.xy * r.yx;\n\t\t\tm.xy = l.xx * r.xy + l.xy * r.yy;\n\t\t\tm.yx = l.yx * r.xx + l.yy * r.yx;\n\t\t\tm.yy = l.yx * r.xy + l.yy * r.yy;\n\t\t\tm.dx = l.xx * r.dx + l.xy * r.dy + l.dx;\n\t\t\tm.dy = l.yx * r.dx + l.yy * r.dy + l.dy;\n\t\t}\n\t\treturn m; \/\/ dojo.gfx.matrix.Matrix2D","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"matrix":{"type":"dojo.gfx.matrix.Matrix2D...","summary":"a 2D matrix-like object, all subsequent arguments are matrix-like objects too"}}}},"dojo.gfx.matrix._sandwich":{"meta":{"summary":"applies a matrix at a centrtal point","parameters":{"m":{"type":""},"x":{"type":""},"y":{"type":""}},"src":" \treturn dojo.gfx.matrix.multiply(dojo.gfx.matrix.translate(x, y), m, dojo.gfx.matrix.translate(-x, -y)); \/\/ dojo.gfx.matrix.Matrix2D","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"m":{"type":"dojo.gfx.matrix.Matrix2D","summary":"a 2D matrix-like object, which is applied at a central point"},"x":{"type":"Number","summary":"an x component of the central point"},"y":{"type":"Number","summary":"a y component of the central point"}}}},"dojo.gfx.matrix.scaleAt":{"meta":{"summary":"scales a picture using a specified point as a center of scaling","parameters":{"a":{"type":""},"b":{"type":""},"c":{"type":""},"d":{"type":""}},"src":" \tswitch(arguments.length){\n\t\t\tcase 4:\n\t\t\t\t\/\/ a and b are scale factor components, c and d are components of a point\n\t\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.scale(a, b), c, d); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t\tcase 3:\n\t\t\t\tif(typeof c == \"number\"){\n\t\t\t\t\t\/\/ branch\n\t\t\t\t\t\/\/ a: Number: a uniform scaling factor used for both coordinates\n\t\t\t\t\t\/\/ b: Number: an x component of a central point\n\t\t\t\t\t\/\/ c: Number: a y component of a central point\n\t\t\t\t\t\/\/ d: null\n\t\t\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.scale(a), b, c); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t\t\t}\n\t\t\t\t\/\/ branch\n\t\t\t\t\/\/ a: Number: a scaling factor used for the x coordinate\n\t\t\t\t\/\/ b: Number: a scaling factor used for the y coordinate\n\t\t\t\t\/\/ c: dojo.gfx.Point: a central point\n\t\t\t\t\/\/ d: null\n\t\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.scale(a, b), c.x, c.y); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ a: Number: a uniform scaling factor used for both coordinates\n\t\t\/\/ b: dojo.gfx.Point: a central point\n\t\t\/\/ c: null\n\t\t\/\/ d: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.scale(a), b.x, b.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.scale().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"a":{"type":"Number","summary":"a scaling factor used for the x coordinate"},"b":{"type":"Number","summary":"a scaling factor used for the y coordinate"},"c":{"type":"Number","summary":"an x component of a central point"},"d":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) uniform scale factor, Point 2) uniform scale factor, x, y 3) x scale, y scale, Point 4) x scale, y scale, x, y"}}}},"dojo.gfx.matrix.rotateAt":{"meta":{"summary":"rotates a picture using a specified point as a center of rotation","parameters":{"angle":{"type":""},"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.rotate(angle), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ angle: Number: an angle of rotation in radians (>0 for CCW)\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.rotate(angle), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.rotate().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an angle of rotation in radians (>0 for CCW)"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) rotation angle in radians, Point 2) rotation angle in radians, x, y"}}}},"dojo.gfx.matrix.rotategAt":{"meta":{"summary":"rotates a picture using a specified point as a center of rotation","parameters":{"degree":{"type":""},"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.rotateg(degree), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ degree: Number: an angle of rotation in degrees (>0 for CCW)\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.rotateg(degree), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.rotateg().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an angle of rotation in degrees (>0 for CCW)"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) rotation angle in degrees, Point 2) rotation angle in degrees, x, y"}}}},"dojo.gfx.matrix.skewXAt":{"meta":{"summary":"skews a picture along the x axis using a specified point as a center of skewing","parameters":{"angle":{"type":""},"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewX(angle), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ angle: Number: an skewing angle in radians\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewX(angle), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.skewX().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an skewing angle in radians"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) skew angle in radians, Point 2) skew angle in radians, x, y"}}}},"dojo.gfx.matrix.skewXgAt":{"meta":{"summary":"skews a picture along the x axis using a specified point as a center of skewing","parameters":{"degree":{"type":""},"a":{"type":""},"b":{"type":""}},"src":"\t\tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewXg(degree), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ degree: Number: an skewing angle in degrees\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewXg(degree), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.skewXg().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an skewing angle in degrees"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) skew angle in degrees, Point 2) skew angle in degrees, x, y"}}}},"dojo.gfx.matrix.skewYAt":{"meta":{"summary":"skews a picture along the y axis using a specified point as a center of skewing","parameters":{"angle":{"type":""},"a":{"type":""},"b":{"type":""}},"src":" \tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewY(angle), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ angle: Number: an skewing angle in radians\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewY(angle), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.skewY().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"angle":{"type":"Number","summary":"an skewing angle in radians"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) skew angle in radians, Point 2) skew angle in radians, x, y"}}}},"dojo.gfx.matrix.skewYgAt":{"meta":{"summary":"skews a picture along the y axis using a specified point as a center of skewing","parameters":{"degree":{"type":"Number"},"a":{"type":"Number||Point"},"b":{"type":"Number, optional"}},"src":"\t\tif(arguments.length > 2){\n\t\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewYg(degree), a, b); \/\/ dojo.gfx.matrix.Matrix2D\n\t\t}\n\t\t\/\/ branch\n\t\t\/\/ degree: Number: an skewing angle in degrees\n\t\t\/\/ a: dojo.gfx.Point: a central point\n\t\t\/\/ b: null\n\t\treturn dojo.gfx.matrix._sandwich(dojo.gfx.matrix.skewYg(degree), a.x, a.y); \/\/ dojo.gfx.matrix.Matrix2D","description":"Compare with dojo.gfx.matrix.skewYg().","returns":"dojo.gfx.matrix.Matrix2D"},"extra":{"parameters":{"degree":{"type":"Number","summary":"an skewing angle in degrees"},"a":{"type":"Number","summary":"an x component of a central point"},"b":{"type":"Number","summary":"a y component of a central point accepts several signatures: 1) skew angle in degrees, Point 2) skew angle in degrees, x, y"}}}}}}},"dojo.gfx.path":{"meta":{"requires":{"common":["dojo.math","dojo.gfx.shape"]},"functions":{"dojo.gfx.path.Path":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}}}}},"dojo.gfx.shape":{"meta":{"requires":{"common":["dojo.lang.declare","dojo.gfx.common"]},"functions":{"dojo.gfx.shape.VirtualGroup":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Rect":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Ellipse":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Circle":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Line":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Polyline":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.shape.Image":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}}}}},"dojo.gfx.svg":{"meta":{"requires":{"common":["dojo.lang.declare","dojo.svg","dojo.gfx.color","dojo.gfx.common","dojo.gfx.shape","dojo.gfx.path","dojo.experimental"]},"functions":{"dojo.gfx.Group":{"meta":{"prototype_chain":["dojo.gfx.Shape"],"call_chain":["dojo.gfx.Shape"]}},"dojo.gfx.Rect":{"meta":{"prototype_chain":["dojo.gfx.shape.Rect"],"call_chain":["dojo.gfx.shape.Rect"]}},"dojo.gfx.Polyline":{"meta":{"prototype_chain":["dojo.gfx.shape.Polyline"],"call_chain":["dojo.gfx.shape.Polyline"]}},"dojo.gfx.Image":{"meta":{"prototype_chain":["dojo.gfx.shape.Image"],"call_chain":["dojo.gfx.shape.Image"]}},"dojo.gfx.Path":{"meta":{"prototype_chain":["dojo.gfx.path.Path"],"call_chain":["dojo.gfx.path.Path"]}},"dojo.gfx.svg.getRef":{"meta":{"summary":"returns a DOM Node specified by the fill argument or null","parameters":{"fill":{"type":""}},"src":" if(!fill || fill == \"none\") return null;\n\tif(fill.match(\/^url\\(#.+\\)$\/)){\n\t\treturn dojo.byId(fill.slice(5, -1));\t\/\/ Node\n\t}\n\t\/\/ Opera's bug: incorrect representation of a reference\n\tif(dojo.render.html.opera && fill.match(\/^#dj_unique_.+$\/)){\n\t\t\/\/ we assume here that a reference was generated by dojo.gfx\n\t\treturn dojo.byId(fill.slice(1));\t\/\/ Node\n\t}\n\treturn null;\t\/\/ Node","returns":"Node"},"extra":{"parameters":{"fill":{"type":"String","summary":"an SVG fill"}}}},"dojo.gfx.attachNode":{"meta":{"summary":"creates a shape from a Node","parameters":{"node":{"type":""}},"src":" if(!node) return null;\n\tvar s = null;\n\tswitch(node.tagName.toLowerCase()){\n\t\tcase dojo.gfx.Rect.nodeType:\n\t\t\ts = new dojo.gfx.Rect();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Ellipse.nodeType:\n\t\t\ts = new dojo.gfx.Ellipse();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Polyline.nodeType:\n\t\t\ts = new dojo.gfx.Polyline();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Path.nodeType:\n\t\t\ts = new dojo.gfx.Path();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Circle.nodeType:\n\t\t\ts = new dojo.gfx.Circle();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Line.nodeType:\n\t\t\ts = new dojo.gfx.Line();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Image.nodeType:\n\t\t\ts = new dojo.gfx.Image();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdojo.debug(\"FATAL ERROR! tagName = \" + node.tagName);\n\t}\n\ts.attach(node);\n\treturn s;\t\/\/ dojo.gfx.Shape","returns":"dojo.gfx.Shape"},"extra":{"parameters":{"node":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.createSurface":{"meta":{"summary":"creates a surface (SVG)","parameters":{"parentNode":{"type":""},"width":{"type":""},"height":{"type":""}},"src":"\tvar s = new dojo.gfx.Surface();\n\ts.rawNode = document.createElementNS(dojo.svg.xmlns.svg, \"svg\");\n\ts.rawNode.setAttribute(\"width\",  width);\n\ts.rawNode.setAttribute(\"height\", height);\n\tvar defs = new dojo.gfx.svg.Defines();\n\tvar node = document.createElementNS(dojo.svg.xmlns.svg, dojo.gfx.svg.Defines.nodeType); \n\tdefs.setRawNode(node);\n\ts.rawNode.appendChild(node);\n\tdojo.byId(parentNode).appendChild(s.rawNode);\n\treturn s;\t\/\/ dojo.gfx.Surface","returns":"dojo.gfx.Surface"},"extra":{"parameters":{"parentNode":{"type":"Node","summary":"a parent node"},"width":{"type":"String","summary":"width of surface, e.g., \"100px\""},"height":{"type":"String","summary":"height of surface, e.g., \"100px\""}}}},"dojo.gfx.attachSurface":{"meta":{"summary":"creates a surface from a Node","parameters":{"node":{"type":""}},"src":" var s = new dojo.gfx.Surface();\n\ts.rawNode = node;\n\treturn s;\t\/\/ dojo.gfx.Surface","returns":"dojo.gfx.Surface"},"extra":{"parameters":{"node":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.svg.Defines":{"meta":{"summary":"","src":" this.rawNode = null;","instance_variables":["rawNode"]}},"dojo.gfx.Shape.setFill":{"meta":{"summary":"sets a fill object (SVG)","parameters":{"fill":{"type":""}},"src":" \tif(!fill){\n\t\t\t\/\/ don't fill\n\t\t\tthis.fillStyle = null;\n\t\t\tthis.rawNode.setAttribute(\"fill\", \"none\");\n\t\t\tthis.rawNode.setAttribute(\"fill-opacity\", 0);\n\t\t\treturn this;\n\t\t}\n\t\tif(typeof(fill) == \"object\" && \"type\" in fill){\n\t\t\t\/\/ gradient\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultLinearGradient, fill);\n\t\t\t\t\tvar gradient = this._setFillObject(f, \"linearGradient\");\n\t\t\t\t\tdojo.lang.forEach([\"x1\", \"y1\", \"x2\", \"y2\"], function(x){\n\t\t\t\t\t\tgradient.setAttribute(x, f[x].toFixed(8));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultRadialGradient, fill);\n\t\t\t\t\tvar gradient = this._setFillObject(f, \"radialGradient\");\n\t\t\t\t\tdojo.lang.forEach([\"cx\", \"cy\", \"r\"], function(x){\n\t\t\t\t\t\tgradient.setAttribute(x, f[x].toFixed(8));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pattern\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultPattern, fill);\n\t\t\t\t\tvar pattern = this._setFillObject(f, \"pattern\");\n\t\t\t\t\tdojo.lang.forEach([\"x\", \"y\", \"width\", \"height\"], function(x){\n\t\t\t\t\t\tpattern.setAttribute(x, f[x].toFixed(8));\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\t\/\/ color object\n\t\tvar f = dojo.gfx.normalizeColor(fill);\n\t\tthis.fillStyle = f;\n\t\tthis.rawNode.setAttribute(\"fill\", f.toCss());\n\t\tthis.rawNode.setAttribute(\"fill-opacity\", f.a);\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"fill":{"type":"Object","summary":"a fill object (see dojo.gfx.defaultLinearGradient, dojo.gfx.defaultRadialGradient, dojo.gfx.defaultPattern, or dojo.gfx.color.Color)"}}}},"dojo.gfx.Shape":{"meta":{"instance_variables":["fillStyle","strokeStyle","strokeStyle.color","rawNode","shape","matrix"]}},"dojo.gfx.Shape.setStroke":{"meta":{"summary":"sets a stroke object (SVG)","parameters":{"stroke":{"type":""}},"src":" \tif(!stroke){\n\t\t\t\/\/ don't stroke\n\t\t\tthis.strokeStyle = null;\n\t\t\tthis.rawNode.setAttribute(\"stroke\", \"none\");\n\t\t\tthis.rawNode.setAttribute(\"stroke-opacity\", 0);\n\t\t\treturn this;\n\t\t}\n\t\t\/\/ normalize the stroke\n\t\tthis.strokeStyle = dojo.gfx.makeParameters(dojo.gfx.defaultStroke, stroke);\n\t\tthis.strokeStyle.color = dojo.gfx.normalizeColor(this.strokeStyle.color);\n\t\t\/\/ generate attributes\n\t\tvar s = this.strokeStyle;\n\t\tvar rn = this.rawNode;\n\t\tif(s){\n\t\t\trn.setAttribute(\"stroke\", s.color.toCss());\n\t\t\trn.setAttribute(\"stroke-opacity\", s.color.a);\n\t\t\trn.setAttribute(\"stroke-width\",   s.width);\n\t\t\trn.setAttribute(\"stroke-linecap\", s.cap);\n\t\t\tif(typeof(s.join) == \"number\"){\n\t\t\t\trn.setAttribute(\"stroke-linejoin\",   \"miter\");\n\t\t\t\trn.setAttribute(\"stroke-miterlimit\", s.join);\n\t\t\t}else{\n\t\t\t\trn.setAttribute(\"stroke-linejoin\",   s.join);\n\t\t\t}\n\t\t}\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"stroke":{"type":"Object","summary":"a stroke object (see dojo.gfx.defaultStroke)"}}}},"dojo.gfx.Shape._setFillObject":{"meta":{"summary":"","parameters":{"f":{"type":""},"nodeType":{"type":""}},"src":" \tvar def_elems = this.rawNode.parentNode.getElementsByTagName(\"defs\");\n\t\tif(def_elems.length == 0){ return this; }\n\t\tthis.fillStyle = f;\n\t\tvar defs = def_elems[0];\n\t\tvar fill = this.rawNode.getAttribute(\"fill\");\n\t\tvar ref  = dojo.gfx.svg.getRef(fill);\n\t\tif(ref){\n\t\t\tfill = ref;\n\t\t\tif(fill.tagName.toLowerCase() != nodeType.toLowerCase()){\n\t\t\t\tvar id = fill.id;\n\t\t\t\tfill.parentNode.removeChild(fill);\n\t\t\t\tfill = document.createElementNS(dojo.svg.xmlns.svg, nodeType);\n\t\t\t\tfill.setAttribute(\"id\", id);\n\t\t\t\tdefs.appendChild(fill);\n\t\t\t}else{\n\t\t\t\twhile(fill.childNodes.length){\n\t\t\t\t\tfill.removeChild(fill.lastChild);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tfill = document.createElementNS(dojo.svg.xmlns.svg, nodeType);\n\t\t\tfill.setAttribute(\"id\", dojo.dom.getUniqueId());\n\t\t\tdefs.appendChild(fill);\n\t\t}\n\t\tif(nodeType == \"pattern\"){\n\t\t\tfill.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n\t\t\tvar img = document.createElementNS(dojo.svg.xmlns.svg, \"image\");\n\t\t\timg.setAttribute(\"x\", 0);\n\t\t\timg.setAttribute(\"y\", 0);\n\t\t\timg.setAttribute(\"width\",  f.width .toFixed(8));\n\t\t\timg.setAttribute(\"height\", f.height.toFixed(8));\n\t\t\timg.setAttributeNS(dojo.svg.xmlns.xlink, \"href\", f.src);\n\t\t\tfill.appendChild(img);\n\t\t}else{\n\t\t\tfill.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n\t\t\tfor(var i = 0; i < f.colors.length; ++i){\n\t\t\t\tf.colors[i].color = dojo.gfx.normalizeColor(f.colors[i].color);\n\t\t\t\tvar t = document.createElementNS(dojo.svg.xmlns.svg, \"stop\");\n\t\t\t\tt.setAttribute(\"offset\",     f.colors[i].offset.toFixed(8));\n\t\t\t\tt.setAttribute(\"stop-color\", f.colors[i].color.toCss());\n\t\t\t\tfill.appendChild(t);\n\t\t\t}\n\t\t}\n\t\tthis.rawNode.setAttribute(\"fill\", \"url(#\" + fill.getAttribute(\"id\") +\")\");\n\t\tthis.rawNode.removeAttribute(\"fill-opacity\");\n\t\treturn fill;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape._applyTransform":{"meta":{"summary":"","src":" \tvar matrix = this._getRealMatrix();\n\t\tif(matrix){\n\t\t\tvar tm = this.matrix;\n\t\t\tthis.rawNode.setAttribute(\"transform\", \"matrix(\" +\n\t\t\t\ttm.xx.toFixed(8) + \",\" + tm.yx.toFixed(8) + \",\" +\n\t\t\t\ttm.xy.toFixed(8) + \",\" + tm.yy.toFixed(8) + \",\" +\n\t\t\t\ttm.dx.toFixed(8) + \",\" + tm.dy.toFixed(8) + \")\");\n\t\t}else{\n\t\t\tthis.rawNode.removeAttribute(\"transform\");\n\t\t}\n\t\treturn this;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.setRawNode":{"meta":{"summary":"assigns and clears the underlying node that will represent this shape. Once set, transforms, gradients, etc, can be applied. (no fill & stroke by default)","parameters":{"rawNode":{"type":""}},"src":" \twith(rawNode){\n\t\t\tsetAttribute(\"fill\", \"none\");\n\t\t\tsetAttribute(\"fill-opacity\", 0);\n\t\t\tsetAttribute(\"stroke\", \"none\");\n\t\t\tsetAttribute(\"stroke-opacity\", 0);\n\t\t\tsetAttribute(\"stroke-width\", 1);\n\t\t\tsetAttribute(\"stroke-linecap\", \"butt\");\n\t\t\tsetAttribute(\"stroke-linejoin\", \"miter\");\n\t\t\tsetAttribute(\"stroke-miterlimit\", 4);\n\t\t}\n\t\tthis.rawNode = rawNode;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.moveToFront":{"meta":{"summary":"moves a shape to front of its parent's list of shapes (SVG)","src":" \tthis.rawNode.parentNode.appendChild(this.rawNode);\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.moveToBack":{"meta":{"summary":"moves a shape to back of its parent's list of shapes (SVG)","src":" \tthis.rawNode.parentNode.insertBefore(this.rawNode, this.rawNode.parentNode.firstChild);\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.setShape":{"meta":{"summary":"sets a shape object (SVG)","parameters":{"newShape":{"type":""}},"src":" \tthis.shape = dojo.gfx.makeParameters(this.shape, newShape);\n\t\tfor(var i in this.shape){\n\t\t\tif(i != \"type\"){ this.rawNode.setAttribute(i, this.shape[i]); }\n\t\t}\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"newShape":{"type":"Object","summary":"a shape object (see dojo.gfx.defaultPath, dojo.gfx.defaultPolyline, dojo.gfx.defaultRect, dojo.gfx.defaultEllipse, dojo.gfx.defaultCircle, dojo.gfx.defaultLine, or dojo.gfx.defaultImage)"}}}},"dojo.gfx.Shape.attachFill":{"meta":{"summary":"deduces a fill style from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar fillStyle = null;\n\t\tif(rawNode){\n\t\t\tvar fill = rawNode.getAttribute(\"fill\");\n\t\t\tif(fill == \"none\"){ return; }\n\t\t\tvar ref  = dojo.gfx.svg.getRef(fill);\n\t\t\tif(ref){\n\t\t\t\tvar gradient = ref;\n\t\t\t\tswitch(gradient.tagName.toLowerCase()){\n\t\t\t\t\tcase \"lineargradient\":\n\t\t\t\t\t\tfillStyle = this._getGradient(dojo.gfx.defaultLinearGradient, gradient);\n\t\t\t\t\t\tdojo.lang.forEach([\"x1\", \"y1\", \"x2\", \"y2\"], function(x){\n\t\t\t\t\t\t\tfillStyle[x] = gradient.getAttribute(x);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"radialgradient\":\n\t\t\t\t\t\tfillStyle = this._getGradient(dojo.gfx.defaultRadialGradient, gradient);\n\t\t\t\t\t\tdojo.lang.forEach([\"cx\", \"cy\", \"r\"], function(x){\n\t\t\t\t\t\t\tfillStyle[x] = gradient.getAttribute(x);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfillStyle.cx = gradient.getAttribute(\"cx\");\n\t\t\t\t\t\tfillStyle.cy = gradient.getAttribute(\"cy\");\n\t\t\t\t\t\tfillStyle.r  = gradient.getAttribute(\"r\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"pattern\":\n\t\t\t\t\t\tfillStyle = dojo.lang.shallowCopy(dojo.gfx.defaultPattern, true);\n\t\t\t\t\t\tdojo.lang.forEach([\"x\", \"y\", \"width\", \"height\"], function(x){\n\t\t\t\t\t\t\tfillStyle[x] = gradient.getAttribute(x);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfillStyle.src = gradient.firstChild.getAttributeNS(dojo.svg.xmlns.xlink, \"href\");\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfillStyle = new dojo.gfx.color.Color(fill);\n\t\t\t\tvar opacity = rawNode.getAttribute(\"fill-opacity\");\n\t\t\t\tif(opacity != null) fillStyle.a = opacity;\n\t\t\t}\n\t\t}\n\t\treturn fillStyle;\t\/\/ Object","returns":"Object","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.Shape._getGradient":{"meta":{"summary":"","parameters":{"defaultGradient":{"type":""},"gradient":{"type":""}},"src":" \tvar fillStyle = dojo.lang.shallowCopy(defaultGradient, true);\n\t\tfillStyle.colors = [];\n\t\tfor(var i = 0; i < gradient.childNodes.length; ++i){\n\t\t\tfillStyle.colors.push({\n\t\t\t\toffset: gradient.childNodes[i].getAttribute(\"offset\"),\n\t\t\t\tcolor:  new dojo.gfx.color.Color(gradient.childNodes[i].getAttribute(\"stop-color\"))\n\t\t\t});\n\t\t}\n\t\treturn fillStyle;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.attachStroke":{"meta":{"summary":"deduces a stroke style from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tif(!rawNode){ return; }\n\t\tvar stroke = rawNode.getAttribute(\"stroke\");\n\t\tif(stroke == null || stroke == \"none\") return null;\n\t\tvar strokeStyle = dojo.lang.shallowCopy(dojo.gfx.defaultStroke, true);\n\t\tvar color = new dojo.gfx.color.Color(stroke);\n\t\tif(color){\n\t\t\tstrokeStyle.color = color;\n\t\t\tstrokeStyle.color.a = rawNode.getAttribute(\"stroke-opacity\");\n\t\t\tstrokeStyle.width = rawNode.getAttribute(\"stroke-width\");\n\t\t\tstrokeStyle.cap = rawNode.getAttribute(\"stroke-linecap\");\n\t\t\tstrokeStyle.join = rawNode.getAttribute(\"stroke-linejoin\");\n\t\t\tif(strokeStyle.join == \"miter\"){\n\t\t\t\tstrokeStyle.join = rawNode.getAttribute(\"stroke-miterlimit\");\n\t\t\t}\n\t\t}\n\t\treturn strokeStyle;\t\/\/ Object","returns":"Object","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.Shape.attachTransform":{"meta":{"summary":"deduces a transformation matrix from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar matrix = null;\n\t\tif(rawNode){\n\t\t\tmatrix = rawNode.getAttribute(\"transform\");\n\t\t\tif(matrix.match(\/^matrix\\(.+\\)$\/)){\n\t\t\t\tvar t = matrix.slice(7, -1).split(\",\");\n\t\t\t\tmatrix = dojo.gfx.matrix.normalize({\n\t\t\t\t\txx: parseFloat(t[0]), xy: parseFloat(t[2]), \n\t\t\t\t\tyx: parseFloat(t[1]), yy: parseFloat(t[3]), \n\t\t\t\t\tdx: parseFloat(t[4]), dy: parseFloat(t[5])\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn matrix;\t\/\/ dojo.gfx.matrix.Matrix","returns":"dojo.gfx.matrix.Matrix","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.Shape.attachShape":{"meta":{"summary":"builds a shape from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar shape = null;\n\t\tif(rawNode){\n\t\t\tshape = dojo.lang.shallowCopy(this.shape, true);\n\t\t\tfor(var i in shape) {\n\t\t\t\tshape[i] = rawNode.getAttribute(i);\n\t\t\t}\n\t\t}\n\t\treturn shape;\t\/\/ dojo.gfx.Shape","returns":"dojo.gfx.Shape","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.Shape.attach":{"meta":{"summary":"reconstructs all shape parameters from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tif(rawNode) {\n\t\t\tthis.rawNode = rawNode;\n\t\t\tthis.fillStyle = this.attachFill(rawNode);\n\t\t\tthis.strokeStyle = this.attachStroke(rawNode);\n\t\t\tthis.matrix = this.attachTransform(rawNode);\n\t\t\tthis.shape = this.attachShape(rawNode);\n\t\t}","prototype":"dojo.gfx.Shape"},"extra":{"variables":{"rawNode":{"type":"Node","summary":"an SVG node"}}}},"dojo.gfx.Surface.setDimensions":{"meta":{"summary":"sets the width and height of the rawNode","parameters":{"width":{"type":""},"height":{"type":""}},"src":" \tif(!this.rawNode){ return this; }\n\t\tthis.rawNode.setAttribute(\"width\",  width);\n\t\tthis.rawNode.setAttribute(\"height\", height);\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Surface"},"extra":{"parameters":{"width":{"type":"String","summary":"width of surface, e.g., \"100px\""},"height":{"type":"String","summary":"height of surface, e.g., \"100px\""}}}},"dojo.gfx.Surface.getDimensions":{"meta":{"summary":"returns an object with properties \"width\" and \"height\"","src":" \treturn this.rawNode ? {width: this.rawNode.getAttribute(\"width\"), height: this.rawNode.getAttribute(\"height\")} : null; \/\/ Object","returns":"Object","prototype":"dojo.gfx.Surface"}},"dojo.gfx.svg.Defines.setRawNode":{"meta":{"summary":"","parameters":{"rawNode":{"type":""}},"src":" \tthis.rawNode = rawNode;","prototype":"dojo.gfx.svg.Defines"}},"dojo.gfx._creators.createPath":{"meta":{"summary":"creates an SVG path shape","parameters":{"path":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Path, path);\t\/\/ dojo.gfx.Path","returns":"dojo.gfx.Path"},"extra":{"parameters":{"path":{"type":"Object","summary":"a path object (see dojo.gfx.defaultPath)"}}}},"dojo.gfx._creators.createRect":{"meta":{"summary":"creates an SVG rectangle shape","parameters":{"rect":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Rect, rect);\t\/\/ dojo.gfx.Rect","returns":"dojo.gfx.Rect"},"extra":{"parameters":{"rect":{"type":"Object","summary":"a path object (see dojo.gfx.defaultRect)"}}}},"dojo.gfx._creators.createCircle":{"meta":{"summary":"creates an SVG circle shape","parameters":{"circle":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Circle, circle);\t\/\/ dojo.gfx.Circle","returns":"dojo.gfx.Circle"},"extra":{"parameters":{"circle":{"type":"Object","summary":"a circle object (see dojo.gfx.defaultCircle)"}}}},"dojo.gfx._creators.createEllipse":{"meta":{"summary":"creates an SVG ellipse shape","parameters":{"ellipse":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Ellipse, ellipse);\t\/\/ dojo.gfx.Ellipse","returns":"dojo.gfx.Ellipse"},"extra":{"parameters":{"ellipse":{"type":"Object","summary":"an ellipse object (see dojo.gfx.defaultEllipse)"}}}},"dojo.gfx._creators.createLine":{"meta":{"summary":"creates an SVG line shape","parameters":{"line":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Line, line);\t\/\/ dojo.gfx.Line","returns":"dojo.gfx.Line"},"extra":{"parameters":{"line":{"type":"Object","summary":"a line object (see dojo.gfx.defaultLine)"}}}},"dojo.gfx._creators.createPolyline":{"meta":{"summary":"creates an SVG polyline\/polygon shape","parameters":{"points":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Polyline, points);\t\/\/ dojo.gfx.Polyline","returns":"dojo.gfx.Polyline"},"extra":{"parameters":{"points":{"type":"Object","summary":"a points object (see dojo.gfx.defaultPolyline) or an Array of points"}}}},"dojo.gfx._creators.createImage":{"meta":{"summary":"creates an SVG image shape","parameters":{"image":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Image, image);\t\/\/ dojo.gfx.Image","returns":"dojo.gfx.Image"},"extra":{"parameters":{"image":{"type":"Object","summary":"an image object (see dojo.gfx.defaultImage)"}}}},"dojo.gfx._creators.createGroup":{"meta":{"summary":"creates an SVG group shape","src":" \treturn this.createObject(dojo.gfx.Group);\t\/\/ dojo.gfx.Group","returns":"dojo.gfx.Group"}},"dojo.gfx._creators.createObject":{"meta":{"summary":"creates an instance of the passed shapeType class","parameters":{"shapeType":{"type":""},"rawShape":{"type":""}},"src":" \tif(!this.rawNode){ return null; }\n\t\tvar shape = new shapeType();\n\t\tvar node = document.createElementNS(dojo.svg.xmlns.svg, shapeType.nodeType); \n\t\tshape.setRawNode(node);\n\t\tthis.rawNode.appendChild(node);\n\t\tshape.setShape(rawShape);\n\t\tthis.add(shape);\n\t\treturn shape;\t\/\/ dojo.gfx.Shape","returns":"dojo.gfx.Shape"},"extra":{"parameters":{"shapeType":{"type":"Function","summary":"a class constructor to create an instance of"},"rawShape":{"type":"Object","summary":"properties to be passed in to the classes \"setShape\" method"}}}},"dojo.gfx._creators.add":{"meta":{"summary":"adds a shape to a group\/surface","parameters":{"shape":{"type":""}},"src":" \tvar oldParent = shape.getParent();\n\t\tif(oldParent){\n\t\t\toldParent.remove(shape, true);\n\t\t}\n\t\tshape._setParent(this, null);\n\t\tthis.rawNode.appendChild(shape.rawNode);\n\t\treturn this;\t\/\/ self","returns":"self"},"extra":{"parameters":{"shape":{"type":"dojo.gfx.Shape","summary":"an SVG shape object"}}}},"dojo.gfx._creators.remove":{"meta":{"summary":"remove a shape from a group\/surface","parameters":{"shape":{"type":""},"silently":{"type":""}},"src":" \tif(this.rawNode == shape.rawNode.parentNode){\n\t\t\tthis.rawNode.removeChild(shape.rawNode);\n\t\t}\n\t\tshape._setParent(null, null);\n\t\treturn this;\t\/\/ self","instance_variables":["rawNode"],"returns":"self"},"extra":{"parameters":{"shape":{"type":"dojo.gfx.Shape","summary":"an SVG shape object"},"silently":{"type":"Boolean?","summary":"if true, regenerate a picture"}}}}},"objects":{"dojo.gfx._creators":{"meta":{"summary":"SVG shape creators group control"}}}}},"dojo.gfx.vml":{"meta":{"requires":{"common":["dojo.dom","dojo.math","dojo.lang.declare","dojo.lang.extras","dojo.string.*","dojo.html.metrics","dojo.gfx.color","dojo.gfx.common","dojo.gfx.shape","dojo.gfx.path","dojo.experimental"]},"functions":{"dojo.gfx.Group":{"meta":{"prototype_chain":["dojo.gfx.shape.VirtualGroup"],"call_chain":["dojo.gfx.shape.VirtualGroup"]}},"dojo.gfx.Rect":{"meta":{"prototype_chain":["dojo.gfx.shape.Rect"],"call_chain":["dojo.gfx.shape.Rect"]}},"dojo.gfx.Ellipse":{"meta":{"prototype_chain":["dojo.gfx.shape.Ellipse"],"call_chain":["dojo.gfx.shape.Ellipse"]}},"dojo.gfx.Circle":{"meta":{"prototype_chain":["dojo.gfx.shape.Circle"],"call_chain":["dojo.gfx.shape.Circle"]}},"dojo.gfx.Line":{"meta":{"prototype_chain":["dojo.gfx.shape.Line"],"call_chain":["dojo.gfx.shape.Line"],"instance_variables":["shape","bbox","rawNode.path.v"],"summary":"","parameters":{"rawNode":{"type":""}},"src":" \tif(rawNode) rawNode.setAttribute(\"dojoGfxType\", \"line\");"}},"dojo.gfx.Line.attachShape":{"meta":{"summary":"builds a line shape from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar p = rawNode.path.v.match(dojo.gfx.pathRegExp);\n\t\tvar shape = {};\n\t\tdo{\n\t\t\tif(p.length < 7 || p[0] != \"m\" || p[3] != \"l\" || p[6] != \"e\") break;\n\t\t\tshape.x1 = parseInt(p[1]);\n\t\t\tshape.y1 = parseInt(p[2]);\n\t\t\tshape.x2 = parseInt(p[4]);\n\t\t\tshape.y2 = parseInt(p[5]);\n\t\t}while(false);\n\t\treturn dojo.gfx.makeParameters(dojo.gfx.defaultLine, shape);\t\/\/ dojo.gfx.shape.Line","returns":"dojo.gfx.shape.Line","prototype":"dojo.gfx.Line"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Line.setShape":{"meta":{"summary":"sets a line shape object (VML)","parameters":{"newShape":{"type":""}},"src":" \tvar shape = this.shape = dojo.gfx.makeParameters(this.shape, newShape);\n\t\tthis.bbox = null;\n\t\tthis.rawNode.path.v = \"m\" + shape.x1.toFixed() + \" \" + shape.y1.toFixed() +\n\t\t\t\"l\" + shape.x2.toFixed() + \" \" + shape.y2.toFixed() + \"e\";\n\t\treturn this.setTransform(this.matrix);\t\/\/ self","returns":"self","prototype":"dojo.gfx.Line"},"extra":{"parameters":{"newShape":{"type":"Object","summary":"a line shape object"}}}},"dojo.gfx.Polyline":{"meta":{"prototype_chain":["dojo.gfx.shape.Polyline"],"call_chain":["dojo.gfx.shape.Polyline"],"instance_variables":["shape","bbox","rawNode.path.v"],"summary":"","parameters":{"rawNode":{"type":""}},"src":" \tif(rawNode) rawNode.setAttribute(\"dojoGfxType\", \"polyline\");"}},"dojo.gfx.Polyline.attachShape":{"meta":{"summary":"builds a polyline\/polygon shape from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar shape = dojo.lang.shallowCopy(dojo.gfx.defaultPolyline, true);\n\t\tvar p = rawNode.path.v.match(dojo.gfx.pathRegExp);\n\t\tdo{\n\t\t\tif(p.length < 3 || p[0] != \"m\") break;\n\t\t\tvar x = parseInt(p[0]);\n\t\t\tvar y = parseInt(p[1]);\n\t\t\tif(isNaN(x) || isNaN(y)) break;\n\t\t\tshape.points.push({x: x, y: y});\n\t\t\tif(p.length < 6 || p[3] != \"l\") break;\n\t\t\tfor(var i = 4; i < p.length; i += 2){\n\t\t\t\tx = parseInt(p[i]);\n\t\t\t\ty = parseInt(p[i + 1]);\n\t\t\t\tif(isNaN(x) || isNaN(y)) break;\n\t\t\t\tshape.points.push({x: x, y: y});\n\t\t\t}\n\t\t}while(false);\n\t\treturn shape;\t\/\/ dojo.gfx.shape.Polyline","returns":"dojo.gfx.shape.Polyline","prototype":"dojo.gfx.Polyline"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Polyline.setShape":{"meta":{"summary":"sets a polyline\/polygon shape object (SVG)","parameters":{"points":{"type":""},"closed":{"type":""}},"src":" \tif(points && points instanceof Array){\n\t\t\t\/\/ branch\n\t\t\t\/\/ points: Array: an array of points\n\t\t\tthis.shape = dojo.gfx.makeParameters(this.shape, { points: points });\n\t\t\tif(closed && this.shape.points.length) this.shape.points.push(this.shape.points[0]);\n\t\t}else{\n\t\t\tthis.shape = dojo.gfx.makeParameters(this.shape, points);\n\t\t}\n\t\tthis.bbox = null;\n\t\tvar attr = [];\n\t\tvar p = this.shape.points;\n\t\tif(p.length > 0){\n\t\t\tattr.push(\"m\");\n\t\t\tattr.push(p[0].x.toFixed());\n\t\t\tattr.push(p[0].y.toFixed());\n\t\t\tif(p.length > 1){\n\t\t\t\tattr.push(\"l\");\n\t\t\t\tfor(var i = 1; i < p.length; ++i){\n\t\t\t\t\tattr.push(p[i].x.toFixed());\n\t\t\t\t\tattr.push(p[i].y.toFixed());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tattr.push(\"e\");\n\t\tthis.rawNode.path.v = attr.join(\" \");\n\t\treturn this.setTransform(this.matrix);\t\/\/ self","returns":"self","prototype":"dojo.gfx.Polyline"},"extra":{"parameters":{"points":{"type":"Object","summary":"a polyline\/polygon shape object"},"closed":{"type":"Boolean?","summary":"if true, close the polyline explicitely"}}}},"dojo.gfx.Image":{"meta":{"prototype_chain":["dojo.gfx.shape.Image"],"call_chain":["dojo.gfx.shape.Image"]}},"dojo.gfx.Path":{"meta":{"prototype_chain":["dojo.gfx.path.Path"],"call_chain":["dojo.gfx.path.Path"],"prototype_variables":["_PI4","_curvePI4"],"instance_variables":["vmlPath","rawNode.path.v","lastControl","lastControl.type","lastControl.x","lastControl.y"],"variables":["_PI4","_curvePI4"],"summary":"","parameters":{"rawNode":{"type":""}},"src":" \tif(rawNode) rawNode.setAttribute(\"dojoGfxType\", \"path\");\n\t\tthis.vmlPath = \"\";\n\t\tthis.lastControl = {};"}},"dojo.gfx.Path._updateWithSegment":{"meta":{"summary":"updates the bounding box of path with new segment","parameters":{"segment":{"type":""}},"src":" \tvar last = dojo.lang.shallowCopy(this.last);\n\t\tdojo.gfx.Path.superclass._updateWithSegment.apply(this, arguments);\n\t\t\/\/ add a VML path segment\n\t\tvar path = this[this.renderers[segment.action]](segment, last);\n\t\tif(typeof(this.vmlPath) == \"string\"){\n\t\t\tthis.vmlPath += path.join(\"\");\n\t\t}else{\n\t\t\tthis.vmlPath = this.vmlPath.concat(path);\n\t\t}\n\t\tif(typeof(this.vmlPath) == \"string\"){\n\t\t\tthis.rawNode.path.v = this.vmlPath + \" e\";\n\t\t}","call_chain":["dojo.gfx.Path.superclass._updateWithSegment"],"prototype":"dojo.gfx.Path"},"extra":{"parameters":{"segment":{"type":"Object","summary":"a segment"}}}},"dojo.gfx.Path.attachShape":{"meta":{"summary":"builds a path shape from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar shape = dojo.lang.shallowCopy(dojo.gfx.defaultPath, true);\n\t\tvar p = rawNode.path.v.match(dojo.gfx.pathRegExp);\n\t\tvar t = [], skip = false;\n\t\tfor(var i = 0; i < p.length; ++p){\n\t\t\tvar s = p[i];\n\t\t\tif(s in this._pathVmlToSvgMap) {\n\t\t\t\tskip = false;\n\t\t\t\tt.push(this._pathVmlToSvgMap[s]);\n\t\t\t} else if(!skip){\n\t\t\t\tvar n = parseInt(s);\n\t\t\t\tif(isNaN(n)){\n\t\t\t\t\tskip = true;\n\t\t\t\t}else{\n\t\t\t\t\tt.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t.length) shape.path = t.join(\" \");\n\t\treturn shape;\t\/\/ dojo.gfx.path.Path","returns":"dojo.gfx.path.Path","prototype":"dojo.gfx.Path"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Path.setShape":{"meta":{"summary":"forms a path using a shape (VML)","parameters":{"newShape":{"type":""}},"src":" \tthis.vmlPath = [];\n\t\tthis.lastControl = {};\n\t\tdojo.gfx.Path.superclass.setShape.apply(this, arguments);\n\t\tthis.vmlPath = this.vmlPath.join(\"\");\n\t\tthis.rawNode.path.v = this.vmlPath + \" e\";\n\t\treturn this;","call_chain":["dojo.gfx.Path.superclass.setShape"],"prototype":"dojo.gfx.Path"},"extra":{"parameters":{"newShape":{"type":"Object","summary":"an VML path string or a path object (see dojo.gfx.defaultPath)"}}}},"dojo.gfx.Path._addArgs":{"meta":{"summary":"","parameters":{"path":{"type":""},"args":{"type":""},"from":{"type":""},"upto":{"type":""}},"src":" \tif(typeof(upto) == \"undefined\"){\n\t\t\tupto = args.length;\n\t\t}\n\t\tif(typeof(from) == \"undefined\"){\n\t\t\tfrom = 0;\n\t\t}\n\t\tfor(var i = from; i < upto; ++i){\n\t\t\tpath.push(\" \");\n\t\t\tpath.push(args[i].toFixed());\n\t\t}","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._addArgsAdjusted":{"meta":{"summary":"","parameters":{"path":{"type":""},"last":{"type":""},"args":{"type":""},"from":{"type":""},"upto":{"type":""}},"src":" \tif(typeof(upto) == \"undefined\"){\n\t\t\tupto = args.length;\n\t\t}\n\t\tif(typeof(from) == \"undefined\"){\n\t\t\tfrom = 0;\n\t\t}\n\t\tfor(var i = from; i < upto; i += 2){\n\t\t\tpath.push(\" \");\n\t\t\tpath.push((last.x + args[i]).toFixed());\n\t\t\tpath.push(\" \");\n\t\t\tpath.push((last.y + args[i + 1]).toFixed());\n\t\t}","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._moveToA":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [\" m\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tif(l == 2){\n\t\t\tthis._addArgs(p, n);\n\t\t}else{\n\t\t\tthis._addArgs(p, n, 0, 2);\n\t\t\tp.push(\" l\");\n\t\t\tthis._addArgs(p, n, 2);\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._moveToR":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [\"x\" in last ? \" t\" : \" m\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tif(l == 2){\n\t\t\tthis._addArgs(p, n);\n\t\t}else{\n\t\t\tthis._addArgs(p, n, 0, 2);\n\t\t\tp.push(\" r\");\n\t\t\tthis._addArgs(p, n, 2);\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._lineToA":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [\" l\"];\n\t\tthis._addArgs(p, segment.args);\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._lineToR":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [\" r\"];\n\t\tthis._addArgs(p, segment.args);\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._hLineToA":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [\" l\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tvar y = \" \" + last.y.toFixed();\n\t\tfor(var i = 0; i < l; ++i){\n\t\t\tp.push(\" \");\n\t\t\tp.push(n[i].toFixed());\n\t\t\tp.push(y);\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._hLineToR":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [\" r\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; ++i){\n\t\t\tp.push(\" \");\n\t\t\tp.push(n[i].toFixed());\n\t\t\tp.push(\" 0\");\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._vLineToA":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [\" l\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tvar x = \" \" + last.x.toFixed();\n\t\tfor(var i = 0; i < l; ++i){\n\t\t\tp.push(x);\n\t\t\tp.push(\" \");\n\t\t\tp.push(n[i].toFixed());\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._vLineToR":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [\" r\"];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; ++i){\n\t\t\tp.push(\" 0 \");\n\t\t\tp.push(n[i].toFixed());\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._curveToA":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 6){\n\t\t\tp.push(\" c\");\n\t\t\tthis._addArgs(p, n, i, i + 6);\n\t\t}\n\t\tthis.lastControl = {x: n[l - 4], y: n[l - 3], type: \"C\"};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._curveToR":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 6){\n\t\t\tp.push(\" v\");\n\t\t\tthis._addArgs(p, n, i, i + 6);\n\t\t\tthis.lastControl = {x: last.x + n[i + 2], y: last.y + n[i + 3]};\n\t\t\tlast.x += n[i + 4];\n\t\t\tlast.y += n[i + 5];\n\t\t}\n\t\tthis.lastControl.type = \"C\";\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._smoothCurveToA":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 4){\n\t\t\tp.push(\" c\");\n\t\t\tif(this.lastControl.type == \"C\"){\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\t2 * last.x - this.lastControl.x, \n\t\t\t\t\t2 * last.y - this.lastControl.y\n\t\t\t\t]);\n\t\t\t}else{\n\t\t\t\tthis._addArgs(p, [last.x, last.y]);\n\t\t\t}\n\t\t\tthis._addArgs(p, n, i, i + 4);\n\t\t}\n\t\tthis.lastControl = {x: n[l - 4], y: n[l - 3], type: \"C\"};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._smoothCurveToR":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 4){\n\t\t\tp.push(\" v\");\n\t\t\tif(this.lastControl.type == \"C\"){\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\tlast.x - this.lastControl.x, \n\t\t\t\t\tlast.y - this.lastControl.y\n\t\t\t\t]);\n\t\t\t}else{\n\t\t\t\tthis._addArgs(p, [0, 0]);\n\t\t\t}\n\t\t\tthis._addArgs(p, n, i, i + 4);\n\t\t\tthis.lastControl = {x: last.x + n[i], y: last.y + n[i + 1]};\n\t\t\tlast.x += n[i + 2];\n\t\t\tlast.y += n[i + 3];\n\t\t}\n\t\tthis.lastControl.type = \"C\";\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._qCurveToA":{"meta":{"summary":"","parameters":{"segment":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 4){\n\t\t\tp.push(\" qb\");\n\t\t\tthis._addArgs(p, n, i, i + 4);\n\t\t}\n\t\tthis.lastControl = {x: n[l - 4], y: n[l - 3], type: \"Q\"};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._qCurveToR":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 4){\n\t\t\tp.push(\" qb\");\n\t\t\tthis._addArgsAdjusted(p, last, n, i, i + 4);\n\t\t\tthis.lastControl = {x: last.x + n[i], y: last.y + n[i + 1]};\n\t\t\tlast.x += n[i + 2];\n\t\t\tlast.y += n[i + 3];\n\t\t}\n\t\tthis.lastControl.type = \"Q\";\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._qSmoothCurveToA":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 2){\n\t\t\tp.push(\" qb\");\n\t\t\tif(this.lastControl.type == \"Q\"){\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\tthis.lastControl.x = 2 * last.x - this.lastControl.x, \n\t\t\t\t\tthis.lastControl.y = 2 * last.y - this.lastControl.y\n\t\t\t\t]);\n\t\t\t}else{\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\tthis.lastControl.x = last.x, \n\t\t\t\t\tthis.lastControl.y = last.y\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis._addArgs(p, n, i, i + 2);\n\t\t}\n\t\tthis.lastControl.type = \"Q\";\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._qSmoothCurveToR":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tfor(var i = 0; i < l; i += 2){\n\t\t\tp.push(\" qb\");\n\t\t\tif(this.lastControl.type == \"Q\"){\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\tthis.lastControl.x = 2 * last.x - this.lastControl.x, \n\t\t\t\t\tthis.lastControl.y = 2 * last.y - this.lastControl.y\n\t\t\t\t]);\n\t\t\t}else{\n\t\t\t\tthis._addArgs(p, [\n\t\t\t\t\tthis.lastControl.x = last.x, \n\t\t\t\t\tthis.lastControl.y = last.y\n\t\t\t\t]);\n\t\t\t}\n\t\t\tthis._addArgsAdjusted(p, last, n, i, i + 2);\n\t\t}\n\t\tthis.lastControl.type = \"Q\";\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._calcArcTo":{"meta":{"summary":"","parameters":{"path":{"type":""},"last":{"type":""},"rx":{"type":""},"ry":{"type":""},"xRotg":{"type":""},"large":{"type":""},"cw":{"type":""},"x":{"type":""},"y":{"type":""}},"src":" \tvar m = dojo.gfx.matrix;\n\t\t\/\/ calculate parameters\n\t\tvar xRot = -dojo.math.degToRad(xRotg);\n\t\tvar rx2 = rx * rx;\n\t\tvar ry2 = ry * ry;\n\t\tvar pa = m.multiplyPoint(\n\t\t\tm.rotate(-xRot), \n\t\t\t{x: (last.x - x) \/ 2, y: (last.y - y) \/ 2}\n\t\t);\n\t\tvar pax2 = pa.x * pa.x;\n\t\tvar pay2 = pa.y * pa.y;\n\t\tvar c1 = Math.sqrt((rx2 * ry2 - rx2 * pay2 - ry2 * pax2) \/ (rx2 * pay2 + ry2 * pax2));\n\t\tvar ca = {\n\t\t\tx:  c1 * rx * pa.y \/ ry,\n\t\t\ty: -c1 * ry * pa.x \/ rx\n\t\t};\n\t\tif(large == cw){\n\t\t\tca = {x: -ca.x, y: -ca.y};\n\t\t}\n\t\t\/\/ our center\n\t\tvar c = m.multiplyPoint(\n\t\t\t[\n\t\t\t\tm.translate(\n\t\t\t\t\t(last.x + x) \/ 2,\n\t\t\t\t\t(last.y + y) \/ 2\n\t\t\t\t),\n\t\t\t\tm.rotate(xRot)\n\t\t\t], \n\t\t\tca\n\t\t);\n\t\t\/\/ start of our arc\n\t\tvar startAngle = Math.atan2(c.y - last.y, last.x - c.x) - xRot;\n\t\tvar endAngle   = Math.atan2(c.y - y, x - c.x) - xRot;\n\t\t\/\/ size of our arc in radians\n\t\tvar theta = cw ? startAngle - endAngle : endAngle - startAngle;\n\t\tif(theta < 0){\n\t\t\ttheta += this._2PI;\n\t\t}else if(theta > this._2PI){\n\t\t\ttheta = this._2PI;\n\t\t}\n\t\t\/\/ calculate our elliptic transformation\n\t\tvar elliptic_transform = m.normalize([\n\t\t\tm.translate(c.x, c.y),\n\t\t\tm.rotate(xRot),\n\t\t\tm.scale(rx, ry)\n\t\t]);\n\t\t\/\/ draw curve chunks\n\t\tvar alpha = this._PI4 \/ 2;\n\t\tvar curve = this._curvePI4;\n\t\tvar step  = cw ? -alpha : alpha;\n\t\tfor(var angle = theta; angle > 0; angle -= this._PI4){\n\t\t\tif(angle < this._PI4){\n\t\t\t\talpha = angle \/ 2;\n\t\t\t\tcurve = dojo.gfx.path._calcArc(alpha);\n\t\t\t\tstep  = cw ? -alpha : alpha;\n\t\t\t}\n\t\t\tvar c1, c2, e;\n\t\t\tvar M = m.normalize([elliptic_transform, m.rotate(startAngle + step)]);\n\t\t\tif(cw){\n\t\t\t\tc1 = m.multiplyPoint(M, curve.c2);\n\t\t\t\tc2 = m.multiplyPoint(M, curve.c1);\n\t\t\t\te  = m.multiplyPoint(M, curve.s );\n\t\t\t}else{\n\t\t\t\tc1 = m.multiplyPoint(M, curve.c1);\n\t\t\t\tc2 = m.multiplyPoint(M, curve.c2);\n\t\t\t\te  = m.multiplyPoint(M, curve.e );\n\t\t\t}\n\t\t\t\/\/ draw the curve\n\t\t\tpath.push(\" c\");\n\t\t\tthis._addArgs(path, [c1.x, c1.y, c2.x, c2.y, e.x, e.y]);\n\t\t\tstartAngle += 2 * step;\n\t\t}","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._arcTo":{"meta":{"summary":"","parameters":{"segment":{"type":""},"last":{"type":""}},"src":" \tvar p = [];\n\t\tvar n = segment.args;\n\t\tvar l = n.length;\n\t\tvar relative = segment.action == \"a\";\n\t\tfor(var i = 0; i < l; i += 7){\n\t\t\tvar x1 = n[i + 5];\n\t\t\tvar y1 = n[i + 6];\n\t\t\tif(relative){\n\t\t\t\tx1 += last.x;\n\t\t\t\ty1 += last.y;\n\t\t\t}\n\t\t\tthis._calcArcTo(\n\t\t\t\tp, last, n[i], n[i + 1], n[i + 2], \n\t\t\t\tn[i + 3] ? 1 : 0, n[i + 4] ? 1 : 0,\n\t\t\t\tx1, y1\n\t\t\t);\n\t\t\tlast = {x: x1, y: y1};\n\t\t}\n\t\tthis.lastControl = {};\n\t\treturn p;","prototype":"dojo.gfx.Path"}},"dojo.gfx.Path._closePath":{"meta":{"summary":"","src":" \tthis.lastControl = {};\n\t\treturn [\"x\"];","prototype":"dojo.gfx.Path"}},"dojo.gfx.vml._parseFloat":{"meta":{"summary":"a helper function to parse VML-specific floating-point values","parameters":{"str":{"type":""}},"src":" return str.match(\/^\\d+f$\/i) ? parseInt(str) \/ 65536 : parseFloat(str);\t\/\/ Number","returns":"Number"},"extra":{"parameters":{"str":{"type":"String","summary":"a representation of a floating-point number"}}}},"dojo.gfx.vml.px_in_pt":{"meta":{"summary":"returns a number of pixels per point","src":" return dojo.html.getCachedFontMeasurements()[\"12pt\"] \/ 12;\t\/\/ Number","returns":"Number"}},"dojo.gfx.vml.pt2px":{"meta":{"summary":"converts points to pixels","parameters":{"len":{"type":""}},"src":" return len * this.px_in_pt();\t\/\/ Number","returns":"Number"},"extra":{"parameters":{"len":{"type":"Number","summary":"a value in points"}}}},"dojo.gfx.vml.px2pt":{"meta":{"summary":"converts pixels to points","parameters":{"len":{"type":""}},"src":" return len \/ this.px_in_pt();\t\/\/ Number","returns":"Number"},"extra":{"parameters":{"len":{"type":"Number","summary":"a value in pixels"}}}},"dojo.gfx.vml.normalizedLength":{"meta":{"summary":"converts any length value to points","parameters":{"len":{"type":""}},"src":" if(len.length == 0) return 0;\n\tif(len.length > 2){\n\t\tvar px_in_pt = this.px_in_pt();\n\t\tvar val = parseFloat(len);\n\t\tswitch(len.slice(-2)){\n\t\t\tcase \"px\": return val;\n\t\t\tcase \"pt\": return val * px_in_pt;\n\t\t\tcase \"in\": return val * 72 * px_in_pt;\n\t\t\tcase \"pc\": return val * 12 * px_in_pt;\n\t\t\tcase \"mm\": return val \/ this.mm_in_pt * px_in_pt;\n\t\t\tcase \"cm\": return val \/ this.cm_in_pt * px_in_pt;\n\t\t}\n\t}\n\treturn parseFloat(len);\t\/\/ Number","returns":"Number"},"extra":{"parameters":{"len":{"type":"String","summary":"a length, e.g., \"12pc\""}}}},"dojo.gfx.path._calcArc":{"meta":{"summary":"","parameters":{"alpha":{"type":""}},"src":" var cosa  = Math.cos(alpha);\n\tvar sina  = Math.sin(alpha);\n\t\/\/ return a start point, 1st and 2nd control points, and an end point\n\tvar p2 = {x: cosa + (4 \/ 3) * (1 - cosa), y: sina - (4 \/ 3) * cosa * (1 - cosa) \/ sina};\n\treturn {\n\t\ts:  {x: cosa, y: sina},\n\t\tc1: p2,\n\t\tc2: {x: p2.x, y: -p2.y},\n\t\te:  {x: cosa, y: -sina}\n\t};"}},"dojo.gfx.attachNode":{"meta":{"summary":"creates a shape from a Node","parameters":{"node":{"type":""}},"src":" if(!node) return null;\n\tvar s = null;\n\tswitch(node.tagName.toLowerCase()){\n\t\tcase dojo.gfx.Rect.nodeType:\n\t\t\ts = new dojo.gfx.Rect();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Ellipse.nodeType:\n\t\t\ts = (node.style.width == node.style.height)\n\t\t\t\t? new dojo.gfx.Circle()\n\t\t\t\t: new dojo.gfx.Ellipse();\n\t\t\tbreak;\n\t\tcase dojo.gfx.Path.nodeType:\n\t\t\tswitch(node.getAttribute(\"dojoGfxType\")){\n\t\t\t\tcase \"line\":\n\t\t\t\t\ts = new dojo.gfx.Line();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"polyline\":\n\t\t\t\t\ts = new dojo.gfx.Polyline();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"path\":\n\t\t\t\t\ts = new dojo.gfx.Path();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase dojo.gfx.Image.nodeType:\n\t\t\ts = new dojo.gfx.Image();\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdojo.debug(\"FATAL ERROR! tagName = \" + node.tagName);\n\t}\n\ts.attach(node);\n\treturn s;\t\/\/ dojo.gfx.Shape","returns":"dojo.gfx.Shape"},"extra":{"parameters":{"node":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.createSurface":{"meta":{"summary":"creates a surface (VML)","parameters":{"parentNode":{"type":""},"width":{"type":""},"height":{"type":""}},"src":"\tvar s = new dojo.gfx.Surface();\n\ts.rawNode = document.createElement(\"v:group\");\n\ts.rawNode.style.width  = width  ? width  : \"100%\";\n\ts.rawNode.style.height = height ? height : \"100%\";\n\ts.rawNode.coordsize = (width && height)\n\t\t? (parseFloat(width) + \" \" + parseFloat(height))\n\t\t: \"100% 100%\";\n\ts.rawNode.coordorigin = \"0 0\";\n\tdojo.byId(parentNode).appendChild(s.rawNode);\n\treturn s;\t\/\/ dojo.gfx.Surface","returns":"dojo.gfx.Surface"},"extra":{"parameters":{"parentNode":{"type":"Node","summary":"a parent node"},"width":{"type":"String","summary":"width of surface, e.g., \"100px\""},"height":{"type":"String","summary":"height of surface, e.g., \"100px\""}}}},"dojo.gfx.attachSurface":{"meta":{"summary":"creates a surface from a Node","parameters":{"node":{"type":""}},"src":" var s = new dojo.gfx.Surface();\n\ts.rawNode = node;\n\treturn s;\t\/\/ dojo.gfx.Surface","returns":"dojo.gfx.Surface"},"extra":{"parameters":{"node":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Shape.setFill":{"meta":{"summary":"sets a fill object (VML)","parameters":{"fill":{"type":""}},"src":"\t\tif(!fill){\n\t\t\t\/\/ don't fill\n\t\t\tthis.fillStyle = null;\n\t\t\tthis.rawNode.filled = false;\n\t\t\treturn this;\n\t\t}\n\t\tif(typeof(fill) == \"object\" && \"type\" in fill){\n\t\t\t\/\/ gradient\n\t\t\tswitch(fill.type){\n\t\t\t\tcase \"linear\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultLinearGradient, fill);\n\t\t\t\t\tthis.fillStyle = f;\n\t\t\t\t\tvar s = \"\";\n\t\t\t\t\tfor(var i = 0; i < f.colors.length; ++i){\n\t\t\t\t\t\tf.colors[i].color = dojo.gfx.normalizeColor(f.colors[i].color);\n\t\t\t\t\t\ts += f.colors[i].offset.toFixed(8) + \" \" + f.colors[i].color.toHex() + \";\";\n\t\t\t\t\t}\n\t\t\t\t\tvar fo = this.rawNode.fill;\n\t\t\t\t\tfo.colors.value = s;\n\t\t\t\t\tfo.method = \"sigma\";\n\t\t\t\t\tfo.type = \"gradient\";\n\t\t\t\t\tfo.angle = (dojo.math.radToDeg(Math.atan2(f.x2 - f.x1, f.y2 - f.y1)) + 180) % 360;\n\t\t\t\t\tfo.on = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"radial\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultRadialGradient, fill);\n\t\t\t\t\tthis.fillStyle = f;\n\t\t\t\t\tvar w = parseFloat(this.rawNode.style.width);\n\t\t\t\t\tvar h = parseFloat(this.rawNode.style.height);\n\t\t\t\t\tvar c = isNaN(w) ? 1 : 2 * f.r \/ w;\n\t\t\t\t\tvar i = f.colors.length - 1;\n\t\t\t\t\tf.colors[i].color = dojo.gfx.normalizeColor(f.colors[i].color);\n\t\t\t\t\tvar s = \"0 \" + f.colors[i].color.toHex();\n\t\t\t\t\tfor(; i >= 0; --i){\n\t\t\t\t\t\tf.colors[i].color = dojo.gfx.normalizeColor(f.colors[i].color);\n\t\t\t\t\t\ts += (1 - c * f.colors[i].offset).toFixed(8) + \" \" + f.colors[i].color.toHex() + \";\";\n\t\t\t\t\t}\n\t\t\t\t\tvar fo = this.rawNode.fill;\n\t\t\t\t\tfo.colors.value = s;\n\t\t\t\t\tfo.method = \"sigma\";\n\t\t\t\t\tfo.type = \"gradientradial\";\n\t\t\t\t\tif(isNaN(w) || isNaN(h)){\n\t\t\t\t\t\tfo.focusposition = \"0.5 0.5\";\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfo.focusposition = (f.cx \/ w).toFixed(8) + \" \" + (f.cy \/ h).toFixed(8);\n\t\t\t\t\t}\n\t\t\t\t\tfo.focussize = \"0 0\";\n\t\t\t\t\tfo.on = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pattern\":\n\t\t\t\t\tvar f = dojo.gfx.makeParameters(dojo.gfx.defaultPattern, fill);\n\t\t\t\t\tthis.fillStyle = f;\n\t\t\t\t\tvar fo = this.rawNode.fill;\n\t\t\t\t\tfo.type = \"tile\";\n\t\t\t\t\tfo.src = f.src;\n\t\t\t\t\tif(f.width && f.height){\n\t\t\t\t\t\t\/\/ in points\n\t\t\t\t\t\tfo.size.x = dojo.gfx.vml.px2pt(f.width);\n\t\t\t\t\t\tfo.size.y = dojo.gfx.vml.px2pt(f.height);\n\t\t\t\t\t}\n\t\t\t\t\tfo.alignShape = false;\n\t\t\t\t\tfo.position.x = 0;\n\t\t\t\t\tfo.position.y = 0;\n\t\t\t\t\tfo.origin.x = f.width  ? f.x \/ f.width  : 0;\n\t\t\t\t\tfo.origin.y = f.height ? f.y \/ f.height : 0;\n\t\t\t\t\tfo.on = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.rawNode.fill.opacity = 1;\n\t\t\treturn this;\n\t\t}\n\t\t\/\/ color object\n\t\tthis.fillStyle = dojo.gfx.normalizeColor(fill);\n\t\tthis.rawNode.fillcolor = this.fillStyle.toHex();\n\t\tthis.rawNode.fill.opacity = this.fillStyle.a;\n\t\tthis.rawNode.filled = true;\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"fill":{"type":"Object","summary":"a fill object (see dojo.gfx.defaultLinearGradient, dojo.gfx.defaultRadialGradient, dojo.gfx.defaultPattern, or dojo.gfx.color.Color)"}}}},"dojo.gfx.Shape":{"meta":{"instance_variables":["fillStyle","rawNode.filled","rawNode.fill.opacity","rawNode.fillcolor","strokeStyle","rawNode.stroked","strokeStyle.color","rawNode.strokecolor","rawNode.strokeweight","rawNode.stroke.opacity","rawNode.stroke.endcap","rawNode.stroke.joinstyle","rawNode.stroke.miterlimit","rawNode","shape","matrix"],"prototype_variables":["_capMap","_capMapReversed"]}},"dojo.gfx.Shape.setStroke":{"meta":{"summary":"sets a stroke object (VML)","parameters":{"stroke":{"type":""}},"src":" \tif(!stroke){\n\t\t\t\/\/ don't stroke\n\t\t\tthis.strokeStyle = null;\n\t\t\tthis.rawNode.stroked = false;\n\t\t\treturn this;\n\t\t}\n\t\t\/\/ normalize the stroke\n\t\tthis.strokeStyle = dojo.gfx.makeParameters(dojo.gfx.defaultStroke, stroke);\n\t\tthis.strokeStyle.color = dojo.gfx.normalizeColor(this.strokeStyle.color);\n\t\t\/\/ generate attributes\n\t\tvar s = this.strokeStyle;\n\t\tthis.rawNode.stroked = true;\n\t\tthis.rawNode.strokecolor = s.color.toCss();\n\t\tthis.rawNode.strokeweight = s.width + \"px\";\t\/\/ TODO: should we assume that the width is always in pixels?\n\t\tif(this.rawNode.stroke) {\n\t\t\tthis.rawNode.stroke.opacity = s.color.a;\n\t\t\tthis.rawNode.stroke.endcap = this._translate(this._capMap, s.cap);\n\t\t\tif(typeof(s.join) == \"number\") {\n\t\t\t\tthis.rawNode.stroke.joinstyle = \"miter\";\n\t\t\t\tthis.rawNode.stroke.miterlimit = s.join;\n\t\t\t}else{\n\t\t\t\tthis.rawNode.stroke.joinstyle = s.join;\n\t\t\t\t\/\/ this.rawNode.stroke.miterlimit = s.width;\n\t\t\t}\n\t\t}\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"stroke":{"type":"Object","summary":"a stroke object (see dojo.gfx.defaultStroke)"}}}},"dojo.gfx.Shape._translate":{"meta":{"summary":"","parameters":{"dict":{"type":""},"value":{"type":""}},"src":" \treturn (value in dict) ? dict[value] : value;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape._applyTransform":{"meta":{"summary":"","src":" \tvar matrix = this._getRealMatrix();\n\t\tif(!matrix) return this;\n\t\tvar skew = this.rawNode.skew;\n\t\tif(typeof(skew) == \"undefined\"){\n\t\t\tfor(var i = 0; i < this.rawNode.childNodes.length; ++i){\n\t\t\t\tif(this.rawNode.childNodes[i].tagName == \"skew\"){\n\t\t\t\t\tskew = this.rawNode.childNodes[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(skew){\n\t\t\tskew.on = false;\n\t\t\tvar mt = matrix.xx.toFixed(8) + \" \" + matrix.xy.toFixed(8) + \" \" + \n\t\t\t\tmatrix.yx.toFixed(8) + \" \" + matrix.yy.toFixed(8) + \" 0 0\";\n\t\t\tvar offset = Math.floor(matrix.dx).toFixed() + \"px \" + Math.floor(matrix.dy).toFixed() + \"px\";\n\t\t\tvar l = parseFloat(this.rawNode.style.left);\n\t\t\tvar t = parseFloat(this.rawNode.style.top);\n\t\t\tvar w = parseFloat(this.rawNode.style.width);\n\t\t\tvar h = parseFloat(this.rawNode.style.height);\n\t\t\tif(isNaN(l)) l = 0;\n\t\t\tif(isNaN(t)) t = 0;\n\t\t\tif(isNaN(w)) w = 1;\n\t\t\tif(isNaN(h)) h = 1;\n\t\t\tvar origin = (-l \/ w - 0.5).toFixed(8) + \" \" + (-t \/ h - 0.5).toFixed(8);\n\t\t\tskew.matrix =  mt;\n\t\t\tskew.origin = origin;\n\t\t\tskew.offset = offset;\n\t\t\tskew.on = true;\n\t\t}\n\t\treturn this;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.setRawNode":{"meta":{"summary":"assigns and clears the underlying node that will represent this shape. Once set, transforms, gradients, etc, can be applied. (no fill & stroke by default)","parameters":{"rawNode":{"type":""}},"src":" \trawNode.stroked = false;\n\t\trawNode.filled  = false;\n\t\tthis.rawNode = rawNode;","prototype":"dojo.gfx.Shape"}},"dojo.gfx.Shape.attachFill":{"meta":{"summary":"deduces a fill style from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar fillStyle = null;\n\t\tvar fo = rawNode.fill;\n\t\tif(rawNode) {\n\t\t\tif(fo.on && fo.type == \"gradient\"){\n\t\t\t\tvar fillStyle = dojo.lang.shallowCopy(dojo.gfx.defaultLinearGradient, true);\n\t\t\t\tvar rad = dojo.math.degToRad(fo.angle);\n\t\t\t\tfillStyle.x2 = Math.cos(rad);\n\t\t\t\tfillStyle.y2 = Math.sin(rad);\n\t\t\t\tfillStyle.colors = [];\n\t\t\t\tvar stops = fo.colors.value.split(\";\");\n\t\t\t\tfor(var i = 0; i < stops.length; ++i){\n\t\t\t\t\tvar t = stops[i].match(\/\\S+\/g);\n\t\t\t\t\tif(!t || t.length != 2) continue;\n\t\t\t\t\tfillStyle.colors.push({offset: dojo.gfx.vml._parseFloat(t[0]), color: new dojo.gfx.color.Color(t[1])});\n\t\t\t\t}\n\t\t\t}else if(fo.on && fo.type == \"gradientradial\"){\n\t\t\t\tvar fillStyle = dojo.lang.shallowCopy(dojo.gfx.defaultRadialGradient, true);\n\t\t\t\tvar w = parseFloat(rawNode.style.width);\n\t\t\t\tvar h = parseFloat(rawNode.style.height);\n\t\t\t\tfillStyle.cx = isNaN(w) ? 0 : fo.focusposition.x * w;\n\t\t\t\tfillStyle.cy = isNaN(h) ? 0 : fo.focusposition.y * h;\n\t\t\t\tfillStyle.r  = isNaN(w) ? 1 : w \/ 2;\n\t\t\t\tfillStyle.colors = [];\n\t\t\t\tvar stops = fo.colors.value.split(\";\");\n\t\t\t\tfor(var i = stops.length - 1; i >= 0; --i){\n\t\t\t\t\tvar t = stops[i].match(\/\\S+\/g);\n\t\t\t\t\tif(!t || t.length != 2) continue;\n\t\t\t\t\tfillStyle.colors.push({offset: dojo.gfx.vml._parseFloat(t[0]), color: new dojo.gfx.color.Color(t[1])});\n\t\t\t\t}\n\t\t\t}else if(fo.on && fo.type == \"tile\"){\n\t\t\t\tvar fillStyle = dojo.lang.shallowCopy(dojo.gfx.defaultPattern, true);\n\t\t\t\tfillStyle.width  = dojo.gfx.vml.pt2px(fo.size.x); \/\/ from pt\n\t\t\t\tfillStyle.height = dojo.gfx.vml.pt2px(fo.size.y); \/\/ from pt\n\t\t\t\tfillStyle.x = fo.origin.x * fillStyle.width;\n\t\t\t\tfillStyle.y = fo.origin.y * fillStyle.height;\n\t\t\t\tfillStyle.src = fo.src;\n\t\t\t}else if(fo.on && rawNode.fillcolor){\n\t\t\t\t\/\/ a color object !\n\t\t\t\tfillStyle = new dojo.gfx.color.Color(rawNode.fillcolor+\"\");\n\t\t\t\tfillStyle.a = fo.opacity;\n\t\t\t}\n\t\t}\n\t\treturn fillStyle;\t\/\/ Object","returns":"Object","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Shape.attachStroke":{"meta":{"summary":"deduces a stroke style from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar strokeStyle = dojo.lang.shallowCopy(dojo.gfx.defaultStroke, true);\n\t\tif(rawNode && rawNode.stroked){\n\t\t\tstrokeStyle.color = new dojo.gfx.color.Color(rawNode.strokecolor.value);\n\t\t\tdojo.debug(\"We are expecting an .75pt here, instead of strokeweight = \" + rawNode.strokeweight );\n\t\t\tstrokeStyle.width = dojo.gfx.vml.normalizedLength(rawNode.strokeweight+\"\");\n\t\t\tstrokeStyle.color.a = rawNode.stroke.opacity;\n\t\t\tstrokeStyle.cap = this._translate(this._capMapReversed, rawNode.stroke.endcap);\n\t\t\tstrokeStyle.join = rawNode.stroke.joinstyle == \"miter\" ? rawNode.stroke.miterlimit : rawNode.stroke.joinstyle;\n\t\t}else{\n\t\t\treturn null;\n\t\t}\n\t\treturn strokeStyle;\t\/\/ Object","returns":"Object","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Shape.attachTransform":{"meta":{"summary":"deduces a transformation matrix from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tvar matrix = {};\n\t\tif(rawNode){\n\t\t\tvar s = rawNode.skew;\n\t\t\tmatrix.xx = s.matrix.xtox;\n\t\t\tmatrix.xy = s.matrix.ytox;\n\t\t\tmatrix.yx = s.matrix.xtoy;\n\t\t\tmatrix.yy = s.matrix.ytoy;\n\t\t\tmatrix.dx = dojo.gfx.vml.pt2px(s.offset.x);\n\t\t\tmatrix.dy = dojo.gfx.vml.pt2px(s.offset.y);\n\t\t}\n\t\treturn dojo.gfx.matrix.normalize(matrix);\t\/\/ dojo.gfx.matrix.Matrix","returns":"dojo.gfx.matrix.Matrix","prototype":"dojo.gfx.Shape"},"extra":{"parameters":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Shape.attach":{"meta":{"summary":"reconstructs all shape parameters from a Node.","parameters":{"rawNode":{"type":""}},"src":" \tif(rawNode){\n\t\t\tthis.rawNode = rawNode;\n\t\t\tthis.shape = this.attachShape(rawNode);\n\t\t\tthis.fillStyle = this.attachFill(rawNode);\n\t\t\tthis.strokeStyle = this.attachStroke(rawNode);\n\t\t\tthis.matrix = this.attachTransform(rawNode);\n\t\t}","prototype":"dojo.gfx.Shape"},"extra":{"variables":{"rawNode":{"type":"Node","summary":"an VML node"}}}},"dojo.gfx.Surface.setDimensions":{"meta":{"summary":"sets the width and height of the rawNode","parameters":{"width":{"type":""},"height":{"type":""}},"src":" \tif(!this.rawNode) return this;\n\t\tthis.rawNode.style.width = width;\n\t\tthis.rawNode.style.height = height;\n\t\tthis.rawNode.coordsize = width + \" \" + height;\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Surface"},"extra":{"parameters":{"width":{"type":"String","summary":"width of surface, e.g., \"100px\""},"height":{"type":"String","summary":"height of surface, e.g., \"100px\""}}}},"dojo.gfx.Surface":{"meta":{"instance_variables":["rawNode.style.width","rawNode.style.height","rawNode.coordsize","rawNode"]}},"dojo.gfx.Surface.getDimensions":{"meta":{"summary":"returns an object with properties \"width\" and \"height\"","src":" \treturn this.rawNode ? { width: this.rawNode.style.width, height: this.rawNode.style.height } : null; \/\/ Object","returns":"Object","prototype":"dojo.gfx.Surface"}},"dojo.gfx.Surface.add":{"meta":{"summary":"adds a shape to a group\/surface","parameters":{"shape":{"type":""}},"src":" \tvar oldParent = shape.getParent();\n\t\tif(this != oldParent){\n\t\t\tthis.rawNode.appendChild(shape.rawNode);\n\t\t\tif(oldParent){\n\t\t\t\toldParent.remove(shape, true);\n\t\t\t}\n\t\t\tshape._setParent(this, null);\n\t\t}\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Surface"},"extra":{"parameters":{"shape":{"type":"dojo.gfx.Shape","summary":"an VMLshape object"}}}},"dojo.gfx.Surface.remove":{"meta":{"summary":"remove a shape from a group\/surface","parameters":{"shape":{"type":""},"silently":{"type":""}},"src":" \tif(this == shape.getParent()){\n\t\t\tif(this.rawNode == shape.rawNode.parentNode){\n\t\t\t\tthis.rawNode.removeChild(shape.rawNode);\n\t\t\t}\n\t\t\tshape._setParent(null, null);\n\t\t}\n\t\treturn this;\t\/\/ self","returns":"self","prototype":"dojo.gfx.Surface"},"extra":{"parameters":{"shape":{"type":"dojo.gfx.Shape","summary":"an VML shape object"},"silently":{"type":"Boolean?","summary":"if true, regenerate a picture"}}}},"zIndex.moveToFront":{"meta":{"summary":"moves a shape to front of its parent's list of shapes (VML)","src":" \tthis.rawNode.parentNode.appendChild(this.rawNode);\n\t\treturn this;"}},"zIndex.moveToBack":{"meta":{"summary":"moves a shape to back of its parent's list of shapes (VML)","src":" \tthis.rawNode.parentNode.insertBefore(this.rawNode, this.rawNode.parentNode.firstChild);\n\t\treturn this;"}},"dojo.gfx._creators.createPath":{"meta":{"summary":"creates an SVG path shape","parameters":{"path":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Path, path, true);\t\/\/ dojo.gfx.Path","returns":"dojo.gfx.Path"},"extra":{"parameters":{"path":{"type":"Object","summary":"a path object (see dojo.gfx.defaultPath)"}}}},"dojo.gfx._creators.createRect":{"meta":{"summary":"creates an VML rectangle shape","parameters":{"rect":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Rect, rect);\t\/\/ dojo.gfx.Rect","returns":"dojo.gfx.Rect"},"extra":{"parameters":{"rect":{"type":"Object","summary":"a path object (see dojo.gfx.defaultRect)"}}}},"dojo.gfx._creators.createCircle":{"meta":{"summary":"creates an VML circle shape","parameters":{"circle":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Circle, circle);\t\/\/ dojo.gfx.Circle","returns":"dojo.gfx.Circle"},"extra":{"parameters":{"circle":{"type":"Object","summary":"a circle object (see dojo.gfx.defaultCircle)"}}}},"dojo.gfx._creators.createEllipse":{"meta":{"summary":"creates an VML ellipse shape","parameters":{"ellipse":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Ellipse, ellipse);\t\/\/ dojo.gfx.Ellipse","returns":"dojo.gfx.Ellipse"},"extra":{"parameters":{"ellipse":{"type":"Object","summary":"an ellipse object (see dojo.gfx.defaultEllipse)"}}}},"dojo.gfx._creators.createLine":{"meta":{"summary":"creates an VML line shape","parameters":{"line":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Line, line, true);\t\/\/ dojo.gfx.Line","returns":"dojo.gfx.Line"},"extra":{"parameters":{"line":{"type":"Object","summary":"a line object (see dojo.gfx.defaultLine)"}}}},"dojo.gfx._creators.createPolyline":{"meta":{"summary":"creates an VML polyline\/polygon shape","parameters":{"points":{"type":""}},"src":" \treturn this.createObject(dojo.gfx.Polyline, points, true);\t\/\/ dojo.gfx.Polyline","returns":"dojo.gfx.Polyline"},"extra":{"parameters":{"points":{"type":"Object","summary":"a points object (see dojo.gfx.defaultPolyline) or an Array of points"}}}},"dojo.gfx._creators.createImage":{"meta":{"summary":"creates an VML image shape","parameters":{"image":{"type":""}},"src":" \tif(!this.rawNode) return null;\n\t\tvar shape = new dojo.gfx.Image();\n\t\tvar node = document.createElement('div');\n\t\tnode.style.position = \"relative\";\n\t\tnode.style.width  = this.rawNode.style.width;\n\t\tnode.style.height = this.rawNode.style.height;\n\t\tnode.style.filter = \"progid:DXImageTransform.Microsoft.Matrix(M11=1, M12=0, M21=0, M22=1, Dx=0, Dy=0)\";\n\t\tvar img  = document.createElement('img');\n\t\tnode.appendChild(img);\n\t\tshape.setRawNode(node);\n\t\tthis.rawNode.appendChild(node);\n\t\tshape.setShape(image);\n\t\tthis.add(shape);\n\t\treturn shape;\t\/\/ dojo.gfx.Image","returns":"dojo.gfx.Image"},"extra":{"parameters":{"image":{"type":"Object","summary":"an image object (see dojo.gfx.defaultImage)"}}}},"dojo.gfx._creators.createGroup":{"meta":{"summary":"creates an VML group shape","src":" \treturn this.createObject(dojo.gfx.Group, null, true);\t\/\/ dojo.gfx.Group","returns":"dojo.gfx.Group"}},"dojo.gfx._creators.createObject":{"meta":{"summary":"creates an instance of the passed shapeType class","parameters":{"shapeType":{"type":""},"rawShape":{"type":""},"overrideSize":{"type":""}},"src":" \tif(!this.rawNode) return null;\n\t\tvar shape = new shapeType();\n\t\tvar node = document.createElement('v:' + shapeType.nodeType);\n\t\tshape.setRawNode(node);\n\t\tthis.rawNode.appendChild(node);\n\t\tif(overrideSize) this._overrideSize(node);\n\t\tshape.setShape(rawShape);\n\t\tthis.add(shape);\n\t\treturn shape;\t\/\/ dojo.gfx.Shape","returns":"dojo.gfx.Shape"},"extra":{"parameters":{"shapeType":{"type":"Function","summary":"a class constructor to create an instance of"},"rawShape":{"type":"Object","summary":"properties to be passed in to the classes \"setShape\" method"}}}},"dojo.gfx._creators._overrideSize":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":" \tnode.style.width  = this.rawNode.style.width;\n\t\tnode.style.height = this.rawNode.style.height;\n\t\tnode.coordsize = parseFloat(node.style.width) + \" \" + parseFloat(node.style.height);"}}},"objects":{"dojo.gfx.Path._pathVmlToSvgMap":{"meta":{"variables":["m","l","t","r","c","v","qb","x","e"]}},"dojo.gfx.Path.renderers":{"meta":{"variables":["M","m","L","l","H","h","V","v","C","c","S","s","Q","q","T","t","A","a","Z","z"]}},"dojo.gfx._creators":{"meta":{"summary":"VML shape creators"}}}}}}