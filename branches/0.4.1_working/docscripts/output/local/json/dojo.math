{"dojo.math.curves":{"meta":{"requires":{"common":["dojo.math"]},"functions":{".getValue":{"meta":{"summary":"Returns the point at point N (in terms of percentage) on this curve.","parameters":{"n":{"type":"float"}},"src":" \t\tvar found = false, value = 0;\n\t\t\tfor(var i = 0; i < ranges.length; i++) {\n\t\t\t\tvar r = ranges[i];\n\t\t\t\t\/\/w(r.join(\" ... \"));\n\t\t\t\tif( n >= r[0] && n < r[1] ) {\n\t\t\t\t\tvar subN = (n - r[0]) \/ r[2];\n\t\t\t\t\tvalue = curves[i].getValue(subN);\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ FIXME: Do we want to assume we're at the end?\n\t\t\tif( !found ) {\n\t\t\t\tvalue = curves[curves.length-1].getValue(1);\n\t\t\t}\n\t\t\tfor(var j = 0; j < i; j++) {\n\t\t\t\tvalue = dojo.math.points.translate(value, curves[j].getValue(1));\n\t\t\t}\n\t\t\treturn value;\t\/\/\tarray","returns":"array"}},".add":{"meta":{"summary":"Add a curve segment to this path","parameters":{"curve":{"type":"dojo.math.curves.*"},"weight":{"type":"float"}},"src":" \t\tif( weight < 0 ) { dojo.raise(\"dojo.math.curves.Path.add: weight cannot be less than 0\"); }\n\t\t\tcurves.push(curve);\n\t\t\tweights.push(weight);\n\t\t\ttotalWeight += weight;\n\t\t\tcomputeRanges();"}},".remove":{"meta":{"summary":"Remove a curve segment from this path","parameters":{"curve":{"type":"dojo.math.curves.*"}},"src":" \t\tfor(var i = 0; i < curves.length; i++) {\n\t\t\t\tif( curves[i] == curve ) {\n\t\t\t\t\tcurves.splice(i, 1);\n\t\t\t\t\ttotalWeight -= weights.splice(i, 1)[0];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomputeRanges();"}},".removeAll":{"meta":{"summary":"Remove all curve segments","src":" \t\tcurves = [];\n\t\t\tweights = [];\n\t\t\ttotalWeight = 0;"}},"computeRanges":{"meta":{"summary":"","src":" \t\tvar start = 0;\n\t\t\tfor(var i = 0; i < weights.length; i++) {\n\t\t\t\tvar end = start + weights[i] \/ totalWeight;\n\t\t\t\tvar len = end - start;\n\t\t\t\tranges[i] = [start, end, len];\n\t\t\t\tstart = end;\n\t\t\t}"}},"dojo.math.curves.Line":{"meta":{"summary":"Creates a straight line object","parameters":{"start":{"type":"array"},"end":{"type":"array"}},"src":" \tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.dimensions = start.length;\n\t\tfor(var i = 0; i < start.length; i++) {\n\t\t\tstart[i] = Number(start[i]);\n\t\t}\n\t\tfor(var i = 0; i < end.length; i++) {\n\t\t\tend[i] = Number(end[i]);\n\t\t}\n\t\t\/\/simple function to find point on an n-dimensional, straight line\n\t\tthis.getValue = function(\/* float *\/n){\n\t\t\t\/\/\tsummary\n\t\t\t\/\/\tReturns the point at point N (in terms of percentage) on this line.\n\t\t\tvar retVal = new Array(this.dimensions);\n\t\t\tfor(var i=0;i<this.dimensions;i++)\n\t\t\t\tretVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];\n\t\t\treturn retVal;\t\/\/\tarray\n\t\t}\n\t\treturn this;\t\/\/\tdojo.math.curves.Line","instance_variables":["start","end","dimensions","getValue"],"returns":"mixed"}},"dojo.math.curves.Line.getValue":{"meta":{"summary":"Returns the point at point N (in terms of percentage) on this line.","parameters":{"n":{"type":"float"}},"src":" \t\tvar retVal = new Array(this.dimensions);\n\t\t\tfor(var i=0;i<this.dimensions;i++)\n\t\t\t\tretVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];\n\t\t\treturn retVal;\t\/\/\tarray","returns":"array","instance":"dojo.math.curves.Line"}}},"objects":{"dojo.math.curves":{"meta":{"variables":["Bezier"]}}}}},"dojo.math.matrix":{"meta":{"functions":{"dojo.math.matrix.multiply":{"meta":{"summary":"","parameters":{"a":{"type":""},"b":{"type":""}},"src":" var ay = a.length;\n\tvar ax = a[0].length;\n\tvar by = b.length;\n\tvar bx = b[0].length;\n\tif (ax != by){\n\t\tdojo.debug(\"Can't multiply matricies of sizes \"+ax+','+ay+' and '+bx+','+by);\n\t\treturn [[0]];\n\t}\n\tvar c = [];\n\tfor(var k=0; k<ay; k++){\n\t\tc[k] = [];\n\t\tfor(var i=0; i<bx; i++){\n\t\t\tc[k][i] = 0;\n\t\t\tfor(var m=0; m<ax; m++){\n\t\t\t\tc[k][i] += a[k][m]*b[m][i];\n\t\t\t}\n\t\t}\n\t}\n\treturn c;"}},"dojo.math.matrix.product":{"meta":{"summary":"","src":" if (arguments.length==0) {\n\t\tdojo.debug (\"can't multiply 0 matrices!\");\n\t\treturn 1;\n\t}\n\tvar result = arguments[0];\n\tfor (var i=1; i<arguments.length; i++){\n\t\tresult = dojo.math.matrix.multiply(result,arguments[i]);\n\t}\n\treturn result;"}},"dojo.math.matrix.sum":{"meta":{"summary":"","src":" if (arguments.length==0) {\n\t\tdojo.debug (\"can't sum 0 matrices!\");\n\t\treturn 0;\n\t}\n\tvar result = dojo.math.matrix.copy(arguments[0]);\n\tvar rows = result.length;\n\tif (rows==0) {\n\t\tdojo.debug (\"can't deal with matrices of 0 rows!\");\n\t\treturn 0;\n\t}\n\tvar cols = result[0].length;\n\tif (cols==0) {\n\t\tdojo.debug (\"can't deal with matrices of 0 cols!\");\n\t\treturn 0;\n\t}\n\tfor (var i=1; i<arguments.length; ++i) {\n\t\tvar arg = arguments[i];\n\t\tif (arg.length!=rows || arg[0].length!=cols) {\n\t\t\tdojo.debug (\"can't add matrices of different dimensions: first dimensions were \" + rows + \"x\" + cols + \", current dimensions are \"+arg.length + \"x\" + arg[0].length);\n\t\t\treturn 0;\n\t\t}\n\t\t\/\/ The actual addition:\n\t\tfor (var r=0; r<rows; r++){\n\t\t\tfor (var c=0; c<cols; c++){\n\t\t\t\tresult[r][c] += arg[r][c];\n\t\t\t}\n\t\t}\n\t}\n\treturn result;"}},"dojo.math.matrix.inverse":{"meta":{"summary":"","parameters":{"a":{"type":""}},"src":" if (a.length==1 && a[0].length==1){\n\t\treturn [[ 1 \/ a[0][0] ]];\n\t}\n\t\/\/ Formula used to Calculate Inverse:\n\t\/\/ inv(A) = 1\/det(A) * adj(A)\n\tvar tms = a.length;\n\tvar m = dojo.math.matrix.create(tms, tms);\n\tvar mm = dojo.math.matrix.adjoint(a);\n\tvar det = dojo.math.matrix.determinant(a);\n\tvar dd = 0;\n\tif(det == 0){\n\t\tdojo.debug(\"Determinant Equals 0, Not Invertible.\");\n\t\treturn [[0]];\n\t}else{\n\t\tdd = 1 \/ det;\n\t}\n\tfor (var i = 0; i < tms; i++){\n\t\tfor (var j = 0; j < tms; j++) {\n\t\t\tm[i][j] = dd * mm[i][j];\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.determinant":{"meta":{"summary":"","parameters":{"a":{"type":""}},"src":" if (a.length != a[0].length){\n\t\tdojo.debug(\"Can't calculate the determiant of a non-squre matrix!\");\n\t\treturn 0;\n\t}\n\tvar tms = a.length;\n\tvar det = 1;\n\tvar b = dojo.math.matrix.upperTriangle(a);\n\tfor (var i=0; i < tms; i++){\n\t\tvar bii = b[i][i];\n\t\tif (Math.abs(bii) < dojo.math.matrix.ALMOST_ZERO){\n\t\t\treturn 0;\n\t\t}\n\t\tdet *= bii;\n\t}\n\tdet = det * dojo.math.matrix.iDF;\n\treturn det;"}},"dojo.math.matrix.upperTriangle":{"meta":{"summary":"","parameters":{"m":{"type":""}},"src":" m = dojo.math.matrix.copy(m);     \/\/ Copy m, because m is changed!\n\tvar f1 = 0;\n\tvar temp = 0;\n\tvar tms = m.length;\n\tvar v = 1;\n\t\/\/Erel: why use a global variable and not a local variable?\n\tdojo.math.matrix.iDF = 1;\n\tfor (var col = 0; col < tms - 1; col++) {\n\t\tif (typeof m[col][col] != 'number'){\n\t\t\tdojo.debug(\"non-numeric entry found in a numeric matrix: m[\"+col+\"][\"+col+\"]=\"+m[col][col]);\n\t\t}\n\t\tv = 1;\n\t\tvar stop_loop = 0;\n\t\t\/\/ check if there is a 0 in diagonal\n\t\twhile ((m[col][col] == 0) && !stop_loop) {\n\t\t\t\/\/ if so,  switch rows until there is no 0 in diagonal:\n\t\t\tif (col + v >= tms){\n\t\t\t\t\/\/ check if switched all rows\n\t\t\t\tdojo.math.matrix.iDF = 0;\n\t\t\t\tstop_loop = 1;\n\t\t\t}else{\n\t\t\t\tfor (var r = 0; r < tms; r++) {\n\t\t\t\t\ttemp = m[col][r];\n\t\t\t\t\tm[col][r] = m[col + v][r]; \/\/ switch rows\n\t\t\t\t\tm[col + v][r] = temp;\n\t\t\t\t}\n\t\t\t\tv++; \/\/ count row switchs\n\t\t\t\tdojo.math.matrix.iDF *= -1; \/\/ each switch changes determinant factor\n\t\t\t}\n\t\t}\n\t\t\/\/ loop over lower-right triangle (where row>col):\n\t\t\/\/ for each row, make m[row][col] = 0 by linear operations that don't change the determinant:\n\t\tfor (var row = col + 1; row < tms; row++) {\n\t\t\tif (typeof m[row][col] != 'number'){\n\t\t\t\tdojo.debug(\"non-numeric entry found in a numeric matrix: m[\"+row+\"][\"+col+\"]=\"+m[row][col]);\n\t\t\t}\n\t\t\tif (typeof m[col][row] != 'number'){\n\t\t\t\tdojo.debug(\"non-numeric entry found in a numeric matrix: m[\"+col+\"][\"+row+\"]=\"+m[col][row]);\n\t\t\t}\n\t\t\tif (m[col][col] != 0) {\n\t\t\t\tvar f1 = (-1) * m[row][col] \/ m[col][col];\n\t\t\t\t\/\/ this should make m[row][col] zero:\n\t\t\t\t\/\/ \tm[row] += f1 * m[col];\n\t\t\t\tfor (var i = col; i < tms; i++) {\n\t\t\t\t\tm[row][i] = f1 * m[col][i] + m[row][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.create":{"meta":{"summary":"","parameters":{"a":{"type":""},"b":{"type":""},"value":{"type":""}},"src":" if(!value){\n\t\tvalue = 0;\n\t}\n\tvar m = [];\n\tfor(var i=0; i<b; i++){\n\t\tm[i] = [];\n\t\tfor(var j=0; j<a; j++){\n\t\t\tm[i][j] = value;\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.ones":{"meta":{"summary":"","parameters":{"a":{"type":""},"b":{"type":""}},"src":" return dojo.math.matrix.create(a,b,1); "}},"dojo.math.matrix.zeros":{"meta":{"summary":"","parameters":{"a":{"type":""},"b":{"type":""}},"src":" return dojo.math.matrix.create(a,b,0); "}},"dojo.math.matrix.identity":{"meta":{"summary":"","parameters":{"size":{"type":""},"scale":{"type":""}},"src":" if (!scale){\n\t\tscale = 1;\n\t}\n\tvar m = [];\n\tfor(var i=0; i<size; i++){\n\t\tm[i] = [];\n\t\tfor(var j=0; j<size; j++){\n\t\t\tm[i][j] = (i==j? scale: 0);\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.adjoint":{"meta":{"summary":"","parameters":{"a":{"type":""}},"src":" var tms = a.length;\n\t\/\/ Erel: added \"<=\" to catch zero-size matrix\n\tif (tms <= 1){\n\t\tdojo.debug(\"Can't find the adjoint of a matrix with a dimension less than 2\");\n\t\treturn [[0]];\n\t}\n\tif (a.length != a[0].length){\n\t\tdojo.debug(\"Can't find the adjoint of a non-square matrix\");\n\t\treturn [[0]];\n\t}\n\tvar m = dojo.math.matrix.create(tms, tms);\n\tvar ii = 0;\n\tvar jj = 0;\n\tvar ia = 0;\n\tvar ja = 0;\n\tvar det = 0;\n\tvar ap = dojo.math.matrix.create(tms-1, tms-1);\n\tfor (var i = 0; i < tms; i++){\n\t\tfor (var j = 0; j < tms; j++){\n\t\t\tia = 0;\n\t\t\tfor (ii = 0; ii < tms; ii++) {   \/\/ create a temporary matrix for determinant calc\n\t\t\t\tif (ii==i){\n\t\t\t\t\tcontinue;       \/\/ skip current row\n\t\t\t\t}\n\t\t\t\tja = 0;\n\t\t\t\tfor (jj = 0; jj < tms; jj++) {\n\t\t\t\t\tif (jj==j){\n\t\t\t\t\t\tcontinue;       \/\/ skip current col\n\t\t\t\t\t}\n\t\t\t\t\tap[ia][ja] = a[ii][jj];\n\t\t\t\t\tja++;\n\t\t\t\t}\n\t\t\t\tia++;\n\t\t\t}\n\t\t\tdet = dojo.math.matrix.determinant(ap);\n\t\t\tm[i][j] = Math.pow(-1 , (i + j)) * det;\n\t\t}\n\t}\n\tm = dojo.math.matrix.transpose(m);\n\treturn m;"}},"dojo.math.matrix.transpose":{"meta":{"summary":"","parameters":{"a":{"type":""}},"src":" var m = dojo.math.matrix.create(a.length, a[0].length);\n\tfor (var i = 0; i < a.length; i++){\n\t\tfor (var j = 0; j < a[i].length; j++){\n\t\t\tm[j][i] = a[i][j];\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.format":{"meta":{"summary":"","parameters":{"a":{"type":""},"decimal_points":{"type":""}},"src":" if (arguments.length<=1){\n\t\tdecimal_points = 5;\n\t}\n\tfunction format_int(x, dp){\n\t\tvar fac = Math.pow(10 , dp);\n\t\tvar a = Math.round(x*fac)\/fac;\n\t\tvar b = a.toString();\n\t\tif (b.charAt(0) != '-'){ b = ' ' + b;}\n\t\tvar has_dp = 0;\n\t\tfor(var i=1; i<b.length; i++){\n\t\t\tif (b.charAt(i) == '.'){ has_dp = 1; }\n\t\t}\n\t\tif (!has_dp){ b += '.'; }\n\t\twhile(b.length < dp+3){ b += '0'; }\n\t\treturn b;\n\t}\n\tvar ya = a.length;\n\tvar xa = ya>0? a[0].length: 0;\n\tvar buffer = '';\n\tfor (var y=0; y<ya; y++){\n\t\tbuffer += '| ';\n\t\tfor (var x=0; x<xa; x++){\n\t\t\tbuffer += format_int(a[y][x], decimal_points) + ' ';\n\t\t}\n\t\tbuffer += '|\\n';\n\t}\n\treturn buffer;"}},"dojo.math.matrix.copy":{"meta":{"summary":"","parameters":{"a":{"type":""}},"src":" var ya = a.length;\n\tvar xa = a[0].length;\n\tvar m = dojo.math.matrix.create(xa, ya);\n\tfor (var y=0; y<ya; y++){\n\t\tfor (var x=0; x<xa; x++){\n\t\t\tm[y][x] = a[y][x];\n\t\t}\n\t}\n\treturn m;"}},"dojo.math.matrix.scale":{"meta":{"summary":"","parameters":{"k":{"type":""},"a":{"type":""}},"src":" a = dojo.math.matrix.copy(a);  \/\/ Copy a because a is changed!\n\tvar ya = a.length;\n\tvar xa = a[0].length;\n\tfor (var y=0; y<ya; y++){\n\t\tfor (var x=0; x<xa; x++){\n\t\t\ta[y][x] *= k;\n\t\t}\n\t}\n\treturn a;"}}}}},"dojo.math.points":{"meta":{"requires":{"common":["dojo.math"]},"functions":{"dojo.math.points.translate":{"meta":{"summary":"translate a by b, and return the result.","parameters":{"a":{"type":"array"},"b":{"type":"array"}},"src":" \tif( a.length != b.length ) {\n\t\t\tdojo.raise(\"dojo.math.translate: points not same size (a:[\" + a + \"], b:[\" + b + \"])\");\n\t\t}\n\t\tvar c = new Array(a.length);\n\t\tfor(var i = 0; i < a.length; i++) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t\treturn c;\t\/\/\tarray","returns":"array"}},"dojo.math.points.midpoint":{"meta":{"summary":"Find the point midway between a and b","parameters":{"a":{"type":"array"},"b":{"type":"array"}},"src":" \tif( a.length != b.length ) {\n\t\t\tdojo.raise(\"dojo.math.midpoint: points not same size (a:[\" + a + \"], b:[\" + b + \"])\");\n\t\t}\n\t\tvar c = new Array(a.length);\n\t\tfor(var i = 0; i < a.length; i++) {\n\t\t\tc[i] = (a[i] + b[i]) \/ 2;\n\t\t}\n\t\treturn c;\t\/\/\tarray","returns":"array"}},"dojo.math.points.invert":{"meta":{"summary":"invert the values in a and return it.","parameters":{"a":{"type":"array"}},"src":" \tvar b = new Array(a.length);\n\t\tfor(var i = 0; i < a.length; i++) { b[i] = -a[i]; }\n\t\treturn b;\t\/\/\tarray","returns":"array"}},"dojo.math.points.distance":{"meta":{"summary":"Calculate the distance between point a and point b","parameters":{"a":{"type":"array"},"b":{"type":"array"}},"src":" \treturn Math.sqrt(Math.pow(b[0]-a[0], 2) + Math.pow(b[1]-a[1], 2));\t\/\/ \tfloat","returns":"float"}}}}},"dojo.math":{"meta":{"functions":{"dojo.math.degToRad":{"meta":{"summary":"Converts degrees to radians.","parameters":{"x":{"type":"float"}},"src":" return (x*Math.PI) \/ 180; \t\/\/\tfloat","returns":"float"}},"dojo.math.radToDeg":{"meta":{"summary":"Converts radians to degrees.","parameters":{"x":{"type":"float"}},"src":" return (x*180) \/ Math.PI; \t\/\/\tfloat","returns":"float"}},"dojo.math.factorial":{"meta":{"summary":"Returns n!","parameters":{"n":{"type":"integer"}},"src":" if(n<1){ return 0; }\n\tvar retVal = 1;\n\tfor(var i=1;i<=n;i++){ retVal *= i; }\n\treturn retVal;\t\/\/\tinteger","returns":"integer"}},"dojo.math.permutations":{"meta":{"summary":"The number of ways of obtaining an ordered subset of k elements from a set of n elements","parameters":{"n":{"type":"integer"},"k":{"type":"integer"}},"src":" if(n==0 || k==0) return 1;\n\treturn (dojo.math.factorial(n) \/ dojo.math.factorial(n-k));\t\/\/\tfloat","returns":"float"}},"dojo.math.combinations":{"meta":{"summary":"The number of ways of picking n unordered outcomes from r possibilities","parameters":{"n":{"type":"integer"},"r":{"type":"integer"}},"src":" if(n==0 || r==0) return 1;\n\treturn (dojo.math.factorial(n) \/ (dojo.math.factorial(n-r) * dojo.math.factorial(r)));\t\/\/\tfloat","returns":"float"}},"dojo.math.bernstein":{"meta":{"summary":"Calculates a weighted average based on the Bernstein theorem.","parameters":{"t":{"type":"float"},"n":{"type":"float"},"i":{"type":"float"}},"src":" return (dojo.math.combinations(n,i) * Math.pow(t,i) * Math.pow(1-t,n-i));\t\/\/\tfloat","returns":"float"}},"dojo.math.gaussianRandom":{"meta":{"summary":"Returns random numbers with a Gaussian distribution, with the mean set at 0 and the variance set at 1.","src":" var k = 2;\n\tdo {\n\t\tvar i = 2 * Math.random() - 1;\n\t\tvar j = 2 * Math.random() - 1;\n\t\tk = i * i + j * j;\n\t} while (k >= 1);\n\tk = Math.sqrt((-2 * Math.log(k)) \/ k);\n\treturn i * k;\t\/\/\tfloat","returns":"float"}},"dojo.math.mean":{"meta":{"summary":"Calculates the mean of an Array of numbers.","src":" var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;\n\tvar mean = 0;\n\tfor (var i = 0; i < array.length; i++) { mean += array[i]; }\n\treturn mean \/ array.length;\t\/\/\tfloat","returns":"float"}},"dojo.math.round":{"meta":{"summary":"Extends Math.round by adding a second argument specifying the number of decimal places to round to. TODO: add support for significant figures","parameters":{"number":{"type":"float"},"places":{"type":"integer"}},"src":" if (!places) { var shift = 1; }\n\telse { var shift = Math.pow(10, places); }\n\treturn Math.round(number * shift) \/ shift;\t\/\/\tfloat","returns":"float"}},"dojo.math.sd":{"meta":{"is":"dojo.math.standardDeviation"}},"dojo.math.standardDeviation":{"meta":{"summary":"Calculates the standard deviation of an Array of numbers","src":" var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;\n\treturn Math.sqrt(dojo.math.variance(array));\t\/\/\tfloat","returns":"float"}},"dojo.math.variance":{"meta":{"summary":"Calculates the variance of an Array of numbers","src":" var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;\n\tvar mean = 0, squares = 0;\n\tfor (var i = 0; i < array.length; i++) {\n\t\tmean += array[i];\n\t\tsquares += Math.pow(array[i], 2);\n\t}\n\treturn (squares \/ array.length) - Math.pow(mean \/ array.length, 2);\t\/\/\tfloat","returns":"float"}},"dojo.math.range":{"meta":{"summary":"implementation of Python's range()","parameters":{"a":{"type":"integer"},"b":{"type":"integer"},"step":{"type":"integer"}},"src":"    if(arguments.length < 2) {\n        b = a;\n        a = 0;\n    }\n    if(arguments.length < 3) {\n        step = 1;\n    }\n    var range = [];\n    if(step > 0) {\n        for(var i = a; i < b; i += step) {\n            range.push(i);\n        }\n    } else if(step < 0) {\n        for(var i = a; i > b; i += step) {\n            range.push(i);\n        }\n    } else {\n        throw new Error(\"dojo.math.range: step must be non-zero\");\n    }\n    return range;\t\/\/\tarray","returns":"array"}}}}}}