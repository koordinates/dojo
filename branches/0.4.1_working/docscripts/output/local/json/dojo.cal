{"dojo.cal.iCalendar":{"meta":{"requires":{"common":["dojo.lang.common","dojo.cal.textDirectory","dojo.date.common","dojo.date.serialize"]},"functions":{"dojo.cal.iCalendar.fromText":{"meta":{"summary":"Parse text of an iCalendar and return an array of iCalendar objects","parameters":{"text":{"type":"string"}},"src":"\tvar properties = dojo.cal.textDirectory.tokenise(text);\n\tvar calendars = [];\n\t\/\/dojo.debug(\"Parsing iCal String\");\n\tfor (var i = 0, begun = false; i < properties.length; i++) {\n\t\tvar prop = properties[i];\n\t\tif (!begun) {\n\t\t\tif (prop.name == 'BEGIN' && prop.value == 'VCALENDAR') {\n\t\t\t\tbegun = true;\n\t\t\t\tvar calbody = [];\n\t\t\t}\n\t\t} else if (prop.name == 'END' && prop.value == 'VCALENDAR') {\n\t\t\tcalendars.push(new dojo.cal.iCalendar.VCalendar(calbody));\n\t\t\tbegun = false;\n\t\t} else {\n\t\t\tcalbody.push(prop);\n\t\t}\n\t}\n\treturn \/* array *\/calendars;"}},"dojo.cal.iCalendar.Component":{"meta":{"summary":"A component is the basic container of all this stuff.","parameters":{"body":{"type":"string"}},"src":"\tif (!this.name) {\n\t\tthis.name = \"COMPONENT\"\n\t}\n\tthis.properties = [];\n\tthis.components = [];\n\tif (body) {\n\t\tfor (var i = 0, context = ''; i < body.length; i++) {\n\t\t\tif (context == '') {\n\t\t\t\tif (body[i].name == 'BEGIN') {\n\t\t\t\t\tcontext = body[i].value;\n\t\t\t\t\tvar childprops = [];\n\t\t\t\t} else {\n\t\t\t\t\tthis.addProperty(new dojo.cal.iCalendar.Property(body[i]));\n\t\t\t\t}\n\t\t\t} else if (body[i].name == 'END' && body[i].value == context) {\n\t\t\t\tif (context==\"VEVENT\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VEvent(childprops));\n\t\t\t\t} else if (context==\"VTIMEZONE\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VTimeZone(childprops));\n\t\t\t\t} else if (context==\"VTODO\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VTodo(childprops));\n\t\t\t\t} else if (context==\"VJOURNAL\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VJournal(childprops));\n\t\t\t\t} else if (context==\"VFREEBUSY\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VFreeBusy(childprops));\n\t\t\t\t} else if (context==\"STANDARD\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.Standard(childprops));\n\t\t\t\t} else if (context==\"DAYLIGHT\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.Daylight(childprops));\n\t\t\t\t} else if (context==\"VALARM\") {\n\t\t\t\t\tthis.addComponent(new dojo.cal.iCalendar.VAlarm(childprops));\n\t\t\t\t}else {\n\t\t\t\t\tdojo.unimplemented(\"dojo.cal.iCalendar.\" + context);\n\t\t\t\t}\n\t\t\t\tcontext = '';\n\t\t\t} else {\n\t\t\t\tchildprops.push(body[i]);\n\t\t\t}\n\t\t}\n\t\tif (this._ValidProperties) {\n\t\t\tthis.postCreate();\n\t\t}\n\t}","instance_variables":["name","properties","components"]}},"dojo.cal.iCalendar.Property":{"meta":{"summary":"A single property of a component.","parameters":{"prop":{"type":""}},"src":"\t\/\/ unpack the values\n\tthis.name = prop.name;\n\tthis.group = prop.group;\n\tthis.params = prop.params;\n\tthis.value = prop.value;","instance_variables":["name","group","params","value"]}},"_P":{"meta":{"summary":"","parameters":{"n":{"type":""},"oc":{"type":""},"req":{"type":""}},"src":" return {name: n, required: (req) ? true : false,\n\t\toccurance: (oc == '*' || !oc) ? -1 : oc}"}},"dojo.cal.iCalendar.VCalendar":{"meta":{"summary":"VCALENDAR Component","parameters":{"calbody":{"type":"string"}},"src":"\tthis.name = \"VCALENDAR\";\n\tthis.recurring = [];\n\tthis.nonRecurringEvents = function(){};\n\tdojo.cal.iCalendar.Component.call(this, calbody);","instance_variables":["name","recurring","nonRecurringEvents"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VCalendar.nonRecurringEvents":{"meta":{"summary":"","src":"","instance":"dojo.cal.iCalendar.VCalendar"}},"dojo.cal.iCalendar.Standard":{"meta":{"summary":"STANDARD Component","parameters":{"body":{"type":"string"}},"src":"\tthis.name = \"STANDARD\";\n\tthis._ValidProperties = StandardProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.Daylight":{"meta":{"summary":"Daylight Component","parameters":{"body":{"type":"string"}},"src":" this.name = \"DAYLIGHT\";\n\tthis._ValidProperties = DaylightProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VEvent":{"meta":{"summary":"VEVENT Component","parameters":{"body":{"type":"string"}},"src":" this._ValidProperties = VEventProperties;\n\tthis.name = \"VEVENT\";\n\tdojo.cal.iCalendar.Component.call(this, body);\n\tthis.recurring = false;\n\tthis.startDate = dojo.date.fromIso8601(this.dtstart.value);","instance_variables":["_ValidProperties","name","recurring","startDate"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VTimeZone":{"meta":{"summary":"VTIMEZONE Component","parameters":{"body":{"type":"string"}},"src":" this.name = \"VTIMEZONE\";\n\tthis._ValidProperties = VTimeZoneProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VTodo":{"meta":{"summary":"VTODO Componenet","parameters":{"body":{"type":"string"}},"src":" this.name = \"VTODO\";\n\tthis._ValidProperties = VTodoProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VJournal":{"meta":{"summary":"VJOURNAL Component","parameters":{"body":{"type":"string"}},"src":" this.name = \"VJOURNAL\";\n\tthis._ValidProperties = VJournalProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VFreeBusy":{"meta":{"summary":"VFREEBUSY Component","parameters":{"body":{"type":"string"}},"src":" this.name = \"VFREEBUSY\";\n\tthis._ValidProperties = VFreeBusyProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.VAlarm":{"meta":{"summary":"VALARM Component","parameters":{"body":{"type":"string"}},"src":" this.name = \"VALARM\";\n\tthis._ValidProperties = VAlarmProperties;\n\tdojo.cal.iCalendar.Component.call(this, body);","instance_variables":["name","_ValidProperties"],"call_chain":["dojo.cal.iCalendar.Component"],"prototype_chain":["dojo.cal.iCalendar.Component"]}},"dojo.cal.iCalendar.Component.addProperty":{"meta":{"summary":"push a new property onto a component.","parameters":{"prop":{"type":""}},"src":" \tthis.properties.push(prop);\n\t\tthis[prop.name.toLowerCase()] = prop;"}},"dojo.cal.iCalendar.Component.addComponent":{"meta":{"summary":"add a component to this components list of children.","parameters":{"prop":{"type":""}},"src":" \tthis.components.push(prop);"}},"dojo.cal.iCalendar.Component.postCreate":{"meta":{"summary":"","src":" \tfor (var x=0; x<this._ValidProperties.length; x++) {\n\t\t\tvar evtProperty = this._ValidProperties[x];\n\t\t\tvar found = false;\n\t\t\tfor (var y=0; y<this.properties.length; y++) {\t\n\t\t\t\tvar prop = this.properties[y];\n\t\t\t\tvar propName = prop.name.toLowerCase();\n\t\t\t\tif (dojo.lang.isArray(evtProperty)) {\n\t\t\t\t\tvar alreadySet = false;\n\t\t\t\t\tfor (var z=0; z<evtProperty.length; z++) {\n\t\t\t\t\t\tvar evtPropertyName = evtProperty[z].name.toLowerCase();\n\t\t\t\t\t\tif((this[evtPropertyName])  && (evtPropertyName != propName )) {\n\t\t\t\t\t\t\talreadySet=true;\n\t\t\t\t\t\t} \n\t\t\t\t\t}\n\t\t\t\t\tif (!alreadySet) {\n\t\t\t\t\t\tthis[propName] = prop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (propName == evtProperty.name.toLowerCase()) {\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tif (evtProperty.occurance == 1){\n\t\t\t\t\t\t\tthis[propName] = prop;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tif (!dojo.lang.isArray(this[propName])) {\n\t\t\t\t\t\t\t \tthis[propName] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis[propName].push(prop);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (evtProperty.required && !found) {\t\n\t\t\t\tdojo.debug(\"iCalendar - \" + this.name + \": Required Property not found: \" + evtProperty.name);\n\t\t\t}\n\t\t}\n\t\t\/\/ parse any rrules\t\t\n\t\tif (dojo.lang.isArray(this.rrule)) {\n\t\t\tfor(var x=0; x<this.rrule.length; x++) {\n\t\t\t\tvar rule = this.rrule[x].value;\n\t\t\t\t\/\/add a place to cache dates we have checked for recurrance\n\t\t\t\tthis.rrule[x].cache = function() {};\n\t\t\t\tvar temp = rule.split(\";\");\n\t\t\t\tfor (var y=0; y<temp.length; y++) {\n\t\t\t\t\tvar pair = temp[y].split(\"=\");\n\t\t\t\t\tvar key = pair[0].toLowerCase();\n\t\t\t\t\tvar val = pair[1];\n\t\t\t\t\tif ((key == \"freq\") || (key==\"interval\") || (key==\"until\")) {\n\t\t\t\t\t\tthis.rrule[x][key]= val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar valArray = val.split(\",\");\n\t\t\t\t\t\tthis.rrule[x][key] = valArray; \n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tthis.recurring = true;\n\t\t}","instance_variables":["recurring"]}},"dojo.cal.iCalendar.Component.toString":{"meta":{"summary":"output a string representation of this component.","src":" \treturn \"[iCalendar.Component; \" + this.name + \", \" + this.properties.length +\n\t\t\t\" properties, \" + this.components.length + \" components]\";"}},"dojo.cal.iCalendar.Property.toString":{"meta":{"summary":"output a string reprensentation of this component.","src":" \treturn \"[iCalenday.Property; \" + this.name + \": \" + this.value + \"]\";"}},"dojo.cal.iCalendar.VCalendar.addComponent":{"meta":{"summary":"add component to the calenadar that makes it easy to pull them out again later.","parameters":{"prop":{"type":""}},"src":" \tthis.components.push(prop);\n\t\tif (prop.name.toLowerCase() == \"vevent\") {\n\t\t\tif (prop.rrule) {\n\t\t\t\tthis.recurring.push(prop);\n\t\t\t} else {\n\t\t\t\tvar startDate = prop.getDate();\n\t\t\t\tvar month = startDate.getMonth() + 1;\n\t\t\t\tvar dateString= month + \"-\" + startDate.getDate() + \"-\" + startDate.getFullYear();\n\t\t\t\tif (!dojo.lang.isArray(this[dateString])) {\n\t\t\t\t\tthis.nonRecurringEvents[dateString] = [];\n\t\t\t\t}\n\t\t\t\tthis.nonRecurringEvents[dateString].push(prop);\n\t\t\t}\n\t\t}"}},"dojo.cal.iCalendar.VCalendar.preComputeRecurringEvents":{"meta":{"summary":"","parameters":{"until":{"type":""}},"src":" \tvar calculatedEvents = function(){};\n\t\tfor(var x=0; x<this.recurring.length; x++) {\n\t\t\tvar dates = this.recurring[x].getDates(until);\n\t\t\tfor (var y=0; y<dates.length;y++) {\n\t\t\t\tvar month = dates[y].getMonth() + 1;\n\t\t\t\tvar dateStr = month + \"-\" + dates[y].getDate() + \"-\" + dates[y].getFullYear();\n\t\t\t\tif (!dojo.lang.isArray(calculatedEvents[dateStr])) {\n\t\t\t\t\tcalculatedEvents[dateStr] = [];\n\t\t\t\t}\n\t\t\t\tif (!dojo.lang.inArray(calculatedEvents[dateStr], this.recurring[x])) { \n\t\t\t\t\tcalculatedEvents[dateStr].push(this.recurring[x]);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tthis.recurringEvents = calculatedEvents;","instance_variables":["recurringEvents"]}},"dojo.cal.iCalendar.VCalendar.getEvents":{"meta":{"summary":"Gets all events occuring on a particular date","parameters":{"date":{"type":"Date"}},"src":" \tvar events = [];\n\t\tvar recur = [];\n\t\tvar nonRecur = [];\n\t\tvar month = date.getMonth() + 1;\n\t\tvar dateStr= month + \"-\" + date.getDate() + \"-\" + date.getFullYear();\n\t\tif (dojo.lang.isArray(this.nonRecurringEvents[dateStr])) {\n\t\t\tnonRecur= this.nonRecurringEvents[dateStr];\n\t\t\tdojo.debug(\"Number of nonRecurring Events: \" + nonRecur.length);\n\t\t} \n\t\tif (dojo.lang.isArray(this.recurringEvents[dateStr])) {\n\t\t\trecur= this.recurringEvents[dateStr];\n\t\t} \n\t\tevents = recur.concat(nonRecur);\n\t\tif (events.length > 0) {\n\t\t\treturn events;\n\t\t} \n\t\treturn null;\t\t\t"}},"dojo.cal.iCalendar.VEvent.getDates":{"meta":{"summary":"","parameters":{"until":{"type":""}},"src":" \t\tvar dtstart = this.getDate();\n\t\t\tvar recurranceSet = [];\n\t\t\tvar weekdays=[\"su\",\"mo\",\"tu\",\"we\",\"th\",\"fr\",\"sa\"];\n\t\t\tvar order = { \n\t\t\t\t\"daily\": 1, \"weekly\": 2, \"monthly\": 3, \"yearly\": 4,\n\t\t\t\t\"byday\": 1, \"bymonthday\": 1, \"byweekno\": 2, \"bymonth\": 3, \"byyearday\": 4};\n\t\t\t\/\/ expand rrules into the recurrance \n\t\t\tfor (var x=0; x<this.rrule.length; x++) {\n\t\t\t\tvar rrule = this.rrule[x];\n\t\t\t\tvar freq = rrule.freq.toLowerCase();\n\t\t\t\tvar interval = 1;\n\t\t\t\tif (rrule.interval > interval) {\n\t\t\t\t\tinterval = rrule.interval;\n\t\t\t\t}\n\t\t\t\tvar set = [];\n\t\t\t\tvar freqInt = order[freq];\n\t\t\t\tif (rrule.until) {\n\t\t\t\t\tvar tmpUntil = dojo.date.fromIso8601(rrule.until);\n\t\t\t\t} else {\n\t\t\t\t\tvar tmpUntil = until\n\t\t\t\t}\n\t\t\t\tif (tmpUntil > until) {\n\t\t\t\t\ttmpUntil = until\n\t\t\t\t}\n\t\t\t\tif (dtstart<tmpUntil) {\n\t\t\t\t\tvar expandingRules = function(){};\n\t\t\t\t\tvar cullingRules = function(){};\n\t\t\t\t\texpandingRules.length=0;\n\t\t\t\t\tcullingRules.length =0;\n\t\t\t\t\tswitch(freq) {\n\t\t\t\t\t\tcase \"yearly\":\n\t\t\t\t\t\t\tvar nextDate = new Date(dtstart);\n\t\t\t\t\t\t\tset.push(nextDate);\n\t\t\t\t\t\t\twhile(nextDate < tmpUntil) {\n\t\t\t\t\t\t\t\tnextDate.setYear(nextDate.getFullYear()+interval);\n\t\t\t\t\t\t\t\ttmpDate = new Date(nextDate);\n\t\t\t\t\t\t\t\tif(tmpDate < tmpUntil) {\n\t\t\t\t\t\t\t\t\tset.push(tmpDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"monthly\":\n\t\t\t\t\t\t\tnextDate = new Date(dtstart);\n\t\t\t\t\t\t\tset.push(nextDate);\n\t\t\t\t\t\t\twhile(nextDate < tmpUntil) {\n\t\t\t\t\t\t\t\tnextDate.setMonth(nextDate.getMonth()+interval);\n\t\t\t\t\t\t\t\tvar tmpDate = new Date(nextDate);\n\t\t\t\t\t\t\t\tif (tmpDate < tmpUntil) {\n\t\t\t\t\t\t\t\t\tset.push(tmpDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"weekly\":\n\t\t\t\t\t\t\tnextDate = new Date(dtstart);\n\t\t\t\t\t\t\tset.push(nextDate);\n\t\t\t\t\t\t\twhile(nextDate < tmpUntil) {\n\t\t\t\t\t\t\t\tnextDate.setDate(nextDate.getDate()+(7*interval));\n\t\t\t\t\t\t\t\tvar tmpDate = new Date(nextDate);\n\t\t\t\t\t\t\t\tif (tmpDate < tmpUntil) {\n\t\t\t\t\t\t\t\t\tset.push(tmpDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t\tcase \"daily\":\n\t\t\t\t\t\t\tnextDate = new Date(dtstart);\n\t\t\t\t\t\t\tset.push(nextDate);\n\t\t\t\t\t\t\twhile(nextDate < tmpUntil) {\n\t\t\t\t\t\t\t\tnextDate.setDate(nextDate.getDate()+interval);\n\t\t\t\t\t\t\t\tvar tmpDate = new Date(nextDate);\n\t\t\t\t\t\t\t\tif (tmpDate < tmpUntil) {\n\t\t\t\t\t\t\t\t\tset.push(tmpDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((rrule[\"bymonth\"]) && (order[\"bymonth\"]<freqInt))\t{\n\t\t\t\t\t\tfor (var z=0; z<rrule[\"bymonth\"].length; z++) {\n\t\t\t\t\t\t\tif (z==0) {\n\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\tset[zz].setMonth(rrule[\"bymonth\"][z]-1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar subset=[];\n\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\tvar newDate = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\tnewDate.setMonth(rrule[z]);\n\t\t\t\t\t\t\t\t\tsubset.push(newDate);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\ttmp = set.concat(subset);\n\t\t\t\t\t\t\t\tset = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time\n\t\t\t\t\t\/\/ and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web\n\t\t\t\t\tif (rrule[\"byweekno\"] && !rrule[\"bymonth\"]) {\t\n\t\t\t\t\t\tdojo.debug(\"TODO: no support for byweekno yet\");\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time\n\t\t\t\t\t\/\/ and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web\n\t\t\t\t\tif (rrule[\"byyearday\"] && !rrule[\"bymonth\"] && !rrule[\"byweekno\"] ) {\t\n\t\t\t\t\t\tif (rrule[\"byyearday\"].length > 1) {\n\t\t\t\t\t\t\tvar regex = \"([+-]?)([0-9]{1,3})\";\n\t\t\t\t\t\t\tfor (var z=1; x<rrule[\"byyearday\"].length; z++) {\n\t\t\t\t\t\t\t\tvar regexResult = rrule[\"byyearday\"][z].match(regex);\n\t\t\t\t\t\t\t\tif (z==1) {\n\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\tdojo.date.setDayOfYear(set[zz],366-regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdojo.date.setDayOfYear(set[zz],regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\telse {\n\t\t\t\t\t\t\t\t\tvar subset=[];\n\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\tvar newDate = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\tdojo.date.setDayOfYear(newDate,366-regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdojo.date.setDayOfYear(newDate,regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsubset.push(newDate);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttmp = set.concat(subset);\n\t\t\t\t\t\t\t\t\tset = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (rrule[\"bymonthday\"]  && (order[\"bymonthday\"]<freqInt)) {\t\n\t\t\t\t\t\tif (rrule[\"bymonthday\"].length > 0) {\n\t\t\t\t\t\t\tvar regex = \"([+-]?)([0-9]{1,3})\";\n\t\t\t\t\t\t\tfor (var z=0; z<rrule[\"bymonthday\"].length; z++) {\n\t\t\t\t\t\t\t\tvar regexResult = rrule[\"bymonthday\"][z].match(regex);\n\t\t\t\t\t\t\t\tif (z==0) {\n\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\telse {\n\t\t\t\t\t\t\t\t\tvar subset=[];\n\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\tvar newDate = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewDate.setDate(regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsubset.push(newDate);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttmp = set.concat(subset);\n\t\t\t\t\t\t\t\t\tset = tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (rrule[\"byday\"]  && (order[\"byday\"]<freqInt)) {\t\n\t\t\t\t\t\tif (rrule[\"bymonth\"]) {\n\t\t\t\t\t\t\tif (rrule[\"byday\"].length > 0) {\n\t\t\t\t\t\t\t\tvar regex = \"([+-]?)([0-9]{0,1}?)([A-Za-z]{1,2})\";\n\t\t\t\t\t\t\t\tfor (var z=0; z<rrule[\"byday\"].length; z++) {\n\t\t\t\t\t\t\t\t\tvar regexResult = rrule[\"byday\"][z].match(regex);\n\t\t\t\t\t\t\t\t\tvar occurance = regexResult[2];\n\t\t\t\t\t\t\t\t\tvar day = regexResult[3].toLowerCase();\n\t\t\t\t\t\t\t\t\tif (z==0) {\n\t\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\/\/find the nth to last occurance of date \n\t\t\t\t\t\t\t\t\t\t\t\tvar numDaysFound = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar lastDayOfMonth = dojo.date.getDaysInMonth(set[zz]);\n\t\t\t\t\t\t\t\t\t\t\t\tvar daysToSubtract = 1;\n\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(lastDayOfMonth); \n\t\t\t\t\t\t\t\t\t\t\t\tif (weekdays[set[zz].getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToSubtract=7;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdaysToSubtract = 1;\n\t\t\t\t\t\t\t\t\t\t\t\twhile (numDaysFound < occurance) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(set[zz].getDate()-daysToSubtract);\t\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (weekdays[set[zz].getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToSubtract=7;\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (occurance) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar numDaysFound=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar daysToAdd=1;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(weekdays[set[zz].getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToAdd=7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(numDaysFound < occurance) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(set[zz].getDate()+daysToAdd);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(weekdays[set[zz].getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToAdd=7;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\/\/we're gonna expand here to add a date for each of the specified days for each month\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar numDaysFound=0;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar subset = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\tlastDayOfMonth = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar daysInMonth = dojo.date.getDaysInMonth(set[zz]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tlastDayOfMonth.setDate(daysInMonth);\n\t\t\t\t\t\t\t\t\t\t\t\t\tset[zz].setDate(1);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (weekdays[set[zz].getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar tmpDate = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToAdd = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\twhile(tmpDate.getDate() < lastDayOfMonth) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (weekdays[tmpDate.getDay()] == day) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnumDaysFound++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (numDaysFound==1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tset[zz] = tmpDate;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubset.push(tmpDate);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmpDate = new Date(tmpDate);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdaysToAdd=7;\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmpDate.setDate(tmpDate.getDate() + daysToAdd);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttmpDate.setDate(tmpDate.getDate() + daysToAdd);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar t = set.concat(subset);\n\t\t\t\t\t\t\t\t\t\t\t\t\tset = t; \n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\telse {\n\t\t\t\t\t\t\t\t\t\tvar subset=[];\n\t\t\t\t\t\t\t\t\t\tfor (var zz=0; zz < set.length; zz++) {\n\t\t\t\t\t\t\t\t\t\t\tvar newDate = new Date(set[zz]);\n\t\t\t\t\t\t\t\t\t\t\tif (regexResult[1] == \"-\") {\n\t\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewDate.setDate(regexResult[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tsubset.push(newDate);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttmp = set.concat(subset);\n\t\t\t\t\t\t\t\t\t\tset = tmp;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdojo.debug(\"TODO: byday within a yearly rule without a bymonth\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdojo.debug(\"TODO: Process BYrules for units larger than frequency\");\n\t\t\t\t\t\/\/add this set of events to the complete recurranceSet\t\n\t\t\t\t\tvar tmp = recurranceSet.concat(set);\n\t\t\t\t\trecurranceSet = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ TODO: add rdates to the recurrance set here\n\t\t\t\/\/ TODO: subtract exdates from the recurrance set here\n\t\t\t\/\/TODO:  subtract dates generated by exrules from recurranceSet here\n\t\t\trecurranceSet.push(dtstart);\n\t\t\treturn recurranceSet;"}},"dojo.cal.iCalendar.VEvent.getDate":{"meta":{"summary":"","src":" \t\treturn dojo.date.fromIso8601(this.dtstart.value);"}}}}},"dojo.cal.textDirectory":{"meta":{"requires":{"common":["dojo.string"]},"functions":{"dojo.cal.textDirectory.Property":{"meta":{"summary":"parses a single line from an iCalendar text\/directory file and creates an object with four named values; name, group, params and value. name, group and value are strings containing the original tokens unaltered and values is an array containing name\/value pairs or a single name token packed into arrays.","parameters":{"line":{"type":"String"}},"src":"\t\/\/ split into name\/value pair\n\tvar left = dojo.string.trim(line.substring(0, line.indexOf(':')));\n\tvar right = dojo.string.trim(line.substr(line.indexOf(':') + 1));\n\t\/\/ separate name and paramters\t\n\tvar parameters = dojo.string.splitEscaped(left,';');\n\tthis.name = parameters[0];\n\tparameters.splice(0, 1);\n\t\/\/ parse paramters\n\tthis.params = [];\n\tvar arr;\n\tfor(var i = 0; i < parameters.length; i++){\n\t\tarr = parameters[i].split(\"=\");\n\t\tvar key = dojo.string.trim(arr[0].toUpperCase());\n\t\tif(arr.length == 1){ this.params.push([key]); continue; }\n\t\tvar values = dojo.string.splitEscaped(arr[1],',');\n\t\tfor(var j = 0; j < values.length; j++){\n\t\t\tif(dojo.string.trim(values[j]) != ''){\n\t\t\t\tthis.params.push([key, dojo.string.trim(values[j])]);\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ separate group\n\tif(this.name.indexOf('.') > 0){\n\t\tarr = this.name.split('.');\n\t\tthis.group = arr[0];\n\t\tthis.name = arr[1];\n\t}\n\t\/\/ don't do any parsing, leave to implementation\n\tthis.value = right;","instance_variables":["name","params","group","value"]}},"dojo.cal.textDirectory.tokenise":{"meta":{"summary":"parses text into an array of properties.","parameters":{"text":{"type":"String"}},"src":"\t\/\/ normlize to one property per line and parse\n\tvar nText = dojo.string.normalizeNewlines(text,\"\\n\").\n\t\treplace(\/\\n[ \\t]\/g, '').\n\t\treplace(\/\\x00\/g, '');\n\tvar lines = nText.split(\"\\n\");\n\tvar properties = [];\n\tfor(var i = 0; i < lines.length; i++){\n\t\tif(dojo.string.trim(lines[i]) == ''){ continue; }\n\t\tvar prop = new dojo.cal.textDirectory.Property(lines[i]);\n\t\tproperties.push(prop);\n\t}\n\treturn properties; \/\/ Array","returns":"Array"}}}}}}