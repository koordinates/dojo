{"dojo.hostenv_browser":{"meta":{"functions":{"dojo.hostenv.getXmlhttpObject":{"meta":{"summary":"does the work of portably generating a new XMLHTTPRequest object.","src":" \tvar http = null;\n\t\tvar last_e = null;\n\t\ttry{ http = new XMLHttpRequest(); }catch(e){}\n\t\tif(!http){\n\t\t\tfor(var i=0; i<3; ++i){\n\t\t\t\tvar progid = dojo.hostenv._XMLHTTP_PROGIDS[i];\n\t\t\t\ttry{\n\t\t\t\t\thttp = new ActiveXObject(progid);\n\t\t\t\t}catch(e){\n\t\t\t\t\tlast_e = e;\n\t\t\t\t}\n\t\t\t\tif(http){\n\t\t\t\t\tdojo.hostenv._XMLHTTP_PROGIDS = [progid];  \/\/ so faster next time\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/*if(http && !http.toString) {\n\t\t\t\thttp.toString = function() { \"[object XMLHttpRequest]\"; }\n\t\t\t}*\/\n\t\t}\n\t\tif(!http){\n\t\t\treturn dojo.raise(\"XMLHTTP not available\", last_e);\n\t\t}\n\t\treturn http; \/\/ XMLHTTPRequest instance","returns":"XMLHTTPRequest instance"}},"dojo.hostenv.getText":{"meta":{"summary":"Read the contents of the specified uri and return those contents.","parameters":{"uri":{"type":""},"async_cb":{"type":""},"fail_ok":{"type":""}},"src":"\t\t\/\/ need to block async callbacks from snatching this thread as the result\n\t\t\/\/ of an async callback might call another sync XHR, this hangs khtml forever\n\t\t\/\/ hostenv._blockAsync must also be checked in BrowserIO's watchInFlight()\n\t\t\/\/ NOTE: must be declared before scope switches ie. this.getXmlhttpObject()\n\t\tif(!async_cb){ this._blockAsync = true; }\n\t\tvar http = this.getXmlhttpObject();\n\t\tfunction isDocumentOk(http){\n\t\t\tvar stat = http[\"status\"];\n\t\t\t\/\/ allow a 304 use cache, needed in konq (is this compliant with the http spec?)\n\t\t\treturn Boolean((!stat)||((200 <= stat)&&(300 > stat))||(stat==304));\n\t\t}\n\t\tif(async_cb){\n\t\t\tvar _this = this, timer = null, gbl = dojo.global();\n\t\t\tvar xhr = dojo.evalObjPath(\"dojo.io.XMLHTTPTransport\");\n\t\t\thttp.onreadystatechange = function(){\n\t\t\t\tif(timer){ gbl.clearTimeout(timer); timer = null; }\n\t\t\t\tif(_this._blockAsync || (xhr && xhr._blockAsync)){\n\t\t\t\t\ttimer = gbl.setTimeout(function () { http.onreadystatechange.apply(this); }, 10);\n\t\t\t\t}else{\n\t\t\t\t\tif(4==http.readyState){\n\t\t\t\t\t\tif(isDocumentOk(http)){\n\t\t\t\t\t\t\t\/\/ dojo.debug(\"LOADED URI: \"+uri);\n\t\t\t\t\t\t\tasync_cb(http.responseText);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thttp.open('GET', uri, async_cb ? true : false);\n\t\ttry{\n\t\t\thttp.send(null);\n\t\t\tif(async_cb){\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(!isDocumentOk(http)){\n\t\t\t\tvar err = Error(\"Unable to load \"+uri+\" status:\"+ http.status);\n\t\t\t\terr.status = http.status;\n\t\t\t\terr.responseText = http.responseText;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}catch(e){\n\t\t\tthis._blockAsync = false;\n\t\t\tif((fail_ok)&&(!async_cb)){\n\t\t\t\treturn null;\n\t\t\t}else{\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\tthis._blockAsync = false;\n\t\treturn http.responseText; \/\/ String","instance_variables":["_blockAsync"],"returns":"String","call_chain":["http.onreadystatechange"]},"extra":{"parameters":{"uri":{"type":"A","summary":"relative or absolute uri. If absolute, it still must be in the same \"domain\" as we are."},"async_cb":{"type":"If","summary":"not specified, load synchronously. If specified, load asynchronously, and use async_cb as the progress handler which takes the xmlhttp object as its argument. If async_cb, this function returns null."},"fail_ok":{"type":"Default","summary":"false. If fail_ok and !async_cb and loading fails, return null instead of throwing."}}}},"dojo.hostenv.println":{"meta":{"summary":"prints the provided line to whatever logging container is available. If the page isn't loaded yet, the line may be added to a buffer for printing later.","parameters":{"line":{"type":"String"}},"src":" \tif(!dojo.hostenv._println_safe){\n\t\t\tdojo.hostenv._println_buffer.push(line);\n\t\t}else{\n\t\t\ttry {\n\t\t\t\tvar console = document.getElementById(djConfig.debugContainerId ?\n\t\t\t\t\tdjConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);\n\t\t\t\tif(!console) { console = dojo.body(); }\n\t\t\t\tvar div = document.createElement(\"div\");\n\t\t\t\tdiv.appendChild(document.createTextNode(line));\n\t\t\t\tconsole.appendChild(div);\n\t\t\t} catch (e) {\n\t\t\t\ttry{\n\t\t\t\t\t\/\/ safari needs the output wrapped in an element for some reason\n\t\t\t\t\tdocument.write(\"<div>\" + line + \"<\/div>\");\n\t\t\t\t}catch(e2){\n\t\t\t\t\twindow.status = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}"}},"dj_addNodeEvtHdlr":{"meta":{"summary":"non-destructively adds the specified function to the node's","parameters":{"node":{"type":"DomNode"},"evtName":{"type":"String"},"fp":{"type":"Function"}},"src":" \tvar oldHandler = node[\"on\"+evtName] || function(){};\n\t\tnode[\"on\"+evtName] = function(){\n\t\t\tfp.apply(node, arguments);\n\t\t\toldHandler.apply(node, arguments);\n\t\t}\n\t\treturn true;","call_chain":["fp","oldHandler"]},"extra":{"parameters":{"evtName":{"type":"should","summary":"be in the form \"click\" for \"onclick\" handlers"},"node":{"type":"the","summary":"DomNode to add the handler to"}}}},"dj_load_init":{"meta":{"summary":"","parameters":{"e":{"type":""}},"src":" \tvar type = (e && e.type) ? e.type.toLowerCase() : \"load\";\n\t\tif(arguments.callee.initialized || (type!=\"domcontentloaded\" && type!=\"load\")){ return; }\n\t\targuments.callee.initialized = true;\n\t\tif(typeof(_timer) != 'undefined'){\n\t\t\tclearInterval(_timer);\n\t\t\tdelete _timer;\n\t\t}\n\t\tvar initFunc = function(){\n\t\t\t\/\/perform initialization\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tdojo.hostenv.makeWidgets();\n\t\t\t}\n\t\t};\n\t\tif(dojo.hostenv.inFlightCount == 0){\n\t\t\tinitFunc();\n\t\t\tdojo.hostenv.modulesLoaded();\n\t\t}else{\n\t\t\t\/\/This else case should be xdomain loading.\n\t\t\t\/\/Make sure this is the first thing in the load listener array.\n\t\t\t\/\/Part of the dojo.addOnLoad guarantee is that when the listeners are notified,\n\t\t\t\/\/It means the DOM (or page) has loaded and that widgets have been parsed.\n\t\t\tdojo.hostenv.modulesLoadedListeners.unshift(initFunc);\n\t\t}"}},"dojo.hostenv.makeWidgets":{"meta":{"summary":"","src":" \tvar sids = [];\n\t\tif(djConfig.searchIds && djConfig.searchIds.length > 0) {\n\t\t\tsids = sids.concat(djConfig.searchIds);\n\t\t}\n\t\tif(dojo.hostenv.searchIds && dojo.hostenv.searchIds.length > 0) {\n\t\t\tsids = sids.concat(dojo.hostenv.searchIds);\n\t\t}\n\t\tif((djConfig.parseWidgets)||(sids.length > 0)){\n\t\t\tif(dojo.evalObjPath(\"dojo.widget.Parse\")){\n\t\t\t\t\/\/ we must do this on a delay to avoid:\n\t\t\t\t\/\/\thttp:\/\/www.shaftek.org\/blog\/archives\/000212.html\n\t\t\t\t\/\/ (IE bug)\n\t\t\t\t\tvar parser = new dojo.xml.Parse();\n\t\t\t\t\tif(sids.length > 0){\n\t\t\t\t\t\tfor(var x=0; x<sids.length; x++){\n\t\t\t\t\t\t\tvar tmpNode = document.getElementById(sids[x]);\n\t\t\t\t\t\t\tif(!tmpNode){ continue; }\n\t\t\t\t\t\t\tvar frag = parser.parseElement(tmpNode, null, true);\n\t\t\t\t\t\t\tdojo.widget.getParser().createComponents(frag);\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(djConfig.parseWidgets){\n\t\t\t\t\t\tvar frag  = parser.parseElement(dojo.body(), null, true);\n\t\t\t\t\t\tdojo.widget.getParser().createComponents(frag);\n\t\t\t\t\t}\n\t\t\t}\n\t\t}"}},"dojo.hostenv.writeIncludes":{"meta":{"summary":"","src":""}},"dojo.doc":{"meta":{"summary":"return the document object associated with the dojo.global()","src":" \treturn dj_currentDocument;"}},"dojo.body":{"meta":{"summary":"return the body object associated with dojo.doc() Note: document.body is not defined for a strict xhtml document","src":" \treturn dojo.doc().body || dojo.doc().getElementsByTagName(\"body\")[0];"}},"dojo.byId":{"meta":{"summary":"similar to other library's \"$\" function, takes a string representing a DOM id or a DomNode and returns the corresponding DomNode. If a Node is passed, this function is a no-op. Returns a single DOM node or null, working around several browser-specific bugs to do so.","parameters":{"id":{"type":"String"},"doc":{"type":"DocumentElement"}},"src":" \tif((id)&&((typeof id == \"string\")||(id instanceof String))){\n\t\t\tif(!doc){ doc = dj_currentDocument; }\n\t\t\tvar ele = doc.getElementById(id);\n\t\t\t\/\/ workaround bug in IE and Opera 8.2 where getElementById returns wrong element\n\t\t\tif(ele && (ele.id != id) && doc.all){\n\t\t\t\tele = null;\n\t\t\t\t\/\/ get all matching elements with this id\n\t\t\t\teles = doc.all[id];\n\t\t\t\tif(eles){\n\t\t\t\t\t\/\/ if more than 1, choose first with the correct id\n\t\t\t\t\tif(eles.length){\n\t\t\t\t\t\tfor(var i=0; i<eles.length; i++){\n\t\t\t\t\t\t\tif(eles[i].id == id){\n\t\t\t\t\t\t\t\tele = eles[i];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\/\/ return 1 and only element\n\t\t\t\t\t}else{\n\t\t\t\t\t\tele = eles;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ele; \/\/ DomNode\n\t\t}\n\t\treturn id; \/\/ DomNode","returns":"DomNode"},"extra":{"parameters":{"id":{"type":"DOM","summary":"id or DOM Node"},"doc":{"type":"optional","summary":"defaults to the current value of dj_currentDocument. Can be used to retreive node references from other documents."}}}},"dojo.setContext":{"meta":{"summary":"changes the behavior of many core Dojo functions that deal with namespace and DOM lookup, changing them to work in a new global context. The varibles dj_currentContext and dj_currentDocument are modified as a result of calling this function.","parameters":{"globalObject":{"type":"Object"},"globalDocument":{"type":"DocumentElement"}},"src":" \tdj_currentContext = globalObject;\n\t\tdj_currentDocument = globalDocument;"}},"dojo._fireCallback":{"meta":{"summary":"","parameters":{"callback":{"type":""},"context":{"type":""},"cbArguments":{"type":""}},"src":" \tif((context)&&((typeof callback == \"string\")||(callback instanceof String))){\n\t\t\tcallback=context[callback];\n\t\t}\n\t\treturn (context ? callback.apply(context, cbArguments || [ ]) : callback());","call_chain":["callback"]}},"dojo.withGlobal":{"meta":{"summary":"Call callback with globalObject as dojo.global() and globalObject.document as dojo.doc(). If provided, globalObject will be executed in the context of object thisObject","parameters":{"globalObject":{"type":"Object"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"},"cbArguments":{"type":"Array?"}},"src":" \tvar rval;\n\t\tvar oldGlob = dj_currentContext;\n\t\tvar oldDoc = dj_currentDocument;\n\t\ttry{\n\t\t\tdojo.setContext(globalObject, globalObject.document);\n\t\t\trval = dojo._fireCallback(callback, thisObject, cbArguments);\n\t\t}finally{\n\t\t\tdojo.setContext(oldGlob, oldDoc);\n\t\t}\n\t\treturn rval;","description":"When callback() returns or throws an error, the dojo.global() and dojo.doc() will be restored to its previous state."}},"dojo.withDoc":{"meta":{"summary":"Call callback with documentObject as dojo.doc(). If provided, callback will be executed in the context of object thisObject","parameters":{"documentObject":{"type":"Object"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"},"cbArguments":{"type":"Array?"}},"src":" \tvar rval;\n\t\tvar oldDoc = dj_currentDocument;\n\t\ttry{\n\t\t\tdj_currentDocument = documentObject;\n\t\t\trval = dojo._fireCallback(callback, thisObject, cbArguments);\n\t\t}finally{\n\t\t\tdj_currentDocument = oldDoc;\n\t\t}\n\t\treturn rval;","description":"When callback() returns or throws an error, the dojo.doc() will be restored to its previous state."}}}}}}