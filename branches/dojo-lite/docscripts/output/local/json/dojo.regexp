{"dojo.regexp":{"meta":{"functions":{"dojo.regexp.tld":{"meta":{"summary":"Builds a RE that matches a top-level domain","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.allowCC != \"boolean\"){ flags.allowCC = true; }\n\tif(typeof flags.allowInfra != \"boolean\"){ flags.allowInfra = true; }\n\tif(typeof flags.allowGeneric != \"boolean\"){ flags.allowGeneric = true; }\n\t\/\/ Infrastructure top-level domain - only one at present\n\tvar infraRE = \"arpa\";\n\t\/\/ Generic top-level domains RE.\n\tvar genericRE = \n\t\t\"aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|xxx|jobs|mobi|post\";\n\t\/\/ Country Code top-level domains RE\n\tvar ccRE = \n\t\t\"ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|\" +\n\t\t\"bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|\" +\n\t\t\"ec|ee|eg|er|eu|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|\"\n\t\t+\n\t\t\"gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kr|kw|ky|kz|\" +\n\t\t\"la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|\" +\n\t\t\"my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|\" +\n\t\t\"re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sk|sl|sm|sn|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|\" +\n\t\t\"tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw\";\n\t\/\/ Build top-level domain RE\n\tvar a = [];\n\tif(flags.allowInfra){ a.push(infraRE); }\n\tif(flags.allowGeneric){ a.push(genericRE); }\n\tif(flags.allowCC){ a.push(ccRE); }\n\tvar tldRE = \"\";\n\tif (a.length > 0) {\n\t\ttldRE = \"(\" + a.join(\"|\") + \")\";\n\t}\n\treturn tldRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"allowInfra","summary":"Include infrastructure domains. Default is true."}}}},"dojo.regexp.ipAddress":{"meta":{"summary":"Builds a RE that matches an IP Address","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.allowDottedDecimal != \"boolean\"){ flags.allowDottedDecimal = true; }\n\tif(typeof flags.allowDottedHex != \"boolean\"){ flags.allowDottedHex = true; }\n\tif(typeof flags.allowDottedOctal != \"boolean\"){ flags.allowDottedOctal = true; }\n\tif(typeof flags.allowDecimal != \"boolean\"){ flags.allowDecimal = true; }\n\tif(typeof flags.allowHex != \"boolean\"){ flags.allowHex = true; }\n\tif(typeof flags.allowIPv6 != \"boolean\"){ flags.allowIPv6 = true; }\n\tif(typeof flags.allowHybrid != \"boolean\"){ flags.allowHybrid = true; }\n\t\/\/ decimal-dotted IP address RE.\n\tvar dottedDecimalRE = \n\t\t\/\/ Each number is between 0-255.  Zero padding is not allowed.\n\t\t\"((\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.){3}(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\";\n\t\/\/ dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.\n\tvar dottedHexRE = \"(0[xX]0*[\\\\da-fA-F]?[\\\\da-fA-F]\\\\.){3}0[xX]0*[\\\\da-fA-F]?[\\\\da-fA-F]\";\n\t\/\/ dotted octal IP address RE.  Each number is between 0000-0377.  \n\t\/\/ Zero padding is allowed, but each number must have at least 4 characters.\n\tvar dottedOctalRE = \"(0+[0-3][0-7][0-7]\\\\.){3}0+[0-3][0-7][0-7]\";\n\t\/\/ decimal IP address RE.  A decimal number between 0-4294967295.  \n\tvar decimalRE =  \"(0|[1-9]\\\\d{0,8}|[1-3]\\\\d{9}|4[01]\\\\d{8}|42[0-8]\\\\d{7}|429[0-3]\\\\d{6}|\" +\n\t\t\"4294[0-8]\\\\d{5}|42949[0-5]\\\\d{4}|429496[0-6]\\\\d{3}|4294967[01]\\\\d{2}|42949672[0-8]\\\\d|429496729[0-5])\";\n\t\/\/ hexadecimal IP address RE. \n\t\/\/ A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.\n\tvar hexRE = \"0[xX]0*[\\\\da-fA-F]{1,8}\";\n\t\/\/ IPv6 address RE. \n\t\/\/ The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,\n\t\/\/ where x is between 0000-ffff. Zero padding is optional. Case insensitive. \n\tvar ipv6RE = \"([\\\\da-fA-F]{1,4}\\\\:){7}[\\\\da-fA-F]{1,4}\";\n\t\/\/ IPv6\/IPv4 Hybrid address RE. \n\t\/\/ The format is written as six groups of four hexadecimal digits, \n\t\/\/ followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d\n\tvar hybridRE = \"([\\\\da-fA-F]{1,4}\\\\:){6}\" + \n\t\t\"((\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.){3}(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\";\n\t\/\/ Build IP Address RE\n\tvar a = [];\n\tif(flags.allowDottedDecimal){ a.push(dottedDecimalRE); }\n\tif(flags.allowDottedHex){ a.push(dottedHexRE); }\n\tif(flags.allowDottedOctal){ a.push(dottedOctalRE); }\n\tif(flags.allowDecimal){ a.push(decimalRE); }\n\tif(flags.allowHex){ a.push(hexRE); }\n\tif(flags.allowIPv6){ a.push(ipv6RE); }\n\tif(flags.allowHybrid){ a.push(hybridRE); }\n\tvar ipAddressRE = \"\";\n\tif(a.length > 0){\n\t\tipAddressRE = \"(\" + a.join(\"|\") + \")\";\n\t}\n\treturn ipAddressRE; \/\/ String","description":"Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal. Supports 2 formats for Ipv6.","returns":"String"},"extra":{"parameters":{"flags":{"type":"allowHybrid","summary":"IPv6 address written as six groups of four hexadecimal digits followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d"}}}},"dojo.regexp.host":{"meta":{"summary":"Builds a RE that matches a host","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.allowIP != \"boolean\"){ flags.allowIP = true; }\n\tif(typeof flags.allowLocal != \"boolean\"){ flags.allowLocal = false; }\n\tif(typeof flags.allowPort != \"boolean\"){ flags.allowPort = true; }\n\t\/\/ Domain names can not end with a dash.\n\tvar domainNameRE = \"([0-9a-zA-Z]([-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?\\\\.)+\" + dojo.regexp.tld(flags);\n\t\/\/ port number RE\n\tvar portRE = ( flags.allowPort ) ? \"(\\\\:\" + dojo.regexp.integer({signed: false}) + \")?\" : \"\";\n\t\/\/ build host RE\n\tvar hostNameRE = domainNameRE;\n\tif(flags.allowIP){ hostNameRE += \"|\" +  dojo.regexp.ipAddress(flags); }\n\tif(flags.allowLocal){ hostNameRE += \"|localhost\"; }\n\treturn \"(\" + hostNameRE + \")\" + portRE; \/\/ String","description":"A host is a domain name or an IP address, possibly followed by a port number.","returns":"String"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.regexp.url":{"meta":{"summary":"Builds a regular expression that matches a URL","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.scheme == \"undefined\"){ flags.scheme = [true, false]; }\n\t\/\/ Scheme RE\n\tvar protocolRE = dojo.regexp.buildGroupRE(flags.scheme,\n\t\tfunction(q){ if(q){ return \"(https?|ftps?)\\\\:\/\/\"; } return \"\"; }\n\t);\n\t\/\/ Path and query and anchor RE\n\tvar pathRE = \"(\/([^?#\\\\s\/]+\/)*)?([^?#\\\\s\/]+(\\\\?[^?#\\\\s\/]*)?(#[A-Za-z][\\\\w.:-]*)?)?\";\n\treturn protocolRE + dojo.regexp.host(flags) + pathRE;","returns":"\"; } return \"\"; }"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.regexp.emailAddress":{"meta":{"summary":"Builds a regular expression that matches an email address","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif (typeof flags.allowCruft != \"boolean\") { flags.allowCruft = false; }\n\tflags.allowPort = false; \/\/ invalid in email addresses\n\t\/\/ user name RE - apostrophes are valid if there's not 2 in a row\n\tvar usernameRE = \"([\\\\da-z]+[-._+&'])*[\\\\da-z]+\";\n\t\/\/ build emailAddress RE\n\tvar emailAddressRE = usernameRE + \"@\" + dojo.regexp.host(flags);\n\t\/\/ Allow email addresses with cruft\n\tif ( flags.allowCruft ) {\n\t\temailAddressRE = \"<?(mailto\\\\:)?\" + emailAddressRE + \">?\";\n\t}\n\treturn emailAddressRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.regexp.emailAddressList":{"meta":{"summary":"Builds a regular expression that matches a list of email addresses.","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.listSeparator != \"string\"){ flags.listSeparator = \"\\\\s;,\"; }\n\t\/\/ build a RE for an Email Address List\n\tvar emailAddressRE = dojo.regexp.emailAddress(flags);\n\tvar emailAddressListRE = \"(\" + emailAddressRE + \"\\\\s*[\" + flags.listSeparator + \"]\\\\s*)*\" + \n\t\temailAddressRE + \"\\\\s*[\" + flags.listSeparator + \"]?\\\\s*\";\n\treturn emailAddressListRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.regexp.integer":{"meta":{"summary":"Builds a regular expression that matches an integer","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.signed == \"undefined\"){ flags.signed = [true, false]; }\n\tif(typeof flags.separator == \"undefined\"){\n\t\tflags.separator = \"\";\n\t} else if(typeof flags.groupSize == \"undefined\"){\n\t\tflags.groupSize = 3;\n\t}\n\t\/\/ build sign RE\n\tvar signRE = dojo.regexp.buildGroupRE(flags.signed,\n\t\tfunction(q) { return q ? \"[-+]\" : \"\"; }\n\t);\n\t\/\/ number RE\n\tvar numberRE = dojo.regexp.buildGroupRE(flags.separator,\n\t\tfunction(sep){ \n\t\t\tif(sep == \"\"){ \n\t\t\t\treturn \"(0|[1-9]\\\\d*)\";\n\t\t\t}\n\t\t\tvar grp = flags.groupSize, grp2 = flags.groupSize2;\n\t\t\tif(typeof grp2 != \"undefined\"){\n\t\t\t\tvar grp2RE = \"(0|[1-9]\\\\d{0,\" + (grp2-1) + \"}([\" + sep + \"]\\\\d{\" + grp2 + \"})*[\" + sep + \"]\\\\d{\" + grp + \"})\";\n\t\t\t\treturn ((grp-grp2) > 0) ? \"(\" + grp2RE + \"|(0|[1-9]\\\\d{0,\" + (grp-1) + \"}))\" : grp2RE;\n\t\t\t}\n\t\t\treturn  \"(0|[1-9]\\\\d{0,\" + (grp-1) + \"}([\" + sep + \"]\\\\d{\" + grp + \"})*)\";\n\t\t}\n\t);\n\t\/\/ integer RE\n\treturn signRE + numberRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"groupSize2","summary":"second grouping (for India)"}}}},"dojo.regexp.realNumber":{"meta":{"summary":"Builds a regular expression to match a real number in exponential notation","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.places != \"number\"){ flags.places = Infinity; }\n\tif(typeof flags.decimal != \"string\"){ flags.decimal = \".\"; }\n\tif(typeof flags.fractional == \"undefined\"){ flags.fractional = [true, false]; }\n\tif(typeof flags.exponent == \"undefined\"){ flags.exponent = [true, false]; }\n\tif(typeof flags.eSigned == \"undefined\"){ flags.eSigned = [true, false]; }\n\t\/\/ integer RE\n\tvar integerRE = dojo.regexp.integer(flags);\n\t\/\/ decimal RE\n\tvar decimalRE = dojo.regexp.buildGroupRE(flags.fractional,\n\t\tfunction(q){\n\t\t\tvar re = \"\";\n\t\t\tif(q && (flags.places > 0)){\n\t\t\t\tre = \"\\\\\" + flags.decimal;\n\t\t\t\tif(flags.places == Infinity){ \n\t\t\t\t\tre = \"(\" + re + \"\\\\d+)?\"; \n\t\t\t\t}else{ \n\t\t\t\t\tre = re + \"\\\\d{\" + flags.places + \"}\"; \n\t\t\t\t}\n\t\t\t}\n\t\t\treturn re;\n\t\t}\n\t);\n\t\/\/ exponent RE\n\tvar exponentRE = dojo.regexp.buildGroupRE(flags.exponent,\n\t\tfunction(q){ \n\t\t\tif(q){ return \"([eE]\" + dojo.regexp.integer({ signed: flags.eSigned}) + \")\"; }\n\t\t\treturn \"\"; \n\t\t}\n\t);\n\t\/\/ real number RE\n\treturn integerRE + decimalRE + exponentRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.integer can be applied."}}}},"dojo.regexp.currency":{"meta":{"summary":"Builds a regular expression to match a monetary value","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.signed == \"undefined\"){ flags.signed = [true, false]; }\n\tif(typeof flags.symbol == \"undefined\"){ flags.symbol = \"$\"; }\n\tif(typeof flags.placement != \"string\"){ flags.placement = \"before\"; }\n\tif(typeof flags.signPlacement != \"string\"){ flags.signPlacement = \"before\"; }\n\tif(typeof flags.separator == \"undefined\"){ flags.separator = \",\"; }\n\tif(typeof flags.fractional == \"undefined\" && typeof flags.cents != \"undefined\"){\n\t\tdojo.deprecated(\"dojo.regexp.currency: flags.cents\", \"use flags.fractional instead\", \"0.5\");\n\t\tflags.fractional = flags.cents;\n\t}\n\tif(typeof flags.decimal != \"string\"){ flags.decimal = \".\"; }\n\t\/\/ build sign RE\n\tvar signRE = dojo.regexp.buildGroupRE(flags.signed,\n\t\tfunction(q){ if (q){ return \"[-+]\"; } return \"\"; }\n\t);\n\t\/\/ build symbol RE\n\tvar symbolRE = dojo.regexp.buildGroupRE(flags.symbol,\n\t\tfunction(symbol){ \n\t\t\t\/\/ escape all special characters\n\t\t\treturn \"\\\\s?\" + symbol.replace( \/([.$?*!=:|\\\\\\\/^])\/g, \"\\\\$1\") + \"\\\\s?\";\n\t\t}\n\t);\n\tswitch (flags.signPlacement){\n\t\tcase \"before\":\n\t\t\tsymbolRE = signRE + symbolRE;\n\t\t\tbreak;\n\t\tcase \"after\":\n\t\t\tsymbolRE = symbolRE + signRE;\n\t\t\tbreak;\n\t}\n\t\/\/ number RE\n\tvar flagsCopy = flags; \/\/TODO: copy by value?\n\tflagsCopy.signed = false; flagsCopy.exponent = false;\n\tvar numberRE = dojo.regexp.realNumber(flagsCopy);\n\t\/\/ build currency RE\n\tvar currencyRE;\n\tswitch (flags.placement){\n\t\tcase \"before\":\n\t\t\tcurrencyRE = symbolRE + numberRE;\n\t\t\tbreak;\n\t\tcase \"after\":\n\t\t\tcurrencyRE = numberRE + symbolRE;\n\t\t\tbreak;\n\t}\n\tswitch (flags.signPlacement){\n\t\tcase \"around\":\n\t\t\tcurrencyRE = \"(\" + currencyRE + \"|\" + \"\\\\(\" + currencyRE + \"\\\\)\" + \")\";\n\t\t\tbreak;\n\t\tcase \"begin\":\n\t\t\tcurrencyRE = signRE + currencyRE;\n\t\t\tbreak;\n\t\tcase \"end\":\n\t\t\tcurrencyRE = currencyRE + signRE;\n\t\t\tbreak;\n\t}\n\treturn currencyRE; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"in","summary":"regexp.realNumber can be applied except exponent, eSigned."}}}},"dojo.regexp.us.state":{"meta":{"summary":"A regular expression to match US state and territory abbreviations","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.allowTerritories != \"boolean\"){ flags.allowTerritories = true; }\n\tif(typeof flags.allowMilitary != \"boolean\"){ flags.allowMilitary = true; }\n\t\/\/ state RE\n\tvar statesRE = \n\t\t\"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|\" + \n\t\t\"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY\";\n\t\/\/ territories RE\n\tvar territoriesRE = \"AS|FM|GU|MH|MP|PW|PR|VI\";\n\t\/\/ military states RE\n\tvar militaryRE = \"AA|AE|AP\";\n\t\/\/ Build states and territories RE\n\tif(flags.allowTerritories){ statesRE += \"|\" + territoriesRE; }\n\tif(flags.allowMilitary){ statesRE += \"|\" + militaryRE; }\n\treturn \"(\" + statesRE + \")\"; \/\/ String","returns":"String"},"extra":{"parameters":{"flags":{"type":"allowMilitary","summary":"Allow military 'states', e.g. Armed Forces Europe (AE). Default is true."}}}},"dojo.regexp.time":{"meta":{"summary":"Builds a regular expression to match any International format for time","parameters":{"flags":{"type":"Object?"}},"src":"\tdojo.deprecated(\"dojo.regexp.time\", \"Use dojo.date.parse instead\", \"0.5\");\n\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.format == \"undefined\"){ flags.format = \"h:mm:ss t\"; }\n\tif(typeof flags.amSymbol != \"string\"){ flags.amSymbol = \"AM\"; }\n\tif(typeof flags.pmSymbol != \"string\"){ flags.pmSymbol = \"PM\"; }\n\t\/\/ Converts a time format to a RE\n\tvar timeRE = function(format){\n\t\t\/\/ escape all special characters\n\t\tformat = format.replace( \/([.$?*!=:|{}\\(\\)\\[\\]\\\\\\\/^])\/g, \"\\\\$1\");\n\t\tvar amRE = flags.amSymbol.replace( \/([.$?*!=:|{}\\(\\)\\[\\]\\\\\\\/^])\/g, \"\\\\$1\");\n\t\tvar pmRE = flags.pmSymbol.replace( \/([.$?*!=:|{}\\(\\)\\[\\]\\\\\\\/^])\/g, \"\\\\$1\");\n\t\t\/\/ replace tokens with Regular Expressions\n\t\tformat = format.replace(\"hh\", \"(0[1-9]|1[0-2])\");\n\t\tformat = format.replace(\"h\", \"([1-9]|1[0-2])\");\n\t\tformat = format.replace(\"HH\", \"([01][0-9]|2[0-3])\");\n\t\tformat = format.replace(\"H\", \"([0-9]|1[0-9]|2[0-3])\");\n\t\tformat = format.replace(\"mm\", \"([0-5][0-9])\");\n\t\tformat = format.replace(\"m\", \"([1-5][0-9]|[0-9])\");\n\t\tformat = format.replace(\"ss\", \"([0-5][0-9])\");\n\t\tformat = format.replace(\"s\", \"([1-5][0-9]|[0-9])\");\n\t\tformat = format.replace(\"t\", \"\\\\s?(\" + amRE + \"|\" + pmRE + \")\\\\s?\" );\n\t\treturn format; \/\/ String\n\t};\n\t\/\/ build RE for multiple time formats\n\treturn dojo.regexp.buildGroupRE(flags.format, timeRE); \/\/ String","description":"The RE can match one format or one of multiple formats. Format h 12 hour, no zero padding. hh 12 hour, has leading zero. H 24 hour, no zero padding. HH 24 hour, has leading zero. m minutes, no zero padding. mm minutes, has leading zero. s seconds, no zero padding. ss seconds, has leading zero. t am or pm, case insensitive. All other characters must appear literally in the expression. Example \"h:m:s t\" -> 2:5:33 PM \"HH:mm:ss\" -> 14:05:33","returns":"String"},"extra":{"parameters":{"flags":{"type":"pmSymbol","summary":"The symbol used for PM. Default is \"PM\"."}}}},"dojo.regexp.numberFormat":{"meta":{"summary":"Builds a regular expression to match any sort of number based format","parameters":{"flags":{"type":"Object?"}},"src":"\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tif(typeof flags.format == \"undefined\"){ flags.format = \"###-###-####\"; }\n\t\/\/ Converts a number format to RE.\n\tvar digitRE = function(format){\n\t\t\/\/ escape all special characters, except '?'\n\t\tformat = format.replace( \/([.$*!=:|{}\\(\\)\\[\\]\\\\\\\/^])\/g, \"\\\\$1\");\n\t\t\/\/ Now replace '?' with Regular Expression\n\t\tformat = format.replace(\/\\?\/g, \"\\\\d?\");\n\t\t\/\/ replace # with Regular Expression\n\t\tformat = format.replace(\/#\/g, \"\\\\d\");\n\t\treturn format; \/\/ String\n\t};\n\t\/\/ build RE for multiple number formats\n\treturn dojo.regexp.buildGroupRE(flags.format, digitRE); \/\/String","description":"Use this method for phone numbers, social security numbers, zip-codes, etc. The RE can match one format or one of multiple formats. Format # Stands for a digit, 0-9. ? Stands for an optional digit, 0-9 or nothing. All other characters must appear literally in the expression. Example \"(###) ###-####\" -> (510) 542-9742 \"(###) ###-#### x#???\" -> (510) 542-9742 x153 \"###-##-####\" -> 506-82-1089 i.e. social security number \"#####-####\" -> 98225-1649 i.e. zip code","returns":"String"},"extra":{"parameters":{"flags":{"type":"format","summary":"A string or an Array of strings for multiple formats."}}}},"dojo.regexp.buildGroupRE":{"meta":{"summary":"Builds a regular expression that groups subexpressions","parameters":{"a":{"type":"value or Array of values"},"re":{"type":"Function(x) returns a regular expression as a String"}},"src":"\t\/\/ case 1: a is a single value.\n\tif(!(a instanceof Array)){\n\t\treturn re(a); \/\/ String\n\t}\n\t\/\/ case 2: a is an array\n\tvar b = [];\n\tfor (var i = 0; i < a.length; i++){\n\t\t\/\/ convert each elem to a RE\n\t\tb.push(re(a[i]));\n\t}\n\t \/\/ join the REs as alternatives in a RE group.\n\treturn \"(\" + b.join(\"|\") + \")\"; \/\/ String","description":"A utility function used by some of the RE generators. The subexpressions are constructed by the function, re, in the second parameter.","returns":"String"},"extra":{"parameters":{"re":{"type":"A","summary":"function. Takes one parameter and converts it to a regular expression."},"a":{"type":"A","summary":"single value or an array of values."}}}}}}}}