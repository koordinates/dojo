{"dojo.Deferred":{"meta":{"requires":{"common":["dojo.lang.func"]},"functions":{"dojo.Deferred":{"meta":{"summary":"","parameters":{"canceller":{"type":"Function?"}},"src":" this.chain = [];\n\tthis.id = this._nextId();\n\tthis.fired = -1;\n\tthis.paused = 0;\n\tthis.results = [null, null];\n\tthis.canceller = canceller;\n\tthis.silentlyCancelled = false;","instance_variables":["chain","id","fired","paused","results","canceller","silentlyCancelled"],"prototype_variables":["toString","_nextId"]}},"dojo.Deferred.getFunctionFromArgs":{"meta":{"summary":"","src":" \tvar a = arguments;\n\t\tif((a[0])&&(!a[1])){\n\t\t\tif(dojo.lang.isFunction(a[0])){\n\t\t\t\treturn a[0];\n\t\t\t}else if(dojo.lang.isString(a[0])){\n\t\t\t\treturn dj_global[a[0]];\n\t\t\t}\n\t\t}else if((a[0])&&(a[1])){\n\t\t\treturn dojo.lang.hitch(a[0], a[1]);\n\t\t}\n\t\treturn null;","prototype":"dojo.Deferred"}},"dojo.Deferred.makeCalled":{"meta":{"summary":"","src":" \tvar deferred = new dojo.Deferred();\n\t\tdeferred.callback();\n\t\treturn deferred;","prototype":"dojo.Deferred"}},"dojo.Deferred.repr":{"meta":{"summary":"","src":" \tvar state;\n\t\tif(this.fired == -1){\n\t\t\tstate = 'unfired';\n\t\t}else if(this.fired == 0){\n\t\t\tstate = 'success';\n\t\t} else {\n\t\t\tstate = 'error';\n\t\t}\n\t\treturn 'Deferred(' + this.id + ', ' + state + ')';","prototype":"dojo.Deferred"}},"dojo.Deferred.cancel":{"meta":{"summary":"Cancels a Deferred that has not yet received a value, or is waiting on another Deferred as its value.","src":" \tif(this.fired == -1){\n\t\t\tif (this.canceller){\n\t\t\t\tthis.canceller(this);\n\t\t\t}else{\n\t\t\t\tthis.silentlyCancelled = true;\n\t\t\t}\n\t\t\tif(this.fired == -1){\n\t\t\t\tthis.errback(new Error(this.repr()));\n\t\t\t}\n\t\t}else if(\t(this.fired == 0)&&\n\t\t\t\t\t(this.results[0] instanceof dojo.Deferred)){\n\t\t\tthis.results[0].cancel();\n\t\t}","description":"If a canceller is defined, the canceller is called. If the canceller did not return an error, or there was no canceller, then the errback chain is started with CancelledError.","prototype":"dojo.Deferred"}},"dojo.Deferred._pause":{"meta":{"summary":"Used internally to signal that it's waiting on another Deferred","src":" \tthis.paused++;","prototype":"dojo.Deferred"}},"dojo.Deferred._unpause":{"meta":{"summary":"Used internally to signal that it's no longer waiting on another Deferred.","src":" \tthis.paused--;\n\t\tif ((this.paused == 0) && (this.fired >= 0)) {\n\t\t\tthis._fire();\n\t\t}","prototype":"dojo.Deferred"}},"dojo.Deferred._continue":{"meta":{"summary":"Used internally when a dependent deferred fires.","parameters":{"res":{"type":""}},"src":" \tthis._resback(res);\n\t\tthis._unpause();","prototype":"dojo.Deferred"}},"dojo.Deferred._resback":{"meta":{"summary":"","parameters":{"res":{"type":""}},"src":" \tthis.fired = ((res instanceof Error) ? 1 : 0);\n\t\tthis.results[this.fired] = res;\n\t\tthis._fire();","prototype":"dojo.Deferred"}},"dojo.Deferred._check":{"meta":{"summary":"","src":" \tif(this.fired != -1){\n\t\t\tif(!this.silentlyCancelled){\n\t\t\t\tdojo.raise(\"already called!\");\n\t\t\t}\n\t\t\tthis.silentlyCancelled = false;\n\t\t\treturn;\n\t\t}","prototype":"dojo.Deferred"}},"dojo.Deferred.callback":{"meta":{"summary":"Begin the callback sequence with a non-error value.","parameters":{"res":{"type":""}},"src":" \tthis._check();\n\t\tthis._resback(res);","prototype":"dojo.Deferred"}},"dojo.Deferred.errback":{"meta":{"summary":"Begin the callback sequence with an error result.","parameters":{"res":{"type":""}},"src":" \tthis._check();\n\t\tif(!(res instanceof Error)){\n\t\t\tres = new Error(res);\n\t\t}\n\t\tthis._resback(res);","prototype":"dojo.Deferred"}},"dojo.Deferred.addBoth":{"meta":{"summary":"","parameters":{"cb":{"type":""},"cbfn":{"type":""}},"src":" \tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.addCallbacks(enclosed, enclosed);","prototype":"dojo.Deferred"}},"dojo.Deferred.addCallback":{"meta":{"summary":"Add a single callback to the end of the callback sequence.","parameters":{"cb":{"type":""},"cbfn":{"type":""}},"src":" \tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.addCallbacks(enclosed, null);","prototype":"dojo.Deferred"}},"dojo.Deferred.addErrback":{"meta":{"summary":"Add a single callback to the end of the callback sequence.","parameters":{"cb":{"type":""},"cbfn":{"type":""}},"src":" \tvar enclosed = this.getFunctionFromArgs(cb, cbfn);\n\t\tif(arguments.length > 2){\n\t\t\tenclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);\n\t\t}\n\t\treturn this.addCallbacks(null, enclosed);\n\t\treturn this.addCallbacks(null, cbfn);","prototype":"dojo.Deferred"}},"dojo.Deferred.addCallbacks":{"meta":{"summary":"Add separate callback and errback to the end of the callback sequence.","parameters":{"cb":{"type":""},"eb":{"type":""}},"src":" \tthis.chain.push([cb, eb])\n\t\tif (this.fired >= 0) {\n\t\t\tthis._fire();\n\t\t}\n\t\treturn this;","prototype":"dojo.Deferred"}},"dojo.Deferred._fire":{"meta":{"summary":"Used internally to exhaust the callback sequence when a result is available.","src":" \tvar chain = this.chain;\n\t\tvar fired = this.fired;\n\t\tvar res = this.results[fired];\n\t\tvar self = this;\n\t\tvar cb = null;\n\t\twhile (chain.length > 0 && this.paused == 0) {\n\t\t\t\/\/ Array\n\t\t\tvar pair = chain.shift();\n\t\t\tvar f = pair[fired];\n\t\t\tif (f == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tres = f(res);\n\t\t\t\tfired = ((res instanceof Error) ? 1 : 0);\n\t\t\t\tif(res instanceof dojo.Deferred) {\n\t\t\t\t\tcb = function(res){\n\t\t\t\t\t\tself._continue(res);\n\t\t\t\t\t}\n\t\t\t\t\tthis._pause();\n\t\t\t\t}\n\t\t\t}catch(err){\n\t\t\t\tfired = 1;\n\t\t\t\tres = err;\n\t\t\t}\n\t\t}\n\t\tthis.fired = fired;\n\t\tthis.results[fired] = res;\n\t\tif((cb)&&(this.paused)){\n\t\t\t\/\/ this is for \"tail recursion\" in case the dependent\n\t\t\t\/\/ deferred is already fired\n\t\t\tres.addBoth(cb);\n\t\t}","prototype":"dojo.Deferred"}}}}}}