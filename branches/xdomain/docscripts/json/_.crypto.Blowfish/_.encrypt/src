var out=dojo.crypto.outputTypes.Base64;
var mode=dojo.crypto.cipherModes.EBC;
if (ao){
	if (ao.outputType) out=ao.outputType;
	if (ao.cipherMode) mode=ao.cipherMode;
}

var bx = init(key);
var padding = 8-(plaintext.length&7);
for (var i=0; i<padding; i++) plaintext+=String.fromCharCode(padding);
var cipher=[];
var count=plaintext.length >> 3;
var pos=0;
var o={};
var isCBC=(mode==dojo.crypto.cipherModes.CBC);
var vector={left:iv.left||null, right:iv.right||null};
for(var i=0; i<count; i++){
	o.left=plaintext.charCodeAt(pos)*POW24
		|plaintext.charCodeAt(pos+1)*POW16
		|plaintext.charCodeAt(pos+2)*POW8
		|plaintext.charCodeAt(pos+3);
	o.right=plaintext.charCodeAt(pos+4)*POW24
		|plaintext.charCodeAt(pos+5)*POW16
		|plaintext.charCodeAt(pos+6)*POW8
		|plaintext.charCodeAt(pos+7);

	if(isCBC){
		o.left=xor(o.left, vector.left);
		o.right=xor(o.right, vector.right);
	}

	eb(o, bx);		encrypt the block

	if(isCBC){
		vector.left=o.left;
		vector.right=o.right;dojo.crypto.outputTypes.Hex
	}

	cipher.push((o.left>>24)&0xff); 
	cipher.push((o.left>>16)&0xff); 
	cipher.push((o.left>>8)&0xff);
	cipher.push(o.left&0xff);
	cipher.push((o.right>>24)&0xff); 
	cipher.push((o.right>>16)&0xff); 
	cipher.push((o.right>>8)&0xff);
	cipher.push(o.right&0xff);
	pos+=8;
}
switch(out){
	case dojo.crypto.outputTypes.Hex:{
		var s=[];
		for(var i=0; i<cipher.length; i++)
			s.push((cipher[i]).toString(16));
		return s.join("");
	}
	case dojo.crypto.outputTypes.String:{
		return cipher.join("");
	}
	case dojo.crypto.outputTypes.Raw:{
		return cipher;
	}
	default:{
		return toBase64(cipher);
	}
}