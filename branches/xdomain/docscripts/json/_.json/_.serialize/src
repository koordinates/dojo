var objtype = typeof(o);
if(objtype == "undefined"){
	return "undefined";
}else if((objtype == "number")||(objtype == "boolean")){
	return o + "";
}else if(o === null){
	return "null";
}
var m = dojo.lang;
if(objtype == "string"){
	return m.reprString(o);
}
 recurse
var me = arguments.callee;
 short-circuit for objects that support "json" serialization
 if they return "self" then just pass-through...
var newObj;
if(typeof(o.__json__) == "function"){
	newObj = o.__json__();
	if(o !== newObj){
		return me(newObj);
	}
}
if(typeof(o.json) == "function"){
	newObj = o.json();
	if (o !== newObj) {
		return me(newObj);
	}
}
 array
if(objtype != "function" && typeof(o.length) == "number"){
	var res = [];
	for(var i = 0; i < o.length; i++){
		var val = me(o[i]);
		if(typeof(val) != "string"){
			val = "undefined";
		}
		res.push(val);
	}
	return "[" + res.join(",") + "]";
}
 look in the registry
try {
	window.o = o;
	newObj = dojo.json.jsonRegistry.match(o);
	return me(newObj);
}catch(e){
	 dojo.debug(e);
}
 it's a function with no adapter, bad
if(objtype == "function"){
	return null;
}
 generic object code path
res = [];
for (var k in o){
	var useKey;
	if (typeof(k) == "number"){
		useKey = '"' + k + '"';
	}else if (typeof(k) == "string"){
		useKey = m.reprString(k);
	}else{
		 skip non-string or number keys
		continue;
	}
	val = me(o[k]);
	if(typeof(val) != "string"){
		 skip non-serializable values
		continue;
	}
	res.push(useKey + ":" + val);
}
return "{" + res.join(",") + "}";