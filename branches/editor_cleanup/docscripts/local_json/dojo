{"dojo":{"meta":{"functions":{"dj_undef":{"_":{"meta":{"summary":"Returns true if 'name' is defined on 'object' (or globally if 'object' is null).","parameters":{"name":{"type":"String"},"object":{"type":"Object?"}},"description":"Note that 'defined' and 'exists' are not the same concept. Boolean","src":"","returns":"Boolean"}}},"dojo.global":{"_":{"meta":{"summary":" return the current global context object (e.g., the window object in a browser).","description":" Refer to 'dojo.global()' rather than referring to window to ensure your code runs correctly in contexts other than web browsers (eg: Rhino on a server).","src":""}}},"dojo.evalProp":{"_":{"meta":{"summary":"Returns 'object[name]'.  If not defined and 'create' is true, will return a new Object.","parameters":{"name":{"type":"String"},"object":{"type":"Object"},"create":{"type":"Boolean?"}},"description":" Returns null if 'object[name]' is not defined and 'create' is not true. Note: 'defined' and 'exists' are not the same concept. undefined","src":"\tif(!dj_undef(name, object)) return object[name]; \/\/ mixed\n\treturn (create ? (object[name]={}) : undefined);\t\/\/ mixed","returns":"mixed"}}},"dojo.parseObjPath":{"_":{"meta":{"summary":"Parse string path to an object, and return corresponding object reference and property name.","parameters":{"path":{"type":"String"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"description":" Returns an object with two properties, 'obj' and 'prop'. 'obj[prop]' is the reference indicated by 'path'.","src":"\tvar names = path.split('.');\n\tvar prop = names.pop();\n\tfor (var i=0,l=names.length;i<l && object;i++){\n\t\tobject = dojo.evalProp(names[i], object, create);\n\t}\n\treturn {obj: object, prop: prop};\t\/\/ Object: {obj: Object, prop: String}","returns":"Object: {obj: Object, prop: String}"}}},"dojo.evalObjPath":{"_":{"meta":{"summary":"Return the value of object at 'path' in the global scope, without using 'eval()'.","parameters":{"path":{"type":"String"},"create":{"type":"Boolean?"}},"src":"\t\treturn dojo.global(); \n\t}\n\t\/\/ fast path for no periods\n\tif(path.indexOf('.') == -1){\n\t\treturn dojo.evalProp(path, dojo.global(), create);\t\t\/\/ mixed\n\t}\n\n\t\/\/MOW: old 'with' syntax was confusing and would throw an error if parseObjPath returned null.\n\tvar ref = dojo.parseObjPath(path, dojo.global(), create);\n\tif(ref){\n\t\treturn dojo.evalProp(ref.prop, ref.obj, create);\t\/\/ mixed\n\t}\n\treturn null;","returns":"mixed"}}},"dojo.errorToString":{"_":{"meta":{"summary":"Return an exception's 'message', 'description' or text. TODO: overriding Error.prototype.toString won't accomplish this? ... since natively generated Error objects do not always reflect such things?","parameters":{"exception":{"type":"Error"}},"src":"\t\treturn exception.message;\t\t\/\/ String\n\t}else if(!dj_undef(\"description\", exception)){\n\t\treturn exception.description;\t\/\/ String\n\t}else{\n\t\treturn exception;\t\t\t\t\/\/ Error\n\t}","returns":"mixed"}}},"dojo.raise":{"_":{"meta":{"summary":"Throw an error message, appending text of 'exception' if provided. note: Also prints a message to the user using 'dojo.hostenv.println'.","parameters":{"message":{"type":"String"},"exception":{"type":"Error?"}},"src":"\t\tmessage = message + \": \"+dojo.errorToString(exception);\n\t}\n\n\t\/\/ print the message to the user if hostenv.println is defined\n\ttry {\tdojo.hostenv.println(\"FATAL: \"+message); } catch (e) {}\n\n\tthrow Error(message);"}}},"dojo.debug":{"_":{"meta":{"summary":"","src":""}}},"dojo.debugShallow":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""}},"src":""}}},"dj_eval":{"_":{"meta":{"summary":"Perform an evaluation in the global scope.  Use this rather than calling 'eval()' directly.","parameters":{"scriptFragment":{"type":"String"}},"description":"Placed in a separate function to minimize size of trapped evaluation context. note: - JSC eval() takes an optional second argument which can be 'unsafe'. - Mozilla\/SpiderMonkey eval() takes an optional second argument which is the scope object for new symbols. mixed","src":"","returns":"mixed"}}},"dojo.unimplemented":{"_":{"meta":{"summary":"Throw an exception because some function is not implemented.","parameters":{"funcname":{"type":"String"},"extra":{"type":"String?"}},"src":"\tif (extra != null) { message += \" \" + extra; }\n\tdojo.raise(message);"}}},"dojo.deprecated":{"_":{"meta":{"summary":"Log a debug message to indicate that a behavior has been deprecated.","parameters":{"behaviour":{"type":"String"},"extra":{"type":"String?"},"removal":{"type":"String?"}},"src":"\tif(extra){ message += \" \" + extra; }\n\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\tdojo.debug(message);"}}},"vscaffold":{"_":{"meta":{"summary":"","parameters":{"prefs":{"type":""},"names":{"type":""}},"src":"\t\tvar tmp = {\n\t\t\tcapable: false,\n\t\t\tsupport: {\n\t\t\t\tbuiltin: false,\n\t\t\t\tplugin: false\n\t\t\t},\n\t\t\tprefixes: prefs\n\t\t};\n\t\tfor(var i=0; i<names.length; i++){\n\t\t\ttmp[names[i]] = false;\n\t\t}\n\t\treturn tmp;"}}},"dojo.hostenv.getBaseScriptUri":{"_":{"meta":{"summary":"Return the base script uri that other scripts are found relative to. TODOC: HUH?  This comment means nothing to me.  What other scripts? Is this the path to other dojo libraries? MAYBE:  Return the base uri to scripts in the dojo library.\t ??? return: Empty string or a path ending in '\/'.","src":"\t\treturn djConfig.baseScriptUri;\n\t}\n\n\t\/\/ MOW: Why not:\n\t\/\/\t\t\turi = djConfig.libraryScriptUri || djConfig.baseRelativePath\n\t\/\/\t\t??? Why 'new String(...)'\n\tvar uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);\n\tif (!uri) { dojo.raise(\"Nothing returned by getLibraryScriptUri(): \" + uri); }\n\n\t\/\/ MOW: uri seems to not be actually used.  Seems to be hard-coding to djConfig.baseRelativePath... ???\n\tvar lastslash = uri.lastIndexOf('\/');\t\t\/\/ MOW ???\n\tdjConfig.baseScriptUri = djConfig.baseRelativePath;\n\treturn djConfig.baseScriptUri;\t\/\/ String","returns":"String"}}},"dojo.normalizeLocale":{"_":{"meta":{"summary":"","parameters":{"locale":{"type":""}},"src":"\treturn locale ? locale.toLowerCase() : dojo.locale;"}}},"dojo.searchLocalePath":{"_":{"meta":{"summary":"","parameters":{"locale":{"type":""},"down":{"type":""},"searchFunc":{"type":""}},"src":"\tlocale = dojo.normalizeLocale(locale);\n\n\tvar elements = locale.split('-');\n\tvar searchlist = [];\n\tfor(var i = elements.length; i > 0; i--){\n\t\tsearchlist.push(elements.slice(0, i).join('-'));\n\t}\n\tsearchlist.push(false);\n\tif(down){searchlist.reverse();}\n\n\tfor(var j = searchlist.length - 1; j >= 0; j--){\n\t\tvar loc = searchlist[j] || \"ROOT\";\n\t\tvar stop = searchFunc(loc);\n\t\tif(stop){ break; }\n\t}"}}},"dojo.requireLocalization":{"_":{"meta":{"summary":"","parameters":{"modulename":{"type":""},"bundlename":{"type":""},"locale":{"type":""},"m":{"type":""},"b":{"type":""}},"src":"\t\t\treq(m,b,locale);\n\t\t\tif(locale){return;}\n\t\t\tfor(var i=0; i<extra.length; i++){\n\t\t\t\treq(m,b,extra[i]);\n\t\t\t}"}}},"preload":{"_":{"meta":{"summary":"","parameters":{"locale":{"type":""}},"src":"\t\tif(!dj_undef(\"dj_localesGenerated\", dj_global)){\n\t\t\tdojo.setModulePrefix(\"nls\",\"nls\");\n\n\t\t\tlocale = dojo.normalizeLocale(locale);\n\t\t\tdojo.searchLocalePath(locale, true, function(loc){\n\t\t\t\tfor(var i=0; i<dj_localesGenerated.length;i++){\n\t\t\t\t\tif(dj_localesGenerated[i] == loc){\n\t\t\t\t\t\tdojo.require(\"nls.dojo_\"+loc);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}"}}},"dojo.hostenv.loadPath":{"_":{"meta":{"summary":"","parameters":{"relpath":{"type":""},"module":{"type":"optional"},"cb":{"type":"optional"}},"src":"\tvar uri;\n\tif((relpath.charAt(0) == '\/')||(relpath.match(\/^\\w+:\/))){\n\t\t\/\/ dojo.raise(\"relpath '\" + relpath + \"'; must be relative\");\n\t\turi = relpath;\n\t}else{\n\t\turi = this.getBaseScriptUri() + relpath;\n\t}\n\tif(djConfig.cacheBust && dojo.render.html.capable){\n\t\turi += \"?\" + String(djConfig.cacheBust).replace(\/\\W+\/g,\"\");\n\t}\n\ttry{\n\t\treturn ((!module) ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb));\n\t}catch(e){\n\t\tdojo.debug(e);\n\t\treturn false;\n\t}"}}},"dojo.hostenv.loadUri":{"_":{"meta":{"summary":"","parameters":{"uri":{"type":""},"cb":{"type":"optional"}},"src":"\tif(this.loadedUris[uri]){\n\t\treturn 1;\n\t}\n\tvar contents = this.getText(uri, null, true);\n\tif(contents == null){ return 0; }\n\tthis.loadedUris[uri] = true;\n\tif(cb){ contents = '('+contents+')'; }\n\tvar value = dj_eval(contents);\n\tif(cb){\n\t\tcb(value);\n\t}\n\treturn 1;"}}},"dojo.hostenv.loadUriAndCheck":{"_":{"meta":{"summary":"","parameters":{"uri":{"type":""},"module":{"type":""},"cb":{"type":""}},"src":"\tvar ok = true;\n\ttry{\n\t\tok = this.loadUri(uri, cb);\n\t}catch(e){\n\t\tdojo.debug(\"failed loading \", uri, \" with error: \", e);\n\t}\n\treturn ((ok)&&(this.findModule(module, false))) ? true : false;"}}},"dojo.loaded":{"_":{"meta":{"summary":"","src":""}}},"dojo.unloaded":{"_":{"meta":{"summary":"","src":""}}},"dojo.hostenv.loaded":{"_":{"meta":{"summary":"","src":"\tthis.loadNotifying = true;\n\tthis.post_load_ = true;\n\tvar mll = this.modulesLoadedListeners;\n\tfor(var x=0; x<mll.length; x++){\n\t\tmll[x]();\n\t}\n\n\t\/\/Clear listeners so new ones can be added\n\t\/\/For other xdomain package loads after the initial load.\n\tthis.modulesLoadedListeners = [];\n\tthis.loadNotifying = false;\n\n\tdojo.loaded();","this_variables":["loadNotifying","post_load_","modulesLoadedListeners"]}}},"dojo.hostenv.unloaded":{"_":{"meta":{"summary":"","src":"\tvar mll = this.unloadListeners;\n\twhile(mll.length){\n\t\t(mll.pop())();\n\t}\n\tdojo.unloaded();"}}},"dojo.addOnLoad":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""},"fcnName":{"type":""}},"src":"\tvar dh = dojo.hostenv;\n\tif(arguments.length == 1) {\n\t\tdh.modulesLoadedListeners.push(obj);\n\t} else if(arguments.length > 1) {\n\t\tdh.modulesLoadedListeners.push(function() {\n\t\t\tobj[fcnName]();\n\t\t});\n\t}\n\n\t\/\/Added for xdomain loading. dojo.addOnLoad is used to\n\t\/\/indicate callbacks after doing some dojo.require() statements.\n\t\/\/In the xdomain case, if all the requires are loaded (after initial\n\t\/\/page load), then immediately call any listeners.\n\tif(dh.post_load_ && dh.inFlightCount == 0 && !dh.loadNotifying){\n\t\tdh.callLoaded();\n\t}"}}},"dojo.addOnUnload":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""},"fcnName":{"type":""}},"src":"\tvar dh = dojo.hostenv;\n\tif(arguments.length == 1){\n\t\tdh.unloadListeners.push(obj);\n\t} else if(arguments.length > 1) {\n\t\tdh.unloadListeners.push(function() {\n\t\t\tobj[fcnName]();\n\t\t});\n\t}"}}},"dojo.hostenv.modulesLoaded":{"_":{"meta":{"summary":"","src":"\tif(this.post_load_){ return; }\n\tif((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){\n\t\tif(this.inFlightCount > 0){ \n\t\t\tdojo.debug(\"files still in flight!\");\n\t\t\treturn;\n\t\t}\n\t\tdojo.hostenv.callLoaded();\n\t}","this_variables":["loadUriStack.length"]}}},"dojo.hostenv.callLoaded":{"_":{"meta":{"summary":"","src":"\tif(typeof setTimeout == \"object\"){\n\t\tsetTimeout(\"dojo.hostenv.loaded();\", 0);\n\t}else{\n\t\tdojo.hostenv.loaded();\n\t}"}}},"dojo.hostenv.getModuleSymbols":{"_":{"meta":{"summary":"","parameters":{"modulename":{"type":""}},"src":"\tvar syms = modulename.split(\".\");\n\tfor(var i = syms.length - 1; i > 0; i--){\n\t\tvar parentModule = syms.slice(0, i).join(\".\");\n\t\tvar parentModulePath = this.getModulePrefix(parentModule);\n\t\tif (parentModulePath != parentModule){\n\t\t\tsyms.splice(0, i, parentModulePath);\n\t\t}else if(i==1){\n\t\t\tsyms[0] = \"..\/\" + syms[0];\t\t\t\n\t\t}\n\t}\n\treturn syms;"}}},"dojo.hostenv.loadModule":{"_":{"meta":{"summary":"","parameters":{"modulename":{"type":""},"exact_only":{"type":""},"omit_module_check":{"type":""}},"src":"\tif(!modulename){ return; }\n\tomit_module_check = this._global_omit_module_check || omit_module_check;\n\tvar module = this.findModule(modulename, false);\n\tif(module){\n\t\treturn module;\n\t}\n\n\t\/\/ protect against infinite recursion from mutual dependencies\n\tif(dj_undef(modulename, this.loading_modules_)){\n\t\tthis.addedToLoadingCount.push(modulename);\n\t}\n\tthis.loading_modules_[modulename] = 1;\n\n\t\/\/ convert periods to slashes\n\tvar relpath = modulename.replace(\/\\.\/g, '\/') + '.js';\n\n\tvar nsyms = modulename.split(\".\");\n\t\n\t\/\/ this line allowed loading of a module manifest as if it were a namespace\n\t\/\/ it's an interesting idea, but shouldn't be combined with 'namespaces' proper\n\t\/\/ and leads to unwanted dependencies\n\t\/\/ the effect can be achieved in other (albeit less-flexible) ways now, so I am\n\t\/\/ removing this pending further design work\n\t\/\/ perhaps we can explicitly define this idea of a 'module manifest', and subclass\n\t\/\/ 'namespace manifest' from that\n\t\/\/dojo.getNamespace(nsyms[0]);\n\n\tvar syms = this.getModuleSymbols(modulename);\n\tvar startedRelative = ((syms[0].charAt(0) != '\/')&&(!syms[0].match(\/^\\w+:\/)));\n\tvar last = syms[syms.length - 1];\n\t\/\/ figure out if we're looking for a full package, if so, we want to do\n\t\/\/ things slightly diffrently\n\tif(last==\"*\"){\n\t\tmodulename = (nsyms.slice(0, -1)).join('.');\n\t\twhile(syms.length){\n\t\t\tsyms.pop();\n\t\t\tsyms.push(this.pkgFileName);\n\t\t\trelpath = syms.join(\"\/\") + '.js';\n\t\t\tif(startedRelative && (relpath.charAt(0)==\"\/\")){\n\t\t\t\trelpath = relpath.slice(1);\n\t\t\t}\n\t\t\tok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));\n\t\t\tif(ok){ break; }\n\t\t\tsyms.pop();\n\t\t}\n\t}else{\n\t\trelpath = syms.join(\"\/\") + '.js';\n\t\tmodulename = nsyms.join('.');\n\t\tvar ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));\n\t\tif((!ok)&&(!exact_only)){\n\t\t\tsyms.pop();\n\t\t\twhile(syms.length){\n\t\t\t\trelpath = syms.join('\/') + '.js';\n\t\t\t\tok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));\n\t\t\t\tif(ok){ break; }\n\t\t\t\tsyms.pop();\n\t\t\t\trelpath = syms.join('\/') + '\/'+this.pkgFileName+'.js';\n\t\t\t\tif(startedRelative && (relpath.charAt(0)==\"\/\")){\n\t\t\t\t\trelpath = relpath.slice(1);\n\t\t\t\t}\n\t\t\t\tok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));\n\t\t\t\tif(ok){ break; }\n\t\t\t}\n\t\t}\n\n\t\tif((!ok)&&(!omit_module_check)){\n\t\t\tdojo.raise(\"Could not load '\" + modulename + \"'; last tried '\" + relpath + \"'\");\n\t\t}\n\t}\n\n\t\/\/ check that the symbol was defined\n\t\/\/Don't bother if we're doing xdomain (asynchronous) loading.\n\tif(!omit_module_check && !this[\"isXDomain\"]){\n\t\t\/\/ pass in false so we can give better error\n\t\tmodule = this.findModule(modulename, false);\n\t\tif(!module){\n\t\t\tdojo.raise(\"symbol '\" + modulename + \"' is not defined after loading '\" + relpath + \"'\"); \n\t\t}\n\t}\n\n\treturn module;"}}},"dojo.hostenv.startPackage":{"_":{"meta":{"summary":"","parameters":{"packname":{"type":""}},"src":"\tvar strippedPkgName = fullPkgName;\n\n\tvar syms = packname.split(\/\\.\/);\n\tif(syms[syms.length-1]==\"*\"){\n\t\tsyms.pop();\n\t\tstrippedPkgName = syms.join(\".\");\n\t}\n\tvar evaledPkg = dojo.evalObjPath(strippedPkgName.toString(), true);\n\tthis.loaded_modules_[fullPkgName] = evaledPkg;\n\tthis.loaded_modules_[strippedPkgName] = evaledPkg;\n\t\n\treturn evaledPkg;"}}},"dojo.hostenv.findModule":{"_":{"meta":{"summary":"","parameters":{"modulename":{"type":""},"must_exist":{"type":""}},"src":"\tvar lmn = String(modulename).toString();\n\n\tif(this.loaded_modules_[lmn]){\n\t\treturn this.loaded_modules_[lmn];\n\t}\n\n\tif(must_exist){\n\t\tdojo.raise(\"no loaded module named '\" + modulename + \"'\");\n\t}\n\treturn null;"}}},"dojo.kwCompoundRequire":{"_":{"meta":{"summary":"","parameters":{"modMap":{"type":""}},"src":"\tvar common = modMap[\"common\"]||[];\n\tvar result = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[\"default\"]||[]);\n\n\tfor(var x=0; x<result.length; x++){\n\t\tvar curr = result[x];\n\t\tif(curr.constructor == Array){\n\t\t\tdojo.hostenv.loadModule.apply(dojo.hostenv, curr);\n\t\t}else{\n\t\t\tdojo.hostenv.loadModule(curr);\n\t\t}\n\t}"}}},"dojo.require":{"_":{"meta":{"summary":"","src":"\tdojo.hostenv.loadModule.apply(dojo.hostenv, arguments);"}}},"dojo.requireIf":{"_":{"meta":{"summary":"","src":"\tif((arguments[0] === true)||(arguments[0]==\"common\")||(arguments[0] && dojo.render[arguments[0]].capable)){\n\t\tvar args = [];\n\t\tfor (var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }\n\t\tdojo.require.apply(dojo, args);\n\t}"}}},"dojo.provide":{"_":{"meta":{"summary":"","src":"\treturn dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);"}}},"dojo.registerModulePath":{"_":{"meta":{"summary":"","parameters":{"module":{"type":""},"prefix":{"type":""}},"src":"\treturn dojo.hostenv.setModulePrefix(module, prefix);"}}},"dojo.setModulePrefix":{"_":{"meta":{"summary":"","parameters":{"module":{"type":""},"prefix":{"type":""}},"src":"\tdojo.deprecated('dojo.setModulePrefix(\"' + module + '\", \"' + prefix + '\")', \"replaced by dojo.registerModulePath\", \"0.5\");\n\treturn dojo.registerModulePath(module, prefix);"}}},"dojo.exists":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""},"name":{"type":""}},"src":"\tvar p = name.split(\".\");\n\tfor(var i = 0; i < p.length; i++){\n\t\tif(!(obj[p[i]])){ return false; }\n\t\tobj = obj[p[i]];\n\t}\n\treturn true;"}}}},"requires":{"common":["nls.dojo_\"+loc"]}}}}