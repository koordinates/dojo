{"dojo.date.common":{"meta":{"functions":{"dojo.date.setDayOfYear":{"meta":{"summary":"sets dateObject according to day of the year (1..366)","parameters":{"dateObject":{"type":"Date"},"dayOfYear":{"type":"Number"}},"src":" dateObject.setMonth(0);\n\tdateObject.setDate(dayOfYear);\n\treturn dateObject; \/\/ Date","returns":"Date"}},"dojo.date.getDayOfYear":{"meta":{"summary":"gets the day of the year as represented by dateObject","parameters":{"dateObject":{"type":"Date"}},"src":" var fullYear = dateObject.getFullYear();\n\tvar lastDayOfPrevYear = new Date(fullYear-1, 11, 31);\n\treturn Math.floor((dateObject.getTime() -\n\t\tlastDayOfPrevYear.getTime()) \/ 86400000); \/\/ Number"}},"dojo.date.setWeekOfYear":{"meta":{"summary":"","parameters":{"dateObject":{"type":"Date"},"week":{"type":"Number"},"firstDay":{"type":"Number"}},"src":" if(arguments.length == 1){ firstDay = 0; } \/\/ Sunday\n\tdojo.unimplemented(\"dojo.date.setWeekOfYear\");"}},"dojo.date.getWeekOfYear":{"meta":{"summary":"","parameters":{"dateObject":{"type":"Date"},"firstDay":{"type":"Number"}},"src":" if(arguments.length == 1){ firstDay = 0; } \/\/ Sunday\n\t\/\/ work out the first day of the year corresponding to the week\n\tvar firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);\n\tvar day = firstDayOfYear.getDay();\n\tfirstDayOfYear.setDate(firstDayOfYear.getDate() -\n\t\t\tday + firstDay - (day > firstDay ? 7 : 0));\n\treturn Math.floor((dateObject.getTime() -\n\t\tfirstDayOfYear.getTime()) \/ 604800000);"}},"dojo.date.setIsoWeekOfYear":{"meta":{"summary":"unimplemented","parameters":{"dateObject":{"type":"Date"},"week":{"type":"Number"},"firstDay":{"type":"Number"}},"src":" if (arguments.length == 1) { firstDay = 1; } \/\/ Monday\n\tdojo.unimplemented(\"dojo.date.setIsoWeekOfYear\");"}},"dojo.date.getIsoWeekOfYear":{"meta":{"summary":"unimplemented","parameters":{"dateObject":{"type":"Date"},"firstDay":{"type":"Number"}},"src":" if (arguments.length == 1) { firstDay = 1; } \/\/ Monday\n\tdojo.unimplemented(\"dojo.date.getIsoWeekOfYear\");"}},"dojo.date.getDaysInMonth":{"meta":{"summary":"returns the number of days in the month used by dateObject","parameters":{"dateObject":{"type":"Date"}},"src":" var month = dateObject.getMonth();\n\tvar days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\tif (month == 1 && dojo.date.isLeapYear(dateObject)) { return 29; } \/\/ Number\n\telse { return days[month]; } \/\/ Number","returns":"Number"}},"dojo.date.isLeapYear":{"meta":{"summary":"Determines if the year of the dateObject is a leap year","parameters":{"dateObject":{"type":"Date"}},"src":"\tvar year = dateObject.getFullYear();\n\treturn (year%400 == 0) ? true : (year%100 == 0) ? false : (year%4 == 0) ? true : false; \/\/ Boolean","description":"Leap years are years with an additional day YYYY-02-29, where the year number is a multiple of four with the following exception: If a year is a multiple of 100, then it is only a leap year if it is also a multiple of 400. For example, 1900 was not a leap year, but 2000 is one.","returns":"Boolean"}},"dojo.date.getTimezoneName":{"meta":{"summary":"Get the user's time zone as provided by the browser","parameters":{"dateObject":{"type":"Date"}},"src":"\tvar str = dateObject.toString(); \/\/ Start looking in toString\n\tvar tz = ''; \/\/ The result -- return empty string if nothing found\n\tvar match;\n\t\/\/ First look for something in parentheses -- fast lookup, no regex\n\tvar pos = str.indexOf('(');\n\tif (pos > -1) {\n\t\tpos++;\n\t\ttz = str.substring(pos, str.indexOf(')'));\n\t}\n\t\/\/ If at first you don't succeed ...\n\telse{\n\t\t\/\/ If IE knows about the TZ, it appears before the year\n\t\t\/\/ Capital letters or slash before a 4-digit year \n\t\t\/\/ at the end of string\n\t\tvar pat = \/([A-Z\\\/]+) \\d{4}$\/;\n\t\tif((match = str.match(pat))) {\n\t\t\ttz = match[1];\n\t\t}\n\t\t\/\/ Some browsers (e.g. Safari) glue the TZ on the end\n\t\t\/\/ of toLocaleString instead of putting it in toString\n\t\telse{\n\t\t\tstr = dateObject.toLocaleString();\n\t\t\t\/\/ Capital letters or slash -- end of string, \n\t\t\t\/\/ after space\n\t\t\tpat = \/ ([A-Z\\\/]+)$\/;\n\t\t\tif((match = str.match(pat))) {\n\t\t\t\ttz = match[1];\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ Make sure it doesn't somehow end up return AM or PM\n\treturn tz == 'AM' || tz == 'PM' ? '' : tz; \/\/String","description":"Try to get time zone info from toString or toLocaleString method of the Date object -- UTC offset is not a time zone. See http: \/\/ www.twinsun.com\/tz\/tz-link.htm Note: results may be inconsistent across browsers.","returns":"mixed"},"extra":{"parameters":{"dateObject":{"type":"needed","summary":"because the timezone may vary with time (daylight savings)"}}}},"dojo.date.getOrdinal":{"meta":{"summary":"returns the appropriate suffix (English only) for the day of the month, e.g. 'st' for 1, 'nd' for 2, etc.)","parameters":{"dateObject":{"type":""}},"src":" var date = dateObject.getDate();\n\tif(date%100 != 11 && date%10 == 1){ return \"st\"; } \/\/ String\n\telse if(date%100 != 12 && date%10 == 2){ return \"nd\"; } \/\/ String\n\telse if(date%100 != 13 && date%10 == 3){ return \"rd\"; } \/\/ String\n\telse{ return \"th\"; } \/\/ String","returns":"String"}},"dojo.date.compare":{"meta":{"summary":"Compare two date objects by date, time, or both. Returns 0 if equal, positive if a > b, else negative.","parameters":{"dateA":{"type":"Date"},"dateB":{"type":"Date"},"options":{"type":"dojo.date.compareTypes"}},"src":" var dA=dateA;\n\tvar dB=dateB||new Date();\n\tvar now=new Date();\n\t\/\/FIXME: shorten this code\n\twith(dojo.date.compareTypes){\n\t\tvar opt=options||(DATE|TIME);\n\t\tvar d1=new Date(\n\t\t\t(opt&DATE)?dA.getFullYear():now.getFullYear(), \n\t\t\t(opt&DATE)?dA.getMonth():now.getMonth(),\n\t\t\t(opt&DATE)?dA.getDate():now.getDate(),\n\t\t\t(opt&TIME)?dA.getHours():0,\n\t\t\t(opt&TIME)?dA.getMinutes():0,\n\t\t\t(opt&TIME)?dA.getSeconds():0\n\t\t);\n\t\tvar d2=new Date(\n\t\t\t(opt&DATE)?dB.getFullYear():now.getFullYear(),\n\t\t\t(opt&DATE)?dB.getMonth():now.getMonth(),\n\t\t\t(opt&DATE)?dB.getDate():now.getDate(),\n\t\t\t(opt&TIME)?dB.getHours():0,\n\t\t\t(opt&TIME)?dB.getMinutes():0,\n\t\t\t(opt&TIME)?dB.getSeconds():0\n\t\t);\n\t}\n\tif(d1.valueOf()>d2.valueOf()){\n\t\treturn 1;\t\/\/\tint\n\t}\n\tif(d1.valueOf()<d2.valueOf()){\n\t\treturn -1;\t\/\/\tint\n\t}\n\treturn 0;\t\/\/\tint","returns":"int"}},"dojo.date.add":{"meta":{"summary":"Add to a Date in intervals of different size, from milliseconds to years","parameters":{"dt":{"type":"Date"},"interv":{"type":"dojo.date.dateParts"},"incr":{"type":"int"}},"src":"\tif(typeof dt == 'number'){dt = new Date(dt);} \/\/ Allow timestamps\n\/\/FIXME: what's the reason behind this?\tincr = incr || 1;\n\tfunction fixOvershoot(){\n\t\tif (sum.getDate() < dt.getDate()){\n\t\t\tsum.setDate(0);\n\t\t}\n\t}\n\tvar sum = new Date(dt);\n\twith(dojo.date.dateParts){\n\t\tswitch(interv){\n\t\t\tcase YEAR:\n\t\t\t\tsum.setFullYear(dt.getFullYear()+incr);\n\t\t\t\t\/\/ Keep increment\/decrement from 2\/29 out of March\n\t\t\t\tfixOvershoot();\n\t\t\t\tbreak;\n\t\t\tcase QUARTER:\n\t\t\t\t\/\/ Naive quarter is just three months\n\t\t\t\tincr*=3;\n\t\t\t\t\/\/ fallthrough...\n\t\t\tcase MONTH:\n\t\t\t\tsum.setMonth(dt.getMonth()+incr);\n\t\t\t\t\/\/ Reset to last day of month if you overshoot\n\t\t\t\tfixOvershoot();\n\t\t\t\tbreak;\n\t\t\tcase WEEK:\n\t\t\t\tincr*=7;\n\t\t\t\t\/\/ fallthrough...\n\t\t\tcase DAY:\n\t\t\t\tsum.setDate(dt.getDate() + incr);\n\t\t\t\tbreak;\n\t\t\tcase WEEKDAY:\n\t\t\t\t\/\/FIXME: assumes Saturday\/Sunday weekend, but even this is not fixed.  There are CLDR entries to localize this.\n\t\t\t\tvar dat = dt.getDate();\n\t\t\t\tvar weeks = 0;\n\t\t\t\tvar days = 0;\n\t\t\t\tvar strt = 0;\n\t\t\t\tvar trgt = 0;\n\t\t\t\tvar adj = 0;\n\t\t\t\t\/\/ Divide the increment time span into weekspans plus leftover days\n\t\t\t\t\/\/ e.g., 8 days is one 5-day weekspan \/ and two leftover days\n\t\t\t\t\/\/ Can't have zero leftover days, so numbers divisible by 5 get\n\t\t\t\t\/\/ a days value of 5, and the remaining days make up the number of weeks\n\t\t\t\tvar mod = incr % 5;\n\t\t\t\tif (mod == 0) {\n\t\t\t\t\tdays = (incr > 0) ? 5 : -5;\n\t\t\t\t\tweeks = (incr > 0) ? ((incr-5)\/5) : ((incr+5)\/5);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdays = mod;\n\t\t\t\t\tweeks = parseInt(incr\/5);\n\t\t\t\t}\n\t\t\t\t\/\/ Get weekday value for orig date param\n\t\t\t\tstrt = dt.getDay();\n\t\t\t\t\/\/ Orig date is Sat \/ positive incrementer\n\t\t\t\t\/\/ Jump over Sun\n\t\t\t\tif (strt == 6 && incr > 0) {\n\t\t\t\t\tadj = 1;\n\t\t\t\t}\n\t\t\t\t\/\/ Orig date is Sun \/ negative incrementer\n\t\t\t\t\/\/ Jump back over Sat\n\t\t\t\telse if (strt == 0 && incr < 0) {\n\t\t\t\t\tadj = -1;\n\t\t\t\t}\n\t\t\t\t\/\/ Get weekday val for the new date\n\t\t\t\ttrgt = (strt + days);\n\t\t\t\t\/\/ New date is on Sat or Sun\n\t\t\t\tif (trgt == 0 || trgt == 6) {\n\t\t\t\t\tadj = (incr > 0) ? 2 : -2;\n\t\t\t\t}\n\t\t\t\t\/\/ Increment by number of weeks plus leftover days plus\n\t\t\t\t\/\/ weekend adjustments\n\t\t\t\tsum.setDate(dat + (7*weeks) + days + adj);\n\t\t\t\tbreak;\n\t\t\tcase HOUR:\n\t\t\t\tsum.setHours(sum.getHours()+incr);\n\t\t\t\tbreak;\n\t\t\tcase MINUTE:\n\t\t\t\tsum.setMinutes(sum.getMinutes()+incr);\n\t\t\t\tbreak;\n\t\t\tcase SECOND:\n\t\t\t\tsum.setSeconds(sum.getSeconds()+incr);\n\t\t\t\tbreak;\n\t\t\tcase MILLISECOND:\n\t\t\t\tsum.setMilliseconds(sum.getMilliseconds()+incr);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\/\/ Do nothing\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum; \/\/ Date","returns":"Date"},"extra":{"parameters":{"dt":{"type":"A","summary":"Javascript Date object to start with"},"interv":{"type":"A","summary":"constant representing the interval, e.g. YEAR, MONTH, DAY. See dojo.date.dateParts."},"incr":{"type":"How","summary":"much to add to the date"}}}},"dojo.date.diff":{"meta":{"summary":"Get the difference in a specific unit of time (e.g., number of months, weeks, days, etc.) between two dates.","parameters":{"dtA":{"type":"Date"},"dtB":{"type":"Date"},"interv":{"type":"dojo.date.dateParts"}},"src":"\t\/\/ Accept timestamp input\n\tif(typeof dtA == 'number'){dtA = new Date(dtA);}\n\tif(typeof dtB == 'number'){dtB = new Date(dtB);}\n\tvar yeaDiff = dtB.getFullYear() - dtA.getFullYear();\n\tvar monDiff = (dtB.getMonth() - dtA.getMonth()) + (yeaDiff * 12);\n\tvar msDiff = dtB.getTime() - dtA.getTime(); \/\/ Millisecs\n\tvar secDiff = msDiff\/1000;\n\tvar minDiff = secDiff\/60;\n\tvar houDiff = minDiff\/60;\n\tvar dayDiff = houDiff\/24;\n\tvar weeDiff = dayDiff\/7;\n\tvar delta = 0; \/\/ Integer return value\n\twith(dojo.date.dateParts){\n\t\tswitch(interv){\n\t\t\tcase YEAR:\n\t\t\t\tdelta = yeaDiff;\n\t\t\t\tbreak;\n\t\t\tcase QUARTER:\n\t\t\t\tvar mA = dtA.getMonth();\n\t\t\t\tvar mB = dtB.getMonth();\n\t\t\t\t\/\/ Figure out which quarter the months are in\n\t\t\t\tvar qA = Math.floor(mA\/3) + 1;\n\t\t\t\tvar qB = Math.floor(mB\/3) + 1;\n\t\t\t\t\/\/ Add quarters for any year difference between the dates\n\t\t\t\tqB += (yeaDiff * 4);\n\t\t\t\tdelta = qB - qA;\n\t\t\t\tbreak;\n\t\t\tcase MONTH:\n\t\t\t\tdelta = monDiff;\n\t\t\t\tbreak;\n\t\t\tcase WEEK:\n\t\t\t\t\/\/ Truncate instead of rounding\n\t\t\t\t\/\/ Don't use Math.floor -- value may be negative\n\t\t\t\tdelta = parseInt(weeDiff);\n\t\t\t\tbreak;\n\t\t\tcase DAY:\n\t\t\t\tdelta = dayDiff;\n\t\t\t\tbreak;\n\t\t\tcase WEEKDAY:\n\t\t\t\tvar days = Math.round(dayDiff);\n\t\t\t\tvar weeks = parseInt(days\/7);\n\t\t\t\tvar mod = days % 7;\n\t\t\t\t\/\/ Even number of weeks\n\t\t\t\tif (mod == 0) {\n\t\t\t\t\tdays = weeks*5;\n\t\t\t\t}\n\t\t\t\t\/\/ Weeks plus spare change (< 7 days)\n\t\t\t\telse {\n\t\t\t\t\tvar adj = 0;\n\t\t\t\t\tvar aDay = dtA.getDay();\n\t\t\t\t\tvar bDay = dtB.getDay();\n\t\t\t\t\tweeks = parseInt(days\/7);\n\t\t\t\t\tmod = days % 7;\n\t\t\t\t\t\/\/ Mark the date advanced by the number of\n\t\t\t\t\t\/\/ round weeks (may be zero)\n\t\t\t\t\tvar dtMark = new Date(dtA);\n\t\t\t\t\tdtMark.setDate(dtMark.getDate()+(weeks*7));\n\t\t\t\t\tvar dayMark = dtMark.getDay();\n\t\t\t\t\t\/\/ Spare change days -- 6 or less\n\t\t\t\t\t\/\/ ----------\n\t\t\t\t\t\/\/ Positive diff\n\t\t\t\t\tif (dayDiff > 0) {\n\t\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\t\t\/\/ Range starts on Sat\n\t\t\t\t\t\t\tcase aDay == 6:\n\t\t\t\t\t\t\t\tadj = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range starts on Sun\n\t\t\t\t\t\t\tcase aDay == 0:\n\t\t\t\t\t\t\t\tadj = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range ends on Sat\n\t\t\t\t\t\t\tcase bDay == 6:\n\t\t\t\t\t\t\t\tadj = -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range ends on Sun\n\t\t\t\t\t\t\tcase bDay == 0:\n\t\t\t\t\t\t\t\tadj = -2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range contains weekend\n\t\t\t\t\t\t\tcase (dayMark + mod) > 5:\n\t\t\t\t\t\t\t\tadj = -2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\/\/ Do nothing\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ Negative diff\n\t\t\t\t\telse if (dayDiff < 0) {\n\t\t\t\t\t\tswitch (true) {\n\t\t\t\t\t\t\t\/\/ Range starts on Sat\n\t\t\t\t\t\t\tcase aDay == 6:\n\t\t\t\t\t\t\t\tadj = 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range starts on Sun\n\t\t\t\t\t\t\tcase aDay == 0:\n\t\t\t\t\t\t\t\tadj = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range ends on Sat\n\t\t\t\t\t\t\tcase bDay == 6:\n\t\t\t\t\t\t\t\tadj = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range ends on Sun\n\t\t\t\t\t\t\tcase bDay == 0:\n\t\t\t\t\t\t\t\tadj = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\/\/ Range contains weekend\n\t\t\t\t\t\t\tcase (dayMark + mod) < 0:\n\t\t\t\t\t\t\t\tadj = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\/\/ Do nothing\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdays += adj;\n\t\t\t\t\tdays -= (weeks*2);\n\t\t\t\t}\n\t\t\t\tdelta = days;\n\t\t\t\tbreak;\n\t\t\tcase HOUR:\n\t\t\t\tdelta = houDiff;\n\t\t\t\tbreak;\n\t\t\tcase MINUTE:\n\t\t\t\tdelta = minDiff;\n\t\t\t\tbreak;\n\t\t\tcase SECOND:\n\t\t\t\tdelta = secDiff;\n\t\t\t\tbreak;\n\t\t\tcase MILLISECOND:\n\t\t\t\tdelta = msDiff;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\/\/ Do nothing\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t\/\/ Round for fractional values and DST leaps\n\treturn Math.round(delta); \/\/ Number (integer)","returns":"mixed"},"extra":{"parameters":{"dtA":{"type":"A","summary":"Javascript Date object"},"dtB":{"type":"A","summary":"Javascript Date object"},"interv":{"type":"A","summary":"constant representing the interval, e.g. YEAR, MONTH, DAY. See dojo.date.dateParts."}}}}},"objects":{"dojo.date.compareTypes":{"meta":{"variables":["DATE","TIME"],"summary":"bitmask for comparison operations."}},"dojo.date.dateParts":{"meta":{"variables":["YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","MILLISECOND","QUARTER","WEEK","WEEKDAY"],"summary":"constants for use in dojo.date.add"}}}}},"dojo.date.format":{"meta":{"requires":{"common":["dojo.date.common","dojo.date.supplemental","dojo.lang.array","dojo.lang.common","dojo.lang.func","dojo.string.common","dojo.i18n.common"]},"functions":{"dojo.date.format":{"meta":{"summary":"Format a Date object as a String, using locale-specific settings.","parameters":{"dateObject":{"type":"Date"},"options":{"type":"Object?"}},"src":"\tif(typeof options == \"string\"){\n\t\tdojo.deprecated(\"dojo.date.format\", \"To format dates with POSIX-style strings, please use dojo.date.strftime instead\", \"0.5\");\n\t\treturn dojo.date.strftime(dateObject, options);\n\t}\n\t\/\/ Format a pattern without literals\n\tfunction formatPattern(dateObject, pattern){\n\t\treturn pattern.replace(\/([a-z])\\1*\/ig, function(match){\n\t\t\tvar s;\n\t\t\tvar c = match.charAt(0);\n\t\t\tvar l = match.length;\n\t\t\tvar pad;\n\t\t\tvar widthList = [\"abbr\", \"wide\", \"narrow\"];\n\t\t\tswitch(c){\n\t\t\t\tcase 'G':\n\t\t\t\t\tif(l>3){dojo.unimplemented(\"Era format not implemented\");}\n\t\t\t\t\ts = info.eras[dateObject.getFullYear() < 0 ? 1 : 0];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'y':\n\t\t\t\t\ts = dateObject.getFullYear();\n\t\t\t\t\tswitch(l){\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\ts = String(s).substr(-2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tpad = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Q':\n\t\t\t\tcase 'q':\n\t\t\t\t\ts = Math.ceil((dateObject.getMonth()+1)\/3);\n\t\t\t\t\tswitch(l){\n\t\t\t\t\t\tcase 1: case 2:\n\t\t\t\t\t\t\tpad = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tdojo.unimplemented(\"Quarter format not implemented\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'M':\n\t\t\t\tcase 'L':\n\t\t\t\t\tvar m = dateObject.getMonth();\n\t\t\t\t\tvar width;\n\t\t\t\t\tswitch(l){\n\t\t\t\t\t\tcase 1: case 2:\n\t\t\t\t\t\t\ts = m+1; pad = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3: case 4: case 5:\n\t\t\t\t\t\t\twidth = widthList[l-3];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(width){\n\t\t\t\t\t\tvar type = (c == \"L\") ? \"standalone\" : \"format\";\n\t\t\t\t\t\tvar prop = [\"months\",type,width].join(\"-\");\n\t\t\t\t\t\ts = info[prop][m];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'w':\n\t\t\t\t\tvar firstDay = 0;\n\t\t\t\t\ts = dojo.date.getWeekOfYear(dateObject, firstDay); pad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\ts = dateObject.getDate(); pad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\ts = dojo.date.getDayOfYear(dateObject); pad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\tcase 'e':\n\t\t\t\tcase 'c': \/\/ REVIEW: don't see this in the spec?\n\t\t\t\t\tvar d = dateObject.getDay();\n\t\t\t\t\tvar width;\n\t\t\t\t\tswitch(l){\n\t\t\t\t\t\tcase 1: case 2:\n\t\t\t\t\t\t\tif(c == 'e'){\n\t\t\t\t\t\t\t\tvar first = dojo.date.getFirstDayOfWeek(options.locale);\n\t\t\t\t\t\t\t\td = (d-first+7)%7;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(c != 'c'){\n\t\t\t\t\t\t\t\ts = d+1; pad = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\/\/ else fallthrough...\n\t\t\t\t\t\tcase 3: case 4: case 5:\n\t\t\t\t\t\t\twidth = widthList[l-3];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(width){\n\t\t\t\t\t\tvar type = (c == \"c\") ? \"standalone\" : \"format\";\n\t\t\t\t\t\tvar prop = [\"days\",type,width].join(\"-\");\n\t\t\t\t\t\ts = info[prop][d];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'a':\n\t\t\t\t\tvar timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';\n\t\t\t\t\ts = info[timePeriod];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\tcase 'H':\n\t\t\t\tcase 'K':\n\t\t\t\tcase 'k':\n\t\t\t\t\tvar h = dateObject.getHours();\n\t\t\t\t\t\/\/ strange choices in the date format make it impossible to write this succinctly\n\t\t\t\t\tswitch (c) {\n\t\t\t\t\t\tcase 'h': \/\/ 1-12\n\t\t\t\t\t\t\ts = (h % 12) || 12;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'H': \/\/ 0-23\n\t\t\t\t\t\t\ts = h;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'K': \/\/ 0-11\n\t\t\t\t\t\t\ts = (h % 12);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'k': \/\/ 1-24\n\t\t\t\t\t\t\ts = h || 24;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tpad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\ts = dateObject.getMinutes(); pad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\ts = dateObject.getSeconds(); pad = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\ts = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'v': \/\/ FIXME: don't know what this is. seems to be same as z?\n\t\t\t\tcase 'z':\n\t\t\t\t\t\/\/ We only have one timezone to offer; the one from the browser\n\t\t\t\t\ts = dojo.date.getTimezoneName(dateObject);\n\t\t\t\t\tif(s){break;}\n\t\t\t\t\tl=4;\n\t\t\t\t\t\/\/ fallthrough... use GMT if tz not available\n\t\t\t\tcase 'Z':\n\t\t\t\t\tvar offset = dateObject.getTimezoneOffset();\n\t\t\t\t\tvar tz = [\n\t\t\t\t\t\t(offset<=0 ? \"+\" : \"-\"),\n\t\t\t\t\t\tdojo.string.pad(Math.floor(Math.abs(offset)\/60), 2),\n\t\t\t\t\t\tdojo.string.pad(Math.abs(offset)% 60, 2)\n\t\t\t\t\t];\n\t\t\t\t\tif(l==4){\n\t\t\t\t\t\ttz.splice(0, 0, \"GMT\");\n\t\t\t\t\t\ttz.splice(3, 0, \":\");\n\t\t\t\t\t}\n\t\t\t\t\ts = tz.join(\"\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Y':\n\t\t\t\tcase 'u':\n\t\t\t\tcase 'W':\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'g':\n\t\t\t\tcase 'A':\n\t\t\t\t\tdojo.debug(match+\" modifier not yet implemented\");\n\t\t\t\t\ts = \"?\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdojo.raise(\"dojo.date.format: invalid pattern char: \"+pattern);\n\t\t\t}\n\t\t\tif(pad){ s = dojo.string.pad(s, l); }\n\t\t\treturn s;\n\t\t});\n\t}\n\toptions = options || {};\n\tvar locale = dojo.hostenv.normalizeLocale(options.locale);\n\tvar formatLength = options.formatLength || 'full';\n\tvar info = dojo.date._getGregorianBundle(locale);\n\tvar str = [];\n\tvar sauce = dojo.lang.curry(this, formatPattern, dateObject);\n\tif(options.selector != \"timeOnly\"){\n\t\tvar datePattern = options.datePattern || info[\"dateFormat-\"+formatLength];\n\t\tif(datePattern){str.push(_processPattern(datePattern, sauce));}\n\t}\n\tif(options.selector != \"dateOnly\"){\n\t\tvar timePattern = options.timePattern || info[\"timeFormat-\"+formatLength];\n\t\tif(timePattern){str.push(_processPattern(timePattern, sauce));}\n\t}\n\tvar result = str.join(\" \"); \/\/TODO: use locale-specific pattern to assemble date + time\n\treturn result; \/*String*\/","description":"Create a string from a Date object using a known localized pattern. By default, this method formats both date and time from dateObject. Formatting patterns are chosen appropriate to the locale. Different formatting lengths may be chosen, with \"full\" used by default. Custom patterns may be used or registered with translations using the addCustomBundle method. Formatting patterns are implemented using the syntax described at http: \/\/ www.unicode.org\/reports\/tr35\/tr35-4.html#Date_Format_Patterns","returns":"String"},"extra":{"parameters":{"dateObject":{"type":"the","summary":"date and\/or time to be formatted. If a time only is formatted, the values in the year, month, and day fields are irrelevant. The opposite is true when formatting only dates."},"options":{"type":"object","summary":"{selector: string, formatLength: string, datePattern: string, timePattern: string, locale: string} selector- choice of timeOnly,dateOnly (default: date and time) formatLength- choice of long, short, medium or full (plus any custom additions). Defaults to 'full' datePattern,timePattern- override pattern with this string am,pm- override strings for am\/pm in times locale- override the locale used to determine formatting rules"}}}},"dojo.date.parse":{"meta":{"summary":"Convert a properly formatted string to a primitive Date object, using locale-specific settings.","parameters":{"value":{"type":"String"},"options":{"type":"Object?"}},"src":"\toptions = options || {};\n\tvar locale = dojo.hostenv.normalizeLocale(options.locale);\n\tvar info = dojo.date._getGregorianBundle(locale);\n\tvar formatLength = options.formatLength || 'full';\n\tif(!options.selector){ options.selector = 'dateOnly'; }\n\tvar datePattern = options.datePattern || info[\"dateFormat-\" + formatLength];\n\tvar timePattern = options.timePattern || info[\"timeFormat-\" + formatLength];\n\tvar pattern;\n\tif(options.selector == 'dateOnly'){\n\t\tpattern = datePattern;\n\t}\n\telse if(options.selector == 'timeOnly'){\n\t\tpattern = timePattern;\n\t}else if(options.selector == 'dateTime'){\n\t\tpattern = datePattern + ' ' + timePattern; \/\/TODO: use locale-specific pattern to assemble date + time\n\t}else{\n\t\tvar msg = \"dojo.date.parse: Unknown selector param passed: '\" + options.selector + \"'.\";\n\t\tmsg += \" Defaulting to date pattern.\";\n\t\tdojo.debug(msg);\n\t\tpattern = datePattern;\n\t}\n\tvar groups = [];\n\tvar dateREString = _processPattern(pattern, dojo.lang.curry(this, _buildDateTimeRE, groups, info, options));\n\tvar dateRE = new RegExp(\"^\" + dateREString + \"$\");\n\tvar match = dateRE.exec(value);\n\tif(!match){\n\t\treturn null;\n\t}\n\tvar widthList = ['abbr', 'wide', 'narrow'];\n\t\/\/1972 is a leap year.  We want to avoid Feb 29 rolling over into Mar 1,\n\t\/\/in the cases where the year is parsed after the month and day.\n\tvar result = new Date(1972, 0);\n\tvar expected = {};\n\tfor(var i=1; i<match.length; i++){\n\t\tvar grp=groups[i-1];\n\t\tvar l=grp.length;\n\t\tvar v=match[i];\n\t\tswitch(grp.charAt(0)){\n\t\t\tcase 'y':\n\t\t\t\tif(l != 2){\n\t\t\t\t\t\/\/interpret year literally, so '5' would be 5 A.D.\n\t\t\t\t\tresult.setFullYear(v);\n\t\t\t\t\texpected.year = v;\n\t\t\t\t}else{\n\t\t\t\t\tif(v<100){\n\t\t\t\t\t\tv = Number(v);\n\t\t\t\t\t\t\/\/choose century to apply, according to a sliding window\n\t\t\t\t\t\t\/\/of 80 years before and 20 years after present year\n\t\t\t\t\t\tvar year = '' + new Date().getFullYear();\n\t\t\t\t\t\tvar century = year.substring(0, 2) * 100;\n\t\t\t\t\t\tvar yearPart = Number(year.substring(2, 4));\n\t\t\t\t\t\tvar cutoff = Math.min(yearPart + 20, 99);\n\t\t\t\t\t\tvar num = (v < cutoff) ? century + v : century - 100 + v;\n\t\t\t\t\t\tresult.setFullYear(num);\n\t\t\t\t\t\texpected.year = num;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\/\/we expected 2 digits and got more...\n\t\t\t\t\t\tif(options.strict){\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/interpret literally, so '150' would be 150 A.D.\n\t\t\t\t\t\t\/\/also tolerate '1950', if 'yyyy' input passed to 'yy' format\n\t\t\t\t\t\tresult.setFullYear(v);\n\t\t\t\t\t\texpected.year = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\tif (l>2) {\n\t\t\t\t\tif(!options.strict){\n\t\t\t\t\t\t\/\/Tolerate abbreviating period in month part\n\t\t\t\t\t\tv = v.replace(\/\\.\/g,'');\n\t\t\t\t\t\t\/\/Case-insensitive\n\t\t\t\t\t\tv = v.toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\tvar months = info['months-format-' + widthList[l-3]].concat();\n\t\t\t\t\tfor (var j=0; j<months.length; j++){\n\t\t\t\t\t\tif(!options.strict){\n\t\t\t\t\t\t\t\/\/Case-insensitive\n\t\t\t\t\t\t\tmonths[j] = months[j].toLowerCase();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(v == months[j]){\n\t\t\t\t\t\t\tresult.setMonth(j);\n\t\t\t\t\t\t\texpected.month = j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(j==months.length){\n\t\t\t\t\t\tdojo.debug(\"dojo.date.parse: Could not parse month name: '\" + v + \"'.\");\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tresult.setMonth(v-1);\n\t\t\t\t\texpected.month = v-1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'E':\n\t\t\tcase 'e':\n\t\t\t\tif(!options.strict){\n\t\t\t\t\t\/\/Case-insensitive\n\t\t\t\t\tv = v.toLowerCase();\n\t\t\t\t}\n\t\t\t\tvar days = info['days-format-' + widthList[l-3]].concat();\n\t\t\t\tfor (var j=0; j<days.length; j++){\n\t\t\t\t\tif(!options.strict){\n\t\t\t\t\t\t\/\/Case-insensitive\n\t\t\t\t\t\tdays[j] = days[j].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\tif(v == days[j]){\n\t\t\t\t\t\t\/\/TODO: not sure what to actually do with this input,\n\t\t\t\t\t\t\/\/in terms of setting something on the Date obj...?\n\t\t\t\t\t\t\/\/without more context, can't affect the actual date\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j==days.length){\n\t\t\t\t\tdojo.debug(\"dojo.date.parse: Could not parse weekday name: '\" + v + \"'.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tbreak;\t\n\t\t\tcase 'd':\n\t\t\t\tresult.setDate(v);\n\t\t\t\texpected.date = v;\n\t\t\t\tbreak;\n\t\t\tcase 'a': \/\/am\/pm\n\t\t\t\tvar am = options.am || info.am;\n\t\t\t\tvar pm = options.pm || info.pm;\n\t\t\t\tif(!options.strict){\n\t\t\t\t\tv = v.replace(\/\\.\/g,'').toLowerCase();\n\t\t\t\t\tam = am.replace(\/\\.\/g,'').toLowerCase();\n\t\t\t\t\tpm = pm.replace(\/\\.\/g,'').toLowerCase();\n\t\t\t\t}\n\t\t\t\tif(options.strict && v != am && v != pm){\n\t\t\t\t\tdojo.debug(\"dojo.date.parse: Could not parse am\/pm part.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tvar hours = result.getHours();\n\t\t\t\tif(v == pm && hours < 12){\n\t\t\t\t\tresult.setHours(hours + 12); \/\/e.g., 3pm -> 15\n\t\t\t\t} else if(v == am && hours == 12){\n\t\t\t\t\tresult.setHours(0); \/\/12am -> 0\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'K': \/\/hour (1-24)\n\t\t\t\tif(v==24){v=0;}\n\t\t\t\t\/\/ fallthrough...\n\t\t\tcase 'h': \/\/hour (1-12)\n\t\t\tcase 'H': \/\/hour (0-23)\n\t\t\tcase 'k': \/\/hour (0-11)\n\t\t\t\t\/\/TODO: strict bounds checking, padding\n\t\t\t\tif(v>23){\n\t\t\t\t\tdojo.debug(\"dojo.date.parse: Illegal hours value\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t\/\/in the 12-hour case, adjusting for am\/pm requires the 'a' part\n\t\t\t\t\/\/which for now we will assume always comes after the 'h' part\n\t\t\t\tresult.setHours(v);\n\t\t\t\tbreak;\n\t\t\tcase 'm': \/\/minutes\n\t\t\t\tresult.setMinutes(v);\n\t\t\t\tbreak;\n\t\t\tcase 's': \/\/seconds\n\t\t\t\tresult.setSeconds(v);\n\t\t\t\tbreak;\n\t\t\tcase 'S': \/\/milliseconds\n\t\t\t\tresult.setMilliseconds(v);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdojo.unimplemented(\"dojo.date.parse: unsupported pattern char=\" + grp.charAt(0));\n\t\t}\n\t}\n\t\/\/validate parse date fields versus input date fields\n\tif(expected.year && result.getFullYear() != expected.year){\n\t\tdojo.debug(\"Parsed year: '\" + result.getFullYear() + \"' did not match input year: '\" + expected.year + \"'.\");\n\t\treturn null;\n\t}\n\tif(expected.month && result.getMonth() != expected.month){\n\t\tdojo.debug(\"Parsed month: '\" + result.getMonth() + \"' did not match input month: '\" + expected.month + \"'.\");\n\t\treturn null;\n\t}\n\tif(expected.date && result.getDate() != expected.date){\n\t\tdojo.debug(\"Parsed day of month: '\" + result.getDate() + \"' did not match input day of month: '\" + expected.date + \"'.\");\n\t\treturn null;\n\t}\n\t\/\/TODO: implement a getWeekday() method in order to test \n\t\/\/validity of input strings containing 'EEE' or 'EEEE'...\n\treturn result; \/*Date*\/","description":"Create a Date object from a string using a known localized pattern. By default, this method parses looking for both date and time in the string. Formatting patterns are chosen appropriate to the locale. Different formatting lengths may be chosen, with \"full\" used by default. Custom patterns may be used or registered with translations using the addCustomBundle method. Formatting patterns are implemented using the syntax described at http: \/\/ www.unicode.org\/reports\/tr35\/#Date_Format_Patterns","returns":"Date"},"extra":{"parameters":{"value":{"type":"A","summary":"string representation of a date"},"options":{"type":"object","summary":"{selector: string, formatLength: string, datePattern: string, timePattern: string, locale: string, strict: boolean} selector- choice of timeOnly, dateOnly, dateTime (default: dateOnly) formatLength- choice of long, short, medium or full (plus any custom additions). Defaults to 'full' datePattern,timePattern- override pattern with this string am,pm- override strings for am\/pm in times locale- override the locale used to determine formatting rules strict- strict parsing, off by default"}}}},"_processPattern":{"meta":{"summary":"","parameters":{"pattern":{"type":""},"applyPattern":{"type":""},"applyLiteral":{"type":""},"applyAll":{"type":""}},"src":" var identity = function(x){return x;};\n\tapplyPattern = applyPattern || identity;\n\tapplyLiteral = applyLiteral || identity;\n\tapplyAll = applyAll || identity;\n\t\/\/split on single quotes (which escape literals in date format strings) \n\t\/\/but preserve escaped single quotes (e.g., o''clock)\n\tvar chunks = pattern.match(\/(''|[^'])+\/g); \n\tvar literal = false;\n\tfor(var i=0; i<chunks.length; i++){\n\t\tif(!chunks[i]){\n\t\t\tchunks[i]='';\n\t\t} else {\n\t\t\tchunks[i]=(literal ? applyLiteral : applyPattern)(chunks[i]);\n\t\t\tliteral = !literal;\n\t\t}\n\t}\n\treturn applyAll(chunks.join(''));"}},"_buildDateTimeRE":{"meta":{"summary":"","parameters":{"groups":{"type":""},"info":{"type":""},"options":{"type":""},"pattern":{"type":""}},"src":" return pattern.replace(\/([a-z])\\1*\/ig, function(match){\n\t\t\/\/ Build a simple regexp without parenthesis, which would ruin the match list\n\t\tvar s;\n\t\tvar c = match.charAt(0);\n\t\tvar l = match.length;\n\t\tswitch(c){\n\t\t\tcase 'y':\n\t\t\t\ts = '\\\\d' + ((l==2) ? '{2,4}' : '+');\n\t\t\t\tbreak;\n\t\t\tcase 'M':\n\t\t\t\ts = (l>2) ? '\\\\S+' : '\\\\d{1,2}';\n\t\t\t\tbreak;\n\t\t\tcase 'd':\n\t\t\t\ts = '\\\\d{1,2}';\n\t\t\t\tbreak;\n\t\t    case 'E':\n\t\t\t\ts = '\\\\S+';\n\t\t\t\tbreak;\n\t\t\tcase 'h': \n\t\t\tcase 'H': \n\t\t\tcase 'K': \n\t\t\tcase 'k':\n\t\t\t\ts = '\\\\d{1,2}';\n\t\t\t\tbreak;\n\t\t\tcase 'm':\n\t\t\tcase 's':\n\t\t\t\ts = '[0-5]\\\\d';\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\ts = '\\\\d{1,3}';\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\tvar am = options.am || info.am || 'AM';\n\t\t\t\tvar pm = options.pm || info.pm || 'PM';\n\t\t\t\tif(options.strict){\n\t\t\t\t\ts = am + '|' + pm;\n\t\t\t\t}else{\n\t\t\t\t\ts = am;\n\t\t\t\t\ts += (am != am.toLowerCase()) ? '|' + am.toLowerCase() : '';\n\t\t\t\t\ts += '|';\n\t\t\t\t\ts += (pm != pm.toLowerCase()) ? pm + '|' + pm.toLowerCase() : pm;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdojo.unimplemented(\"parse of date format, pattern=\" + pattern);\n\t\t}\n\t\tif(groups){ groups.push(match); }\n\/\/FIXME: replace whitespace within final regexp with more flexible whitespace match instead?\n\t\t\/\/tolerate whitespace\n\t\treturn '\\\\s*(' + s + ')\\\\s*';\n\t});"}},"dojo.date.strftime":{"meta":{"summary":"Formats the date object using the specifications of the POSIX strftime function","parameters":{"dateObject":{"type":"Date"},"format":{"type":"String"},"locale":{"type":"String?"}},"src":"\t\/\/ zero pad\n\tvar padChar = null;\n\tfunction _(s, n){\n\t\treturn dojo.string.pad(s, n || 2, padChar || \"0\");\n\t}\n\tvar info = dojo.date._getGregorianBundle(locale);\n\tfunction $(property){\n\t\tswitch (property){\n\t\t\tcase \"a\": \/\/ abbreviated weekday name according to the current locale\n\t\t\t\treturn dojo.date.getDayShortName(dateObject, locale);\n\t\t\tcase \"A\": \/\/ full weekday name according to the current locale\n\t\t\t\treturn dojo.date.getDayName(dateObject, locale);\n\t\t\tcase \"b\":\n\t\t\tcase \"h\": \/\/ abbreviated month name according to the current locale\n\t\t\t\treturn dojo.date.getMonthShortName(dateObject, locale);\n\t\t\tcase \"B\": \/\/ full month name according to the current locale\n\t\t\t\treturn dojo.date.getMonthName(dateObject, locale);\n\t\t\tcase \"c\": \/\/ preferred date and time representation for the current\n\t\t\t\t      \/\/ locale\n\t\t\t\treturn dojo.date.format(dateObject, {locale: locale});\n\t\t\tcase \"C\": \/\/ century number (the year divided by 100 and truncated\n\t\t\t\t      \/\/ to an integer, range 00 to 99)\n\t\t\t\treturn _(Math.floor(dateObject.getFullYear()\/100));\n\t\t\tcase \"d\": \/\/ day of the month as a decimal number (range 01 to 31)\n\t\t\t\treturn _(dateObject.getDate());\n\t\t\tcase \"D\": \/\/ same as %m\/%d\/%y\n\t\t\t\treturn $(\"m\") + \"\/\" + $(\"d\") + \"\/\" + $(\"y\");\n\t\t\tcase \"e\": \/\/ day of the month as a decimal number, a single digit is\n\t\t\t\t      \/\/ preceded by a space (range ' 1' to '31')\n\t\t\t\tif(padChar == null){ padChar = \" \"; }\n\t\t\t\treturn _(dateObject.getDate());\n\t\t\tcase \"f\": \/\/ month as a decimal number, a single digit is\n\t\t\t\t\t\t\t\/\/ preceded by a space (range ' 1' to '12')\n\t\t\t\tif(padChar == null){ padChar = \" \"; }\n\t\t\t\treturn _(dateObject.getMonth()+1);\t\t\t\t\n\t\t\tcase \"g\": \/\/ like %G, but without the century.\n\t\t\t\tbreak;\n\t\t\tcase \"G\": \/\/ The 4-digit year corresponding to the ISO week number\n\t\t\t\t      \/\/ (see %V).  This has the same format and value as %Y,\n\t\t\t\t      \/\/ except that if the ISO week number belongs to the\n\t\t\t\t      \/\/ previous or next year, that year is used instead.\n\t\t\t\tdojo.unimplemented(\"unimplemented modifier 'G'\");\n\t\t\t\tbreak;\n\t\t\tcase \"F\": \/\/ same as %Y-%m-%d\n\t\t\t\treturn $(\"Y\") + \"-\" + $(\"m\") + \"-\" + $(\"d\");\n\t\t\tcase \"H\": \/\/ hour as a decimal number using a 24-hour clock (range\n\t\t\t\t      \/\/ 00 to 23)\n\t\t\t\treturn _(dateObject.getHours());\n\t\t\tcase \"I\": \/\/ hour as a decimal number using a 12-hour clock (range\n\t\t\t\t      \/\/ 01 to 12)\n\t\t\t\treturn _(dateObject.getHours() % 12 || 12);\n\t\t\tcase \"j\": \/\/ day of the year as a decimal number (range 001 to 366)\n\t\t\t\treturn _(dojo.date.getDayOfYear(dateObject), 3);\n\t\t\tcase \"k\": \/\/ Hour as a decimal number using a 24-hour clock (range\n\t\t\t\t\t  \/\/ 0 to 23 (space-padded))\n\t\t\t\tif (padChar == null) { padChar = \" \"; }\n\t\t\t\treturn _(dateObject.getHours());\n\t\t\tcase \"l\": \/\/ Hour as a decimal number using a 12-hour clock (range\n\t\t\t\t\t  \/\/ 1 to 12 (space-padded))\n\t\t\t\tif (padChar == null) { padChar = \" \"; }\n\t\t\t\treturn _(dateObject.getHours() % 12 || 12);\n\t\t\tcase \"m\": \/\/ month as a decimal number (range 01 to 12)\n\t\t\t\treturn _(dateObject.getMonth() + 1);\n\t\t\tcase \"M\": \/\/ minute as a decimal number\n\t\t\t\treturn _(dateObject.getMinutes());\n\t\t\tcase \"n\":\n\t\t\t\treturn \"\\n\";\n\t\t\tcase \"p\": \/\/ either `am' or `pm' according to the given time value,\n\t\t\t\t      \/\/ or the corresponding strings for the current locale\n\t\t\t\treturn info[dateObject.getHours() < 12 ? \"am\" : \"pm\"];\n\t\t\tcase \"r\": \/\/ time in a.m. and p.m. notation\n\t\t\t\treturn $(\"I\") + \":\" + $(\"M\") + \":\" + $(\"S\") + \" \" + $(\"p\");\n\t\t\tcase \"R\": \/\/ time in 24 hour notation\n\t\t\t\treturn $(\"H\") + \":\" + $(\"M\");\n\t\t\tcase \"S\": \/\/ second as a decimal number\n\t\t\t\treturn _(dateObject.getSeconds());\n\t\t\tcase \"t\":\n\t\t\t\treturn \"\\t\";\n\t\t\tcase \"T\": \/\/ current time, equal to %H:%M:%S\n\t\t\t\treturn $(\"H\") + \":\" + $(\"M\") + \":\" + $(\"S\");\n\t\t\tcase \"u\": \/\/ weekday as a decimal number [1,7], with 1 representing\n\t\t\t\t      \/\/ Monday\n\t\t\t\treturn String(dateObject.getDay() || 7);\n\t\t\tcase \"U\": \/\/ week number of the current year as a decimal number,\n\t\t\t\t      \/\/ starting with the first Sunday as the first day of the\n\t\t\t\t      \/\/ first week\n\t\t\t\treturn _(dojo.date.getWeekOfYear(dateObject));\n\t\t\tcase \"V\": \/\/ week number of the year (Monday as the first day of the\n\t\t\t\t      \/\/ week) as a decimal number [01,53]. If the week containing\n\t\t\t\t      \/\/ 1 January has four or more days in the new year, then it \n\t\t\t\t      \/\/ is considered week 1. Otherwise, it is the last week of \n\t\t\t\t      \/\/ the previous year, and the next week is week 1.\n\t\t\t\treturn _(dojo.date.getIsoWeekOfYear(dateObject));\n\t\t\tcase \"W\": \/\/ week number of the current year as a decimal number,\n\t\t\t\t      \/\/ starting with the first Monday as the first day of the\n\t\t\t\t      \/\/ first week\n\t\t\t\treturn _(dojo.date.getWeekOfYear(dateObject, 1));\n\t\t\tcase \"w\": \/\/ day of the week as a decimal, Sunday being 0\n\t\t\t\treturn String(dateObject.getDay());\n\t\t\tcase \"x\": \/\/ preferred date representation for the current locale\n\t\t\t\t      \/\/ without the time\n\t\t\t\treturn dojo.date.format(dateObject, {selector:'dateOnly', locale:locale});\n\t\t\tcase \"X\": \/\/ preferred time representation for the current locale\n\t\t\t\t      \/\/ without the date\n\t\t\t\treturn dojo.date.format(dateObject, {selector:'timeOnly', locale:locale});\n\t\t\tcase \"y\": \/\/ year as a decimal number without a century (range 00 to\n\t\t\t\t      \/\/ 99)\n\t\t\t\treturn _(dateObject.getFullYear()%100);\n\t\t\tcase \"Y\": \/\/ year as a decimal number including the century\n\t\t\t\treturn String(dateObject.getFullYear());\n\t\t\tcase \"z\": \/\/ time zone or name or abbreviation\n\t\t\t\tvar timezoneOffset = dateObject.getTimezoneOffset();\n\t\t\t\treturn (timezoneOffset > 0 ? \"-\" : \"+\") + \n\t\t\t\t\t_(Math.floor(Math.abs(timezoneOffset)\/60)) + \":\" +\n\t\t\t\t\t_(Math.abs(timezoneOffset)%60);\n\t\t\tcase \"Z\": \/\/ time zone or name or abbreviation\n\t\t\t\treturn dojo.date.getTimezoneName(dateObject);\n\t\t\tcase \"%\":\n\t\t\t\treturn \"%\";\n\t\t}\n\t}\n\t\/\/ parse the formatting string and construct the resulting string\n\tvar string = \"\";\n\tvar i = 0;\n\tvar index = 0;\n\tvar switchCase = null;\n\twhile ((index = format.indexOf(\"%\", i)) != -1){\n\t\tstring += format.substring(i, index++);\n\t\t\/\/ inspect modifier flag\n\t\tswitch (format.charAt(index++)) {\n\t\t\tcase \"_\": \/\/ Pad a numeric result string with spaces.\n\t\t\t\tpadChar = \" \"; break;\n\t\t\tcase \"-\": \/\/ Do not pad a numeric result string.\n\t\t\t\tpadChar = \"\"; break;\n\t\t\tcase \"0\": \/\/ Pad a numeric result string with zeros.\n\t\t\t\tpadChar = \"0\"; break;\n\t\t\tcase \"^\": \/\/ Convert characters in result string to uppercase.\n\t\t\t\tswitchCase = \"upper\"; break;\n\t\t\tcase \"*\": \/\/ Convert characters in result string to lowercase\n\t\t\t\tswitchCase = \"lower\"; break;\n\t\t\tcase \"#\": \/\/ Swap the case of the result string.\n\t\t\t\tswitchCase = \"swap\"; break;\n\t\t\tdefault: \/\/ no modifier flag so decrement the index\n\t\t\t\tpadChar = null; index--; break;\n\t\t}\n\t\t\/\/ toggle case if a flag is set\n\t\tvar property = $(format.charAt(index++));\n\t\tswitch (switchCase){\n\t\t\tcase \"upper\":\n\t\t\t\tproperty = property.toUpperCase();\n\t\t\t\tbreak;\n\t\t\tcase \"lower\":\n\t\t\t\tproperty = property.toLowerCase();\n\t\t\t\tbreak;\n\t\t\tcase \"swap\": \/\/ Upper to lower, and versey-vicea\n\t\t\t\tvar compareString = property.toLowerCase();\n\t\t\t\tvar swapString = '';\n\t\t\t\tvar j = 0;\n\t\t\t\tvar ch = '';\n\t\t\t\twhile (j < property.length){\n\t\t\t\t\tch = property.charAt(j);\n\t\t\t\t\tswapString += (ch == compareString.charAt(j)) ?\n\t\t\t\t\t\tch.toUpperCase() : ch.toLowerCase();\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\tproperty = swapString;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\tswitchCase = null;\n\t\tstring += property;\n\t\ti = index;\n\t}\n\tstring += format.substring(i);\n\treturn string; \/\/ String","description":"see <http: \/\/ www.opengroup.org\/onlinepubs\/007908799\/xsh\/strftime.html>","returns":"String"}},"dojo.date.addCustomFormats":{"meta":{"summary":"Add a reference to a bundle containing localized custom formats to be used by date\/time formatting and parsing routines.","parameters":{"packageName":{"type":"String"},"bundleName":{"type":"String"}},"src":"\t_customFormats.push({pkg:packageName,name:bundleName});","description":"The user may add custom localized formats where the bundle has properties following the same naming convention used by dojo for the CLDR data: dateFormat-xxxx \/ timeFormat-xxxx The pattern string should match the format used by the CLDR. See dojo.date.format for details. The resources must be loaded by dojo.requireLocalization() prior to use"}},"dojo.date._getGregorianBundle":{"meta":{"summary":"","parameters":{"locale":{"type":"String"}},"src":" var gregorian = {};\n\tdojo.lang.forEach(_customFormats, function(desc){\n\t\tvar bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);\n\t\tgregorian = dojo.lang.mixin(gregorian, bundle);\n\t}, this);\n\treturn gregorian; \/*Object*\/","returns":"Object"}},"dojo.date.getNames":{"meta":{"summary":"Used to get localized strings for day or month names.","parameters":{"item":{"type":"String"},"type":{"type":"String"},"use":{"type":"String?"},"locale":{"type":"String?"}},"src":"\tvar label;\n\tvar lookup = dojo.date._getGregorianBundle(locale);\n\tvar props = [item, use, type];\n\tif(use == 'standAlone'){\n\t\tlabel = lookup[props.join('-')];\n\t}\n\tprops[1] = 'format';\n\t\/\/ return by copy so changes won't be made accidentally to the in-memory model\n\treturn (label || lookup[props.join('-')]).concat(); \/*Array*\/","returns":"Array"},"extra":{"parameters":{"item":{"type":"months","summary":"|| 'days'"},"type":{"type":"wide","summary":"|| 'narrow' || 'abbr' (e.g. \"Monday\", \"Mon\", or \"M\" respectively, in English)"},"use":{"type":"standAlone","summary":"|| 'format' (default)"},"locale":{"type":"override","summary":"locale used to find the names"}}}},"dojo.date.getDayName":{"meta":{"summary":"gets the full localized day of the week corresponding to the date object","parameters":{"dateObject":{"type":"Date"},"locale":{"type":"String?"}},"src":" return dojo.date.getNames('days', 'wide', 'format', locale)[dateObject.getDay()]; \/*String*\/","returns":"String"}},"dojo.date.getDayShortName":{"meta":{"summary":"gets the abbreviated localized day of the week corresponding to the date object","parameters":{"dateObject":{"type":"Date"},"locale":{"type":"String?"}},"src":" return dojo.date.getNames('days', 'abbr', 'format', locale)[dateObject.getDay()]; \/*String*\/","returns":"String"}},"dojo.date.getMonthName":{"meta":{"summary":"gets the full localized month name corresponding to the date object","parameters":{"dateObject":{"type":"Date"},"locale":{"type":"String?"}},"src":" return dojo.date.getNames('months', 'wide', 'format', locale)[dateObject.getMonth()]; \/*String*\/","returns":"String"}},"dojo.date.getMonthShortName":{"meta":{"summary":"gets the abbreviated localized month name corresponding to the date object","parameters":{"dateObject":{"type":"Date"},"locale":{"type":"String?"}},"src":" return dojo.date.getNames('months', 'abbr', 'format', locale)[dateObject.getMonth()]; \/*String*\/","returns":"String"}},"dojo.date.toRelativeString":{"meta":{"summary":"Returns an description in English of the date relative to the current date. Note: this is not localized yet. English only.","parameters":{"dateObject":{"type":"Date"}},"src":"\tvar now = new Date();\n\tvar diff = (now - dateObject) \/ 1000;\n\tvar end = \" ago\";\n\tvar future = false;\n\tif(diff < 0){\n\t\tfuture = true;\n\t\tend = \" from now\";\n\t\tdiff = -diff;\n\t}\n\tif(diff < 60){\n\t\tdiff = Math.round(diff);\n\t\treturn diff + \" second\" + (diff == 1 ? \"\" : \"s\") + end;\n\t}\n\tif(diff < 60*60){\n\t\tdiff = Math.round(diff\/60);\n\t\treturn diff + \" minute\" + (diff == 1 ? \"\" : \"s\") + end;\n\t}\n\tif(diff < 60*60*24){\n\t\tdiff = Math.round(diff\/3600);\n\t\treturn diff + \" hour\" + (diff == 1 ? \"\" : \"s\") + end;\n\t}\n\tif(diff < 60*60*24*7){\n\t\tdiff = Math.round(diff\/(3600*24));\n\t\tif(diff == 1){\n\t\t\treturn future ? \"Tomorrow\" : \"Yesterday\";\n\t\t}else{\n\t\t\treturn diff + \" days\" + end;\n\t\t}\n\t}\n\treturn dojo.date.format(dateObject); \/\/ String","description":"Example returns: - \"1 minute ago\" - \"4 minutes ago\" - \"Yesterday\" - \"2 days ago\"","returns":"String"}},"dojo.date.toSql":{"meta":{"summary":"Convert a Date to a SQL string","parameters":{"dateObject":{"type":"Date"},"noTime":{"type":"Boolean?"}},"src":"\treturn dojo.date.strftime(dateObject, \"%F\" + !noTime ? \" %T\" : \"\"); \/\/ String","returns":"String"},"extra":{"parameters":{"noTime":{"type":"whether","summary":"to ignore the time portion of the Date. Defaults to false."}}}},"dojo.date.fromSql":{"meta":{"summary":"Convert a SQL date string to a JavaScript Date object","parameters":{"sqlDate":{"type":"String"}},"src":"\tvar parts = sqlDate.split(\/[\\- :]\/g);\n\twhile(parts.length < 6){\n\t\tparts.push(0);\n\t}\n\treturn new Date(parts[0], (parseInt(parts[1],10)-1), parts[2], parts[3], parts[4], parts[5]); \/\/ Date","returns":"Date"}}}}},"dojo.date.serialize":{"meta":{"requires":{"common":["dojo.string.common"]},"functions":{"dojo.date.setIso8601":{"meta":{"summary":"sets a Date object based on an ISO 8601 formatted string (uses date and time)","parameters":{"dateObject":{"type":"Date"},"formattedString":{"type":"String"}},"src":" var comps = (formattedString.indexOf(\"T\") == -1) ? formattedString.split(\" \") : formattedString.split(\"T\");\n\tdateObject = dojo.date.setIso8601Date(dateObject, comps[0]);\n\tif(comps.length == 2){ dateObject = dojo.date.setIso8601Time(dateObject, comps[1]); }\n\treturn dateObject; \/* Date or null *\/","returns":"Date or null"}},"dojo.date.fromIso8601":{"meta":{"summary":"returns a Date object based on an ISO 8601 formatted string (uses date and time)","parameters":{"formattedString":{"type":"String"}},"src":" return dojo.date.setIso8601(new Date(0, 0), formattedString);"}},"dojo.date.setIso8601Date":{"meta":{"summary":"sets a Date object based on an ISO 8601 formatted string (date only)","parameters":{"dateObject":{"type":"String"},"formattedString":{"type":"String"}},"src":" var regexp = \"^([0-9]{4})((-?([0-9]{2})(-?([0-9]{2}))?)|\" +\n\t\t\t\"(-?([0-9]{3}))|(-?W([0-9]{2})(-?([1-7]))?))?$\";\n\tvar d = formattedString.match(new RegExp(regexp));\n\tif(!d){\n\t\tdojo.debug(\"invalid date string: \" + formattedString);\n\t\treturn null; \/\/ null\n\t}\n\tvar year = d[1];\n\tvar month = d[4];\n\tvar date = d[6];\n\tvar dayofyear = d[8];\n\tvar week = d[10];\n\tvar dayofweek = d[12] ? d[12] : 1;\n\tdateObject.setFullYear(year);\n\tif(dayofyear){\n\t\tdateObject.setMonth(0);\n\t\tdateObject.setDate(Number(dayofyear));\n\t}\n\telse if(week){\n\t\tdateObject.setMonth(0);\n\t\tdateObject.setDate(1);\n\t\tvar gd = dateObject.getDay();\n\t\tvar day =  gd ? gd : 7;\n\t\tvar offset = Number(dayofweek) + (7 * Number(week));\n\t\tif(day <= 4){ dateObject.setDate(offset + 1 - day); }\n\t\telse{ dateObject.setDate(offset + 8 - day); }\n\t} else{\n\t\tif(month){\n\t\t\tdateObject.setDate(1);\n\t\t\tdateObject.setMonth(month - 1); \n\t\t}\n\t\tif(date){ dateObject.setDate(date); }\n\t}\n\treturn dateObject; \/\/ Date","returns":"mixed"}},"dojo.date.fromIso8601Date":{"meta":{"summary":"returns a Date object based on an ISO 8601 formatted string (date only)","parameters":{"formattedString":{"type":"String"}},"src":" return dojo.date.setIso8601Date(new Date(0, 0), formattedString);"}},"dojo.date.setIso8601Time":{"meta":{"summary":"sets a Date object based on an ISO 8601 formatted string (time only)","parameters":{"dateObject":{"type":"Date"},"formattedString":{"type":"String"}},"src":"\t\/\/ first strip timezone info from the end\n\tvar timezone = \"Z|(([-+])([0-9]{2})(:?([0-9]{2}))?)$\";\n\tvar d = formattedString.match(new RegExp(timezone));\n\tvar offset = 0; \/\/ local time if no tz info\n\tif(d){\n\t\tif(d[0] != 'Z'){\n\t\t\toffset = (Number(d[3]) * 60) + Number(d[5]);\n\t\t\toffset *= ((d[2] == '-') ? 1 : -1);\n\t\t}\n\t\toffset -= dateObject.getTimezoneOffset();\n\t\tformattedString = formattedString.substr(0, formattedString.length - d[0].length);\n\t}\n\t\/\/ then work out the time\n\tvar regexp = \"^([0-9]{2})(:?([0-9]{2})(:?([0-9]{2})(\\.([0-9]+))?)?)?$\";\n\td = formattedString.match(new RegExp(regexp));\n\tif(!d){\n\t\tdojo.debug(\"invalid time string: \" + formattedString);\n\t\treturn null; \/\/ null\n\t}\n\tvar hours = d[1];\n\tvar mins = Number((d[3]) ? d[3] : 0);\n\tvar secs = (d[5]) ? d[5] : 0;\n\tvar ms = d[7] ? (Number(\"0.\" + d[7]) * 1000) : 0;\n\tdateObject.setHours(hours);\n\tdateObject.setMinutes(mins);\n\tdateObject.setSeconds(secs);\n\tdateObject.setMilliseconds(ms);\n\tif(offset !== 0){\n\t\tdateObject.setTime(dateObject.getTime() + offset * 60000);\n\t}\t\n\treturn dateObject; \/\/ Date","returns":"mixed"}},"dojo.date.fromIso8601Time":{"meta":{"summary":"returns a Date object based on an ISO 8601 formatted string (date only)","parameters":{"formattedString":{"type":"String"}},"src":" return dojo.date.setIso8601Time(new Date(0, 0), formattedString);"}},"dojo.date.toRfc3339":{"meta":{"summary":"Format a JavaScript Date object as a string according to RFC 3339","parameters":{"dateObject":{"type":"Date?"},"selector":{"type":"String?"}},"src":"\/\/FIXME: tolerate Number, string input?\n\tif(!dateObject){\n\t\tdateObject = new Date();\n\t}\n\tvar _ = dojo.string.pad;\n\tvar formattedDate = [];\n\tif(selector != \"timeOnly\"){\n\t\tvar date = [_(dateObject.getFullYear(),4), _(dateObject.getMonth()+1,2), _(dateObject.getDate(),2)].join('-');\n\t\tformattedDate.push(date);\n\t}\n\tif(selector != \"dateOnly\"){\n\t\tvar time = [_(dateObject.getHours(),2), _(dateObject.getMinutes(),2), _(dateObject.getSeconds(),2)].join(':');\n\t\tvar timezoneOffset = dateObject.getTimezoneOffset();\n\t\ttime += (timezoneOffset > 0 ? \"-\" : \"+\") + \n\t\t\t\t\t_(Math.floor(Math.abs(timezoneOffset)\/60),2) + \":\" +\n\t\t\t\t\t_(Math.abs(timezoneOffset)%60,2);\n\t\tformattedDate.push(time);\n\t}\n\treturn formattedDate.join('T'); \/\/ String","returns":"String"},"extra":{"parameters":{"dateObject":{"type":"A","summary":"JavaScript date, or the current date and time, by default"},"selector":{"type":"dateOnly","summary":"or \"timeOnly\" to format selected portions of the Date object. Date and time will be formatted by default."}}}},"dojo.date.fromRfc3339":{"meta":{"summary":"Create a JavaScript Date object from a string formatted according to RFC 3339","parameters":{"rfcDate":{"type":"String"}},"src":"\t\/\/ backwards compatible support for use of \"any\" instead of just not \n\t\/\/ including the time\n\tif(rfcDate.indexOf(\"Tany\")!=-1){\n\t\trfcDate = rfcDate.replace(\"Tany\",\"\");\n\t}\n\tvar dateObject = new Date();\n\treturn dojo.date.setIso8601(dateObject, rfcDate); \/\/ Date or null","returns":"Date or null"},"extra":{"parameters":{"rfcDate":{"type":"A","summary":"string such as 2005-06-30T08:05:00-07:00 \"any\" is also supported in place of a time."}}}}}}},"dojo.date.supplemental":{"meta":{"functions":{"dojo.date.getFirstDayOfWeek":{"meta":{"summary":"Returns a zero-based index for first day of the week","parameters":{"locale":{"type":"String?"}},"src":"\t\/\/ from http:\/\/www.unicode.org\/cldr\/data\/common\/supplemental\/supplementalData.xml:supplementalData\/weekData\/firstDay\n\tvar firstDay = {\/*default is 1=Monday*\/\n\t\tmv:5,\n\t\tae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,lb:6,ly:6,ma:6,om:6,qa:6,sa:6,\n\t\tsd:6,so:6,tn:6,ye:6,\n\t\tas:0,au:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,ie:0,il:0,is:0,jm:0,jp:0,kg:0,kr:0,la:0,\n\t\tmh:0,mo:0,mp:0,mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,vi:0,za:0,zw:0,\n\t\tet:0,mw:0,ng:0,tj:0,\n\t\tgb:0,\n\t\tsy:4\n\t};\n\tlocale = dojo.hostenv.normalizeLocale(locale);\n\tvar country = locale.split(\"-\")[1];\n\tvar dow = firstDay[country];\n\treturn (typeof dow == 'undefined') ? 1 : dow; \/*Number*\/","description":"Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar. e.g. Sunday (returns 0), or Monday (returns 1)","returns":"Number"}},"dojo.date.getWeekend":{"meta":{"summary":"Returns a hash containing the start and end days of the weekend","parameters":{"locale":{"type":"String?"}},"src":"\t\/\/ from http:\/\/www.unicode.org\/cldr\/data\/common\/supplemental\/supplementalData.xml:supplementalData\/weekData\/weekend{Start,End}\n\tvar weekendStart = {\/*default is 6=Saturday*\/\n\t\teg:5,il:5,sy:5,\n\t\t'in':0,\n\t\tae:4,bh:4,dz:4,iq:4,jo:4,kw:4,lb:4,ly:4,ma:4,om:4,qa:4,sa:4,sd:4,tn:4,ye:4\t\t\n\t};\n\tvar weekendEnd = {\/*default is 0=Sunday*\/\n\t\tae:5,bh:5,dz:5,iq:5,jo:5,kw:5,lb:5,ly:5,ma:5,om:5,qa:5,sa:5,sd:5,tn:5,ye:5,af:5,ir:5,\n\t\teg:6,il:6,sy:6\n\t};\n\tlocale = dojo.hostenv.normalizeLocale(locale);\n\tvar country = locale.split(\"-\")[1];\n\tvar start = weekendStart[country];\n\tvar end = weekendEnd[country];\n\tif(typeof start == 'undefined'){start=6;}\n\tif(typeof end == 'undefined'){end=0;}\n\treturn {start:start, end:end}; \/*Object {start,end}*\/","description":"Returns a hash containing the start and end days of the weekend according to local custom using locale, or by default in the user's locale. e.g. {start:6, end:0}","returns":"Object {start,end}"}},"dojo.date.isWeekend":{"meta":{"summary":"Determines if the date falls on a weekend, according to local custom.","parameters":{"dateObj":{"type":"Date?"},"locale":{"type":"String?"}},"src":"\tvar weekend = dojo.date.getWeekend(locale);\n\tvar day = (dateObj || new Date()).getDay();\n\tif(weekend.end<weekend.start){\n\t\tweekend.end+=7;\n\t\tif(day<weekend.start){ day+=7; }\n\t}\n\treturn day >= weekend.start && day <= weekend.end; \/\/ Boolean","returns":"Boolean"}}}}}}