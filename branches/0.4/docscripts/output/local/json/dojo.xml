{"dojo.xml.Parse":{"meta":{"requires":{"common":["dojo.dom"]},"functions":{"dojo.xml.Parse":{"meta":{"summary":"generic class for taking a DOM node and parsing it into an object based on the \"dojo tag name\" of that node. supported dojoTagName's: <prefix:tag> => prefix:tag <dojo:tag> => dojo:tag <dojoTag> => dojo:tag <tag dojoType=\"type\"> => dojo:type <tag dojoType=\"prefix:type\"> => prefix:type <tag dojo:type=\"type\"> => dojo:type <tag class=\"classa dojo-type classb\"> => dojo:type","src":"\tvar isIE = ((dojo.render.html.capable)&&(dojo.render.html.ie));\n\t\/\/ get normalized (lowercase) tagName\n\t\/\/ some browsers report tagNames in lowercase no matter what\n\tfunction getTagName(node){\n\t\t\/*\n\t\treturn ((node)&&(node[\"tagName\"]) ? node.tagName.toLowerCase() : '');\n\t\t*\/\n\t\ttry{\n\t\t\treturn node.tagName.toLowerCase();\n\t\t}catch(e){\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\/\/ locate dojo qualified tag name\n\tfunction getDojoTagName(node){\n\t\tvar tagName = getTagName(node);\n\t\tif (!tagName){\n\t\t\t\treturn '';\n\t\t}\n\t\t\/\/ any registered tag\n\t\tif((dojo.widget)&&(dojo.widget.tags[tagName])){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <prefix:tag> => prefix:tag\n\t\tvar p = tagName.indexOf(\":\");\n\t\tif(p>=0){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <dojo:tag> => dojo:tag\n\t\tif(tagName.substr(0,5) == \"dojo:\"){\n\t\t\treturn tagName;\n\t\t}\n\t\tif(dojo.render.html.capable && dojo.render.html.ie && node.scopeName != 'HTML'){\n\t\t\treturn node.scopeName.toLowerCase() + ':' + tagName;\n\t\t}\n\t\t\/\/ <dojoTag> => dojo:tag\n\t\tif(tagName.substr(0,4) == \"dojo\"){\n\t\t\t\/\/ FIXME: this assumes tag names are always lower case\n\t\t\treturn \"dojo:\" + tagName.substring(4);\n\t\t}\n\t\t\/\/ <tag dojoType=\"prefix:type\"> => prefix:type\n\t\t\/\/ <tag dojoType=\"type\"> => dojo:type\n\t\tvar djt = node.getAttribute(\"dojoType\") || node.getAttribute(\"dojotype\");\n\t\tif(djt){\n\t\t\tif (djt.indexOf(\":\")<0){\n\t\t\t\tdjt = \"dojo:\"+djt;\n\t\t\t}\n\t\t\treturn djt.toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\tdjt = node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,\"type\");\n\t\tif(djt){\n\t\t\treturn \"dojo:\" + djt.toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\ttry{\n\t\t\t\/\/ FIXME: IE really really doesn't like this, so we squelch errors for it\n\t\t\tdjt = node.getAttribute(\"dojo:type\");\n\t\t}catch(e){ \n\t\t\t\/\/ FIXME: log?  \n\t\t}\n\t\tif(djt){ return \"dojo:\"+djt.toLowerCase(); }\n\t\t\/\/ <tag class=\"classa dojo-type classb\"> => dojo:type\t\n\t\tif((dj_global[\"djConfig\"])&&(!djConfig[\"ignoreClassNames\"])){ \n\t\t\t\/\/ FIXME: should we make this optionally enabled via djConfig?\n\t\t\tvar classes = node.className||node.getAttribute(\"class\");\n\t\t\t\/\/ FIXME: following line, without check for existence of classes.indexOf\n\t\t\t\/\/ breaks firefox 1.5's svg widgets\n\t\t\tif((classes )&&(classes.indexOf)&&(classes.indexOf(\"dojo-\")!=-1)){\n\t\t\t\tvar aclasses = classes.split(\" \");\n\t\t\t\tfor(var x=0, c=aclasses.length; x<c; x++){\n\t\t\t\t\tif(aclasses[x].slice(0, 5) == \"dojo-\"){\n\t\t\t\t\t\treturn \"dojo:\"+aclasses[x].substr(5).toLowerCase(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ no dojo-qualified name\n\t\treturn '';\n\t}\n\tthis.parseElement = function(\t\/*DomNode*\/node,\n\t\t\t\t\t\t\t\t\t\/*Boolean*\/hasParentNodeSet, \n\t\t\t\t\t\t\t\t\t\/*Boolean*\/optimizeForDojoML, \n\t\t\t\t\t\t\t\t\t\/*Integer*\/thisIdx\t){\n\t\t\/\/ summary:\n\t\t\/\/\t\trecursively parse the passed node, returning a normalized data\n\t\t\/\/\t\tstructure that represents the \"attributes of interest\" of said\n\t\t\/\/\t\telements. If optimizeForDojoML is true, only nodes that contain\n\t\t\/\/\t\ta \"dojo tag name\" will be inspected for attributes.\n\t\t\/\/ node: the DomNode to be treated as the root of inspection\n\t\t\/\/ hasParentNodeSet: no-op, please pass \"null\"\n\t\t\/\/ optimizeForDojoML: should we ignore non-Dojo nodes? Defaults to false.\n\t\t\/\/ thisIdx:\n\t\t\/\/\t\ta way to specify a synthetic \"index\" property in the resulting\n\t\t\/\/\t\tdata structure. Otherwise the index property of the top-level\n\t\t\/\/\t\treturn element is always \"0\".\n\t\t\/\/ TODOC: document return structure of a non-trivial element set\n\t\t\/\/ run shortcuts to bail out of processing up front to save time and\n\t\t\/\/ object alloc if possible.\n\t\tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(isIE && tagName.indexOf(\"\/\")==0){ return null; }\n\t\ttry{\n\t\t\tvar attr = node.getAttribute(\"parseWidgets\");\n\t\t\tif(attr && attr.toLowerCase() == \"false\"){\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}catch(e){\/*continue*\/}\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\t\tvar parsedNodeSet = {};\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"ns\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo.ns)&&(!dojo.ns.allow(ns))){process=false;}\n\t\t}\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t}\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;\n\t};\n\t\/* parses a set of attributes on a node into an object tree *\/\n\tthis.parseAttributes = function(\/*DomNode*\/node){\n\t\t\/\/ summary:\n\t\t\/\/ \t\tcreates an attribute object that maps attribute values for the\n\t\t\/\/ \t\tpassed node. Note that this is similar to creating a JSON\n\t\t\/\/ \t\trepresentation of a DOM node.\n\t\t\/\/ usage:\n\t\t\/\/\t\ta node with the following serialization:\n\t\t\/\/\t\t\t<div foo=\"bar\" baz=\"thud\">...<\/div>\t\n\t\t\/\/\t\twould yeild the following return structure when passed into this\n\t\t\/\/\t\tfunction:\n\t\t\/\/\t\t\t{\n\t\t\/\/\t\t\t\t\"foo\": {\n\t\t\/\/\t\t\t\t\t\"value\": \"bar\"\n\t\t\/\/\t\t\t\t},\n\t\t\/\/\t\t\t\t\"baz\": {\n\t\t\/\/\t\t\t\t\t\"value\": \"thud\"\n\t\t\/\/\t\t\t\t}\n\t\t\/\/\t\t\t}\n\t\t\/\/\n\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif(isIE){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif((typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;\n\t};","instance_variables":["parseElement","parseAttributes"]}},"dojo.xml.Parse.parseElement":{"meta":{"summary":"recursively parse the passed node, returning a normalized data structure that represents the \"attributes of interest\" of said elements. If optimizeForDojoML is true, only nodes that contain a \"dojo tag name\" will be inspected for attributes.","parameters":{"node":{"type":"DomNode"},"hasParentNodeSet":{"type":"Boolean"},"optimizeForDojoML":{"type":"Boolean"},"thisIdx":{"type":"Integer"}},"src":"\t\t\/\/ TODOC: document return structure of a non-trivial element set\n\t\t\/\/ run shortcuts to bail out of processing up front to save time and\n\t\t\/\/ object alloc if possible.\n\t\tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(isIE && tagName.indexOf(\"\/\")==0){ return null; }\n\t\ttry{\n\t\t\tvar attr = node.getAttribute(\"parseWidgets\");\n\t\t\tif(attr && attr.toLowerCase() == \"false\"){\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}catch(e){\/*continue*\/}\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\t\tvar parsedNodeSet = {};\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"ns\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo.ns)&&(!dojo.ns.allow(ns))){process=false;}\n\t\t}\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t}\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;","instance":"dojo.xml.Parse"},"extra":{"parameters":{"node":{"type":"the","summary":"DomNode to be treated as the root of inspection"},"hasParentNodeSet":{"type":"no-op","summary":"please pass \"null\""},"optimizeForDojoML":{"type":"should","summary":"we ignore non-Dojo nodes? Defaults to false."},"thisIdx":{"type":"a","summary":"way to specify a synthetic \"index\" property in the resulting data structure. Otherwise the index property of the top-level return element is always \"0\"."}}}},"dojo.xml.Parse.parseAttributes":{"meta":{"summary":"creates an attribute object that maps attribute values for the passed node. Note that this is similar to creating a JSON representation of a DOM node. usage: a node with the following serialization: <div foo=\"bar\" baz=\"thud\">...<\/div> would yeild the following return structure when passed into this function: { \"foo\": { \"value\": \"bar\" }, \"baz\": { \"value\": \"thud\" } }","parameters":{"node":{"type":"DomNode"}},"src":" \tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif(isIE){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif((typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;","instance":"dojo.xml.Parse"}}}}},"dojo.xml.XslTransform":{"meta":{"functions":{"dojo.xml.XslTransform":{"meta":{"summary":"dojo.xml.XslTransform is a convenience object that takes the URI String of an XSL file as a constructor argument. After each transformation all parameters will be cleared. Transformation is supported by IE, Mozilla, and partially by Opera. Other browsers (notably Safari) have not yet exposed their transformation primtives well enough to be useful.","parameters":{"xsltUri":{"type":"String"}},"src":" dojo.debug(\"XslTransform is supported by Internet Explorer and Mozilla, with limited support in Opera 9 (no document function support).\");\r\n\tvar IS_IE = dojo.render.html.ie;\r\n\tvar ACTIVEX_DOMS = [\r\n\t\t\"Msxml2.DOMDocument.5.0\", \r\n\t\t\"Msxml2.DOMDocument.4.0\", \r\n\t\t\"Msxml2.DOMDocument.3.0\", \r\n\t\t\"MSXML2.DOMDocument\", \r\n\t\t\"MSXML.DOMDocument\", \r\n\t\t\"Microsoft.XMLDOM\"\r\n\t];\r\n\tvar ACTIVEX_FT_DOMS = [\r\n\t\t\"Msxml2.FreeThreadedDOMDocument.5.0\", \r\n\t\t\"MSXML2.FreeThreadedDOMDocument.4.0\", \r\n\t\t\"MSXML2.FreeThreadedDOMDocument.3.0\"\r\n\t];\r\n\tvar ACTIVEX_TEMPLATES = [\r\n\t\t\"Msxml2.XSLTemplate.5.0\", \r\n\t\t\"Msxml2.XSLTemplate.4.0\", \r\n\t\t\"MSXML2.XSLTemplate.3.0\"\r\n\t];\r\n\tfunction getActiveXImpl(activeXArray){\r\n\t\tfor(var i=0; i < activeXArray.length; i++){\r\n\t\t\ttry{\r\n\t\t\t\tvar testObj = new ActiveXObject(activeXArray[i]);\r\n\t\t\t\tif(testObj){\r\n\t\t\t\t\treturn activeXArray[i];\r\n\t\t\t\t}\r\n\t\t\t}catch(e){}\r\n\t\t}\r\n\t\tdojo.raise(\"Could not find an ActiveX implementation in:\\n\\n \" + activeXArray);\r\n\t}\r\n    if(xsltUri == null || xsltUri == undefined){\r\n        dojo.raise(\"You must pass the URI String for the XSL file to be used!\");\r\n        return false;\r\n    }\r\n\tvar xsltDocument = null;\r\n\tvar xsltProcessor = null;\r\n\tif(IS_IE){\r\n\t\txsltDocument = new ActiveXObject(getActiveXImpl(ACTIVEX_FT_DOMS));\r\n\t\txsltDocument.async = false;\r\n\t}else{\r\n\t\txsltProcessor = new XSLTProcessor();\r\n\t\txsltDocument = document.implementation.createDocument(\"\", \"\", null);\r\n\t\txsltDocument.addEventListener(\"load\", onXslLoad, false);\r\n\t}\r\n\txsltDocument.load(xsltUri);\r\n\tif(IS_IE){\r\n\t\tvar xslt = new ActiveXObject(getActiveXImpl(ACTIVEX_TEMPLATES));\r\n\t\txslt.stylesheet = xsltDocument;  \r\n\t\txsltProcessor = xslt.createProcessor();\r\n\t}\r\n\tfunction onXslLoad(){\r\n\t\txsltProcessor.importStylesheet(xsltDocument); \r\n\t}\r\n\tfunction getResultDom(xmlDoc, params){\r\n\t\tif(IS_IE){\r\n\t\t\taddIeParams(params);\r\n\t\t\tvar result = getIeResultDom(xmlDoc);\r\n\t\t\tremoveIeParams(params);   \r\n\t\t\treturn result;\r\n\t\t}else{\r\n\t\t\treturn getMozillaResultDom(xmlDoc, params);\r\n\t\t}\r\n\t}\r\n\tfunction addIeParams(params){\r\n\t\tif(!params){ return; }\r\n\t\tfor(var i=0; i<params.length; i++){\r\n\t\t\txsltProcessor.addParameter(params[i][0], params[i][1]);\r\n\t\t}\r\n\t}\r\n    function removeIeParams(params){\r\n\t\tif(!params){ return; }\r\n\t\tfor(var i=0; i<params.length; i++){\r\n\t\t\txsltProcessor.addParameter(params[i][0], \"\");\r\n\t\t}\r\n    }\r\n\tfunction getIeResultDom(xmlDoc){\r\n\t\txsltProcessor.input = xmlDoc;\r\n\t\tvar outDoc = new ActiveXObject(getActiveXImpl(ACTIVEX_DOMS));\r\n\t\toutDoc.async = false;  \r\n\t\toutDoc.validateOnParse = false;\r\n\t\txsltProcessor.output = outDoc;\r\n\t\txsltProcessor.transform();\r\n\t\tif(outDoc.parseError.errorCode != 0){\r\n\t\t\tvar err = outDoc.parseError;\r\n\t\t\tdojo.raise(\"err.errorCode: \" + err.errorCode + \"\\n\\nerr.reason: \" + err.reason + \"\\n\\nerr.url: \" + err.url + \"\\n\\nerr.srcText: \" + err.srcText);\r\n\t\t}\r\n\t\treturn outDoc;\r\n\t}\r\n\tfunction getIeResultStr(xmlDoc, params){\r\n\t\txsltProcessor.input = xmlDoc;\r\n\t\txsltProcessor.transform();    \r\n\t\treturn xsltProcessor.output;\r\n\t}\r\n\tfunction addMozillaParams(params){\r\n\t\tif(!params){ return; }\r\n\t\tfor(var i=0; i<params.length; i++){\r\n\t\t\txsltProcessor.setParameter(null, params[i][0], params[i][1]);\r\n\t\t}\r\n\t}\r\n\tfunction getMozillaResultDom(xmlDoc, params){\r\n\t\taddMozillaParams(params);\r\n\t\tvar resultDoc = xsltProcessor.transformToDocument(xmlDoc);\r\n\t\txsltProcessor.clearParameters();\r\n\t\treturn resultDoc;\r\n\t}\r\n\tfunction getMozillaResultStr(xmlDoc, params, parentDoc){\r\n\t\taddMozillaParams(params);\r\n\t\tvar resultDoc = xsltProcessor.transformToFragment(xmlDoc, parentDoc);\r\n\t\tvar serializer = new XMLSerializer();\r\n\t\txsltProcessor.clearParameters();\r\n\t\treturn serializer.serializeToString(resultDoc);\r\n\t}\r\n\tthis.getResultString = function(\t\/*XMLDocument*\/xmlDoc, \r\n\t\t\t\t\t\t\t\t\t\t\/*2 Dimensional Array*\/params, \r\n\t\t\t\t\t\t\t\t\t\t\/*HTMLDocument*\/parentDoc){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\ttransform the xmlDoc and return the result as a string.\r\n\t\t\/\/ xmlDoc: an XML Document to transform\r\n\t\t\/\/ params:\r\n\t\t\/\/\t\ta set of configuration parameters to pass to the transformation\r\n\t\t\/\/\t\tengine.\r\n\t\t\/\/ parentDoc: The HTML docuemnt to transform the subdocument \"under\"\r\n\t\tvar content = null;\r\n\t\tif(IS_IE){\r\n\t\t\taddIeParams(params);\r\n\t\t\tcontent = getIeResultStr(xmlDoc, params);\r\n\t\t\tremoveIeParams(params);  \r\n\t\t}else{\r\n\t\t\tcontent = getMozillaResultStr(xmlDoc, params, parentDoc);\r\n\t\t} \r\n\t\t\/\/dojo.debug(content);\r\n\t\treturn content;\r\n\t};\r\n\tthis.transformToContentPane = function(\t\/*XMLDocument*\/xmlDoc,\r\n\t\t\t\t\t\t\t\t\t\t\t\/*2 Dimensional Array*\/params, \r\n\t\t\t\t\t\t\t\t\t\t\t\/*ContentPane*\/contentPane, \r\n\t\t\t\t\t\t\t\t\t\t\t\/*HTMLDocument*\/parentDoc){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\ttransform the xmlDoc and put the result into the passed\r\n\t\t\/\/\t\tContentPane instance\r\n\t\t\/\/ xmlDoc: an XML Document to transform\r\n\t\t\/\/ params:\r\n\t\t\/\/\t\ta set of configuration parameters to pass to the transformation\r\n\t\t\/\/\t\tengine.\r\n\t\t\/\/ contentPane:\r\n\t\t\/\/\t\tinstance of dojo.widget.ContentPane to assign the transform\r\n\t\t\/\/\t\tresults to\r\n\t\t\/\/ parentDoc: The HTML docuemnt to transform the subdocument \"under\"\r\n\t\t\/\/ FIXME: do we need this function?\r\n\t\tvar content = this.getResultString(xmlDoc, params, parentDoc);\r\n\t\tcontentPane.setContent(content);\r\n\t};\r\n\tthis.transformToRegion = function(\t\/*XMLDocument*\/xmlDoc, \r\n\t\t\t\t\t\t\t\t\t\t\/*2 Dimensional Array*\/params, \r\n\t\t\t\t\t\t\t\t\t\t\/*HTMLElement*\/region, \r\n\t\t\t\t\t\t\t\t\t\t\/*HTMLDocument*\/parentDoc){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\ttransform the xmlDoc and put the result into the passed\r\n\t\t\/\/\t\tDomNode using innerHTML\r\n\t\t\/\/ xmlDoc: an XML Document to transform\r\n\t\t\/\/ params:\r\n\t\t\/\/\t\ta set of configuration parameters to pass to the transformation\r\n\t\t\/\/\t\tengine.\r\n\t\t\/\/ region: node to put transform results in\r\n\t\t\/\/ parentDoc: The HTML docuemnt to transform the subdocument \"under\"\r\n\t\ttry{\r\n\t\t\tvar content = this.getResultString(xmlDoc, params, parentDoc);\r\n\t\t\tregion.innerHTML = content;\r\n\t\t}catch (e){\r\n\t\t\tdojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n\t\t}\r\n\t};\r\n\tthis.transformToDocument = function(\t\/*XMLDocument*\/ xmlDoc, \r\n\t\t\t\t\t\t\t\t\t\t\t\/*2 Dimensional Array*\/params){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\ttransform the xmlDoc and return a new XML document containing\r\n\t\t\/\/\t\tthe result\r\n\t\t\/\/ xmlDoc: an XML Document to transform\r\n\t\t\/\/ params:\r\n\t\t\/\/\t\ta set of configuration parameters to pass to the transformation\r\n\t\t\/\/\t\tengine.\r\n\t\treturn getResultDom(xmlDoc, params); \/\/ XMLDocument\r\n\t}\r\n\tthis.transformToWindow = function(\t\/*XMLDocument*\/ xmlDoc,\r\n\t\t\t\t\t\t\t\t\t\t\/*2 Dimensional Array*\/params, \r\n\t\t\t\t\t\t\t\t\t\t\/*HTMLDocument*\/windowDoc, \r\n\t\t\t\t\t\t\t\t\t\t\/*HTMLDocument*\/parentDoc){\r\n\t\t\/\/ summary:\r\n\t\t\/\/\t\ttransform the xmlDoc and put the contents in the passed\r\n\t\t\/\/\t\twindowDoc, blowing away any previous contents.\r\n\t\t\/\/ xmlDoc: an XML Document to transform\r\n\t\t\/\/ params:\r\n\t\t\/\/\t\ta set of configuration parameters to pass to the transformation\r\n\t\t\/\/\t\tengine.\r\n\t\t\/\/ windowDoc: the HTMLDocument to assign the contents to\r\n\t\t\/\/ parentDoc: The HTML docuemnt to transform the subdocument \"under\"\r\n\t\ttry{\r\n\t\t\twindowDoc.open();\r\n\t\t\twindowDoc.write(this.getResultString(xmlDoc, params, parentDoc));\r\n\t\t\twindowDoc.close();\r\n\t\t}catch(e){\r\n\t\t\tdojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n\t\t}\r\n\t};\r","instance_variables":["getResultString","transformToContentPane","transformToRegion","transformToDocument","transformToWindow"],"returns":"XMLDocument"},"extra":{"parameters":{"xsltUri":{"type":"Url","summary":"of the xslt document to transform nodes with. Transformation is acheived with the transformTo* methods on instances of this class."}}}},"dojo.xml.XslTransform.getResultString":{"meta":{"summary":"transform the xmlDoc and return the result as a string.","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"parentDoc":{"type":"HTMLDocument"}},"src":" \tvar content = null;\r\n\t\tif(IS_IE){\r\n\t\t\taddIeParams(params);\r\n\t\t\tcontent = getIeResultStr(xmlDoc, params);\r\n\t\t\tremoveIeParams(params);  \r\n\t\t}else{\r\n\t\t\tcontent = getMozillaResultStr(xmlDoc, params, parentDoc);\r\n\t\t} \r\n\t\t\/\/dojo.debug(content);\r\n\t\treturn content;\r","instance":"dojo.xml.XslTransform"},"extra":{"parameters":{"xmlDoc":{"type":"an","summary":"XML Document to transform"},"params":{"type":"a","summary":"set of configuration parameters to pass to the transformation engine."},"parentDoc":{"type":"The","summary":"HTML docuemnt to transform the subdocument \"under\""}}}},"dojo.xml.XslTransform.transformToContentPane":{"meta":{"summary":"transform the xmlDoc and put the result into the passed ContentPane instance","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"contentPane":{"type":"ContentPane"},"parentDoc":{"type":"HTMLDocument"}},"src":" \tvar content = this.getResultString(xmlDoc, params, parentDoc);\r\n\t\tcontentPane.setContent(content);\r","instance":"dojo.xml.XslTransform"},"extra":{"parameters":{"xmlDoc":{"type":"an","summary":"XML Document to transform"},"params":{"type":"a","summary":"set of configuration parameters to pass to the transformation engine."},"contentPane":{"type":"instance","summary":"of dojo.widget.ContentPane to assign the transform results to"},"parentDoc":{"type":"The","summary":"HTML docuemnt to transform the subdocument \"under\" FIXME: do we need this function?"}}}},"dojo.xml.XslTransform.transformToRegion":{"meta":{"summary":"transform the xmlDoc and put the result into the passed DomNode using innerHTML","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"region":{"type":"HTMLElement"},"parentDoc":{"type":"HTMLDocument"}},"src":" \ttry{\r\n\t\t\tvar content = this.getResultString(xmlDoc, params, parentDoc);\r\n\t\t\tregion.innerHTML = content;\r\n\t\t}catch (e){\r\n\t\t\tdojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n\t\t}\r","instance":"dojo.xml.XslTransform"},"extra":{"parameters":{"xmlDoc":{"type":"an","summary":"XML Document to transform"},"params":{"type":"a","summary":"set of configuration parameters to pass to the transformation engine."},"region":{"type":"node","summary":"to put transform results in"},"parentDoc":{"type":"The","summary":"HTML docuemnt to transform the subdocument \"under\""}}}},"dojo.xml.XslTransform.transformToDocument":{"meta":{"summary":"transform the xmlDoc and return a new XML document containing the result","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"}},"src":" \treturn getResultDom(xmlDoc, params); \/\/ XMLDocument\r","returns":"XMLDocument","instance":"dojo.xml.XslTransform"},"extra":{"parameters":{"xmlDoc":{"type":"an","summary":"XML Document to transform"},"params":{"type":"a","summary":"set of configuration parameters to pass to the transformation engine."}}}},"dojo.xml.XslTransform.transformToWindow":{"meta":{"summary":"transform the xmlDoc and put the contents in the passed","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"windowDoc":{"type":"HTMLDocument"},"parentDoc":{"type":"HTMLDocument"}},"src":" \ttry{\r\n\t\t\twindowDoc.open();\r\n\t\t\twindowDoc.write(this.getResultString(xmlDoc, params, parentDoc));\r\n\t\t\twindowDoc.close();\r\n\t\t}catch(e){\r\n\t\t\tdojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n\t\t}\r","instance":"dojo.xml.XslTransform"},"extra":{"parameters":{"windowDoc":{"type":"the","summary":"HTMLDocument to assign the contents to"},"xmlDoc":{"type":"an","summary":"XML Document to transform"},"params":{"type":"a","summary":"set of configuration parameters to pass to the transformation engine."},"parentDoc":{"type":"The","summary":"HTML docuemnt to transform the subdocument \"under\""}}}}}}},"dojo.xml._":{"meta":{"requires":{"common":["dojo.dom","dojo.xml.Parse"],"browser":["dojo.html.*"],"dashboard":["dojo.html.*"]}}}}