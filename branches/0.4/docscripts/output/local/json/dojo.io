{"dojo.io.BrowserIO":{"meta":{"requires":{"common":["dojo.io.common","dojo.lang.array","dojo.lang.func","dojo.string.extras","dojo.dom","dojo.undo.browser"]},"functions":{"dojo.io.checkChildrenForFile":{"meta":{"summary":"Checks any child nodes of node for an input type=\"file\" element.","parameters":{"node":{"type":"DOMNode"}},"src":" var hasFile = false;\n\tvar inputs = node.getElementsByTagName(\"input\");\n\tdojo.lang.forEach(inputs, function(input){\n\t\tif(hasFile){ return; }\n\t\tif(input.getAttribute(\"type\")==\"file\"){\n\t\t\thasFile = true;\n\t\t}\n\t});\n\treturn hasFile; \/\/boolean","returns":"boolean"}},"dojo.io.formHasFile":{"meta":{"summary":"Just calls dojo.io.checkChildrenForFile().","parameters":{"formNode":{"type":"DOMNode"}},"src":" return dojo.io.checkChildrenForFile(formNode); \/\/boolean","returns":"boolean"}},"dojo.io.updateNode":{"meta":{"summary":"Updates a DOMnode with the result of a dojo.io.bind() call.","parameters":{"node":{"type":"DOMNode"},"urlOrArgs":{"type":"String or Object"}},"src":" node = dojo.byId(node);\n\tvar args = urlOrArgs;\n\tif(dojo.lang.isString(urlOrArgs)){\n\t\targs = { url: urlOrArgs };\n\t}\n\targs.mimetype = \"text\/html\";\n\targs.load = function(t, d, e){\n\t\twhile(node.firstChild){\n\t\t\tdojo.dom.destroyNode(node.firstChild);\n\t\t}\n\t\tnode.innerHTML = d;\n\t};\n\tdojo.io.bind(args);"},"extra":{"parameters":{"node":{"type":"DOMNode","summary":null},"urlOrArgs":{"type":"String","summary":"or Object Either a String that has an URL, or an object containing dojo.io.bind() arguments."}}}},"dojo.io.formFilter":{"meta":{"summary":"Returns true if the node is an input element that is enabled, has a name, and whose type is one of the following values: [\"file\", \"submit\", \"image\", \"reset\", \"button\"]","parameters":{"node":{"type":"DOMNode"}},"src":" var type = (node.type||\"\").toLowerCase();\n\treturn !node.disabled && node.name\n\t\t&& !dojo.lang.inArray([\"file\", \"submit\", \"image\", \"reset\", \"button\"], type); \/\/boolean"}},"dojo.io.encodeForm":{"meta":{"summary":"Converts the names and values of form elements into an URL-encoded string (name=value&name=value...).","parameters":{"formNode":{"type":"DOMNode"},"encoding":{"type":"String?"},"formFilter":{"type":"Function?"}},"src":" if((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == \"form\")){\n\t\tdojo.raise(\"Attempted to encode a non-form element.\");\n\t}\n\tif(!formFilter) { formFilter = dojo.io.formFilter; }\n\tvar enc = \/utf\/i.test(encoding||\"\") ? encodeURIComponent : dojo.string.encodeAscii;\n\tvar values = [];\n\tfor(var i = 0; i < formNode.elements.length; i++){\n\t\tvar elm = formNode.elements[i];\n\t\tif(!elm || elm.tagName.toLowerCase() == \"fieldset\" || !formFilter(elm)) { continue; }\n\t\tvar name = enc(elm.name);\n\t\tvar type = elm.type.toLowerCase();\n\t\tif(type == \"select-multiple\"){\n\t\t\tfor(var j = 0; j < elm.options.length; j++){\n\t\t\t\tif(elm.options[j].selected) {\n\t\t\t\t\tvalues.push(name + \"=\" + enc(elm.options[j].value));\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dojo.lang.inArray([\"radio\", \"checkbox\"], type)){\n\t\t\tif(elm.checked){\n\t\t\t\tvalues.push(name + \"=\" + enc(elm.value));\n\t\t\t}\n\t\t}else{\n\t\t\tvalues.push(name + \"=\" + enc(elm.value));\n\t\t}\n\t}\n\t\/\/ now collect input type=\"image\", which doesn't show up in the elements array\n\tvar inputs = formNode.getElementsByTagName(\"input\");\n\tfor(var i = 0; i < inputs.length; i++) {\n\t\tvar input = inputs[i];\n\t\tif(input.type.toLowerCase() == \"image\" && input.form == formNode\n\t\t\t&& formFilter(input)) {\n\t\t\tvar name = enc(input.name);\n\t\t\tvalues.push(name + \"=\" + enc(input.value));\n\t\t\tvalues.push(name + \".x=0\");\n\t\t\tvalues.push(name + \".y=0\");\n\t\t}\n\t}\n\treturn values.join(\"&\") + \"&\"; \/\/String","returns":"String"},"extra":{"parameters":{"formNode":{"type":"DOMNode","summary":null},"encoding":{"type":"String?","summary":"The encoding to use for the values. Specify a string that starts with \"utf\" (for instance, \"utf8\"), to use encodeURIComponent() as the encoding function. Otherwise, dojo.string.encodeAscii will be used."},"formFilter":{"type":"Function?","summary":"A function used to filter out form elements. The element node will be passed to the formFilter function, and a boolean result is expected (true indicating indicating that the element should have its name\/value included in the output). If no formFilter is specified, then dojo.io.formFilter() will be used."}}}},"dojo.io.FormBind":{"meta":{"summary":"constructor for a dojo.io.FormBind object. See the Dojo Book for some information on usage: http: \/\/ manual.dojotoolkit.org\/WikiHome\/DojoDotBook\/Book23","parameters":{"args":{"type":"DOMNode or Object"}},"src":" this.bindArgs = {};\n\tif(args && args.formNode) {\n\t\tthis.init(args);\n\t} else if(args) {\n\t\tthis.init({formNode: args});\n\t}","instance_variables":["bindArgs","form","clickedButton"],"prototype_variables":["form","bindArgs","clickedButton"]},"extra":{"parameters":{"args":{"type":"can","summary":"either be the DOMNode for a form element, or an object containing dojo.io.bind() arguments, one of which should be formNode with the value of a form element DOMNode."}}}},"dojo.io.XMLHTTPTransport":{"meta":{"initialized":true,"summary":"The object that implements the dojo.io.bind transport for XMLHttpRequest.","src":" var _this = this;\n\tvar _cache = {}; \/\/ FIXME: make this public? do we even need to?\n\tthis.useCache = false; \/\/ if this is true, we'll cache unless kwArgs.useCache = false\n\tthis.preventCache = false; \/\/ if this is true, we'll always force GET requests to cache\n\t\/\/ FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?\n\tfunction getCacheKey(url, query, method) {\n\t\treturn url + \"|\" + query + \"|\" + method.toLowerCase();\n\t}\n\tfunction addToCache(url, query, method, http) {\n\t\t_cache[getCacheKey(url, query, method)] = http;\n\t}\n\tfunction getFromCache(url, query, method) {\n\t\treturn _cache[getCacheKey(url, query, method)];\n\t}\n\tthis.clearCache = function() {\n\t\t_cache = {};\n\t}\n\t\/\/ moved successful load stuff here\n\tfunction doLoad(kwArgs, http, url, query, useCache) {\n\t\tif(\t((http.status>=200)&&(http.status<300))|| \t\/\/ allow any 2XX response code\n\t\t\t(http.status==304)|| \t\t\t\t\t\t\/\/ get it out of the cache\n\t\t\t(location.protocol==\"file:\" && (http.status==0 || http.status==undefined))||\n\t\t\t(location.protocol==\"chrome:\" && (http.status==0 || http.status==undefined))\n\t\t){\n\t\t\tvar ret;\n\t\t\tif(kwArgs.method.toLowerCase() == \"head\"){\n\t\t\t\tvar headers = http.getAllResponseHeaders();\n\t\t\t\tret = {};\n\t\t\t\tret.toString = function(){ return headers; }\n\t\t\t\tvar values = headers.split(\/[\\r\\n]+\/g);\n\t\t\t\tfor(var i = 0; i < values.length; i++) {\n\t\t\t\t\tvar pair = values[i].match(\/^([^:]+)\\s*:\\s*(.+)$\/i);\n\t\t\t\t\tif(pair) {\n\t\t\t\t\t\tret[pair[1]] = pair[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(kwArgs.mimetype == \"text\/javascript\"){\n\t\t\t\ttry{\n\t\t\t\t\tret = dj_eval(http.responseText);\n\t\t\t\t}catch(e){\n\t\t\t\t\tdojo.debug(e);\n\t\t\t\t\tdojo.debug(http.responseText);\n\t\t\t\t\tret = null;\n\t\t\t\t}\n\t\t\t}else if(kwArgs.mimetype == \"text\/json\" || kwArgs.mimetype == \"application\/json\"){\n\t\t\t\ttry{\n\t\t\t\t\tret = dj_eval(\"(\"+http.responseText+\")\");\n\t\t\t\t}catch(e){\n\t\t\t\t\tdojo.debug(e);\n\t\t\t\t\tdojo.debug(http.responseText);\n\t\t\t\t\tret = false;\n\t\t\t\t}\n\t\t\t}else if((kwArgs.mimetype == \"application\/xml\")||\n\t\t\t\t\t\t(kwArgs.mimetype == \"text\/xml\")){\n\t\t\t\tret = http.responseXML;\n\t\t\t\tif(!ret || typeof ret == \"string\" || !http.getResponseHeader(\"Content-Type\")) {\n\t\t\t\t\tret = dojo.dom.createDocumentFromText(http.responseText);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tret = http.responseText;\n\t\t\t}\n\t\t\tif(useCache){ \/\/ only cache successful responses\n\t\t\t\taddToCache(url, query, kwArgs.method, http);\n\t\t\t}\n\t\t\tkwArgs[(typeof kwArgs.load == \"function\") ? \"load\" : \"handle\"](\"load\", ret, http, kwArgs);\n\t\t}else{\n\t\t\tvar errObj = new dojo.io.Error(\"XMLHttpTransport Error: \"+http.status+\" \"+http.statusText);\n\t\t\tkwArgs[(typeof kwArgs.error == \"function\") ? \"error\" : \"handle\"](\"error\", errObj, http, kwArgs);\n\t\t}\n\t}\n\t\/\/ set headers (note: Content-Type will get overriden if kwArgs.contentType is set)\n\tfunction setHeaders(http, kwArgs){\n\t\tif(kwArgs[\"headers\"]) {\n\t\t\tfor(var header in kwArgs[\"headers\"]) {\n\t\t\t\tif(header.toLowerCase() == \"content-type\" && !kwArgs[\"contentType\"]) {\n\t\t\t\t\tkwArgs[\"contentType\"] = kwArgs[\"headers\"][header];\n\t\t\t\t} else {\n\t\t\t\t\thttp.setRequestHeader(header, kwArgs[\"headers\"][header]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.inFlight = [];\n\tthis.inFlightTimer = null;\n\tthis.startWatchingInFlight = function(){\n\t\t\/\/summary: internal method used to trigger a timer to watch all inflight\n\t\t\/\/XMLHttpRequests.\n\t\tif(!this.inFlightTimer){\n\t\t\t\/\/ setInterval broken in mozilla x86_64 in some circumstances, see\n\t\t\t\/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=344439\n\t\t\t\/\/ using setTimeout instead\n\t\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);\n\t\t}\n\t}\n\tthis.watchInFlight = function(){\n\t\t\/\/summary: internal method that checks each inflight XMLHttpRequest to see\n\t\t\/\/if it has completed or if the timeout situation applies.\n\t\tvar now = null;\n\t\t\/\/ make sure sync calls stay thread safe, if this callback is called during a sync call\n\t\t\/\/ and this results in another sync call before the first sync call ends the browser hangs\n\t\tif(!dojo.hostenv._blockAsync && !_this._blockAsync){\n\t\t\tfor(var x=this.inFlight.length-1; x>=0; x--){\n\t\t\t\ttry{\n\t\t\t\t\tvar tif = this.inFlight[x];\n\t\t\t\t\tif(!tif || tif.http._aborted || !tif.http.readyState){\n\t\t\t\t\t\tthis.inFlight.splice(x, 1); continue; \n\t\t\t\t\t}\n\t\t\t\t\tif(4==tif.http.readyState){\n\t\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\t\tdoLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);\n\t\t\t\t\t}else if (tif.startTime){\n\t\t\t\t\t\t\/\/See if this is a timeout case.\n\t\t\t\t\t\tif(!now){\n\t\t\t\t\t\t\tnow = (new Date()).getTime();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){\n\t\t\t\t\t\t\t\/\/Stop the request.\n\t\t\t\t\t\t\tif(typeof tif.http.abort == \"function\"){\n\t\t\t\t\t\t\t\ttif.http.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\t\t\ttif.req[(typeof tif.req.timeout == \"function\") ? \"timeout\" : \"handle\"](\"timeout\", null, tif.http, tif.req);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar errObj = new dojo.io.Error(\"XMLHttpTransport.watchInFlight Error: \" + e);\n\t\t\t\t\t\ttif.req[(typeof tif.req.error == \"function\") ? \"error\" : \"handle\"](\"error\", errObj, tif.http, tif.req);\n\t\t\t\t\t}catch(e2){\n\t\t\t\t\t\tdojo.debug(\"XMLHttpTransport error callback failed: \" + e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclearTimeout(this.inFlightTimer);\n\t\tif(this.inFlight.length == 0){\n\t\t\tthis.inFlightTimer = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);\n\t}\n\tvar hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;\n\tthis.canHandle = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: Tells dojo.io.bind() if this is a good transport to\n\t\t\/\/use for the particular type of request. This type of transport cannot\n\t\t\/\/handle forms that have an input type=\"file\" element.\n\t\t\/\/ FIXME: we need to determine when form values need to be\n\t\t\/\/ multi-part mime encoded and avoid using this transport for those\n\t\t\/\/ requests.\n\t\treturn hasXmlHttp\n\t\t\t&& dojo.lang.inArray([\"text\/plain\", \"text\/html\", \"application\/xml\", \"text\/xml\", \"text\/javascript\", \"text\/json\", \"application\/json\"], (kwArgs[\"mimetype\"].toLowerCase()||\"\"))\n\t\t\t&& !( kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]) ); \/\/boolean\n\t}\n\tthis.multipartBoundary = \"45309FFF-BD65-4d50-99C9-36986896A96F\";\t\/\/ unique guid as a boundary value for multipart posts\n\tthis.bind = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: function that sends the request to the server.\n\t\t\/\/This function will attach an abort() function to the kwArgs dojo.io.Request object,\n\t\t\/\/so if you need to abort the request, you can call that method on the request object.\n\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\/\/normal dojo.io.Request object properties).\n\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\/\/method: String: the HTTP method to use (GET, POST, etc...).\n\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Valid values are:\n\t\t\/\/\t\ttext\/javascript, text\/json, application\/json, application\/xml, text\/xml. Any other mimetype will give back a text\n\t\t\/\/\t\tstring.\n\t\t\/\/transport: String: specify \"XMLHTTPTransport\" to force the use of this XMLHttpRequest transport.\n\t\t\/\/headers: Object: The object property names and values will be sent as HTTP request header\n\t\t\/\/\t\tnames and values.\n\t\t\/\/sendTransport: boolean: If true, then dojo.transport=xmlhttp will be added to the request.\n\t\t\/\/encoding: String: The type of encoding to use when dealing with the content kwArgs property.\n\t\t\/\/content: Object: The content object is converted into a name=value&name=value string, by\n\t\t\/\/\t\tusing dojo.io.argsFromMap(). The encoding kwArgs property is passed to dojo.io.argsFromMap()\n\t\t\/\/\t\tfor use in encoding the names and values. The resulting string is added to the request.\n\t\t\/\/formNode: DOMNode: a form element node. This should not normally be used. Use new dojo.io.FormBind() instead.\n\t\t\/\/\t\tIf formNode is used, then the names and values of the form elements will be converted\n\t\t\/\/\t\tto a name=value&name=value string and added to the request. The encoding kwArgs property is used\n\t\t\/\/\t\tto encode the names and values.\n\t\t\/\/postContent: String: Raw name=value&name=value string to be included as part of the request.\n\t\t\/\/back or backButton: Function: A function to be called if the back button is pressed. If this kwArgs property\n\t\t\/\/\t\tis used, then back button support via dojo.undo.browser will be used. See notes for dojo.undo.browser on usage.\n\t\t\/\/\t\tYou need to set djConfig.preventBackButtonFix = false to enable back button support.\n\t\t\/\/changeUrl: boolean or String: Used as part of back button support. See notes for dojo.undo.browser on usage.\n\t\t\/\/user: String: The user name. Used in conjuction with password. Passed to XMLHttpRequest.open().\n\t\t\/\/password: String: The user's password. Used in conjuction with user. Passed to XMLHttpRequest.open().\n\t\t\/\/file: Object or Array of Objects: an object simulating a file to be uploaded. file objects should have the following properties:\n\t\t\/\/\t\tname or fileName: the name of the file\n\t\t\/\/\t\tcontentType: the MIME content type for the file.\n\t\t\/\/\t\tcontent: the actual content of the file.\n\t\t\/\/multipart: boolean: indicates whether this should be a multipart mime request. If kwArgs.file exists, then this\n\t\t\/\/\t\tproperty is set to true automatically.\n\t\t\/\/sync: boolean: if true, then a synchronous XMLHttpRequest call is done,\n\t\t\/\/\t\tif false (the default), then an asynchronous call is used.\n\t\t\/\/preventCache: boolean: If true, then a cache busting parameter is added to the request URL.\n\t\t\/\/\t\tdefault value is false.\n\t\t\/\/useCache: boolean: If true, then XMLHttpTransport will keep an internal cache of the server\n\t\t\/\/\t\tresponse and use that response if a similar request is done again.\n\t\t\/\/\t\tA similar request is one that has the same URL, query string and HTTP method value.\n\t\t\/\/\t\tdefault is false.\n\t\tif(!kwArgs[\"url\"]){\n\t\t\t\/\/ are we performing a history action?\n\t\t\tif( !kwArgs[\"formNode\"]\n\t\t\t\t&& (kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"] || kwArgs[\"watchForURL\"])\n\t\t\t\t&& (!djConfig.preventBackButtonFix)) {\n        dojo.deprecated(\"Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request\",\n        \t\t\t\t\"Use dojo.undo.browser.addToHistory() instead.\", \"0.4\");\n\t\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\/\/ build this first for cache purposes\n\t\tvar url = kwArgs.url;\n\t\tvar query = \"\";\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\t\tif(kwArgs[\"file\"]){\n\t\t\t\/\/ force post for file transfer\n\t\t\tkwArgs.method = \"post\";\n\t\t}\n\t\tif(!kwArgs[\"method\"]){\n\t\t\tkwArgs.method = \"get\";\n\t\t}\n\t\t\/\/ guess the multipart value\n\t\tif(kwArgs.method.toLowerCase() == \"get\"){\n\t\t\t\/\/ GET cannot use multipart\n\t\t\tkwArgs.multipart = false;\n\t\t}else{\n\t\t\tif(kwArgs[\"file\"]){\n\t\t\t\t\/\/ enforce multipart when sending files\n\t\t\t\tkwArgs.multipart = true;\n\t\t\t}else if(!kwArgs[\"multipart\"]){\n\t\t\t\t\/\/ default \n\t\t\t\tkwArgs.multipart = false;\n\t\t\t}\n\t\t}\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\t\tvar content = kwArgs[\"content\"] || {};\n\t\tif(kwArgs.sendTransport) {\n\t\t\tcontent[\"dojo.transport\"] = \"xmlhttp\";\n\t\t}\n\t\tdo { \/\/ break-block\n\t\t\tif(kwArgs.postContent){\n\t\t\t\tquery = kwArgs.postContent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(content) {\n\t\t\t\tquery += dojo.io.argsFromMap(content, kwArgs.encoding);\n\t\t\t}\n\t\t\tif(kwArgs.method.toLowerCase() == \"get\" || !kwArgs.multipart){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar\tt = [];\n\t\t\tif(query.length){\n\t\t\t\tvar q = query.split(\"&\");\n\t\t\t\tfor(var i = 0; i < q.length; ++i){\n\t\t\t\t\tif(q[i].length){\n\t\t\t\t\t\tvar p = q[i].split(\"=\");\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + p[0] + \"\\\"\", \n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\tp[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(kwArgs.file){\n\t\t\t\tif(dojo.lang.isArray(kwArgs.file)){\n\t\t\t\t\tfor(var i = 0; i < kwArgs.file.length; ++i){\n\t\t\t\t\t\tvar o = kwArgs.file[i];\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\to.content);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar o = kwArgs.file;\n\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\to.content);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.length){\n\t\t\t\tt.push(\"--\"+this.multipartBoundary+\"--\", \"\");\n\t\t\t\tquery = t.join(\"\\r\\n\");\n\t\t\t}\n\t\t}while(false);\n\t\t\/\/ kwArgs.Connection = \"close\";\n\t\tvar async = kwArgs[\"sync\"] ? false : true;\n\t\tvar preventCache = kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false);\n\t\tvar useCache = kwArgs[\"useCache\"] == true ||\n\t\t\t(this.useCache == true && kwArgs[\"useCache\"] != false );\n\t\t\/\/ preventCache is browser-level (add query string junk), useCache\n\t\t\/\/ is for the local cache. If we say preventCache, then don't attempt\n\t\t\/\/ to look in the cache, but if useCache is true, we still want to cache\n\t\t\/\/ the response\n\t\tif(!preventCache && useCache){\n\t\t\tvar cachedHttp = getFromCache(url, query, kwArgs.method);\n\t\t\tif(cachedHttp){\n\t\t\t\tdoLoad(kwArgs, cachedHttp, url, query, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\/\/ much of this is from getText, but reproduced here because we need\n\t\t\/\/ more flexibility\n\t\tvar http = dojo.hostenv.getXmlhttpObject(kwArgs);\t\n\t\tvar received = false;\n\t\t\/\/ build a handler function that calls back to the handler obj\n\t\tif(async){\n\t\t\tvar startTime = \n\t\t\t\/\/ FIXME: setting up this callback handler leaks on IE!!!\n\t\t\tthis.inFlight.push({\n\t\t\t\t\"req\":\t\tkwArgs,\n\t\t\t\t\"http\":\t\thttp,\n\t\t\t\t\"url\":\t \turl,\n\t\t\t\t\"query\":\tquery,\n\t\t\t\t\"useCache\":\tuseCache,\n\t\t\t\t\"startTime\": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0\n\t\t\t});\n\t\t\tthis.startWatchingInFlight();\n\t\t}else{\n\t\t\t\/\/ block async callbacks until sync is in, needed in khtml, others?\n\t\t\t_this._blockAsync = true;\n\t\t}\n\t\tif(kwArgs.method.toLowerCase() == \"post\"){\n\t\t\t\/\/ FIXME: need to hack in more flexible Content-Type setting here!\n\t\t\tif (!kwArgs.user) {\n\t\t\t\thttp.open(\"POST\", url, async);\n\t\t\t}else{\n        http.open(\"POST\", url, async, kwArgs.user, kwArgs.password);\n\t\t\t}\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\thttp.setRequestHeader(\"Content-Type\", kwArgs.multipart ? (\"multipart\/form-data; boundary=\" + this.multipartBoundary) : \n\t\t\t\t(kwArgs.contentType || \"application\/x-www-form-urlencoded\"));\n\t\t\ttry{\n\t\t\t\thttp.send(query);\n\t\t\t}catch(e){\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}else{\n\t\t\tvar tmpUrl = url;\n\t\t\tif(query != \"\") {\n\t\t\t\ttmpUrl += (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\t}\n\t\t\tif(preventCache) {\n\t\t\t\ttmpUrl += (dojo.string.endsWithAny(tmpUrl, \"?\", \"&\")\n\t\t\t\t\t? \"\" : (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\")) + \"dojo.preventCache=\" + new Date().valueOf();\n\t\t\t}\n\t\t\tif (!kwArgs.user) {\n\t\t\t\thttp.open(kwArgs.method.toUpperCase(), tmpUrl, async);\n\t\t\t}else{\n\t\t\t\thttp.open(kwArgs.method.toUpperCase(), tmpUrl, async, kwArgs.user, kwArgs.password);\n\t\t\t}\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\ttry {\n\t\t\t\thttp.send(null);\n\t\t\t}catch(e)\t{\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}\n\t\tif( !async ) {\n\t\t\tdoLoad(kwArgs, http, url, query, useCache);\n\t\t\t_this._blockAsync = false;\n\t\t}\n\t\tkwArgs.abort = function(){\n\t\t\ttry{\/\/ khtml doesent reset readyState on abort, need this workaround\n\t\t\t\thttp._aborted = true; \n\t\t\t}catch(e){\/*squelsh*\/}\n\t\t\treturn http.abort();\n\t\t}\n\t\treturn;\n\t}\n\tdojo.io.transports.addTransport(\"XMLHTTPTransport\");","instance_variables":["useCache","preventCache","clearCache","inFlight","inFlightTimer","startWatchingInFlight","watchInFlight","inFlight.length","canHandle","multipartBoundary","bind"]}},"dojo.io.XMLHTTPTransport.clearCache":{"meta":{"summary":"","src":" \t_cache = {};","instance":"dojo.io.XMLHTTPTransport"}},"dojo.io.XMLHTTPTransport.startWatchingInFlight":{"meta":{"summary":"internal method used to trigger a timer to watch all inflight XMLHttpRequests.","src":" \tif(!this.inFlightTimer){\n\t\t\t\/\/ setInterval broken in mozilla x86_64 in some circumstances, see\n\t\t\t\/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=344439\n\t\t\t\/\/ using setTimeout instead\n\t\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);\n\t\t}","instance":"dojo.io.XMLHTTPTransport"}},"dojo.io.XMLHTTPTransport.watchInFlight":{"meta":{"summary":"internal method that checks each inflight XMLHttpRequest to see if it has completed or if the timeout situation applies.","src":" \tvar now = null;\n\t\t\/\/ make sure sync calls stay thread safe, if this callback is called during a sync call\n\t\t\/\/ and this results in another sync call before the first sync call ends the browser hangs\n\t\tif(!dojo.hostenv._blockAsync && !_this._blockAsync){\n\t\t\tfor(var x=this.inFlight.length-1; x>=0; x--){\n\t\t\t\ttry{\n\t\t\t\t\tvar tif = this.inFlight[x];\n\t\t\t\t\tif(!tif || tif.http._aborted || !tif.http.readyState){\n\t\t\t\t\t\tthis.inFlight.splice(x, 1); continue; \n\t\t\t\t\t}\n\t\t\t\t\tif(4==tif.http.readyState){\n\t\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\t\tdoLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);\n\t\t\t\t\t}else if (tif.startTime){\n\t\t\t\t\t\t\/\/See if this is a timeout case.\n\t\t\t\t\t\tif(!now){\n\t\t\t\t\t\t\tnow = (new Date()).getTime();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){\n\t\t\t\t\t\t\t\/\/Stop the request.\n\t\t\t\t\t\t\tif(typeof tif.http.abort == \"function\"){\n\t\t\t\t\t\t\t\ttif.http.abort();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\t\t\ttif.req[(typeof tif.req.timeout == \"function\") ? \"timeout\" : \"handle\"](\"timeout\", null, tif.http, tif.req);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tvar errObj = new dojo.io.Error(\"XMLHttpTransport.watchInFlight Error: \" + e);\n\t\t\t\t\t\ttif.req[(typeof tif.req.error == \"function\") ? \"error\" : \"handle\"](\"error\", errObj, tif.http, tif.req);\n\t\t\t\t\t}catch(e2){\n\t\t\t\t\t\tdojo.debug(\"XMLHttpTransport error callback failed: \" + e2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclearTimeout(this.inFlightTimer);\n\t\tif(this.inFlight.length == 0){\n\t\t\tthis.inFlightTimer = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);","instance":"dojo.io.XMLHTTPTransport"}},"dojo.io.XMLHTTPTransport.canHandle":{"meta":{"summary":"Tells dojo.io.bind() if this is a good transport to use for the particular type of request. This type of transport cannot handle forms that have an input type=\"file\" element.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":"\t\t\/\/ FIXME: we need to determine when form values need to be\n\t\t\/\/ multi-part mime encoded and avoid using this transport for those\n\t\t\/\/ requests.\n\t\treturn hasXmlHttp\n\t\t\t&& dojo.lang.inArray([\"text\/plain\", \"text\/html\", \"application\/xml\", \"text\/xml\", \"text\/javascript\", \"text\/json\", \"application\/json\"], (kwArgs[\"mimetype\"].toLowerCase()||\"\"))\n\t\t\t&& !( kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]) ); \/\/boolean","instance":"dojo.io.XMLHTTPTransport"}},"dojo.io.XMLHTTPTransport.bind":{"meta":{"summary":"function that sends the request to the server.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":"\t\t\/\/This function will attach an abort() function to the kwArgs dojo.io.Request object,\n\t\t\/\/so if you need to abort the request, you can call that method on the request object.\n\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\/\/normal dojo.io.Request object properties).\n\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\/\/method: String: the HTTP method to use (GET, POST, etc...).\n\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Valid values are:\n\t\t\/\/\t\ttext\/javascript, text\/json, application\/json, application\/xml, text\/xml. Any other mimetype will give back a text\n\t\t\/\/\t\tstring.\n\t\t\/\/transport: String: specify \"XMLHTTPTransport\" to force the use of this XMLHttpRequest transport.\n\t\t\/\/headers: Object: The object property names and values will be sent as HTTP request header\n\t\t\/\/\t\tnames and values.\n\t\t\/\/sendTransport: boolean: If true, then dojo.transport=xmlhttp will be added to the request.\n\t\t\/\/encoding: String: The type of encoding to use when dealing with the content kwArgs property.\n\t\t\/\/content: Object: The content object is converted into a name=value&name=value string, by\n\t\t\/\/\t\tusing dojo.io.argsFromMap(). The encoding kwArgs property is passed to dojo.io.argsFromMap()\n\t\t\/\/\t\tfor use in encoding the names and values. The resulting string is added to the request.\n\t\t\/\/formNode: DOMNode: a form element node. This should not normally be used. Use new dojo.io.FormBind() instead.\n\t\t\/\/\t\tIf formNode is used, then the names and values of the form elements will be converted\n\t\t\/\/\t\tto a name=value&name=value string and added to the request. The encoding kwArgs property is used\n\t\t\/\/\t\tto encode the names and values.\n\t\t\/\/postContent: String: Raw name=value&name=value string to be included as part of the request.\n\t\t\/\/back or backButton: Function: A function to be called if the back button is pressed. If this kwArgs property\n\t\t\/\/\t\tis used, then back button support via dojo.undo.browser will be used. See notes for dojo.undo.browser on usage.\n\t\t\/\/\t\tYou need to set djConfig.preventBackButtonFix = false to enable back button support.\n\t\t\/\/changeUrl: boolean or String: Used as part of back button support. See notes for dojo.undo.browser on usage.\n\t\t\/\/user: String: The user name. Used in conjuction with password. Passed to XMLHttpRequest.open().\n\t\t\/\/password: String: The user's password. Used in conjuction with user. Passed to XMLHttpRequest.open().\n\t\t\/\/file: Object or Array of Objects: an object simulating a file to be uploaded. file objects should have the following properties:\n\t\t\/\/\t\tname or fileName: the name of the file\n\t\t\/\/\t\tcontentType: the MIME content type for the file.\n\t\t\/\/\t\tcontent: the actual content of the file.\n\t\t\/\/multipart: boolean: indicates whether this should be a multipart mime request. If kwArgs.file exists, then this\n\t\t\/\/\t\tproperty is set to true automatically.\n\t\t\/\/sync: boolean: if true, then a synchronous XMLHttpRequest call is done,\n\t\t\/\/\t\tif false (the default), then an asynchronous call is used.\n\t\t\/\/preventCache: boolean: If true, then a cache busting parameter is added to the request URL.\n\t\t\/\/\t\tdefault value is false.\n\t\t\/\/useCache: boolean: If true, then XMLHttpTransport will keep an internal cache of the server\n\t\t\/\/\t\tresponse and use that response if a similar request is done again.\n\t\t\/\/\t\tA similar request is one that has the same URL, query string and HTTP method value.\n\t\t\/\/\t\tdefault is false.\n\t\tif(!kwArgs[\"url\"]){\n\t\t\t\/\/ are we performing a history action?\n\t\t\tif( !kwArgs[\"formNode\"]\n\t\t\t\t&& (kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"] || kwArgs[\"watchForURL\"])\n\t\t\t\t&& (!djConfig.preventBackButtonFix)) {\n        dojo.deprecated(\"Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request\",\n        \t\t\t\t\"Use dojo.undo.browser.addToHistory() instead.\", \"0.4\");\n\t\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\/\/ build this first for cache purposes\n\t\tvar url = kwArgs.url;\n\t\tvar query = \"\";\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\t\tif(kwArgs[\"file\"]){\n\t\t\t\/\/ force post for file transfer\n\t\t\tkwArgs.method = \"post\";\n\t\t}\n\t\tif(!kwArgs[\"method\"]){\n\t\t\tkwArgs.method = \"get\";\n\t\t}\n\t\t\/\/ guess the multipart value\n\t\tif(kwArgs.method.toLowerCase() == \"get\"){\n\t\t\t\/\/ GET cannot use multipart\n\t\t\tkwArgs.multipart = false;\n\t\t}else{\n\t\t\tif(kwArgs[\"file\"]){\n\t\t\t\t\/\/ enforce multipart when sending files\n\t\t\t\tkwArgs.multipart = true;\n\t\t\t}else if(!kwArgs[\"multipart\"]){\n\t\t\t\t\/\/ default \n\t\t\t\tkwArgs.multipart = false;\n\t\t\t}\n\t\t}\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\t\tvar content = kwArgs[\"content\"] || {};\n\t\tif(kwArgs.sendTransport) {\n\t\t\tcontent[\"dojo.transport\"] = \"xmlhttp\";\n\t\t}\n\t\tdo { \/\/ break-block\n\t\t\tif(kwArgs.postContent){\n\t\t\t\tquery = kwArgs.postContent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(content) {\n\t\t\t\tquery += dojo.io.argsFromMap(content, kwArgs.encoding);\n\t\t\t}\n\t\t\tif(kwArgs.method.toLowerCase() == \"get\" || !kwArgs.multipart){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvar\tt = [];\n\t\t\tif(query.length){\n\t\t\t\tvar q = query.split(\"&\");\n\t\t\t\tfor(var i = 0; i < q.length; ++i){\n\t\t\t\t\tif(q[i].length){\n\t\t\t\t\t\tvar p = q[i].split(\"=\");\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + p[0] + \"\\\"\", \n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\tp[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(kwArgs.file){\n\t\t\t\tif(dojo.lang.isArray(kwArgs.file)){\n\t\t\t\t\tfor(var i = 0; i < kwArgs.file.length; ++i){\n\t\t\t\t\t\tvar o = kwArgs.file[i];\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\to.content);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar o = kwArgs.file;\n\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\to.content);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(t.length){\n\t\t\t\tt.push(\"--\"+this.multipartBoundary+\"--\", \"\");\n\t\t\t\tquery = t.join(\"\\r\\n\");\n\t\t\t}\n\t\t}while(false);\n\t\t\/\/ kwArgs.Connection = \"close\";\n\t\tvar async = kwArgs[\"sync\"] ? false : true;\n\t\tvar preventCache = kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false);\n\t\tvar useCache = kwArgs[\"useCache\"] == true ||\n\t\t\t(this.useCache == true && kwArgs[\"useCache\"] != false );\n\t\t\/\/ preventCache is browser-level (add query string junk), useCache\n\t\t\/\/ is for the local cache. If we say preventCache, then don't attempt\n\t\t\/\/ to look in the cache, but if useCache is true, we still want to cache\n\t\t\/\/ the response\n\t\tif(!preventCache && useCache){\n\t\t\tvar cachedHttp = getFromCache(url, query, kwArgs.method);\n\t\t\tif(cachedHttp){\n\t\t\t\tdoLoad(kwArgs, cachedHttp, url, query, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\/\/ much of this is from getText, but reproduced here because we need\n\t\t\/\/ more flexibility\n\t\tvar http = dojo.hostenv.getXmlhttpObject(kwArgs);\t\n\t\tvar received = false;\n\t\t\/\/ build a handler function that calls back to the handler obj\n\t\tif(async){\n\t\t\tvar startTime = \n\t\t\t\/\/ FIXME: setting up this callback handler leaks on IE!!!\n\t\t\tthis.inFlight.push({\n\t\t\t\t\"req\":\t\tkwArgs,\n\t\t\t\t\"http\":\t\thttp,\n\t\t\t\t\"url\":\t \turl,\n\t\t\t\t\"query\":\tquery,\n\t\t\t\t\"useCache\":\tuseCache,\n\t\t\t\t\"startTime\": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0\n\t\t\t});\n\t\t\tthis.startWatchingInFlight();\n\t\t}else{\n\t\t\t\/\/ block async callbacks until sync is in, needed in khtml, others?\n\t\t\t_this._blockAsync = true;\n\t\t}\n\t\tif(kwArgs.method.toLowerCase() == \"post\"){\n\t\t\t\/\/ FIXME: need to hack in more flexible Content-Type setting here!\n\t\t\tif (!kwArgs.user) {\n\t\t\t\thttp.open(\"POST\", url, async);\n\t\t\t}else{\n        http.open(\"POST\", url, async, kwArgs.user, kwArgs.password);\n\t\t\t}\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\thttp.setRequestHeader(\"Content-Type\", kwArgs.multipart ? (\"multipart\/form-data; boundary=\" + this.multipartBoundary) : \n\t\t\t\t(kwArgs.contentType || \"application\/x-www-form-urlencoded\"));\n\t\t\ttry{\n\t\t\t\thttp.send(query);\n\t\t\t}catch(e){\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}else{\n\t\t\tvar tmpUrl = url;\n\t\t\tif(query != \"\") {\n\t\t\t\ttmpUrl += (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\t}\n\t\t\tif(preventCache) {\n\t\t\t\ttmpUrl += (dojo.string.endsWithAny(tmpUrl, \"?\", \"&\")\n\t\t\t\t\t? \"\" : (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\")) + \"dojo.preventCache=\" + new Date().valueOf();\n\t\t\t}\n\t\t\tif (!kwArgs.user) {\n\t\t\t\thttp.open(kwArgs.method.toUpperCase(), tmpUrl, async);\n\t\t\t}else{\n\t\t\t\thttp.open(kwArgs.method.toUpperCase(), tmpUrl, async, kwArgs.user, kwArgs.password);\n\t\t\t}\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\ttry {\n\t\t\t\thttp.send(null);\n\t\t\t}catch(e)\t{\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}\n\t\tif( !async ) {\n\t\t\tdoLoad(kwArgs, http, url, query, useCache);\n\t\t\t_this._blockAsync = false;\n\t\t}\n\t\tkwArgs.abort = function(){\n\t\t\ttry{\/\/ khtml doesent reset readyState on abort, need this workaround\n\t\t\t\thttp._aborted = true; \n\t\t\t}catch(e){\/*squelsh*\/}\n\t\t\treturn http.abort();\n\t\t}\n\t\treturn;","instance":"dojo.io.XMLHTTPTransport"}},"dojo.io.FormBind.init":{"meta":{"summary":"Internal function called by the dojo.io.FormBind() constructor do not call this method directly.","parameters":{"args":{"type":"DOMNode or Object"}},"src":" \tvar form = dojo.byId(args.formNode);\n\t\tif(!form || !form.tagName || form.tagName.toLowerCase() != \"form\") {\n\t\t\tthrow new Error(\"FormBind: Couldn't apply, invalid form\");\n\t\t} else if(this.form == form) {\n\t\t\treturn;\n\t\t} else if(this.form) {\n\t\t\tthrow new Error(\"FormBind: Already applied to a form\");\n\t\t}\n\t\tdojo.lang.mixin(this.bindArgs, args);\n\t\tthis.form = form;\n\t\tthis.connect(form, \"onsubmit\", \"submit\");\n\t\tfor(var i = 0; i < form.elements.length; i++) {\n\t\t\tvar node = form.elements[i];\n\t\t\tif(node && node.type && dojo.lang.inArray([\"submit\", \"button\"], node.type.toLowerCase())) {\n\t\t\t\tthis.connect(node, \"onclick\", \"click\");\n\t\t\t}\n\t\t}\n\t\tvar inputs = form.getElementsByTagName(\"input\");\n\t\tfor(var i = 0; i < inputs.length; i++) {\n\t\t\tvar input = inputs[i];\n\t\t\tif(input.type.toLowerCase() == \"image\" && input.form == form) {\n\t\t\t\tthis.connect(input, \"onclick\", \"click\");\n\t\t\t}\n\t\t}","prototype":"dojo.io.FormBind"}},"dojo.io.FormBind.onSubmit":{"meta":{"summary":"Function used to verify that the form is OK to submit. Override this function if you want specific form validation done.","parameters":{"form":{"type":"DOMNode"}},"src":" \treturn true; \/\/boolean","returns":"boolean","prototype":"dojo.io.FormBind"}},"dojo.io.FormBind.submit":{"meta":{"summary":"internal function that is connected as a listener to the form's onsubmit event.","parameters":{"e":{"type":"Event"}},"src":" \te.preventDefault();\n\t\tif(this.onSubmit(this.form)) {\n\t\t\tdojo.io.bind(dojo.lang.mixin(this.bindArgs, {\n\t\t\t\tformFilter: dojo.lang.hitch(this, \"formFilter\")\n\t\t\t}));\n\t\t}","prototype":"dojo.io.FormBind"}},"dojo.io.FormBind.click":{"meta":{"summary":"internal method that is connected as a listener to the form's elements whose click event can submit a form.","parameters":{"e":{"type":"Event"}},"src":" \tvar node = e.currentTarget;\n\t\tif(node.disabled) { return; }\n\t\tthis.clickedButton = node;","prototype":"dojo.io.FormBind"}},"dojo.io.FormBind.formFilter":{"meta":{"summary":"internal function used to know which form element values to include in the dojo.io.bind() request.","parameters":{"node":{"type":"DOMNode"}},"src":" \tvar type = (node.type||\"\").toLowerCase();\n\t\tvar accept = false;\n\t\tif(node.disabled || !node.name) {\n\t\t\taccept = false;\n\t\t} else if(dojo.lang.inArray([\"submit\", \"button\", \"image\"], type)) {\n\t\t\tif(!this.clickedButton) { this.clickedButton = node; }\n\t\t\taccept = node == this.clickedButton;\n\t\t} else {\n\t\t\taccept = !dojo.lang.inArray([\"file\", \"submit\", \"reset\", \"button\"], type);\n\t\t}\n\t\treturn accept; \/\/boolean","returns":"boolean","prototype":"dojo.io.FormBind"}},"dojo.io.FormBind.connect":{"meta":{"summary":"internal function used to connect event listeners to form elements that trigger events. Used in case dojo.event is not loaded.","parameters":{"srcObj":{"type":"Object"},"srcFcn":{"type":"Function"},"targetFcn":{"type":"Function"}},"src":" \tif(dojo.evalObjPath(\"dojo.event.connect\")) {\n\t\t\tdojo.event.connect(srcObj, srcFcn, this, targetFcn);\n\t\t} else {\n\t\t\tvar fcn = dojo.lang.hitch(this, targetFcn);\n\t\t\tsrcObj[srcFcn] = function(e) {\n\t\t\t\tif(!e) { e = window.event; }\n\t\t\t\tif(!e.currentTarget) { e.currentTarget = e.srcElement; }\n\t\t\t\tif(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }\n\t\t\t\tfcn(e);\n\t\t\t}\n\t\t}","prototype":"dojo.io.FormBind"}}}}},"dojo.io.IframeIO":{"meta":{"requires":{"common":["dojo.io.BrowserIO","dojo.uri.*"]},"functions":{"dojo.io.createIFrame":{"meta":{"summary":"Creates a hidden iframe in the page. Used mostly for data transports.","parameters":{"fname":{"type":"String"},"onloadstr":{"type":"String"},"uri":{"type":"String?"}},"src":" if(window[fname]){ return window[fname]; }\n\tif(window.frames[fname]){ return window.frames[fname]; }\n\tvar r = dojo.render.html;\n\tvar cframe = null;\n\tvar turi = uri||dojo.uri.dojoUri(\"iframe_history.html?noInit=true\");\n\tvar ifrstr = ((r.ie)&&(dojo.render.os.win)) ? '<iframe name=\"'+fname+'\" src=\"'+turi+'\" onload=\"'+onloadstr+'\">' : 'iframe';\n\tcframe = document.createElement(ifrstr);\n\twith(cframe){\n\t\tname = fname;\n\t\tsetAttribute(\"name\", fname);\n\t\tid = fname;\n\t}\n\tdojo.body().appendChild(cframe);\n\twindow[fname] = cframe;\n\twith(cframe.style){\n\t\tif(!r.safari){\n\t\t\t\/\/We can't change the src in Safari 2.0.3 if absolute position. Bizarro.\n\t\t\tposition = \"absolute\";\n\t\t}\n\t\tleft = top = \"0px\";\n\t\theight = width = \"1px\";\n\t\tvisibility = \"hidden\";\n\t\t\/*\n\t\tif(djConfig.isDebug){\n\t\t\tposition = \"relative\";\n\t\t\theight = \"300px\";\n\t\t\twidth = \"600px\";\n\t\t\tvisibility = \"visible\";\n\t\t}\n\t\t*\/\n\t}\n\tif(!r.ie){\n\t\tdojo.io.setIFrameSrc(cframe, turi, true);\n\t\tcframe.onload = new Function(onloadstr);\n\t}\n\treturn cframe;"},"extra":{"parameters":{"fname":{"type":"String","summary":"The name of the iframe. Used for the name attribute on the iframe."},"onloadstr":{"type":"String","summary":"A string of Javascript that will be executed when the content in the iframe loads."},"uri":{"type":"String","summary":"The value of the src attribute on the iframe element. If a value is not given, then iframe_history.html will be used."}}}},"dojo.io.IframeTransport":{"meta":{"initialized":true,"summary":"The object that implements the dojo.io.bind transport that uses an iframe to communicate to the server.","src":" var _this = this;\n\tthis.currentRequest = null;\n\tthis.requestQueue = [];\n\tthis.iframeName = \"dojoIoIframe\";\n\tthis.fireNextRequest = function(){\n\t\t\/\/summary: Internal method used to fire the next request in the bind queue.\n\t\ttry{\n\t\t\tif((this.currentRequest)||(this.requestQueue.length == 0)){ return; }\n\t\t\t\/\/ dojo.debug(\"fireNextRequest\");\n\t\t\tvar cr = this.currentRequest = this.requestQueue.shift();\n\t\t\tcr._contentToClean = [];\n\t\t\tvar fn = cr[\"formNode\"];\n\t\t\tvar content = cr[\"content\"] || {};\n\t\t\tif(cr.sendTransport) {\n\t\t\t\tcontent[\"dojo.transport\"] = \"iframe\";\n\t\t\t}\n\t\t\tif(fn){\n\t\t\t\tif(content){\n\t\t\t\t\t\/\/ if we have things in content, we need to add them to the form\n\t\t\t\t\t\/\/ before submission\n\t\t\t\t\tfor(var x in content){\n\t\t\t\t\t\tif(!fn[x]){\n\t\t\t\t\t\t\tvar tn;\n\t\t\t\t\t\t\tif(dojo.render.html.ie){\n\t\t\t\t\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t\t\ttn.type = \"hidden\";\n\t\t\t\t\t\t\t\ttn.name = x;\n\t\t\t\t\t\t\t\ttn.value = content[x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcr._contentToClean.push(x);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfn[x].value = content[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cr[\"url\"]){\n\t\t\t\t\tcr._originalAction = fn.getAttribute(\"action\");\n\t\t\t\t\tfn.setAttribute(\"action\", cr.url);\n\t\t\t\t}\n\t\t\t\tif(!fn.getAttribute(\"method\")){\n\t\t\t\t\tfn.setAttribute(\"method\", (cr[\"method\"]) ? cr[\"method\"] : \"post\");\n\t\t\t\t}\n\t\t\t\tcr._originalTarget = fn.getAttribute(\"target\");\n\t\t\t\tfn.setAttribute(\"target\", this.iframeName);\n\t\t\t\tfn.target = this.iframeName;\n\t\t\t\tfn.submit();\n\t\t\t}else{\n\t\t\t\t\/\/ otherwise we post a GET string by changing URL location for the\n\t\t\t\t\/\/ iframe\n\t\t\t\tvar query = dojo.io.argsFromMap(this.currentRequest.content);\n\t\t\t\tvar tmpUrl = cr.url + (cr.url.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\t\tdojo.io.setIFrameSrc(this.iframe, tmpUrl, true);\n\t\t\t}\n\t\t}catch(e){\n\t\t\tthis.iframeOnload(e);\n\t\t}\n\t}\n\tthis.canHandle = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: Tells dojo.io.bind() if this is a good transport to\n\t\t\/\/use for the particular type of request.\n\t\t\/\/description: This type of transport cannot\n\t\t\/\/handle text\/xml or application\/xml return types, is limited to GET\n\t\t\/\/or POST requests, and cannot do synchronous binds.\n\t\treturn (\n\t\t\t(\n\t\t\t\tdojo.lang.inArray([\t\"text\/plain\", \"text\/html\", \"text\/javascript\", \"text\/json\", \"application\/json\"], kwArgs[\"mimetype\"])\n\t\t\t)&&(\n\t\t\t\tdojo.lang.inArray([\"post\", \"get\"], kwArgs[\"method\"].toLowerCase())\n\t\t\t)&&(\n\t\t\t\t\/\/ never handle a sync request\n\t\t\t\t!  ((kwArgs[\"sync\"])&&(kwArgs[\"sync\"] == true))\n\t\t\t)\n\t\t); \/\/boolean\n\t}\n\tthis.bind = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: function that sends the request to the server.\n\t\t\/\/This transport can only process one bind request at a time, so if bind is called\n\t\t\/\/multiple times, it will queue up the calls and only process one at a time.\n\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\/\/normal dojo.io.Request object properties).\n\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\/\/transport: String: specify \"IframeTransport\" to force the use of this transport.\n\t\t\/\/sendTransport: boolean: If true, then dojo.transport=iframe will be added to the request.\n\t\t\/\/formNode: DOMNode: a form element node. The form elements' names and values will be used in\n\t\t\/\/\t\tthe request. This makes it possible to upload files using this transport.\n\t\t\/\/method: String: the HTTP method to use. Must be GET or POST. Default is POST.\n\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Valid values are:\n\t\t\/\/\t\ttext\/plain, text\/html, text\/javascript, text\/json, application\/json. IMPORTANT: For all values EXCEPT text\/html,\n\t\t\/\/\t\tThe server response should be an HTML file with a textarea element. The response data should be inside the textarea\n\t\t\/\/\t\telement. Using an HTML document the only reliable, cross-browser way this transport can know\n\t\t\/\/\t\twhen the response has loaded. For the text\/html mimetype, just return a normal HTML document.\n\t\t\/\/content: Object: If a formNode is one of the other kwArgs properties, then the content\n\t\t\/\/\t\tobject properties become hidden form form elements. For instance, a content\n\t\t\/\/\t\tobject of {name1 : \"value1\"} is converted to a hidden form element with a name\n\t\t\/\/\t\tof \"name1\" and a value of \"value1\". If there is not a formNode property, then\n\t\t\/\/\t\tthe content object is converted into a name=value&name=value string, by\n\t\t\/\/\t\tusing dojo.io.argsFromMap(). No encoding is passed to that method, so the\n\t\t\/\/\t\tnames and values will be encoded using dojo.string.encodeAscii().\n\t\tif(!this[\"iframe\"]){ this.setUpIframe(); }\n\t\tthis.requestQueue.push(kwArgs);\n\t\tthis.fireNextRequest();\n\t\treturn;\n\t}\n\tthis.setUpIframe = function(){\n\t\t\/\/ NOTE: IE 5.0 and earlier Mozilla's don't support an onload event for\n\t\t\/\/       iframes. OTOH, we don't care.\n\t\tthis.iframe = dojo.io.createIFrame(this.iframeName, \"dojo.io.IframeTransport.iframeOnload();\");\n\t}\n\tthis.iframeOnload = function(errorObject \/* Object *\/){\n\t\tif(!_this.currentRequest){\n\t\t\t_this.fireNextRequest();\n\t\t\treturn;\n\t\t}\n\t\tvar req = _this.currentRequest;\n\t\tif(req.formNode){\n\t\t\t\/\/ remove all the hidden content inputs\n\t\t\tvar toClean = req._contentToClean;\n\t\t\tfor(var i = 0; i < toClean.length; i++) {\n\t\t\t\tvar key = toClean[i];\n\t\t\t\tif(dojo.render.html.safari){\n\t\t\t\t\t\/\/In Safari (at least 2.0.3), can't use formNode[key] syntax to find the node,\n\t\t\t\t\t\/\/for nodes that were dynamically added.\n\t\t\t\t\tvar fNode = req.formNode;\n\t\t\t\t\tfor(var j = 0; j < fNode.childNodes.length; j++){\n\t\t\t\t\t\tvar chNode = fNode.childNodes[j];\n\t\t\t\t\t\tif(chNode.name == key){\n\t\t\t\t\t\t\tvar pNode = chNode.parentNode;\n\t\t\t\t\t\t\tpNode.removeChild(chNode);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar input = req.formNode[key];\n\t\t\t\t\treq.formNode.removeChild(input);\n\t\t\t\t\treq.formNode[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ restore original action + target\n\t\t\tif(req[\"_originalAction\"]){\n\t\t\t\treq.formNode.setAttribute(\"action\", req._originalAction);\n\t\t\t}\n\t\t\tif(req[\"_originalTarget\"]){\n\t\t\t\treq.formNode.setAttribute(\"target\", req._originalTarget);\n\t\t\t\treq.formNode.target = req._originalTarget;\n\t\t\t}\n\t\t}\n\t\tvar contentDoc = function(iframe_el){\n\t\t\tvar doc = iframe_el.contentDocument || \/\/ W3\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.contentWindow)&&(iframe_el.contentWindow.document)\n\t\t\t\t) ||  \/\/ IE\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.name)&&(document.frames[iframe_el.name])&&\n\t\t\t\t\t(document.frames[iframe_el.name].document)\n\t\t\t\t) || null;\n\t\t\treturn doc;\n\t\t};\n\t\tvar value;\n\t\tvar success = false;\n\t\tif (errorObject){\n\t\t\t\tthis._callError(req, \"IframeTransport Request Error: \" + errorObject);\n\t\t}else{\n\t\t\tvar ifd = contentDoc(_this.iframe);\n\t\t\t\/\/ handle successful returns\n\t\t\t\/\/ FIXME: how do we determine success for iframes? Is there an equiv of\n\t\t\t\/\/ the \"status\" property?\n\t\t\ttry{\n\t\t\t\tvar cmt = req.mimetype;\n\t\t\t\tif((cmt == \"text\/javascript\")||(cmt == \"text\/json\")||(cmt == \"application\/json\")){\n\t\t\t\t\t\/\/ FIXME: not sure what to do here? try to pull some evalulable\n\t\t\t\t\t\/\/ text from a textarea or cdata section? \n\t\t\t\t\t\/\/ how should we set up the contract for that?\n\t\t\t\t\tvar js = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t\t\tif(cmt == \"text\/json\" || cmt == \"application\/json\") { js = \"(\" + js + \")\"; }\n\t\t\t\t\tvalue = dj_eval(js);\n\t\t\t\t}else if(cmt == \"text\/html\"){\n\t\t\t\t\tvalue = ifd;\n\t\t\t\t}else{ \/\/ text\/plain\n\t\t\t\t\tvalue = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t\t}\n\t\t\t\tsuccess = true;\n\t\t\t}catch(e){ \n\t\t\t\t\/\/ looks like we didn't get what we wanted!\n\t\t\t\tthis._callError(req, \"IframeTransport Error: \" + e);\n\t\t\t}\n\t\t}\n\t\t\/\/ don't want to mix load function errors with processing errors, thus\n\t\t\/\/ a separate try..catch\n\t\ttry {\n\t\t\tif(success && dojo.lang.isFunction(req[\"load\"])){\n\t\t\t\treq.load(\"load\", value, req);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t_this.currentRequest = null;\n\t\t\t_this.fireNextRequest();\n\t\t}\n\t}\n\tthis._callError = function(req \/* Object *\/, message \/* String *\/){\n\t\tvar errObj = new dojo.io.Error(message);\n\t\tif(dojo.lang.isFunction(req[\"error\"])){\n\t\t\treq.error(\"error\", errObj, req);\n\t\t}\n\t}\n\tdojo.io.transports.addTransport(\"IframeTransport\");","instance_variables":["currentRequest","requestQueue","iframeName","fireNextRequest","requestQueue.length","canHandle","bind","setUpIframe","iframe","iframeOnload","_callError"]}},"dojo.io.IframeTransport.fireNextRequest":{"meta":{"summary":"Internal method used to fire the next request in the bind queue.","src":" \ttry{\n\t\t\tif((this.currentRequest)||(this.requestQueue.length == 0)){ return; }\n\t\t\t\/\/ dojo.debug(\"fireNextRequest\");\n\t\t\tvar cr = this.currentRequest = this.requestQueue.shift();\n\t\t\tcr._contentToClean = [];\n\t\t\tvar fn = cr[\"formNode\"];\n\t\t\tvar content = cr[\"content\"] || {};\n\t\t\tif(cr.sendTransport) {\n\t\t\t\tcontent[\"dojo.transport\"] = \"iframe\";\n\t\t\t}\n\t\t\tif(fn){\n\t\t\t\tif(content){\n\t\t\t\t\t\/\/ if we have things in content, we need to add them to the form\n\t\t\t\t\t\/\/ before submission\n\t\t\t\t\tfor(var x in content){\n\t\t\t\t\t\tif(!fn[x]){\n\t\t\t\t\t\t\tvar tn;\n\t\t\t\t\t\t\tif(dojo.render.html.ie){\n\t\t\t\t\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t\t\ttn.type = \"hidden\";\n\t\t\t\t\t\t\t\ttn.name = x;\n\t\t\t\t\t\t\t\ttn.value = content[x];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcr._contentToClean.push(x);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfn[x].value = content[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(cr[\"url\"]){\n\t\t\t\t\tcr._originalAction = fn.getAttribute(\"action\");\n\t\t\t\t\tfn.setAttribute(\"action\", cr.url);\n\t\t\t\t}\n\t\t\t\tif(!fn.getAttribute(\"method\")){\n\t\t\t\t\tfn.setAttribute(\"method\", (cr[\"method\"]) ? cr[\"method\"] : \"post\");\n\t\t\t\t}\n\t\t\t\tcr._originalTarget = fn.getAttribute(\"target\");\n\t\t\t\tfn.setAttribute(\"target\", this.iframeName);\n\t\t\t\tfn.target = this.iframeName;\n\t\t\t\tfn.submit();\n\t\t\t}else{\n\t\t\t\t\/\/ otherwise we post a GET string by changing URL location for the\n\t\t\t\t\/\/ iframe\n\t\t\t\tvar query = dojo.io.argsFromMap(this.currentRequest.content);\n\t\t\t\tvar tmpUrl = cr.url + (cr.url.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\t\tdojo.io.setIFrameSrc(this.iframe, tmpUrl, true);\n\t\t\t}\n\t\t}catch(e){\n\t\t\tthis.iframeOnload(e);\n\t\t}","instance":"dojo.io.IframeTransport"}},"dojo.io.IframeTransport.canHandle":{"meta":{"summary":"Tells dojo.io.bind() if this is a good transport to use for the particular type of request.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":" \treturn (\n\t\t\t(\n\t\t\t\tdojo.lang.inArray([\t\"text\/plain\", \"text\/html\", \"text\/javascript\", \"text\/json\", \"application\/json\"], kwArgs[\"mimetype\"])\n\t\t\t)&&(\n\t\t\t\tdojo.lang.inArray([\"post\", \"get\"], kwArgs[\"method\"].toLowerCase())\n\t\t\t)&&(\n\t\t\t\t\/\/ never handle a sync request\n\t\t\t\t!  ((kwArgs[\"sync\"])&&(kwArgs[\"sync\"] == true))\n\t\t\t)\n\t\t); \/\/boolean","description":"This type of transport cannot handle text\/xml or application\/xml return types, is limited to GET or POST requests, and cannot do synchronous binds.","instance":"dojo.io.IframeTransport"}},"dojo.io.IframeTransport.bind":{"meta":{"summary":"function that sends the request to the server.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":"\t\t\/\/This transport can only process one bind request at a time, so if bind is called\n\t\t\/\/multiple times, it will queue up the calls and only process one at a time.\n\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\/\/normal dojo.io.Request object properties).\n\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\/\/transport: String: specify \"IframeTransport\" to force the use of this transport.\n\t\t\/\/sendTransport: boolean: If true, then dojo.transport=iframe will be added to the request.\n\t\t\/\/formNode: DOMNode: a form element node. The form elements' names and values will be used in\n\t\t\/\/\t\tthe request. This makes it possible to upload files using this transport.\n\t\t\/\/method: String: the HTTP method to use. Must be GET or POST. Default is POST.\n\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Valid values are:\n\t\t\/\/\t\ttext\/plain, text\/html, text\/javascript, text\/json, application\/json. IMPORTANT: For all values EXCEPT text\/html,\n\t\t\/\/\t\tThe server response should be an HTML file with a textarea element. The response data should be inside the textarea\n\t\t\/\/\t\telement. Using an HTML document the only reliable, cross-browser way this transport can know\n\t\t\/\/\t\twhen the response has loaded. For the text\/html mimetype, just return a normal HTML document.\n\t\t\/\/content: Object: If a formNode is one of the other kwArgs properties, then the content\n\t\t\/\/\t\tobject properties become hidden form form elements. For instance, a content\n\t\t\/\/\t\tobject of {name1 : \"value1\"} is converted to a hidden form element with a name\n\t\t\/\/\t\tof \"name1\" and a value of \"value1\". If there is not a formNode property, then\n\t\t\/\/\t\tthe content object is converted into a name=value&name=value string, by\n\t\t\/\/\t\tusing dojo.io.argsFromMap(). No encoding is passed to that method, so the\n\t\t\/\/\t\tnames and values will be encoded using dojo.string.encodeAscii().\n\t\tif(!this[\"iframe\"]){ this.setUpIframe(); }\n\t\tthis.requestQueue.push(kwArgs);\n\t\tthis.fireNextRequest();\n\t\treturn;","instance":"dojo.io.IframeTransport"}},"dojo.io.IframeTransport.setUpIframe":{"meta":{"summary":"","src":" \tthis.iframe = dojo.io.createIFrame(this.iframeName, \"dojo.io.IframeTransport.iframeOnload();\");","instance":"dojo.io.IframeTransport"}},"dojo.io.IframeTransport.iframeOnload":{"meta":{"summary":"","parameters":{"errorObject":{"type":"Object"}},"src":" \tif(!_this.currentRequest){\n\t\t\t_this.fireNextRequest();\n\t\t\treturn;\n\t\t}\n\t\tvar req = _this.currentRequest;\n\t\tif(req.formNode){\n\t\t\t\/\/ remove all the hidden content inputs\n\t\t\tvar toClean = req._contentToClean;\n\t\t\tfor(var i = 0; i < toClean.length; i++) {\n\t\t\t\tvar key = toClean[i];\n\t\t\t\tif(dojo.render.html.safari){\n\t\t\t\t\t\/\/In Safari (at least 2.0.3), can't use formNode[key] syntax to find the node,\n\t\t\t\t\t\/\/for nodes that were dynamically added.\n\t\t\t\t\tvar fNode = req.formNode;\n\t\t\t\t\tfor(var j = 0; j < fNode.childNodes.length; j++){\n\t\t\t\t\t\tvar chNode = fNode.childNodes[j];\n\t\t\t\t\t\tif(chNode.name == key){\n\t\t\t\t\t\t\tvar pNode = chNode.parentNode;\n\t\t\t\t\t\t\tpNode.removeChild(chNode);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar input = req.formNode[key];\n\t\t\t\t\treq.formNode.removeChild(input);\n\t\t\t\t\treq.formNode[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ restore original action + target\n\t\t\tif(req[\"_originalAction\"]){\n\t\t\t\treq.formNode.setAttribute(\"action\", req._originalAction);\n\t\t\t}\n\t\t\tif(req[\"_originalTarget\"]){\n\t\t\t\treq.formNode.setAttribute(\"target\", req._originalTarget);\n\t\t\t\treq.formNode.target = req._originalTarget;\n\t\t\t}\n\t\t}\n\t\tvar contentDoc = function(iframe_el){\n\t\t\tvar doc = iframe_el.contentDocument || \/\/ W3\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.contentWindow)&&(iframe_el.contentWindow.document)\n\t\t\t\t) ||  \/\/ IE\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.name)&&(document.frames[iframe_el.name])&&\n\t\t\t\t\t(document.frames[iframe_el.name].document)\n\t\t\t\t) || null;\n\t\t\treturn doc;\n\t\t};\n\t\tvar value;\n\t\tvar success = false;\n\t\tif (errorObject){\n\t\t\t\tthis._callError(req, \"IframeTransport Request Error: \" + errorObject);\n\t\t}else{\n\t\t\tvar ifd = contentDoc(_this.iframe);\n\t\t\t\/\/ handle successful returns\n\t\t\t\/\/ FIXME: how do we determine success for iframes? Is there an equiv of\n\t\t\t\/\/ the \"status\" property?\n\t\t\ttry{\n\t\t\t\tvar cmt = req.mimetype;\n\t\t\t\tif((cmt == \"text\/javascript\")||(cmt == \"text\/json\")||(cmt == \"application\/json\")){\n\t\t\t\t\t\/\/ FIXME: not sure what to do here? try to pull some evalulable\n\t\t\t\t\t\/\/ text from a textarea or cdata section? \n\t\t\t\t\t\/\/ how should we set up the contract for that?\n\t\t\t\t\tvar js = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t\t\tif(cmt == \"text\/json\" || cmt == \"application\/json\") { js = \"(\" + js + \")\"; }\n\t\t\t\t\tvalue = dj_eval(js);\n\t\t\t\t}else if(cmt == \"text\/html\"){\n\t\t\t\t\tvalue = ifd;\n\t\t\t\t}else{ \/\/ text\/plain\n\t\t\t\t\tvalue = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t\t}\n\t\t\t\tsuccess = true;\n\t\t\t}catch(e){ \n\t\t\t\t\/\/ looks like we didn't get what we wanted!\n\t\t\t\tthis._callError(req, \"IframeTransport Error: \" + e);\n\t\t\t}\n\t\t}\n\t\t\/\/ don't want to mix load function errors with processing errors, thus\n\t\t\/\/ a separate try..catch\n\t\ttry {\n\t\t\tif(success && dojo.lang.isFunction(req[\"load\"])){\n\t\t\t\treq.load(\"load\", value, req);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t_this.currentRequest = null;\n\t\t\t_this.fireNextRequest();\n\t\t}","instance":"dojo.io.IframeTransport"}},"dojo.io.IframeTransport._callError":{"meta":{"summary":"","parameters":{"req":{"type":"Object"},"message":{"type":"String"}},"src":" \tvar errObj = new dojo.io.Error(message);\n\t\tif(dojo.lang.isFunction(req[\"error\"])){\n\t\t\treq.error(\"error\", errObj, req);\n\t\t}","instance":"dojo.io.IframeTransport"}}}}},"dojo.io.RepubsubIO":{"meta":{"requires":{"common":["dojo.event.*","dojo.io.BrowserIO"]},"functions":{"dojo.io.repubsubTranport":{"meta":{"initialized":true,"summary":"","src":" var rps = dojo.io.repubsub;\n\tthis.canHandle = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: Tells dojo.io.bind() if this is a good transport to\n\t\t\/\/use for the particular type of request. This is a legacy transport\n\t\t\/\/and should not be used unless you are dealing with repubsub.\n\t\t\/\/Consider a comet transport instead.\n\t\tif((kwArgs[\"mimetype\"] == \"text\/javascript\")&&(kwArgs[\"method\"] == \"repubsub\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tthis.bind = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: This is a legacy transport and should not be used unless you are dealing with repubsub.\n\t\t\/\/Consider a comet transport instead.\n\t\tif(!rps.isInitialized){\n\t\t\t\/\/ open up our tunnel, queue up requests anyway\n\t\t\trps.init();\n\t\t}\n\t\t\/\/ FIXME: we need to turn this into a topic subscription\n\t\t\/\/ var tgtURL = kwArgs.url+\"?\"+dojo.io.argsFromMap(kwArgs.content);\n\t\t\/\/ sampleTransport.sendRequest(tgtURL, hdlrFunc);\n\t\t\/\/ a normal \"bind()\" call in a request-response transport layer is\n\t\t\/\/ something that (usually) encodes most of it's payload with the\n\t\t\/\/ request. Multi-event systems like repubsub are a bit more complex,\n\t\t\/\/ and repubsub in particular distinguishes the publish and subscribe\n\t\t\/\/ portions of thep rocess with different method calls to handle each.\n\t\t\/\/ Therefore, a \"bind\" in the sense of repubsub must first determine if\n\t\t\/\/ we have an open subscription to a channel provided by the server,\n\t\t\/\/ and then \"publish\" the request payload if there is any. We therefore\n\t\t\/\/ must take care not to incorrectly or too agressively register or\n\t\t\/\/ file event handlers which are provided with the kwArgs method.\n\t\t\/\/ NOTE: we ONLY pay attention to those event handlers that are\n\t\t\/\/ registered with the bind request that subscribes to the channel. If\n\t\t\/\/ event handlers are provided with subsequent requests, we might in\n\t\t\/\/ the future support some additive or replacement syntax, but for now\n\t\t\/\/ they get dropped on the floor.\n\t\t\/\/ NOTE: in this case, url MUST be the \"topic\" to which we\n\t\t\/\/ subscribe\/publish for this channel\n\t\tif(!rps.topics[kwArgs.url]){\n\t\t\tkwArgs.rpsLoad = function(evt){\n\t\t\t\tkwArgs.load(\"load\", evt);\n\t\t\t}\n\t\t\trps.subscribe(kwArgs.url, kwArgs, \"rpsLoad\");\n\t\t}\n\t\tif(kwArgs[\"content\"]){\n\t\t\t\/\/ what we wanted to send\n\t\t\tvar cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);\n\t\t\trps.publish(kwArgs.url, cEvt);\n\t\t}\n\t}\n\tdojo.io.transports.addTransport(\"repubsubTranport\");","instance_variables":["canHandle","bind"]}},"dojo.io.repubsubTranport.canHandle":{"meta":{"summary":"Tells dojo.io.bind() if this is a good transport to use for the particular type of request. This is a legacy transport and should not be used unless you are dealing with repubsub. Consider a comet transport instead.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":" \tif((kwArgs[\"mimetype\"] == \"text\/javascript\")&&(kwArgs[\"method\"] == \"repubsub\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;","instance":"dojo.io.repubsubTranport"}},"dojo.io.repubsubTranport.bind":{"meta":{"summary":"This is a legacy transport and should not be used unless you are dealing with repubsub. Consider a comet transport instead.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":" \tif(!rps.isInitialized){\n\t\t\t\/\/ open up our tunnel, queue up requests anyway\n\t\t\trps.init();\n\t\t}\n\t\t\/\/ FIXME: we need to turn this into a topic subscription\n\t\t\/\/ var tgtURL = kwArgs.url+\"?\"+dojo.io.argsFromMap(kwArgs.content);\n\t\t\/\/ sampleTransport.sendRequest(tgtURL, hdlrFunc);\n\t\t\/\/ a normal \"bind()\" call in a request-response transport layer is\n\t\t\/\/ something that (usually) encodes most of it's payload with the\n\t\t\/\/ request. Multi-event systems like repubsub are a bit more complex,\n\t\t\/\/ and repubsub in particular distinguishes the publish and subscribe\n\t\t\/\/ portions of thep rocess with different method calls to handle each.\n\t\t\/\/ Therefore, a \"bind\" in the sense of repubsub must first determine if\n\t\t\/\/ we have an open subscription to a channel provided by the server,\n\t\t\/\/ and then \"publish\" the request payload if there is any. We therefore\n\t\t\/\/ must take care not to incorrectly or too agressively register or\n\t\t\/\/ file event handlers which are provided with the kwArgs method.\n\t\t\/\/ NOTE: we ONLY pay attention to those event handlers that are\n\t\t\/\/ registered with the bind request that subscribes to the channel. If\n\t\t\/\/ event handlers are provided with subsequent requests, we might in\n\t\t\/\/ the future support some additive or replacement syntax, but for now\n\t\t\/\/ they get dropped on the floor.\n\t\t\/\/ NOTE: in this case, url MUST be the \"topic\" to which we\n\t\t\/\/ subscribe\/publish for this channel\n\t\tif(!rps.topics[kwArgs.url]){\n\t\t\tkwArgs.rpsLoad = function(evt){\n\t\t\t\tkwArgs.load(\"load\", evt);\n\t\t\t}\n\t\t\trps.subscribe(kwArgs.url, kwArgs, \"rpsLoad\");\n\t\t}\n\t\tif(kwArgs[\"content\"]){\n\t\t\t\/\/ what we wanted to send\n\t\t\tvar cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);\n\t\t\trps.publish(kwArgs.url, cEvt);\n\t\t}","instance":"dojo.io.repubsubTranport"}},"dojo.io.repubsub":{"meta":{"initialized":true,"summary":"","src":" this.initDoc = \"init.html\";\n\tthis.isInitialized = false;\n\tthis.subscriptionBacklog = [];\n\tthis.debug = true;\n\tthis.rcvNodeName = null;\n\tthis.sndNodeName = null;\n\tthis.rcvNode = null;\n\tthis.sndNode = null;\n\tthis.canRcv = false;\n\tthis.canSnd = false;\n\tthis.canLog = false;\n\tthis.sndTimer = null;\n\tthis.windowRef = window;\n\tthis.backlog = [];\n\tthis.tunnelInitCount = 0;\n\tthis.tunnelFrameKey = \"tunnel_frame\";\n\tthis.serverBaseURL = location.protocol+\"\/\/\"+location.host+location.pathname;\n\tthis.logBacklog = [];\n\tthis.getRandStr = function(){\n\t\treturn Math.random().toString().substring(2, 10);\n\t}\n\tthis.userid = \"guest\";\n\tthis.tunnelID = this.getRandStr();\n\tthis.attachPathList = [];\n\tthis.topics = []; \/\/ list of topics we have listeners to\n\t\/\/ actually, now that I think about it a little bit more, it would sure be\n\t\/\/ useful to parse out the <script> src attributes. We're looking for\n\t\/\/ something with a \"do_method=lib\", since that's what would have included\n\t\/\/ us in the first place (in the common case).\n\tthis.parseGetStr = function(){\n\t\tvar baseUrl = document.location.toString();\n\t\tvar params = baseUrl.split(\"?\", 2);\n\t\tif(params.length > 1){\n\t\t\tvar paramStr = params[1];\n\t\t\tvar pairs = paramStr.split(\"&\");\n\t\t\tvar opts = [];\n\t\t\tfor(var x in pairs){\n\t\t\t\tvar sp = pairs[x].split(\"=\");\n\t\t\t\t\/\/ FIXME: is this eval dangerous?\n\t\t\t\ttry{\n\t\t\t\t\topts[sp[0]]=eval(sp[1]);\n\t\t\t\t}catch(e){\n\t\t\t\t\topts[sp[0]]=sp[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts;\n\t\t}else{\n\t\t\treturn [];\n\t\t}\n\t}\n\t\/\/ parse URL params and use them as default vals\n\tvar getOpts = this.parseGetStr();\n\tfor(var x in getOpts){\n\t\t\/\/ FIXME: should I be checking for undefined here before setting? Does\n\t\t\/\/        that buy me anything?\n\t\tthis[x] = getOpts[x];\n\t}\n\tif(!this[\"tunnelURI\"]){\n\t\tthis.tunnelURI = [\t\"\/who\/\", escape(this.userid), \"\/s\/\", \n\t\t\t\t\t\t\tthis.getRandStr(), \"\/kn_journal\"].join(\"\");\n\t\t\/\/ this.tunnelURI = this.absoluteTopicURI(this.tunnelURI);\n\t}\n\t\/*\n\tif (self.kn_tunnelID) kn.tunnelID = self.kn_tunnelID; \/\/ the server says\n\tif (kn._argv.kn_tunnelID) kn.tunnelID = kn._argv.kn_tunnelID; \/\/ the url says\n\t*\/\n\t\/\/ check the options object if it exists and use its properties as an\n\t\/\/ over-ride\n\tif(window[\"repubsubOpts\"]||window[\"rpsOpts\"]){\n\t\tvar optObj = window[\"repubsubOpts\"]||window[\"rpsOpts\"];\n\t\tfor(var x in optObj){\n\t\t\tthis[x] = optObj[x]; \/\/ copy the option object properties\n\t\t}\n\t}\n\t\/\/ things that get called directly from our iframe to inform us of events\n\tthis.tunnelCloseCallback = function(){\n\t\t\/\/ when we get this callback, we should immediately attempt to re-start\n\t\t\/\/ our tunnel connection\n\t\tdojo.io.setIFrameSrc(this.rcvNode, this.initDoc+\"?callback=repubsub.rcvNodeReady&domain=\"+document.domain);\n\t}\n\tthis.receiveEventFromTunnel = function(evt, srcWindow){\n\t\t\/\/ we should never be getting events from windows we didn't create\n\t\t\/\/ NOTE: events sourced from the local window are also supported for\n\t\t\/\/ \t\t debugging purposes\n\t\t\/\/ any event object MUST have a an \"elements\" property\n\t\tif(!evt[\"elements\"]){\n\t\t\tthis.log(\"bailing! event received without elements!\", \"error\");\n\t\t\treturn;\n\t\t}\n\t\t\/\/ if the event passes some minimal sanity tests, we need to attempt to\n\t\t\/\/ dispatch it!\n\t\t\/\/ first, it seems we have to munge the event object a bit\n\t\tvar e = {};\n\t\tfor(var i=0; i<evt.elements.length; i++){\n\t\t\tvar ee = evt.elements[i];\n\t\t\te[ee.name||ee.nameU] = (ee.value||ee.valueU);\n\t\t\t\/\/ FIXME: need to enable this only in some extreme debugging mode!\n\t\t\tthis.log(\"[event]: \"+(ee.name||ee.nameU)+\": \"+e[ee.name||ee.nameU]);\n\t\t}\n\t\t\/\/ NOTE: the previous version of this library put a bunch of code here\n\t\t\/\/ to manage state that tried to make sure that we never, ever, lost\n\t\t\/\/ any info about an event. If we unload RIGHT HERE, I don't think it's\n\t\t\/\/ going to make a huge difference one way or another. Time will tell.\n\t\t\/\/ and with THAT out of the way, dispatch it!\n\t\tthis.dispatch(e);\n\t\t\/\/ TODO: remove the script block that created the event obj to save\n\t\t\/\/ memory, etc.\n\t}\n\tthis.widenDomain = function(domainStr){\n\t\t\/\/ the purpose of this is to set the most liberal domain policy\n\t\t\/\/ available\n\t\tvar cd = domainStr||document.domain;\n\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");\n\t}\n\t\/\/ FIXME: parseCookie and setCookie should be methods that are more broadly\n\t\/\/ available. Perhaps in htmlUtils?\n\tthis.parseCookie = function(){\n\t\tvar cs = document.cookie;\n\t\tvar keypairs = cs.split(\";\");\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tkeypairs[x] = keypairs[x].split(\"=\");\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\treturn keypairs;\n\t}\n\tthis.setCookie = function(keypairs, clobber){\n\t\t\/\/ NOTE: we want to only ever set session cookies, so never provide an\n\t\t\/\/ \t\t expires date\n\t\tif((clobber)&&(clobber==true)){ document.cookie = \"\"; }\n\t\tvar cs = \"\";\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tcs += keypairs[x][0]+\"=\"+keypairs[x][1];\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\tdocument.cookie = cs;\n\t}\n\t\/\/ FIXME: need to replace w\/ dojo.log.*\n\tthis.log = function(str, lvl){\n\t\tif(!this.debug){ return; } \/\/ we of course only care if we're in debug mode\n\t\twhile(this.logBacklog.length>0){\n\t\t\tif(!this.canLog){ break; }\n\t\t\tvar blo = this.logBacklog.shift();\n\t\t\tthis.writeLog(\"[\"+blo[0]+\"]: \"+blo[1], blo[2]);\n\t\t}\n\t\tthis.writeLog(str, lvl);\n\t}\n\tthis.writeLog = function(str, lvl){\n\t\tdojo.debug(((new Date()).toLocaleTimeString())+\": \"+str);\n\t}\n\tthis.init = function(){\n\t\tthis.widenDomain();\n\t\t\/\/ this.findPeers();\n\t\tthis.openTunnel();\n\t\tthis.isInitialized = true;\n\t\t\/\/ FIXME: this seems like entirely the wrong place to replay the backlog\n\t\twhile(this.subscriptionBacklog.length){\n\t\t\tthis.subscribe.apply(this, this.subscriptionBacklog.shift());\n\t\t}\n\t}\n\tthis.clobber = function(){\n\t\tif(this.rcvNode){\n\t\t\tthis.setCookie( [\n\t\t\t\t\t[this.tunnelFrameKey,\"closed\"],\n\t\t\t\t\t[\"path\",\"\/\"]\n\t\t\t\t], false \n\t\t\t);\n\t\t}\n\t}\n\tthis.openTunnel = function(){\n\t\t\/\/ We create two iframes here:\n\t\t\/\/ one for getting data\n\t\tthis.rcvNodeName = \"rcvIFrame_\"+this.getRandStr();\n\t\t\/\/ set cookie that can be used to find the receiving iframe\n\t\tthis.setCookie( [\n\t\t\t\t[this.tunnelFrameKey,this.rcvNodeName],\n\t\t\t\t[\"path\",\"\/\"]\n\t\t\t], false\n\t\t);\n\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.rcvNode, this.initDoc+\"?callback=repubsub.rcvNodeReady&domain=\"+document.domain);\n\t\t\/\/ the other for posting data in reply\n\t\tthis.sndNodeName = \"sndIFrame_\"+this.getRandStr();\n\t\tthis.sndNode = dojo.io.createIFrame(this.sndNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.sndNode, this.initDoc+\"?callback=repubsub.sndNodeReady&domain=\"+document.domain);\n\t}\n\tthis.rcvNodeReady = function(){\n\t\t\/\/ FIXME: why is this sequence number needed? Why isn't the UID gen\n\t\t\/\/ \t\t  function enough?\n        var statusURI = [this.tunnelURI, '\/kn_status\/', this.getRandStr(), '_', \n\t\t\t\t\t\t String(this.tunnelInitCount++)].join(\"\"); \n            \/\/ (kn._seqNum++); \/\/ FIXME: !!!!\n\t\t\/\/ this.canRcv = true;\n\t\tthis.log(\"rcvNodeReady\");\n\t\t\/\/ FIXME: initialize receiver and request the base topic\n\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+\"\/kn?do_method=blank\");\n\t\tvar initURIArr = [\tthis.serverBaseURL, \"\/kn?kn_from=\", escape(this.tunnelURI),\n\t\t\t\t\t\t\t\"&kn_id=\", escape(this.tunnelID), \"&kn_status_from=\", \n\t\t\t\t\t\t\tescape(statusURI)];\n\t\t\/\/ FIXME: does the above really need a kn_response_flush? won't the\n\t\t\/\/ \t\t  server already know? If not, what good is it anyway?\n\t\tdojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(\"\"));\n\t\t\/\/ setup a status path listener, but don't tell the server about it,\n\t\t\/\/ since it already knows we're itnerested in our own tunnel status\n\t\tthis.subscribe(statusURI, this, \"statusListener\", true);\n\t\tthis.log(initURIArr.join(\"\"));\n\t}\n\tthis.sndNodeReady = function(){\n\t\tthis.canSnd = true;\n\t\tthis.log(\"sndNodeReady\");\n\t\tthis.log(this.backlog.length);\n\t\t\/\/ FIXME: handle any pent-up send commands\n\t\tif(this.backlog.length > 0){\n\t\t\tthis.dequeueEvent();\n\t\t}\n\t}\n\tthis.statusListener = function(evt){\n\t\tthis.log(\"status listener called\");\n\t\tthis.log(evt.status, \"info\");\n\t}\n\t\/\/ this handles local event propigation\n\tthis.dispatch = function(evt){\n\t\t\/\/ figure out what topic it came from\n\t\tif(evt[\"to\"]||evt[\"kn_routed_from\"]){\n\t\t\tvar rf = evt[\"to\"]||evt[\"kn_routed_from\"];\n\t\t\t\/\/ split off the base server URL\n\t\t\tvar topic = rf.split(this.serverBaseURL, 2)[1];\n\t\t\tif(!topic){\n\t\t\t\t\/\/ FIXME: how do we recover when we don't get a sane \"from\"? Do\n\t\t\t\t\/\/ we try to route to it anyway?\n\t\t\t\ttopic = rf;\n\t\t\t}\n\t\t\tthis.log(\"[topic] \"+topic);\n\t\t\tif(topic.length>3){\n\t\t\t\tif(topic.slice(0, 3)==\"\/kn\"){\n\t\t\t\t\ttopic = topic.slice(3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.attachPathList[topic]){\n\t\t\t\tthis.attachPathList[topic](evt);\n\t\t\t}\n\t\t}\n\t}\n\tthis.subscribe = function(\ttopic \/* kn_from in the old terminilogy *\/, \n\t\t\t\t\t\t\t\ttoObj, toFunc, dontTellServer){\n\t\tif(!this.isInitialized){\n\t\t\tthis.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);\n\t\t\treturn;\n\t\t}\n\t\tif(!this.attachPathList[topic]){\n\t\t\tthis.attachPathList[topic] = function(){ return true; }\n\t\t\tthis.log(\"subscribing to: \"+topic);\n\t\t\tthis.topics.push(topic);\n\t\t}\n\t\tvar revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, \"route\");\n\t\tvar rstr = [this.serverBaseURL+\"\/kn\", revt.toGetString()].join(\"\");\n\t\tdojo.event.kwConnect({\n\t\t\tonce: true,\n\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\/\/ NOTE: the above is a local mapping, if we're not the leader, we\n\t\t\/\/ \t\t should connect our mapping to the topic handler of the peer\n\t\t\/\/ \t\t leader, this ensures that not matter what happens to the\n\t\t\/\/ \t\t leader, we don't really loose our heads if\/when the leader\n\t\t\/\/ \t\t goes away.\n\t\tif(!this.rcvNode){ \/* this should be an error! *\/ }\n\t\tif(dontTellServer){\n\t\t\treturn;\n\t\t}\n\t\tthis.log(\"sending subscription to: \"+topic);\n\t\t\/\/ create a subscription event object and give it all the props we need\n\t\t\/\/ to updates on the specified topic\n\t\t\/\/ FIXME: we should only enqueue if this is our first subscription!\n\t\tthis.sendTopicSubToServer(topic, rstr);\n\t}\n\tthis.sendTopicSubToServer = function(topic, str){\n\t\tif(!this.attachPathList[topic][\"subscriptions\"]){\n\t\t\tthis.enqueueEventStr(str);\n\t\t\tthis.attachPathList[topic].subscriptions = 0;\n\t\t}\n\t\tthis.attachPathList[topic].subscriptions++;\n\t}\n\tthis.unSubscribe = function(topic, toObj, toFunc){\n\t\t\/\/ first, locally disconnect\n\t\tdojo.event.kwDisconnect({\n\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\/\/ FIXME: figure out if there are any remaining listeners to the topic,\n\t\t\/\/ \t\t  and if not, inform the server of our desire not to be\n\t\t\/\/ \t\t  notified of updates to the topic\n\t}\n\t\/\/ the \"publish\" method is really a misnomer, since it really means \"take\n\t\/\/ this event and send it to the server\". Note that the \"dispatch\" method\n\t\/\/ handles local event promigulation, and therefore we emulate both sides\n\t\/\/ of a real event router without having to swallow all of the complexity.\n\tthis.publish = function(topic, event){\n\t\tvar evt = dojo.io.repubsubEvent.initFromProperties(event);\n\t\t\/\/ FIXME: need to make sure we have from and to set correctly\n\t\t\/\/ \t\t  before we serialize and send off to the great blue\n\t\t\/\/ \t\t  younder.\n\t\tevt.to = topic;\n\t\t\/\/ evt.from = this.tunnelURI;\n\t\tvar evtURLParts = [];\n\t\tevtURLParts.push(this.serverBaseURL+\"\/kn\");\n\t\t\/\/ serialize the event to a string and then post it to the correct\n\t\t\/\/ topic\n\t\tevtURLParts.push(evt.toGetString());\n\t\tthis.enqueueEventStr(evtURLParts.join(\"\"));\n\t}\n\tthis.enqueueEventStr = function(evtStr){\n\t\tthis.log(\"enqueueEventStr\");\n\t\tthis.backlog.push(evtStr);\n\t\tthis.dequeueEvent();\n\t}\n\tthis.dequeueEvent = function(force){\n\t\tthis.log(\"dequeueEvent\");\n\t\tif(this.backlog.length <= 0){ return; }\n\t\tif((this.canSnd)||(force)){\n\t\t\tdojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+\"&callback=repubsub.sndNodeReady\");\n\t\t\tthis.canSnd = false;\n\t\t}else{\n\t\t\tthis.log(\"sndNode not available yet!\", \"debug\");\n\t\t}\n\t}","instance_variables":["initDoc","isInitialized","subscriptionBacklog","debug","rcvNodeName","sndNodeName","rcvNode","sndNode","canRcv","canSnd","canLog","sndTimer","windowRef","backlog","tunnelInitCount","tunnelFrameKey","serverBaseURL","logBacklog","getRandStr","userid","tunnelID","attachPathList","topics","parseGetStr","tunnelURI","tunnelCloseCallback","receiveEventFromTunnel","widenDomain","parseCookie","setCookie","log","writeLog","init","clobber","openTunnel","rcvNodeReady","sndNodeReady","statusListener","dispatch","subscribe","sendTopicSubToServer","unSubscribe","publish","enqueueEventStr","dequeueEvent"],"returns":"mixed","call_chain":["this.subscribe"]}},"dojo.io.repubsub.getRandStr":{"meta":{"summary":"","src":" \treturn Math.random().toString().substring(2, 10);","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.parseGetStr":{"meta":{"summary":"","src":" \tvar baseUrl = document.location.toString();\n\t\tvar params = baseUrl.split(\"?\", 2);\n\t\tif(params.length > 1){\n\t\t\tvar paramStr = params[1];\n\t\t\tvar pairs = paramStr.split(\"&\");\n\t\t\tvar opts = [];\n\t\t\tfor(var x in pairs){\n\t\t\t\tvar sp = pairs[x].split(\"=\");\n\t\t\t\t\/\/ FIXME: is this eval dangerous?\n\t\t\t\ttry{\n\t\t\t\t\topts[sp[0]]=eval(sp[1]);\n\t\t\t\t}catch(e){\n\t\t\t\t\topts[sp[0]]=sp[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts;\n\t\t}else{\n\t\t\treturn [];\n\t\t}","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.tunnelCloseCallback":{"meta":{"summary":"","src":" \tdojo.io.setIFrameSrc(this.rcvNode, this.initDoc+\"?callback=repubsub.rcvNodeReady&domain=\"+document.domain);","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.receiveEventFromTunnel":{"meta":{"summary":"","parameters":{"evt":{"type":""},"srcWindow":{"type":""}},"src":"\t\t\/\/ any event object MUST have a an \"elements\" property\n\t\tif(!evt[\"elements\"]){\n\t\t\tthis.log(\"bailing! event received without elements!\", \"error\");\n\t\t\treturn;\n\t\t}\n\t\t\/\/ if the event passes some minimal sanity tests, we need to attempt to\n\t\t\/\/ dispatch it!\n\t\t\/\/ first, it seems we have to munge the event object a bit\n\t\tvar e = {};\n\t\tfor(var i=0; i<evt.elements.length; i++){\n\t\t\tvar ee = evt.elements[i];\n\t\t\te[ee.name||ee.nameU] = (ee.value||ee.valueU);\n\t\t\t\/\/ FIXME: need to enable this only in some extreme debugging mode!\n\t\t\tthis.log(\"[event]: \"+(ee.name||ee.nameU)+\": \"+e[ee.name||ee.nameU]);\n\t\t}\n\t\t\/\/ NOTE: the previous version of this library put a bunch of code here\n\t\t\/\/ to manage state that tried to make sure that we never, ever, lost\n\t\t\/\/ any info about an event. If we unload RIGHT HERE, I don't think it's\n\t\t\/\/ going to make a huge difference one way or another. Time will tell.\n\t\t\/\/ and with THAT out of the way, dispatch it!\n\t\tthis.dispatch(e);\n\t\t\/\/ TODO: remove the script block that created the event obj to save\n\t\t\/\/ memory, etc.","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.widenDomain":{"meta":{"summary":"","parameters":{"domainStr":{"type":""}},"src":" \tvar cd = domainStr||document.domain;\n\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");","returns":"mixed","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.parseCookie":{"meta":{"summary":"","src":" \tvar cs = document.cookie;\n\t\tvar keypairs = cs.split(\";\");\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tkeypairs[x] = keypairs[x].split(\"=\");\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\treturn keypairs;","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.setCookie":{"meta":{"summary":"","parameters":{"keypairs":{"type":""},"clobber":{"type":""}},"src":" \tif((clobber)&&(clobber==true)){ document.cookie = \"\"; }\n\t\tvar cs = \"\";\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tcs += keypairs[x][0]+\"=\"+keypairs[x][1];\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\tdocument.cookie = cs;","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.log":{"meta":{"summary":"","parameters":{"str":{"type":""},"lvl":{"type":""}},"src":" \tif(!this.debug){ return; } \/\/ we of course only care if we're in debug mode\n\t\twhile(this.logBacklog.length>0){\n\t\t\tif(!this.canLog){ break; }\n\t\t\tvar blo = this.logBacklog.shift();\n\t\t\tthis.writeLog(\"[\"+blo[0]+\"]: \"+blo[1], blo[2]);\n\t\t}\n\t\tthis.writeLog(str, lvl);","returns":"we of course only care if we're in debug mode","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.writeLog":{"meta":{"summary":"","parameters":{"str":{"type":""},"lvl":{"type":""}},"src":" \tdojo.debug(((new Date()).toLocaleTimeString())+\": \"+str);","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.init":{"meta":{"summary":"","src":" \tthis.widenDomain();\n\t\t\/\/ this.findPeers();\n\t\tthis.openTunnel();\n\t\tthis.isInitialized = true;\n\t\t\/\/ FIXME: this seems like entirely the wrong place to replay the backlog\n\t\twhile(this.subscriptionBacklog.length){\n\t\t\tthis.subscribe.apply(this, this.subscriptionBacklog.shift());\n\t\t}","call_chain":["this.subscribe"],"instance":"dojo.io.repubsub"}},"dojo.io.repubsub.clobber":{"meta":{"summary":"","src":" \tif(this.rcvNode){\n\t\t\tthis.setCookie( [\n\t\t\t\t\t[this.tunnelFrameKey,\"closed\"],\n\t\t\t\t\t[\"path\",\"\/\"]\n\t\t\t\t], false \n\t\t\t);\n\t\t}","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.openTunnel":{"meta":{"summary":"","src":"\t\t\/\/ one for getting data\n\t\tthis.rcvNodeName = \"rcvIFrame_\"+this.getRandStr();\n\t\t\/\/ set cookie that can be used to find the receiving iframe\n\t\tthis.setCookie( [\n\t\t\t\t[this.tunnelFrameKey,this.rcvNodeName],\n\t\t\t\t[\"path\",\"\/\"]\n\t\t\t], false\n\t\t);\n\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.rcvNode, this.initDoc+\"?callback=repubsub.rcvNodeReady&domain=\"+document.domain);\n\t\t\/\/ the other for posting data in reply\n\t\tthis.sndNodeName = \"sndIFrame_\"+this.getRandStr();\n\t\tthis.sndNode = dojo.io.createIFrame(this.sndNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.sndNode, this.initDoc+\"?callback=repubsub.sndNodeReady&domain=\"+document.domain);","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.rcvNodeReady":{"meta":{"summary":"","src":"        var statusURI = [this.tunnelURI, '\/kn_status\/', this.getRandStr(), '_', \n\t\t\t\t\t\t String(this.tunnelInitCount++)].join(\"\"); \n            \/\/ (kn._seqNum++); \/\/ FIXME: !!!!\n\t\t\/\/ this.canRcv = true;\n\t\tthis.log(\"rcvNodeReady\");\n\t\t\/\/ FIXME: initialize receiver and request the base topic\n\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+\"\/kn?do_method=blank\");\n\t\tvar initURIArr = [\tthis.serverBaseURL, \"\/kn?kn_from=\", escape(this.tunnelURI),\n\t\t\t\t\t\t\t\"&kn_id=\", escape(this.tunnelID), \"&kn_status_from=\", \n\t\t\t\t\t\t\tescape(statusURI)];\n\t\t\/\/ FIXME: does the above really need a kn_response_flush? won't the\n\t\t\/\/ \t\t  server already know? If not, what good is it anyway?\n\t\tdojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(\"\"));\n\t\t\/\/ setup a status path listener, but don't tell the server about it,\n\t\t\/\/ since it already knows we're itnerested in our own tunnel status\n\t\tthis.subscribe(statusURI, this, \"statusListener\", true);\n\t\tthis.log(initURIArr.join(\"\"));","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.sndNodeReady":{"meta":{"summary":"","src":" \tthis.canSnd = true;\n\t\tthis.log(\"sndNodeReady\");\n\t\tthis.log(this.backlog.length);\n\t\t\/\/ FIXME: handle any pent-up send commands\n\t\tif(this.backlog.length > 0){\n\t\t\tthis.dequeueEvent();\n\t\t}","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.statusListener":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":" \tthis.log(\"status listener called\");\n\t\tthis.log(evt.status, \"info\");","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.dispatch":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":" \tif(evt[\"to\"]||evt[\"kn_routed_from\"]){\n\t\t\tvar rf = evt[\"to\"]||evt[\"kn_routed_from\"];\n\t\t\t\/\/ split off the base server URL\n\t\t\tvar topic = rf.split(this.serverBaseURL, 2)[1];\n\t\t\tif(!topic){\n\t\t\t\t\/\/ FIXME: how do we recover when we don't get a sane \"from\"? Do\n\t\t\t\t\/\/ we try to route to it anyway?\n\t\t\t\ttopic = rf;\n\t\t\t}\n\t\t\tthis.log(\"[topic] \"+topic);\n\t\t\tif(topic.length>3){\n\t\t\t\tif(topic.slice(0, 3)==\"\/kn\"){\n\t\t\t\t\ttopic = topic.slice(3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.attachPathList[topic]){\n\t\t\t\tthis.attachPathList[topic](evt);\n\t\t\t}\n\t\t}","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.subscribe":{"meta":{"summary":"","parameters":{"topic":{"type":"kn_from in the old terminilogy"},"toObj":{"type":""},"toFunc":{"type":""},"dontTellServer":{"type":""}},"src":" \tif(!this.isInitialized){\n\t\t\tthis.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);\n\t\t\treturn;\n\t\t}\n\t\tif(!this.attachPathList[topic]){\n\t\t\tthis.attachPathList[topic] = function(){ return true; }\n\t\t\tthis.log(\"subscribing to: \"+topic);\n\t\t\tthis.topics.push(topic);\n\t\t}\n\t\tvar revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, \"route\");\n\t\tvar rstr = [this.serverBaseURL+\"\/kn\", revt.toGetString()].join(\"\");\n\t\tdojo.event.kwConnect({\n\t\t\tonce: true,\n\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\/\/ NOTE: the above is a local mapping, if we're not the leader, we\n\t\t\/\/ \t\t should connect our mapping to the topic handler of the peer\n\t\t\/\/ \t\t leader, this ensures that not matter what happens to the\n\t\t\/\/ \t\t leader, we don't really loose our heads if\/when the leader\n\t\t\/\/ \t\t goes away.\n\t\tif(!this.rcvNode){ \/* this should be an error! *\/ }\n\t\tif(dontTellServer){\n\t\t\treturn;\n\t\t}\n\t\tthis.log(\"sending subscription to: \"+topic);\n\t\t\/\/ create a subscription event object and give it all the props we need\n\t\t\/\/ to updates on the specified topic\n\t\t\/\/ FIXME: we should only enqueue if this is our first subscription!\n\t\tthis.sendTopicSubToServer(topic, rstr);","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.sendTopicSubToServer":{"meta":{"summary":"","parameters":{"topic":{"type":""},"str":{"type":""}},"src":" \tif(!this.attachPathList[topic][\"subscriptions\"]){\n\t\t\tthis.enqueueEventStr(str);\n\t\t\tthis.attachPathList[topic].subscriptions = 0;\n\t\t}\n\t\tthis.attachPathList[topic].subscriptions++;","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.unSubscribe":{"meta":{"summary":"","parameters":{"topic":{"type":""},"toObj":{"type":""},"toFunc":{"type":""}},"src":" \tdojo.event.kwDisconnect({\n\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\/\/ FIXME: figure out if there are any remaining listeners to the topic,\n\t\t\/\/ \t\t  and if not, inform the server of our desire not to be\n\t\t\/\/ \t\t  notified of updates to the topic","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.publish":{"meta":{"summary":"","parameters":{"topic":{"type":""},"event":{"type":""}},"src":" \tvar evt = dojo.io.repubsubEvent.initFromProperties(event);\n\t\t\/\/ FIXME: need to make sure we have from and to set correctly\n\t\t\/\/ \t\t  before we serialize and send off to the great blue\n\t\t\/\/ \t\t  younder.\n\t\tevt.to = topic;\n\t\t\/\/ evt.from = this.tunnelURI;\n\t\tvar evtURLParts = [];\n\t\tevtURLParts.push(this.serverBaseURL+\"\/kn\");\n\t\t\/\/ serialize the event to a string and then post it to the correct\n\t\t\/\/ topic\n\t\tevtURLParts.push(evt.toGetString());\n\t\tthis.enqueueEventStr(evtURLParts.join(\"\"));","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.enqueueEventStr":{"meta":{"summary":"","parameters":{"evtStr":{"type":""}},"src":" \tthis.log(\"enqueueEventStr\");\n\t\tthis.backlog.push(evtStr);\n\t\tthis.dequeueEvent();","instance":"dojo.io.repubsub"}},"dojo.io.repubsub.dequeueEvent":{"meta":{"summary":"","parameters":{"force":{"type":""}},"src":" \tthis.log(\"dequeueEvent\");\n\t\tif(this.backlog.length <= 0){ return; }\n\t\tif((this.canSnd)||(force)){\n\t\t\tdojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+\"&callback=repubsub.sndNodeReady\");\n\t\t\tthis.canSnd = false;\n\t\t}else{\n\t\t\tthis.log(\"sndNode not available yet!\", \"debug\");\n\t\t}","instance":"dojo.io.repubsub"}},"dojo.io.repubsubEvent":{"meta":{"summary":"","parameters":{"to":{"type":""},"from":{"type":""},"method":{"type":""},"id":{"type":""},"routeURI":{"type":""},"payload":{"type":""},"dispname":{"type":""},"uid":{"type":""}},"src":" this.to = to;\n\tthis.from = from;\n\tthis.method = method||\"route\";\n\tthis.id = id||repubsub.getRandStr();\n\tthis.uri = routeURI;\n\tthis.displayname = dispname||repubsub.displayname;\n\tthis.userid = uid||repubsub.userid;\n\tthis.payload = payload||\"\";\n\tthis.flushChars = 4096;\n\tthis.initFromProperties = function(evt){\n\t\tif(evt.constructor = dojo.io.repubsubEvent){ \n\t\t\tfor(var x in evt){\n\t\t\t\tthis[x] = evt[x];\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/ we want to copy all the properties of the evt object, and transform\n\t\t\t\/\/ those that are \"stock\" properties of dojo.io.repubsubEvent. All others should\n\t\t\t\/\/ be copied as-is\n\t\t\tfor(var x in evt){\n\t\t\t\tif(typeof this.forwardPropertiesMap[x] == \"string\"){\n\t\t\t\t\tthis[this.forwardPropertiesMap[x]] = evt[x];\n\t\t\t\t}else{\n\t\t\t\t\tthis[x] = evt[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.toGetString = function(noQmark){\n\t\tvar qs = [ ((noQmark) ? \"\" : \"?\") ];\n\t\tfor(var x=0; x<this.properties.length; x++){\n\t\t\tvar tp = this.properties[x];\n\t\t\tif(this[tp[0]]){\n\t\t\t\tqs.push(tp[1]+\"=\"+encodeURIComponent(String(this[tp[0]])));\n\t\t\t}\n\t\t\t\/\/ FIXME: we need to be able to serialize non-stock properties!!!\n\t\t}\n\t\treturn qs.join(\"&\");\n\t}","instance_variables":["to","from","method","id","uri","displayname","userid","payload","flushChars","initFromProperties","toGetString"]}},"dojo.io.repubsubEvent.initFromProperties":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":" var eventObj = new dojo.io.repubsubEvent();\n\teventObj.initFromProperties(evt);\n\treturn eventObj;","instance":"dojo.io.repubsubEvent"}},"dojo.io.repubsubEvent.toGetString":{"meta":{"summary":"","parameters":{"noQmark":{"type":""}},"src":" \tvar qs = [ ((noQmark) ? \"\" : \"?\") ];\n\t\tfor(var x=0; x<this.properties.length; x++){\n\t\t\tvar tp = this.properties[x];\n\t\t\tif(this[tp[0]]){\n\t\t\t\tqs.push(tp[1]+\"=\"+encodeURIComponent(String(this[tp[0]])));\n\t\t\t}\n\t\t\t\/\/ FIXME: we need to be able to serialize non-stock properties!!!\n\t\t}\n\t\treturn qs.join(\"&\");","instance":"dojo.io.repubsubEvent"}}}}},"dojo.io.RhinoIO":{"meta":{"requires":{"common":["dojo.io.common","dojo.lang.func","dojo.lang.array","dojo.string.extras"]},"functions":{"dojo.io.RhinoHTTPTransport":{"meta":{"initialized":true,"summary":"","src":" \tthis.canHandle = function(\/*dojo.io.Request*\/req){\n\t\t\t\/\/summary: Tells dojo.io.bind() if this is a good transport to\n\t\t\t\/\/use for the particular type of request. This type of transport can\n\t\t\t\/\/only be used inside the Rhino JavaScript engine.\n\t\t\t\/\/ We have to limit to text types because Rhino doesnt support \n\t\t\t\/\/ a W3C dom implementation out of the box.  In the future we \n\t\t\t\/\/ should provide some kind of hook to inject your own, because\n\t\t\t\/\/ in all my projects I use XML for Script to provide a W3C DOM.\n\t\t\tif(dojo.lang.find([\"text\/plain\", \"text\/html\", \"text\/xml\", \"text\/javascript\", \"text\/json\", \"application\/json\"],\n\t\t\t\t(req.mimetype.toLowerCase() || \"\")) < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\/\/ We only handle http requests!  Unfortunately, because the method is \n\t\t\t\/\/ protected, I can't directly create a java.net.HttpURLConnection, so\n\t\t\t\/\/ this is the only way to test.\n\t\t\tif(req.url.substr(0, 7) != \"http:\/\/\"){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tfunction doLoad(req, conn){\n\t\t\tvar ret;\n\t\t\tif (req.method.toLowerCase() == \"head\"){\n\t\t\t\t\/\/ TODO: return the headers\n\t\t\t}else{\n\t\t\t\tvar stream = conn.getContent();\n\t\t\t\tvar reader = new java.io.BufferedReader(new java.io.InputStreamReader(stream));\n\t\t\t\t\/\/ read line-by-line because why not?\n\t\t\t\tvar text = \"\";\n\t\t\t\tvar line = null;\n\t\t\t\twhile((line = reader.readLine()) != null){\n\t\t\t\t\ttext += line;\n\t\t\t\t}\n\t\t\t\tif(req.mimetype == \"text\/javascript\"){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tret = dj_eval(text);\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tdojo.debug(e);\n\t\t\t\t\t\tdojo.debug(text);\n\t\t\t\t\t\tret = null;\n\t\t\t\t\t}\n\t\t\t\t}else if(req.mimetype == \"text\/json\" || req.mimetype == \"application\/json\"){\n\t\t\t\t\ttry{\n\t\t\t\t\t\tret = dj_eval(\"(\"+text+\")\");\n\t\t\t\t\t}catch(e){\n\t\t\t\t\t\tdojo.debug(e);\n\t\t\t\t\t\tdojo.debug(text);\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tret = text;\n\t\t\t\t}\n\t\t\t}\n\t\t\treq.load(\"load\", ret, req);\n\t\t}\n\t\tfunction connect(req){\n\t\t\tvar content = req.content || {};\n\t\t\tvar query;\n\t\t\tif (req.sendTransport){\n\t\t\t\tcontent[\"dojo.transport\"] = \"rhinohttp\";\n\t\t\t}\n\t\t\tif(req.postContent){\n\t\t\t\tquery = req.postContent;\n\t\t\t}else{\n\t\t\t\tquery = dojo.io.argsFromMap(content, req.encoding);\n\t\t\t}\n\t\t\tvar url_text = req.url;\n\t\t\tif(req.method.toLowerCase() == \"get\" && query != \"\"){\n\t\t\t\turl_text = url_text + \"?\" + query;\n\t\t\t}\n\t\t\tvar url  = new java.net.URL(url_text);\n\t\t\tvar conn = url.openConnection();\n\t\t\t\/\/\n\t\t\t\/\/ configure the connection\n\t\t\t\/\/\n\t\t\tconn.setRequestMethod(req.method.toUpperCase());\n\t\t\tif(req.headers){\n\t\t\t\tfor(var header in req.headers){\n\t\t\t\t\tif(header.toLowerCase() == \"content-type\" && !req.contentType){\n\t\t\t\t\t\treq.contentType = req.headers[header];\n\t\t\t\t\t}else{\n\t\t\t\t\t\tconn.setRequestProperty(header, req.headers[header]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(req.contentType){\n\t\t\t\tconn.setRequestProperty(\"Content-Type\", req.contentType);\n\t\t\t}\n\t\t\tif(req.method.toLowerCase() == \"post\"){\n\t\t\t\tconn.setDoOutput(true);\n\t\t\t\t\/\/ write the post data\n\t\t\t\tvar output_stream = conn.getOutputStream();\n\t\t\t\tvar byte_array = (new java.lang.String(query)).getBytes();\n\t\t\t\toutput_stream.write(byte_array, 0, byte_array.length);\n\t\t\t}\n\t\t\t\/\/ do it to it!\n\t\t\tconn.connect();\n\t\t\t\/\/ perform the load\n\t\t\tdoLoad(req, conn);\n\t\t}\n\t\tthis.bind = function(req){\n\t\t\t\/\/summary: function that sends the request to the server.\n\t\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\t\/\/normal dojo.io.Request object properties).\n\t\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\t\/\/method: String: the HTTP method to use (GET, POST, etc...).\n\t\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Values of\n\t\t\t\/\/\t\ttext\/javascript, text\/json, and application\/json will cause the transport\n\t\t\t\/\/\t\tto evaluate the response as JavaScript\/JSON. Any other mimetype will give back a text\n\t\t\t\/\/\t\tstring.\n\t\t\t\/\/transport: String: specify \"RhinoHTTPTransport\" to force the use of this transport.\n\t\t\t\/\/sync: boolean: if true, then a synchronous XMLHttpRequest call is done,\n\t\t\t\/\/\t\tif false (the default), then an asynchronous call is used.\n\t\t\t\/\/headers: Object: The object property names and values will be sent as HTTP request header\n\t\t\t\/\/\t\tnames and values.\n\t\t\t\/\/encoding: String: The type of encoding to use when dealing with the content kwArgs property.\n\t\t\t\/\/content: Object: The content object is converted into a name=value&name=value string, by\n\t\t\t\/\/\t\tusing dojo.io.argsFromMap(). The encoding kwArgs property is passed to dojo.io.argsFromMap()\n\t\t\t\/\/\t\tfor use in encoding the names and values. The resulting string is added to the request.\n\t\t\t\/\/postContent: String: Raw name=value&name=value string to be included as part of the request.\n\t\t\tvar async = req[\"sync\"] ? false : true;\n\t\t\tif (async){\n\t\t\t\tsetTimeout(dojo.lang.hitch(this, function(){\n\t\t\t\t\tconnect(req);\n\t\t\t\t}), 1);\n\t\t\t} else {\n\t\t\t\tconnect(req);\n\t\t\t}\n\t\t}\n\t\tdojo.io.transports.addTransport(\"RhinoHTTPTransport\");","instance_variables":["canHandle","bind"]}},"dojo.io.RhinoHTTPTransport.canHandle":{"meta":{"summary":"Tells dojo.io.bind() if this is a good transport to use for the particular type of request. This type of transport can only be used inside the Rhino JavaScript engine.","parameters":{"req":{"type":"dojo.io.Request"}},"src":"\t\t\t\/\/ We have to limit to text types because Rhino doesnt support \n\t\t\t\/\/ a W3C dom implementation out of the box.  In the future we \n\t\t\t\/\/ should provide some kind of hook to inject your own, because\n\t\t\t\/\/ in all my projects I use XML for Script to provide a W3C DOM.\n\t\t\tif(dojo.lang.find([\"text\/plain\", \"text\/html\", \"text\/xml\", \"text\/javascript\", \"text\/json\", \"application\/json\"],\n\t\t\t\t(req.mimetype.toLowerCase() || \"\")) < 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\/\/ We only handle http requests!  Unfortunately, because the method is \n\t\t\t\/\/ protected, I can't directly create a java.net.HttpURLConnection, so\n\t\t\t\/\/ this is the only way to test.\n\t\t\tif(req.url.substr(0, 7) != \"http:\/\/\"){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;","instance":"dojo.io.RhinoHTTPTransport"}},"dojo.io.RhinoHTTPTransport.bind":{"meta":{"summary":"function that sends the request to the server.","parameters":{"req":{"type":""}},"src":"\t\t\t\/\/The following are acceptable properties in kwArgs (in addition to the\n\t\t\t\/\/normal dojo.io.Request object properties).\n\t\t\t\/\/url: String: URL the server URL to use for the request.\n\t\t\t\/\/method: String: the HTTP method to use (GET, POST, etc...).\n\t\t\t\/\/mimetype: Specifies what format the result data should be given to the load\/handle callback. Values of\n\t\t\t\/\/\t\ttext\/javascript, text\/json, and application\/json will cause the transport\n\t\t\t\/\/\t\tto evaluate the response as JavaScript\/JSON. Any other mimetype will give back a text\n\t\t\t\/\/\t\tstring.\n\t\t\t\/\/transport: String: specify \"RhinoHTTPTransport\" to force the use of this transport.\n\t\t\t\/\/sync: boolean: if true, then a synchronous XMLHttpRequest call is done,\n\t\t\t\/\/\t\tif false (the default), then an asynchronous call is used.\n\t\t\t\/\/headers: Object: The object property names and values will be sent as HTTP request header\n\t\t\t\/\/\t\tnames and values.\n\t\t\t\/\/encoding: String: The type of encoding to use when dealing with the content kwArgs property.\n\t\t\t\/\/content: Object: The content object is converted into a name=value&name=value string, by\n\t\t\t\/\/\t\tusing dojo.io.argsFromMap(). The encoding kwArgs property is passed to dojo.io.argsFromMap()\n\t\t\t\/\/\t\tfor use in encoding the names and values. The resulting string is added to the request.\n\t\t\t\/\/postContent: String: Raw name=value&name=value string to be included as part of the request.\n\t\t\tvar async = req[\"sync\"] ? false : true;\n\t\t\tif (async){\n\t\t\t\tsetTimeout(dojo.lang.hitch(this, function(){\n\t\t\t\t\tconnect(req);\n\t\t\t\t}), 1);\n\t\t\t} else {\n\t\t\t\tconnect(req);\n\t\t\t}","instance":"dojo.io.RhinoHTTPTransport"}}}}},"dojo.io.ScriptSrcIO":{"meta":{"requires":{"common":["dojo.io.BrowserIO","dojo.undo.browser"]},"functions":{"dojo.io.ScriptSrcTransport":{"meta":{"initialized":true,"summary":"","src":" this.preventCache = false; \/\/ if this is true, we'll always force GET requests to not cache\n\tthis.maxUrlLength = 1000; \/\/Used to calculate if script request should be multipart.\n\tthis.inFlightTimer = null;\n\tthis.DsrStatusCodes = {\n\t\tContinue: 100,\n\t\tOk: 200,\n\t\tError: 500\n\t};\n\tthis.startWatchingInFlight = function(){\n\t\t\/\/summary: Internal method to start the process of watching for in-flight requests.\n\t\tif(!this.inFlightTimer){\n\t\t\tthis.inFlightTimer = setInterval(\"dojo.io.ScriptSrcTransport.watchInFlight();\", 100);\n\t\t}\n\t}\n\tthis.watchInFlight = function(){\n\t\t\/\/summary: Internal method to watch for in-flight requests.\n\t\tvar totalCount = 0;\n\t\tvar doneCount = 0;\n\t\tfor(var param in this._state){\n\t\t\ttotalCount++;\n\t\t\tvar currentState = this._state[param];\n\t\t\tif(currentState.isDone){\n\t\t\t\tdoneCount++;\n\t\t\t\tdelete this._state[param];\n\t\t\t}else if(!currentState.isFinishing){\n\t\t\t\tvar listener = currentState.kwArgs;\n\t\t\t\ttry{\n\t\t\t\t\tif(currentState.checkString && eval(\"typeof(\" + currentState.checkString + \") != 'undefined'\")){\n\t\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\t\tthis._finish(currentState, \"load\");\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t}else if(listener.timeoutSeconds && listener.timeout){\n\t\t\t\t\t\tif(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){\n\t\t\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\t\t\tthis._finish(currentState, \"timeout\");\n\t\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(!listener.timeoutSeconds){\n\t\t\t\t\t\t\/\/Increment the done count if no timeout is specified, so\n\t\t\t\t\t\t\/\/that we turn off the timer if all that is left in the state\n\t\t\t\t\t\t\/\/list are things we can't clean up because they fail without\n\t\t\t\t\t\t\/\/getting a callback.\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\tthis._finish(currentState, \"error\", {status: this.DsrStatusCodes.Error, response: e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(doneCount >= totalCount){\n\t\t\tclearInterval(this.inFlightTimer);\n\t\t\tthis.inFlightTimer = null;\n\t\t}\n\t}\n\tthis.canHandle = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: Tells dojo.io.bind() if this is a good transport to\n\t\t\/\/use for the particular type of request. This type of transport can only\n\t\t\/\/handle responses that are JavaScript or JSON that is passed to a JavaScript\n\t\t\/\/callback. It can only do asynchronous binds, is limited to GET HTTP method\n\t\t\/\/requests, and cannot handle formNodes. However, it has the advantage of being\n\t\t\/\/able to do cross-domain requests.\n\t\treturn dojo.lang.inArray([\"text\/javascript\", \"text\/json\", \"application\/json\"], (kwArgs[\"mimetype\"].toLowerCase()))\n\t\t\t&& (kwArgs[\"method\"].toLowerCase() == \"get\")\n\t\t\t&& !(kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]))\n\t\t\t&& (!kwArgs[\"sync\"] || kwArgs[\"sync\"] == false)\n\t\t\t&& !kwArgs[\"file\"]\n\t\t\t&& !kwArgs[\"multipart\"];\n\t}\n\tthis.removeScripts = function(){\n\t\t\/\/summary: Removes any script tags from the DOM that may have been added by ScriptSrcTransport.\n\t\t\/\/description: Be careful though, by removing them from the script, you may invalidate some\n\t\t\/\/script objects that were defined by the js file that was pulled in as the\n\t\t\/\/src of the script tag. Test carefully if you decide to call this method.\n\t\t\/\/In MSIE 6 (and probably 5.x), if you remove the script element while \n\t\t\/\/part of the response script is still executing, the browser might crash.\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; scripts && i < scripts.length; i++){\n\t\t\tvar scriptTag = scripts[i];\n\t\t\tif(scriptTag.className == \"ScriptSrcTransport\"){\n\t\t\t\tvar parent = scriptTag.parentNode;\n\t\t\t\tparent.removeChild(scriptTag);\n\t\t\t\ti--; \/\/Set the index back one since we removed an item.\n\t\t\t}\n\t\t}\n\t}\n\tthis.bind = function(\/*dojo.io.Request*\/kwArgs){\n\t\t\/\/summary: function that sends the request to the server.\n\t\t\/\/description: See the Dojo Book page on this transport for a full\n\t\t\/\/description of supported kwArgs properties and usage:\n\t\t\/\/http:\/\/manual.dojotoolkit.org\/WikiHome\/DojoDotBook\/Book25\n\t\t\/\/START duplication from BrowserIO.js (some changes made)\n\t\tvar url = kwArgs.url;\n\t\tvar query = \"\";\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\t\t\/\/Break off the domain\/path of the URL.\n\t\tvar urlParts = url.split(\"?\");\n\t\tif(urlParts && urlParts.length == 2){\n\t\t\turl = urlParts[0];\n\t\t\tquery += (query ? \"&\" : \"\") + urlParts[1];\n\t\t}\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\t\t\/\/Create an ID for the request.\n\t\tvar id = kwArgs[\"apiId\"] ? kwArgs[\"apiId\"] : \"id\" + this._counter++;\n\t\t\/\/Fill out any other content pieces.\n\t\tvar content = kwArgs[\"content\"];\n\t\tvar jsonpName = kwArgs.jsonParamName;\n\t\tif(kwArgs.sendTransport || jsonpName) {\n\t\t\tif (!content){\n\t\t\t\tcontent = {};\n\t\t\t}\n\t\t\tif(kwArgs.sendTransport){\n\t\t\t\tcontent[\"dojo.transport\"] = \"scriptsrc\";\n\t\t\t}\n\t\t\tif(jsonpName){\n\t\t\t\tcontent[jsonpName] = \"dojo.io.ScriptSrcTransport._state.\" + id + \".jsonpCall\";\n\t\t\t}\n\t\t}\n\t\tif(kwArgs.postContent){\n\t\t\tquery = kwArgs.postContent;\n\t\t}else if(content){\n\t\t\tquery += ((query) ? \"&\" : \"\") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);\n\t\t}\n\t\t\/\/END duplication from BrowserIO.js\n\t\t\/\/START DSR\n\t\t\/\/If an apiId is specified, then we want to make sure useRequestId is true.\n\t\tif(kwArgs[\"apiId\"]){\n\t\t\tkwArgs[\"useRequestId\"] = true;\n\t\t}\n\t\t\/\/Set up the state for this request.\n\t\tvar state = {\n\t\t\t\"id\": id,\n\t\t\t\"idParam\": \"_dsrid=\" + id,\n\t\t\t\"url\": url,\n\t\t\t\"query\": query,\n\t\t\t\"kwArgs\": kwArgs,\n\t\t\t\"startTime\": (new Date()).getTime(),\n\t\t\t\"isFinishing\": false\n\t\t};\n\t\tif(!url){\n\t\t\t\/\/Error. An URL is needed.\n\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.none\"});\n\t\t\treturn;\n\t\t}\n\t\t\/\/If this is a jsonp request, intercept the jsonp callback\n\t\tif(content && content[jsonpName]){\n\t\t\tstate.jsonp = content[jsonpName];\n\t\t\tstate.jsonpCall = function(data){\n\t\t\t\tif(data[\"Error\"]||data[\"error\"]){\n\t\t\t\t\tif(dojo[\"json\"] && dojo[\"json\"][\"serialize\"]){\n\t\t\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\t\t}\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"error\", data);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"load\", data);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\/\/Only store the request state on the state tracking object if a callback\n\t\t\/\/is expected or if polling on a checkString will be done.\n\t\tif(kwArgs[\"useRequestId\"] || kwArgs[\"checkString\"] || state[\"jsonp\"]){\n\t\t\tthis._state[id] = state;\n\t\t}\n\t\t\/\/A checkstring is a string that if evaled will not be undefined once the\n\t\t\/\/script src loads. Used as an alternative to depending on a callback from\n\t\t\/\/the script file. If this is set, then multipart is not assumed to be used,\n\t\t\/\/since multipart requires a specific callback. With checkString we will be doing\n\t\t\/\/polling.\n\t\tif(kwArgs[\"checkString\"]){\n\t\t\tstate.checkString = kwArgs[\"checkString\"];\n\t\t}\n\t\t\/\/Constant params are parameters that should always be sent with each\n\t\t\/\/part of a multipart URL.\n\t\tstate.constantParams = (kwArgs[\"constantParams\"] == null ? \"\" : kwArgs[\"constantParams\"]);\n\t\tif(kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false)){\n\t\t\tstate.nocacheParam = \"dojo.preventCache=\" + new Date().valueOf();\n\t\t}else{\n\t\t\tstate.nocacheParam = \"\";\n\t\t}\n\t\t\/\/Get total length URL, if we were to do it as one URL.\n\t\t\/\/Add some padding, extra & separators.\n\t\tvar urlLength = state.url.length + state.query.length + state.constantParams.length \n\t\t\t\t+ state.nocacheParam.length + this._extraPaddingLength;\n\t\tif(kwArgs[\"useRequestId\"]){\n\t\t\turlLength += state.idParam.length;\n\t\t}\n\t\tif(!kwArgs[\"checkString\"] && kwArgs[\"useRequestId\"] \n\t\t\t&& !state[\"jsonp\"] && !kwArgs[\"forceSingleRequest\"]\n\t\t\t&& urlLength > this.maxUrlLength){\n\t\t\tif(url > this.maxUrlLength){\n\t\t\t\t\/\/Error. The URL domain and path are too long. We can't\n\t\t\t\t\/\/segment that, so return an error.\n\t\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.tooBig\"});\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\t\/\/Start the multiple requests.\n\t\t\t\tthis._multiAttach(state, 1);\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/Send one URL.\n\t\t\tvar queryParams = [state.constantParams, state.nocacheParam, state.query];\n\t\t\tif(kwArgs[\"useRequestId\"] && !state[\"jsonp\"]){\n\t\t\t\tqueryParams.unshift(state.idParam);\n\t\t\t}\n\t\t\tvar finalUrl = this._buildUrl(state.url, queryParams);\n\t\t\t\/\/Track the final URL in case we need to use that instead of api ID when receiving\n\t\t\t\/\/the load callback.\n\t\t\tstate.finalUrl = finalUrl;\n\t\t\tthis._attach(state.id, finalUrl);\n\t\t}\n\t\t\/\/END DSR\n\t\tthis.startWatchingInFlight();\n\t}\n\t\/\/Private properties\/methods\n\tthis._counter = 1;\n\tthis._state = {};\n\tthis._extraPaddingLength = 16;\n\t\/\/Is there a dojo function for this already?\n\tthis._buildUrl = function(url, nameValueArray){\n\t\tvar finalUrl = url;\n\t\tvar joiner = \"?\";\n\t\tfor(var i = 0; i < nameValueArray.length; i++){\n\t\t\tif(nameValueArray[i]){\n\t\t\t\tfinalUrl += joiner + nameValueArray[i];\n\t\t\t\tjoiner = \"&\";\n\t\t\t}\n\t\t}\n\t\treturn finalUrl;\n\t}\n\tthis._attach = function(id, url){\n\t\t\/\/Attach the script to the DOM.\n\t\tvar element = document.createElement(\"script\");\n\t\telement.type = \"text\/javascript\";\n\t\telement.src = url;\n\t\telement.id = id;\n\t\telement.className = \"ScriptSrcTransport\";\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(element);\n\t}\n\tthis._multiAttach = function(state, part){\n\t\t\/\/Check to make sure we still have a query to send up. This is mostly\n\t\t\/\/a protection from a goof on the server side when it sends a part OK\n\t\t\/\/response instead of a final response.\n\t\tif(state.query == null){\n\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"query.null\"});\n\t\t\treturn;\n\t\t}\n\t\tif(!state.constantParams){\n\t\t\tstate.constantParams = \"\";\n\t\t}\n\t\t\/\/How much of the query can we take?\n\t\t\/\/Add a padding constant to account for _part and a couple extra amperstands.\n\t\t\/\/Also add space for id since we'll need it now.\n\t\tvar queryMax = this.maxUrlLength - state.idParam.length\n\t\t\t\t\t - state.constantParams.length - state.url.length\n\t\t\t\t\t - state.nocacheParam.length - this._extraPaddingLength;\n\t\t\/\/Figure out if this is the last part.\n\t\tvar isDone = state.query.length < queryMax;\n\t\t\/\/Break up the query string if necessary.\n\t\tvar currentQuery;\n\t\tif(isDone){\n\t\t\tcurrentQuery = state.query;\n\t\t\tstate.query = null;\n\t\t}else{\n\t\t\t\/\/Find the & or = nearest the max url length.\n\t\t\tvar ampEnd = state.query.lastIndexOf(\"&\", queryMax - 1);\n\t\t\tvar eqEnd = state.query.lastIndexOf(\"=\", queryMax - 1);\n\t\t\t\/\/See if & is closer, or if = is right at the edge,\n\t\t\t\/\/which means we should put it on the next URL.\n\t\t\tif(ampEnd > eqEnd || eqEnd == queryMax - 1){\n\t\t\t\t\/\/& is nearer the end. So just chop off from there.\n\t\t\t\tcurrentQuery = state.query.substring(0, ampEnd);\n\t\t\t\tstate.query = state.query.substring(ampEnd + 1, state.query.length) \/\/strip off amperstand with the + 1.\n\t\t\t}else{\n\t\t\t\t\/\/= is nearer the end. Take the max amount possible. \n\t\t\t\tcurrentQuery = state.query.substring(0, queryMax);\n\t\t\t\t\/\/Find the last query name in the currentQuery so we can prepend it to\n\t\t\t\t\/\/ampEnd. Could be -1 (not there), so account for that.\n\t\t\t\tvar queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);\n\t\t\t\tstate.query = queryName + \"=\" + state.query.substring(queryMax, state.query.length);\n\t\t\t}\n\t\t}\n\t\t\/\/Now send a part of the script\n\t\tvar queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];\n\t\tif(!isDone){\n\t\t\tqueryParams.push(\"_part=\" + part);\n\t\t}\n\t\tvar url = this._buildUrl(state.url, queryParams);\n\t\tthis._attach(state.id + \"_\" + part, url);\n\t}\n\tthis._finish = function(state, callback, event){\n\t\tif(callback != \"partOk\" && !state.kwArgs[callback] && !state.kwArgs[\"handle\"]){\n\t\t\t\/\/Ignore \"partOk\" because that is an internal callback.\n\t\t\tif(callback == \"error\"){\n\t\t\t\tstate.isDone = true;\n\t\t\t\tthrow event;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(callback){\n\t\t\t\tcase \"load\":\n\t\t\t\t\tvar response = event ? event.response : null;\n\t\t\t\t\tif(!response){\n\t\t\t\t\t\tresponse = event;\n\t\t\t\t\t}\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.load == \"function\") ? \"load\" : \"handle\"](\"load\", response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"partOk\":\n\t\t\t\t\tvar part = parseInt(event.response.part, 10) + 1;\n\t\t\t\t\t\/\/Update the constant params, if any.\n\t\t\t\t\tif(event.response.constantParams){\n\t\t\t\t\t\tstate.constantParams = event.response.constantParams;\n\t\t\t\t\t}\n\t\t\t\t\tthis._multiAttach(state, part);\n\t\t\t\t\tstate.isDone = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.error == \"function\") ? \"error\" : \"handle\"](\"error\", event.response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs[callback] == \"function\") ? callback : \"handle\"](callback, event, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t}\n\t\t}\n\t}\n\tdojo.io.transports.addTransport(\"ScriptSrcTransport\");","instance_variables":["preventCache","maxUrlLength","inFlightTimer","DsrStatusCodes","startWatchingInFlight","watchInFlight","canHandle","removeScripts","bind","_counter","_state","_extraPaddingLength","_buildUrl","_attach","_multiAttach","_finish"]}},"dojo.io.ScriptSrcTransport.startWatchingInFlight":{"meta":{"summary":"Internal method to start the process of watching for in-flight requests.","src":" \tif(!this.inFlightTimer){\n\t\t\tthis.inFlightTimer = setInterval(\"dojo.io.ScriptSrcTransport.watchInFlight();\", 100);\n\t\t}","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport.watchInFlight":{"meta":{"summary":"Internal method to watch for in-flight requests.","src":" \tvar totalCount = 0;\n\t\tvar doneCount = 0;\n\t\tfor(var param in this._state){\n\t\t\ttotalCount++;\n\t\t\tvar currentState = this._state[param];\n\t\t\tif(currentState.isDone){\n\t\t\t\tdoneCount++;\n\t\t\t\tdelete this._state[param];\n\t\t\t}else if(!currentState.isFinishing){\n\t\t\t\tvar listener = currentState.kwArgs;\n\t\t\t\ttry{\n\t\t\t\t\tif(currentState.checkString && eval(\"typeof(\" + currentState.checkString + \") != 'undefined'\")){\n\t\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\t\tthis._finish(currentState, \"load\");\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t}else if(listener.timeoutSeconds && listener.timeout){\n\t\t\t\t\t\tif(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){\n\t\t\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\t\t\tthis._finish(currentState, \"timeout\");\n\t\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(!listener.timeoutSeconds){\n\t\t\t\t\t\t\/\/Increment the done count if no timeout is specified, so\n\t\t\t\t\t\t\/\/that we turn off the timer if all that is left in the state\n\t\t\t\t\t\t\/\/list are things we can't clean up because they fail without\n\t\t\t\t\t\t\/\/getting a callback.\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\tcurrentState.isFinishing = true;\n\t\t\t\t\tthis._finish(currentState, \"error\", {status: this.DsrStatusCodes.Error, response: e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(doneCount >= totalCount){\n\t\t\tclearInterval(this.inFlightTimer);\n\t\t\tthis.inFlightTimer = null;\n\t\t}","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport.canHandle":{"meta":{"summary":"Tells dojo.io.bind() if this is a good transport to use for the particular type of request. This type of transport can only handle responses that are JavaScript or JSON that is passed to a JavaScript callback. It can only do asynchronous binds, is limited to GET HTTP method requests, and cannot handle formNodes. However, it has the advantage of being able to do cross-domain requests.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":"\t\treturn dojo.lang.inArray([\"text\/javascript\", \"text\/json\", \"application\/json\"], (kwArgs[\"mimetype\"].toLowerCase()))\n\t\t\t&& (kwArgs[\"method\"].toLowerCase() == \"get\")\n\t\t\t&& !(kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]))\n\t\t\t&& (!kwArgs[\"sync\"] || kwArgs[\"sync\"] == false)\n\t\t\t&& !kwArgs[\"file\"]\n\t\t\t&& !kwArgs[\"multipart\"];","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport.removeScripts":{"meta":{"summary":"Removes any script tags from the DOM that may have been added by ScriptSrcTransport.","src":" \tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; scripts && i < scripts.length; i++){\n\t\t\tvar scriptTag = scripts[i];\n\t\t\tif(scriptTag.className == \"ScriptSrcTransport\"){\n\t\t\t\tvar parent = scriptTag.parentNode;\n\t\t\t\tparent.removeChild(scriptTag);\n\t\t\t\ti--; \/\/Set the index back one since we removed an item.\n\t\t\t}\n\t\t}","description":"Be careful though, by removing them from the script, you may invalidate some script objects that were defined by the js file that was pulled in as the src of the script tag. Test carefully if you decide to call this method. In MSIE 6 (and probably 5.x), if you remove the script element while part of the response script is still executing, the browser might crash.","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport.bind":{"meta":{"summary":"function that sends the request to the server.","parameters":{"kwArgs":{"type":"dojo.io.Request"}},"src":"\t\t\/\/START duplication from BrowserIO.js (some changes made)\n\t\tvar url = kwArgs.url;\n\t\tvar query = \"\";\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\t\t\/\/Break off the domain\/path of the URL.\n\t\tvar urlParts = url.split(\"?\");\n\t\tif(urlParts && urlParts.length == 2){\n\t\t\turl = urlParts[0];\n\t\t\tquery += (query ? \"&\" : \"\") + urlParts[1];\n\t\t}\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\t\t\/\/Create an ID for the request.\n\t\tvar id = kwArgs[\"apiId\"] ? kwArgs[\"apiId\"] : \"id\" + this._counter++;\n\t\t\/\/Fill out any other content pieces.\n\t\tvar content = kwArgs[\"content\"];\n\t\tvar jsonpName = kwArgs.jsonParamName;\n\t\tif(kwArgs.sendTransport || jsonpName) {\n\t\t\tif (!content){\n\t\t\t\tcontent = {};\n\t\t\t}\n\t\t\tif(kwArgs.sendTransport){\n\t\t\t\tcontent[\"dojo.transport\"] = \"scriptsrc\";\n\t\t\t}\n\t\t\tif(jsonpName){\n\t\t\t\tcontent[jsonpName] = \"dojo.io.ScriptSrcTransport._state.\" + id + \".jsonpCall\";\n\t\t\t}\n\t\t}\n\t\tif(kwArgs.postContent){\n\t\t\tquery = kwArgs.postContent;\n\t\t}else if(content){\n\t\t\tquery += ((query) ? \"&\" : \"\") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);\n\t\t}\n\t\t\/\/END duplication from BrowserIO.js\n\t\t\/\/START DSR\n\t\t\/\/If an apiId is specified, then we want to make sure useRequestId is true.\n\t\tif(kwArgs[\"apiId\"]){\n\t\t\tkwArgs[\"useRequestId\"] = true;\n\t\t}\n\t\t\/\/Set up the state for this request.\n\t\tvar state = {\n\t\t\t\"id\": id,\n\t\t\t\"idParam\": \"_dsrid=\" + id,\n\t\t\t\"url\": url,\n\t\t\t\"query\": query,\n\t\t\t\"kwArgs\": kwArgs,\n\t\t\t\"startTime\": (new Date()).getTime(),\n\t\t\t\"isFinishing\": false\n\t\t};\n\t\tif(!url){\n\t\t\t\/\/Error. An URL is needed.\n\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.none\"});\n\t\t\treturn;\n\t\t}\n\t\t\/\/If this is a jsonp request, intercept the jsonp callback\n\t\tif(content && content[jsonpName]){\n\t\t\tstate.jsonp = content[jsonpName];\n\t\t\tstate.jsonpCall = function(data){\n\t\t\t\tif(data[\"Error\"]||data[\"error\"]){\n\t\t\t\t\tif(dojo[\"json\"] && dojo[\"json\"][\"serialize\"]){\n\t\t\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\t\t}\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"error\", data);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"load\", data);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t\/\/Only store the request state on the state tracking object if a callback\n\t\t\/\/is expected or if polling on a checkString will be done.\n\t\tif(kwArgs[\"useRequestId\"] || kwArgs[\"checkString\"] || state[\"jsonp\"]){\n\t\t\tthis._state[id] = state;\n\t\t}\n\t\t\/\/A checkstring is a string that if evaled will not be undefined once the\n\t\t\/\/script src loads. Used as an alternative to depending on a callback from\n\t\t\/\/the script file. If this is set, then multipart is not assumed to be used,\n\t\t\/\/since multipart requires a specific callback. With checkString we will be doing\n\t\t\/\/polling.\n\t\tif(kwArgs[\"checkString\"]){\n\t\t\tstate.checkString = kwArgs[\"checkString\"];\n\t\t}\n\t\t\/\/Constant params are parameters that should always be sent with each\n\t\t\/\/part of a multipart URL.\n\t\tstate.constantParams = (kwArgs[\"constantParams\"] == null ? \"\" : kwArgs[\"constantParams\"]);\n\t\tif(kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false)){\n\t\t\tstate.nocacheParam = \"dojo.preventCache=\" + new Date().valueOf();\n\t\t}else{\n\t\t\tstate.nocacheParam = \"\";\n\t\t}\n\t\t\/\/Get total length URL, if we were to do it as one URL.\n\t\t\/\/Add some padding, extra & separators.\n\t\tvar urlLength = state.url.length + state.query.length + state.constantParams.length \n\t\t\t\t+ state.nocacheParam.length + this._extraPaddingLength;\n\t\tif(kwArgs[\"useRequestId\"]){\n\t\t\turlLength += state.idParam.length;\n\t\t}\n\t\tif(!kwArgs[\"checkString\"] && kwArgs[\"useRequestId\"] \n\t\t\t&& !state[\"jsonp\"] && !kwArgs[\"forceSingleRequest\"]\n\t\t\t&& urlLength > this.maxUrlLength){\n\t\t\tif(url > this.maxUrlLength){\n\t\t\t\t\/\/Error. The URL domain and path are too long. We can't\n\t\t\t\t\/\/segment that, so return an error.\n\t\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.tooBig\"});\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\t\/\/Start the multiple requests.\n\t\t\t\tthis._multiAttach(state, 1);\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/Send one URL.\n\t\t\tvar queryParams = [state.constantParams, state.nocacheParam, state.query];\n\t\t\tif(kwArgs[\"useRequestId\"] && !state[\"jsonp\"]){\n\t\t\t\tqueryParams.unshift(state.idParam);\n\t\t\t}\n\t\t\tvar finalUrl = this._buildUrl(state.url, queryParams);\n\t\t\t\/\/Track the final URL in case we need to use that instead of api ID when receiving\n\t\t\t\/\/the load callback.\n\t\t\tstate.finalUrl = finalUrl;\n\t\t\tthis._attach(state.id, finalUrl);\n\t\t}\n\t\t\/\/END DSR\n\t\tthis.startWatchingInFlight();","description":"of supported kwArgs properties and usage: http: \/\/ manual.dojotoolkit.org\/WikiHome\/DojoDotBook\/Book25","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport._buildUrl":{"meta":{"summary":"","parameters":{"url":{"type":""},"nameValueArray":{"type":""}},"src":" \tvar finalUrl = url;\n\t\tvar joiner = \"?\";\n\t\tfor(var i = 0; i < nameValueArray.length; i++){\n\t\t\tif(nameValueArray[i]){\n\t\t\t\tfinalUrl += joiner + nameValueArray[i];\n\t\t\t\tjoiner = \"&\";\n\t\t\t}\n\t\t}\n\t\treturn finalUrl;","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport._attach":{"meta":{"summary":"","parameters":{"id":{"type":""},"url":{"type":""}},"src":" \tvar element = document.createElement(\"script\");\n\t\telement.type = \"text\/javascript\";\n\t\telement.src = url;\n\t\telement.id = id;\n\t\telement.className = \"ScriptSrcTransport\";\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(element);","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport._multiAttach":{"meta":{"summary":"","parameters":{"state":{"type":""},"part":{"type":""}},"src":" \tif(state.query == null){\n\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"query.null\"});\n\t\t\treturn;\n\t\t}\n\t\tif(!state.constantParams){\n\t\t\tstate.constantParams = \"\";\n\t\t}\n\t\t\/\/How much of the query can we take?\n\t\t\/\/Add a padding constant to account for _part and a couple extra amperstands.\n\t\t\/\/Also add space for id since we'll need it now.\n\t\tvar queryMax = this.maxUrlLength - state.idParam.length\n\t\t\t\t\t - state.constantParams.length - state.url.length\n\t\t\t\t\t - state.nocacheParam.length - this._extraPaddingLength;\n\t\t\/\/Figure out if this is the last part.\n\t\tvar isDone = state.query.length < queryMax;\n\t\t\/\/Break up the query string if necessary.\n\t\tvar currentQuery;\n\t\tif(isDone){\n\t\t\tcurrentQuery = state.query;\n\t\t\tstate.query = null;\n\t\t}else{\n\t\t\t\/\/Find the & or = nearest the max url length.\n\t\t\tvar ampEnd = state.query.lastIndexOf(\"&\", queryMax - 1);\n\t\t\tvar eqEnd = state.query.lastIndexOf(\"=\", queryMax - 1);\n\t\t\t\/\/See if & is closer, or if = is right at the edge,\n\t\t\t\/\/which means we should put it on the next URL.\n\t\t\tif(ampEnd > eqEnd || eqEnd == queryMax - 1){\n\t\t\t\t\/\/& is nearer the end. So just chop off from there.\n\t\t\t\tcurrentQuery = state.query.substring(0, ampEnd);\n\t\t\t\tstate.query = state.query.substring(ampEnd + 1, state.query.length) \/\/strip off amperstand with the + 1.\n\t\t\t}else{\n\t\t\t\t\/\/= is nearer the end. Take the max amount possible. \n\t\t\t\tcurrentQuery = state.query.substring(0, queryMax);\n\t\t\t\t\/\/Find the last query name in the currentQuery so we can prepend it to\n\t\t\t\t\/\/ampEnd. Could be -1 (not there), so account for that.\n\t\t\t\tvar queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);\n\t\t\t\tstate.query = queryName + \"=\" + state.query.substring(queryMax, state.query.length);\n\t\t\t}\n\t\t}\n\t\t\/\/Now send a part of the script\n\t\tvar queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];\n\t\tif(!isDone){\n\t\t\tqueryParams.push(\"_part=\" + part);\n\t\t}\n\t\tvar url = this._buildUrl(state.url, queryParams);\n\t\tthis._attach(state.id + \"_\" + part, url);","instance":"dojo.io.ScriptSrcTransport"}},"dojo.io.ScriptSrcTransport._finish":{"meta":{"summary":"","parameters":{"state":{"type":""},"callback":{"type":""},"event":{"type":""}},"src":" \tif(callback != \"partOk\" && !state.kwArgs[callback] && !state.kwArgs[\"handle\"]){\n\t\t\t\/\/Ignore \"partOk\" because that is an internal callback.\n\t\t\tif(callback == \"error\"){\n\t\t\t\tstate.isDone = true;\n\t\t\t\tthrow event;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(callback){\n\t\t\t\tcase \"load\":\n\t\t\t\t\tvar response = event ? event.response : null;\n\t\t\t\t\tif(!response){\n\t\t\t\t\t\tresponse = event;\n\t\t\t\t\t}\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.load == \"function\") ? \"load\" : \"handle\"](\"load\", response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"partOk\":\n\t\t\t\t\tvar part = parseInt(event.response.part, 10) + 1;\n\t\t\t\t\t\/\/Update the constant params, if any.\n\t\t\t\t\tif(event.response.constantParams){\n\t\t\t\t\t\tstate.constantParams = event.response.constantParams;\n\t\t\t\t\t}\n\t\t\t\t\tthis._multiAttach(state, part);\n\t\t\t\t\tstate.isDone = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.error == \"function\") ? \"error\" : \"handle\"](\"error\", event.response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs[callback] == \"function\") ? callback : \"handle\"](callback, event, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t}\n\t\t}","instance":"dojo.io.ScriptSrcTransport"}},"window.onscriptload":{"meta":{"summary":"","parameters":{"event":{"type":""}},"src":" var state = null;\n\tvar transport = dojo.io.ScriptSrcTransport;\n\t\/\/Find the matching state object for event ID.\n\tif(transport._state[event.id]){\n\t\tstate = transport._state[event.id];\n\t}else{\n\t\t\/\/The ID did not match directly to an entry in the state list.\n\t\t\/\/Try searching the state objects for a matching original URL.\n\t\tvar tempState;\n\t\tfor(var param in transport._state){\n\t\t\ttempState = transport._state[param];\n\t\t\tif(tempState.finalUrl && tempState.finalUrl == event.id){\n\t\t\t\tstate = tempState;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\/\/If no matching original URL is found, then use the URL that was actually used\n\t\t\/\/in the SCRIPT SRC attribute.\n\t\tif(state == null){\n\t\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\t\tfor(var i = 0; scripts && i < scripts.length; i++){\n\t\t\t\tvar scriptTag = scripts[i];\n\t\t\t\tif(scriptTag.getAttribute(\"class\") == \"ScriptSrcTransport\"\n\t\t\t\t\t&& scriptTag.src == event.id){\n\t\t\t\t\tstate = transport._state[scriptTag.id];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/If state is still null, then throw an error.\n\t\tif(state == null){\n\t\t\tthrow \"No matching state for onscriptload event.id: \" + event.id;\n\t\t}\n\t}\n\tvar callbackName = \"error\";\n\tswitch(event.status){\n\t\tcase dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:\n\t\t\t\/\/A part of a multipart request.\n\t\t\tcallbackName = \"partOk\";\n\t\t\tbreak;\n\t\tcase dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:\n\t\t\t\/\/Successful reponse.\n\t\t\tcallbackName = \"load\";\n\t\t\tbreak;\n\t}\n\ttransport._finish(state, callbackName, event);"}}}}},"dojo.io.XhrIframeProxy":{"meta":{"requires":{"common":["dojo.experimental","dojo.io.IframeIO","dojo.dom","dojo.uri.Uri"]},"functions":{"dojo.io.XhrIframeFacade":{"meta":{"summary":"XMLHttpRequest facade object used by dojo.io.XhrIframeProxy.","parameters":{"ifpServerUrl":{"type":""}},"src":" this._requestHeaders = {};\n\tthis._allResponseHeaders = null;\n\tthis._responseHeaders = {};\n\tthis._method = null;\n\tthis._uri = null;\n\tthis._bodyData = null;\n\tthis.responseText = null;\n\tthis.responseXML = null;\n\tthis.status = null;\n\tthis.statusText = null;\n\tthis.readyState = 0;\n\tthis._ifpServerUrl = ifpServerUrl;\n\tthis._stateId = null;","instance_variables":["_requestHeaders","_allResponseHeaders","_responseHeaders","_method","_uri","_bodyData","responseText","responseXML","status","statusText","readyState","_ifpServerUrl","_stateId"],"description":"Do not use this object directly. See the Dojo Book page on XMLHttpRequest IFrame Proxying: http: \/\/ manual.dojotoolkit.org\/WikiHome\/DojoDotBook\/Book75"}},"dojo.io.XhrIframeFacade.open":{"meta":{"summary":"","parameters":{"method":{"type":"String"},"uri":{"type":"String"}},"src":" \tthis._method = method;\n\t\tthis._uri = uri;\n\t\tthis.readyState = 1;","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade.setRequestHeader":{"meta":{"summary":"","parameters":{"header":{"type":"String"},"value":{"type":"String"}},"src":" \tthis._requestHeaders[header] = value;","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade.send":{"meta":{"summary":"","parameters":{"stringData":{"type":"String"}},"src":" \tthis._bodyData = stringData;\n\t\tthis._stateId = dojo.io.XhrIframeProxy.send(this);\n\t\tthis.readyState = 2;","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade.abort":{"meta":{"summary":"","src":" \tdojo.io.XhrIframeProxy.destroyState(this._stateId);","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade.getAllResponseHeaders":{"meta":{"summary":"","src":" \treturn this._allResponseHeaders; \/\/String","returns":"String","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade.getResponseHeader":{"meta":{"summary":"","parameters":{"header":{"type":"String"}},"src":" \treturn this._responseHeaders[header]; \/\/String","returns":"String","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeFacade._setResponseHeaders":{"meta":{"summary":"","parameters":{"allHeaders":{"type":"String"}},"src":" \tif(allHeaders){\n\t\t\tthis._allResponseHeaders = allHeaders;\n\t\t\t\/\/Make sure ther are now CR characters in the headers.\n\t\t\tallHeaders = allHeaders.replace(\/\\r\/g, \"\");\n\t\t\tvar nvPairs = allHeaders.split(\"\\n\");\n\t\t\tfor(var i = 0; i < nvPairs.length; i++){\n\t\t\t\tif(nvPairs[i]){\n\t\t\t\t\tvar nameValue = nvPairs[i].split(\": \");\n\t\t\t\t\tthis._responseHeaders[nameValue[0]] = nameValue[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}","prototype":"dojo.io.XhrIframeFacade"}},"dojo.io.XhrIframeProxy.needFrameRecursion":{"meta":{"summary":"","src":" \treturn (true == dojo.render.html.ie70);"}},"dojo.io.XhrIframeProxy.send":{"meta":{"summary":"","parameters":{"facade":{"type":""}},"src":" \tvar stateId = \"XhrIframeProxy\" + (this._stateIdCounter++);\n\t\tfacade._stateId = stateId;\n\t\tvar frameUrl = this.xipClientUrl + \"#0:init:id=\" + stateId + \"&server=\" \n\t\t\t+ encodeURIComponent(facade._ifpServerUrl) + \"&fr=false\";\n\t\tif(this.needFrameRecursion()){\n\t\t\t\/\/IE7 hack. Need to load server URL, and have that load the xip_client.html.\n\t\t\t\/\/Also, this server URL needs to different from the one eventually loaded by xip_client.html\n\t\t\t\/\/Otherwise, IE7 will not load it. Funky.\n\t\t\tvar fullClientUrl = window.location.href.substring(0, window.location.href.lastIndexOf(\"\/\") + 1);\n\t\t\tfullClientUrl += this.xipClientUrl;\n\t\t\tvar serverUrl = facade._ifpServerUrl\n\t\t\t\t+ (facade._ifpServerUrl.indexOf(\"?\") == -1 ? \"?\" : \"&\") + \"dojo.fr=1\";\n\t\t\tframeUrl = serverUrl + \"#0:init:id=\" + stateId + \"&client=\" \n\t\t\t\t+ encodeURIComponent(fullClientUrl) + \"&fr=\" + this.needFrameRecursion(); \/\/fr is for Frame Recursion\n\t\t}\n\t\tthis._state[stateId] = {\n\t\t\tfacade: facade,\n\t\t\tstateId: stateId,\n\t\t\tclientFrame: dojo.io.createIFrame(stateId, \"\", frameUrl)\n\t\t};\n\t\treturn stateId;"}},"dojo.io.XhrIframeProxy.receive":{"meta":{"summary":"","parameters":{"stateId":{"type":"String"},"urlEncodedData":{"type":"String"}},"src":" \tvar response = {};\n\t\tvar nvPairs = urlEncodedData.split(\"&\");\n\t\tfor(var i = 0; i < nvPairs.length; i++){\n\t\t\tif(nvPairs[i]){\n\t\t\t\tvar nameValue = nvPairs[i].split(\"=\");\n\t\t\t\tresponse[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);\n\t\t\t}\n\t\t}\n\t\t\/\/Set data on facade object.\n\t\tvar state = this._state[stateId];\n\t\tvar facade = state.facade;\n\t\tfacade._setResponseHeaders(response.responseHeaders);\n\t\tif(response.status == 0 || response.status){\n\t\t\tfacade.status = parseInt(response.status, 10);\n\t\t}\n\t\tif(response.statusText){\n\t\t\tfacade.statusText = response.statusText;\n\t\t}\n\t\tif(response.responseText){\n\t\t\tfacade.responseText = response.responseText;\n\t\t\t\/\/Fix responseXML.\n\t\t\tvar contentType = facade.getResponseHeader(\"Content-Type\");\n\t\t\tif(contentType && (contentType == \"application\/xml\" || contentType == \"text\/xml\")){\n\t\t\t\tfacade.responseXML = dojo.dom.createDocumentFromText(response.responseText, contentType);\n\t\t\t}\n\t\t}\n\t\tfacade.readyState = 4;\n\t\tthis.destroyState(stateId);"},"extra":{"parameters":{"urlEncodedData":{"type":"should","summary":"have the following params: Decode response data."}}}},"dojo.io.XhrIframeProxy.clientFrameLoaded":{"meta":{"summary":"","parameters":{"stateId":{"type":"String"}},"src":" \tvar state = this._state[stateId];\n\t\tvar facade = state.facade;\n\t\tif(this.needFrameRecursion()){\n\t\t\tvar clientWindow = window.open(\"\", state.stateId + \"_clientEndPoint\");\n\t\t}else{\n\t\t\tvar clientWindow = state.clientFrame.contentWindow;\n\t\t}\n\t\tvar reqHeaders = [];\n\t\tfor(var param in facade._requestHeaders){\n\t\t\treqHeaders.push(param + \": \" + facade._requestHeaders[param]);\n\t\t}\n\t\tvar requestData = {\n\t\t\turi: facade._uri\n\t\t};\n\t\tif(reqHeaders.length > 0){\n\t\t\trequestData.requestHeaders = reqHeaders.join(\"\\r\\n\");\t\t\n\t\t}\n\t\tif(facade._method){\n\t\t\trequestData.method = facade._method;\n\t\t}\n\t\tif(facade._bodyData){\n\t\t\trequestData.data = facade._bodyData;\n\t\t}\n\t\tclientWindow.send(dojo.io.argsFromMap(requestData, \"utf8\"));"}},"dojo.io.XhrIframeProxy.destroyState":{"meta":{"summary":"","parameters":{"stateId":{"type":"String"}},"src":" \tvar state = this._state[stateId];\n\t\tif(state){\n\t\t\tdelete this._state[stateId];\n\t\t\tvar parentNode = state.clientFrame.parentNode;\n\t\t\tparentNode.removeChild(state.clientFrame);\n\t\t\tstate.clientFrame = null;\n\t\t\tstate = null;\n\t\t}"}},"dojo.io.XhrIframeProxy.createFacade":{"meta":{"summary":"","src":" \tif(arguments && arguments[0] && arguments[0][\"iframeProxyUrl\"]){\n\t\t\treturn new dojo.io.XhrIframeFacade(arguments[0][\"iframeProxyUrl\"]);\n\t\t}else{\n\t\t\treturn dojo.io.XhrIframeProxy.oldGetXmlhttpObject.apply(dojo.hostenv, arguments);\n\t\t}","call_chain":["dojo.io.XhrIframeProxy.oldGetXmlhttpObject"]}}},"objects":{"dojo.io.XhrIframeProxy":{"meta":{"variables":["xipClientUrl","_stateIdCounter"],"summary":"Object that implements the iframe handling for XMLHttpRequest IFrame Proxying.","description":"Do not use this object directly. See the Dojo Book page on XMLHttpRequest IFrame Proxying: http: \/\/ manual.dojotoolkit.org\/WikiHome\/DojoDotBook\/Book75 Usage of XHR IFrame Proxying does not work from local disk in Safari."}}}}},"dojo.io._":{"meta":{"requires":{"common":["dojo.io.common"],"rhino":["dojo.io.RhinoIO"],"browser":["dojo.io.BrowserIO","dojo.io.cookie"],"dashboard":["dojo.io.BrowserIO","dojo.io.cookie"]}}},"dojo.io.cometd":{"meta":{"requires":{"common":["dojo.io.common","dojo.AdapterRegistry","dojo.json","dojo.io.BrowserIO","dojo.io.IframeIO","dojo.io.ScriptSrcIO","dojo.io.cookie","dojo.event.*","dojo.lang.common","dojo.lang.func"]},"functions":{"cometd":{"meta":{"initialized":true,"summary":"","src":" this.initialized = false;\n\tthis.connected = false;\n\tthis.connectionTypes = new dojo.AdapterRegistry(true);\n\tthis.version = 0.1;\n\tthis.minimumVersion = 0.1;\n\tthis.clientId = null;\n\tthis._isXD = false;\n\tthis.handshakeReturn = null;\n\tthis.currentTransport = null;\n\tthis.url = null;\n\tthis.lastMessage = null;\n\tthis.globalTopicChannels = {};\n\tthis.backlog = [];\n\tthis.tunnelInit = function(childLocation, childDomain){\n\t\t\/\/ placeholder\n\t}\n\tthis.tunnelCollapse = function(){\n\t\tdojo.debug(\"tunnel collapsed!\");\n\t\t\/\/ placeholder\n\t}\n\tthis.init = function(props, root, bargs){\n\t\t\/\/ FIXME: if the root isn't from the same host, we should automatically\n\t\t\/\/ try to select an XD-capable transport\n\t\tprops = props||{};\n\t\t\/\/ go ask the short bus server what we can support\n\t\tprops.version = this.version;\n\t\tprops.minimumVersion = this.minimumVersion;\n\t\tprops.channel = \"\/meta\/handshake\";\n\t\t\/\/ FIXME: do we just assume that the props knows\n\t\t\/\/ everything we care about WRT to auth? Should we be trying to\n\t\t\/\/ call back into it for subsequent auth actions? Should we fire\n\t\t\/\/ local auth functions to ask for\/get auth data?\n\t\t\/\/ FIXME: what about ScriptSrcIO for x-domain comet?\n\t\tthis.url = root||djConfig[\"cometdRoot\"];\n\t\tif(!this.url){\n\t\t\tdojo.debug(\"no cometd root specified in djConfig and no root passed\");\n\t\t\treturn;\n\t\t}\n\t\t\/\/ FIXME: we need to select a way to handle JSONP-style stuff\n\t\t\/\/ generically here. We already know if the server is gonna be on\n\t\t\/\/ another domain (or can know it), so we should select appropriate\n\t\t\/\/ negotiation methods here as well as in final transport type\n\t\t\/\/ selection.\n\t\tvar bindArgs = {\n\t\t\turl: this.url,\n\t\t\tmethod: \"POST\",\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, \"finishInit\"),\n\t\t\tcontent: { \"message\": dojo.json.serialize([props]) }\n\t\t};\n\t\t\/\/ borrowed from dojo.uri.Uri in lieu of fixed host and port properties\n        var regexp = \"^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?$\";\n\t\tvar r = (\"\"+window.location).match(new RegExp(regexp));\n\t\tif(r[4]){\n\t\t\tvar tmp = r[4].split(\":\");\n\t\t\tvar thisHost = tmp[0];\n\t\t\tvar thisPort = tmp[1]||\"80\"; \/\/ FIXME: match 443\n\t\t\tr = this.url.match(new RegExp(regexp));\n\t\t\tif(r[4]){\n\t\t\t\ttmp = r[4].split(\":\");\n\t\t\t\tvar urlHost = tmp[0];\n\t\t\t\tvar urlPort = tmp[1]||\"80\";\n\t\t\t\tif(\t(urlHost != thisHost)||\n\t\t\t\t\t(urlPort != thisPort) ){\n\t\t\t\t\tdojo.debug(thisHost, urlHost);\n\t\t\t\t\tdojo.debug(thisPort, urlPort);\n\t\t\t\t\tthis._isXD = true;\n\t\t\t\t\tbindArgs.transport = \"ScriptSrcTransport\";\n\t\t\t\t\tbindArgs.jsonParamName = \"jsonp\";\n\t\t\t\t\tbindArgs.method = \"GET\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bargs){\n\t\t\tdojo.lang.mixin(bindArgs, bargs);\n\t\t}\n\t\treturn dojo.io.bind(bindArgs);\n\t}\n\tthis.finishInit = function(type, data, evt, request){\n\t\tdata = data[0];\n\t\tthis.handshakeReturn = data;\n\t\t\/\/ pick a transport\n\t\tif(data[\"authSuccessful\"] == false){\n\t\t\tdojo.debug(\"cometd authentication failed\");\n\t\t\treturn;\n\t\t}\n\t\tif(data.version < this.minimumVersion){\n\t\t\tdojo.debug(\"cometd protocol version mismatch. We wanted\", this.minimumVersion, \"but got\", data.version);\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport = this.connectionTypes.match(\n\t\t\tdata.supportedConnectionTypes,\n\t\t\tdata.version,\n\t\t\tthis._isXD\n\t\t);\n\t\tthis.currentTransport.version = data.version;\n\t\tthis.clientId = data.clientId;\n\t\tthis.tunnelInit = dojo.lang.hitch(this.currentTransport, \"tunnelInit\");\n\t\tthis.tunnelCollapse = dojo.lang.hitch(this.currentTransport, \"tunnelCollapse\");\n\t\tthis.initialized = true;\n\t\tthis.currentTransport.startup(data);\n\t\twhile(this.backlog.length != 0){\n\t\t\tvar cur = this.backlog.shift();\n\t\t\tvar fn = cur.shift();\n\t\t\tthis[fn].apply(this, cur);\n\t\t}\n\t}\n\tthis._getRandStr = function(){\n\t\treturn Math.random().toString().substring(2, 10);\n\t}\n\t\/\/ public API functions called by cometd or by the transport classes\n\tthis.deliver = function(messages){\n\t\tdojo.lang.forEach(messages, this._deliver, this);\n\t}\n\tthis._deliver = function(message){\n\t\t\/\/ dipatch events along the specified path\n\t\tif(!message[\"channel\"]){\n\t\t\tdojo.debug(\"cometd error: no channel for message!\");\n\t\t\treturn;\n\t\t}\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"deliver\", message]);\n\t\t\treturn;\n\t\t}\n\t\tthis.lastMessage = message;\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.subscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/unsubscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd unsubscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.unsubscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\/\/ send the message down for processing by the transport\n\t\tthis.currentTransport.deliver(message);\n\t\t\/\/ dispatch the message to any locally subscribed listeners\n\t\tvar tname = (this.globalTopicChannels[message.channel]) ? message.channel : \"\/cometd\"+message.channel;\n\t\tdojo.event.topic.publish(tname, message);\n\t}\n\tthis.disconnect = function(){\n\t\tif(!this.currentTransport){\n\t\t\tdojo.debug(\"no current transport to disconnect from\");\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport.disconnect();\n\t}\n\t\/\/ public API functions called by end users\n\tthis.publish = function(\/*string*\/channel, \/*object*\/data, \/*object*\/properties){\n\t\t\/\/ summary: \n\t\t\/\/\t\tpublishes the passed message to the cometd server for delivery\n\t\t\/\/\t\ton the specified topic\n\t\t\/\/ channel:\n\t\t\/\/\t\tthe destination channel for the message\n\t\t\/\/ data:\n\t\t\/\/\t\ta JSON object containing the message \"payload\"\n\t\t\/\/ properties:\n\t\t\/\/\t\tOptional. Other meta-data to be mixed into the top-level of the\n\t\t\/\/\t\tmessage\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"publish\", channel, data, properties]);\n\t\t\treturn;\n\t\t}\n\t\tvar message = {\n\t\t\tdata: data,\n\t\t\tchannel: channel\n\t\t};\n\t\tif(properties){\n\t\t\tdojo.lang.mixin(message, properties);\n\t\t}\n\t\treturn this.currentTransport.sendMessage(message);\n\t}\n\tthis.subscribe = function(\t\/*string*\/\t\t\t\tchannel, \n\t\t\t\t\t\t\t\t\/*boolean, optional*\/\tuseLocalTopics, \n\t\t\t\t\t\t\t\t\/*object, optional*\/\tobjOrFunc, \n\t\t\t\t\t\t\t\t\/*string, optional*\/\tfuncName){ \/\/ return: boolean\n\t\t\/\/ summary:\n\t\t\/\/\t\tinform the server of this client's interest in channel\n\t\t\/\/ channel:\n\t\t\/\/\t\tname of the cometd channel to subscribe to\n\t\t\/\/ useLocalTopics:\n\t\t\/\/\t\tDetermines if up a local event topic subscription to the passed\n\t\t\/\/\t\tfunction using the channel name that was passed is constructed,\n\t\t\/\/\t\tor if the topic name will be prefixed with some other\n\t\t\/\/\t\tidentifier for local message distribution. Setting this to\n\t\t\/\/\t\t\"true\" is a good way to hook up server-sent message delivery to\n\t\t\/\/\t\tpre-existing local topics.\n\t\t\/\/ objOrFunc:\n\t\t\/\/\t\tan object scope for funcName or the name or reference to a\n\t\t\/\/\t\tfunction to be called when messages are delivered to the\n\t\t\/\/\t\tchannel\n\t\t\/\/ funcName:\n\t\t\/\/\t\tthe second half of the objOrFunc\/funcName pair for identifying\n\t\t\/\/\t\ta callback function to notifiy upon channel message delivery\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"subscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\tif(objOrFunc){\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tif(useLocalTopics){\n\t\t\t\tthis.globalTopicChannels[channel] = true;\n\t\t\t}\n\t\t\tdojo.event.topic.subscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\t\/\/ FIXME: would we handle queuing of the subscription if not connected?\n\t\t\/\/ Or should the transport object?\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/subscribe\",\n\t\t\tsubscription: channel\n\t\t});\n\t}\n\tthis.subscribed = function(\t\/*string*\/\t\t\t\tchannel, \n\t\t\t\t\t\t\t\t\/*obj*\/\t\t\t\t\tmessage){\n\t\tdojo.debug(channel);\n\t\tdojo.debugShallow(message);\n\t}\n\tthis.unsubscribe = function(\/*string*\/\t\t\t\tchannel, \n\t\t\t\t\t\t\t\t\/*boolean, optional*\/\tuseLocalTopics, \n\t\t\t\t\t\t\t\t\/*object, optional*\/\tobjOrFunc, \n\t\t\t\t\t\t\t\t\/*string, optional*\/\tfuncName){ \/\/ return: boolean\n\t\t\/\/ summary:\n\t\t\/\/\t\tinform the server of this client's disinterest in channel\n\t\t\/\/ channel:\n\t\t\/\/\t\tname of the cometd channel to subscribe to\n\t\t\/\/ useLocalTopics:\n\t\t\/\/\t\tDetermines if up a local event topic subscription to the passed\n\t\t\/\/\t\tfunction using the channel name that was passed is destroyed,\n\t\t\/\/\t\tor if the topic name will be prefixed with some other\n\t\t\/\/\t\tidentifier for stopping message distribution.\n\t\t\/\/ objOrFunc:\n\t\t\/\/\t\tan object scope for funcName or the name or reference to a\n\t\t\/\/\t\tfunction to be called when messages are delivered to the\n\t\t\/\/\t\tchannel\n\t\t\/\/ funcName:\n\t\t\/\/\t\tthe second half of the objOrFunc\/funcName pair for identifying\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"unsubscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\t\/\/\t\ta callback function to notifiy upon channel message delivery\n\t\tif(objOrFunc){\n\t\t\t\/\/ FIXME: should actual local topic unsubscription be delayed for\n\t\t\t\/\/ successful unsubcribe notices from the other end? (guessing \"no\")\n\t\t\t\/\/ FIXME: if useLocalTopics is false, should we go ahead and\n\t\t\t\/\/ destroy the local topic?\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tdojo.event.topic.unsubscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/unsubscribe\",\n\t\t\tsubscription: channel\n\t\t});\n\t}\n\tthis.unsubscribed = function(\/*string*\/\t\t\t\tchannel, \n\t\t\t\t\t\t\t\t\/*obj*\/\t\t\t\t\tmessage){\n\t\tdojo.debug(channel);\n\t\tdojo.debugShallow(message);\n\t}\n\t\/\/ FIXME: add an \"addPublisher\" function","instance_variables":["initialized","connected","connectionTypes","version","minimumVersion","clientId","_isXD","handshakeReturn","currentTransport","url","lastMessage","globalTopicChannels","backlog","tunnelInit","tunnelCollapse","init","finishInit","currentTransport.version","_getRandStr","deliver","_deliver","disconnect","publish","subscribe","subscribed","unsubscribe","unsubscribed"],"returns":"return: boolean"}},"cometd.tunnelInit":{"meta":{"summary":"","parameters":{"childLocation":{"type":""},"childDomain":{"type":""}},"src":"\t\t\/\/ placeholder","instance":"cometd"}},"cometd.tunnelCollapse":{"meta":{"summary":"","src":" \tdojo.debug(\"tunnel collapsed!\");\n\t\t\/\/ placeholder","instance":"cometd"}},"cometd.init":{"meta":{"summary":"","parameters":{"props":{"type":""},"root":{"type":""},"bargs":{"type":""}},"src":" \tprops = props||{};\n\t\t\/\/ go ask the short bus server what we can support\n\t\tprops.version = this.version;\n\t\tprops.minimumVersion = this.minimumVersion;\n\t\tprops.channel = \"\/meta\/handshake\";\n\t\t\/\/ FIXME: do we just assume that the props knows\n\t\t\/\/ everything we care about WRT to auth? Should we be trying to\n\t\t\/\/ call back into it for subsequent auth actions? Should we fire\n\t\t\/\/ local auth functions to ask for\/get auth data?\n\t\t\/\/ FIXME: what about ScriptSrcIO for x-domain comet?\n\t\tthis.url = root||djConfig[\"cometdRoot\"];\n\t\tif(!this.url){\n\t\t\tdojo.debug(\"no cometd root specified in djConfig and no root passed\");\n\t\t\treturn;\n\t\t}\n\t\t\/\/ FIXME: we need to select a way to handle JSONP-style stuff\n\t\t\/\/ generically here. We already know if the server is gonna be on\n\t\t\/\/ another domain (or can know it), so we should select appropriate\n\t\t\/\/ negotiation methods here as well as in final transport type\n\t\t\/\/ selection.\n\t\tvar bindArgs = {\n\t\t\turl: this.url,\n\t\t\tmethod: \"POST\",\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, \"finishInit\"),\n\t\t\tcontent: { \"message\": dojo.json.serialize([props]) }\n\t\t};\n\t\t\/\/ borrowed from dojo.uri.Uri in lieu of fixed host and port properties\n        var regexp = \"^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?$\";\n\t\tvar r = (\"\"+window.location).match(new RegExp(regexp));\n\t\tif(r[4]){\n\t\t\tvar tmp = r[4].split(\":\");\n\t\t\tvar thisHost = tmp[0];\n\t\t\tvar thisPort = tmp[1]||\"80\"; \/\/ FIXME: match 443\n\t\t\tr = this.url.match(new RegExp(regexp));\n\t\t\tif(r[4]){\n\t\t\t\ttmp = r[4].split(\":\");\n\t\t\t\tvar urlHost = tmp[0];\n\t\t\t\tvar urlPort = tmp[1]||\"80\";\n\t\t\t\tif(\t(urlHost != thisHost)||\n\t\t\t\t\t(urlPort != thisPort) ){\n\t\t\t\t\tdojo.debug(thisHost, urlHost);\n\t\t\t\t\tdojo.debug(thisPort, urlPort);\n\t\t\t\t\tthis._isXD = true;\n\t\t\t\t\tbindArgs.transport = \"ScriptSrcTransport\";\n\t\t\t\t\tbindArgs.jsonParamName = \"jsonp\";\n\t\t\t\t\tbindArgs.method = \"GET\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bargs){\n\t\t\tdojo.lang.mixin(bindArgs, bargs);\n\t\t}\n\t\treturn dojo.io.bind(bindArgs);","instance":"cometd"}},"cometd.finishInit":{"meta":{"summary":"","parameters":{"type":{"type":""},"data":{"type":""},"evt":{"type":""},"request":{"type":""}},"src":" \tdata = data[0];\n\t\tthis.handshakeReturn = data;\n\t\t\/\/ pick a transport\n\t\tif(data[\"authSuccessful\"] == false){\n\t\t\tdojo.debug(\"cometd authentication failed\");\n\t\t\treturn;\n\t\t}\n\t\tif(data.version < this.minimumVersion){\n\t\t\tdojo.debug(\"cometd protocol version mismatch. We wanted\", this.minimumVersion, \"but got\", data.version);\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport = this.connectionTypes.match(\n\t\t\tdata.supportedConnectionTypes,\n\t\t\tdata.version,\n\t\t\tthis._isXD\n\t\t);\n\t\tthis.currentTransport.version = data.version;\n\t\tthis.clientId = data.clientId;\n\t\tthis.tunnelInit = dojo.lang.hitch(this.currentTransport, \"tunnelInit\");\n\t\tthis.tunnelCollapse = dojo.lang.hitch(this.currentTransport, \"tunnelCollapse\");\n\t\tthis.initialized = true;\n\t\tthis.currentTransport.startup(data);\n\t\twhile(this.backlog.length != 0){\n\t\t\tvar cur = this.backlog.shift();\n\t\t\tvar fn = cur.shift();\n\t\t\tthis[fn].apply(this, cur);\n\t\t}","instance":"cometd"}},"cometd._getRandStr":{"meta":{"summary":"","src":" \treturn Math.random().toString().substring(2, 10);","instance":"cometd"}},"cometd.deliver":{"meta":{"summary":"","parameters":{"messages":{"type":""}},"src":" \tdojo.lang.forEach(messages, this._deliver, this);","instance":"cometd"}},"cometd._deliver":{"meta":{"summary":"","parameters":{"message":{"type":""}},"src":" \tif(!message[\"channel\"]){\n\t\t\tdojo.debug(\"cometd error: no channel for message!\");\n\t\t\treturn;\n\t\t}\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"deliver\", message]);\n\t\t\treturn;\n\t\t}\n\t\tthis.lastMessage = message;\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.subscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/unsubscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd unsubscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.unsubscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\/\/ send the message down for processing by the transport\n\t\tthis.currentTransport.deliver(message);\n\t\t\/\/ dispatch the message to any locally subscribed listeners\n\t\tvar tname = (this.globalTopicChannels[message.channel]) ? message.channel : \"\/cometd\"+message.channel;\n\t\tdojo.event.topic.publish(tname, message);","instance":"cometd"}},"cometd.disconnect":{"meta":{"summary":"","src":" \tif(!this.currentTransport){\n\t\t\tdojo.debug(\"no current transport to disconnect from\");\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport.disconnect();","instance":"cometd"}},"cometd.publish":{"meta":{"summary":"publishes the passed message to the cometd server for delivery on the specified topic","parameters":{"channel":{"type":"string"},"data":{"type":"object"},"properties":{"type":"object"}},"src":" \tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"publish\", channel, data, properties]);\n\t\t\treturn;\n\t\t}\n\t\tvar message = {\n\t\t\tdata: data,\n\t\t\tchannel: channel\n\t\t};\n\t\tif(properties){\n\t\t\tdojo.lang.mixin(message, properties);\n\t\t}\n\t\treturn this.currentTransport.sendMessage(message);","instance":"cometd"},"extra":{"parameters":{"channel":{"type":"the","summary":"destination channel for the message"},"data":{"type":"a","summary":"JSON object containing the message \"payload\""},"properties":{"type":"Optional.","summary":"Other meta-data to be mixed into the top-level of the message"}}}},"cometd.subscribe":{"meta":{"summary":"return: boolean inform the server of this client's interest in channel","parameters":{"channel":{"type":"string"},"useLocalTopics":{"type":"boolean, optional"},"objOrFunc":{"type":"object, optional"},"funcName":{"type":"string, optional"}},"src":" \tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"subscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\tif(objOrFunc){\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tif(useLocalTopics){\n\t\t\t\tthis.globalTopicChannels[channel] = true;\n\t\t\t}\n\t\t\tdojo.event.topic.subscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\t\/\/ FIXME: would we handle queuing of the subscription if not connected?\n\t\t\/\/ Or should the transport object?\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/subscribe\",\n\t\t\tsubscription: channel\n\t\t});","instance":"cometd"},"extra":{"parameters":{"channel":{"type":"name","summary":"of the cometd channel to subscribe to"},"useLocalTopics":{"type":"Determines","summary":"if up a local event topic subscription to the passed function using the channel name that was passed is constructed, or if the topic name will be prefixed with some other identifier for local message distribution. Setting this to \"true\" is a good way to hook up server-sent message delivery to pre-existing local topics."},"objOrFunc":{"type":"an","summary":"object scope for funcName or the name or reference to a function to be called when messages are delivered to the"},"funcName":{"type":"the","summary":"second half of the objOrFunc\/funcName pair for identifying a callback function to notifiy upon channel message delivery"}}}},"cometd.subscribed":{"meta":{"summary":"","parameters":{"channel":{"type":"string"},"message":{"type":"obj"}},"src":" \tdojo.debug(channel);\n\t\tdojo.debugShallow(message);","instance":"cometd"}},"cometd.unsubscribe":{"meta":{"summary":"return: boolean inform the server of this client's disinterest in channel","parameters":{"channel":{"type":"string"},"useLocalTopics":{"type":"boolean, optional"},"objOrFunc":{"type":"object, optional"},"funcName":{"type":"string, optional"}},"src":" \tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"unsubscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\t\/\/\t\ta callback function to notifiy upon channel message delivery\n\t\tif(objOrFunc){\n\t\t\t\/\/ FIXME: should actual local topic unsubscription be delayed for\n\t\t\t\/\/ successful unsubcribe notices from the other end? (guessing \"no\")\n\t\t\t\/\/ FIXME: if useLocalTopics is false, should we go ahead and\n\t\t\t\/\/ destroy the local topic?\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tdojo.event.topic.unsubscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/unsubscribe\",\n\t\t\tsubscription: channel\n\t\t});","instance":"cometd"},"extra":{"parameters":{"channel":{"type":"name","summary":"of the cometd channel to subscribe to"},"useLocalTopics":{"type":"Determines","summary":"if up a local event topic subscription to the passed function using the channel name that was passed is destroyed, or if the topic name will be prefixed with some other identifier for stopping message distribution."},"objOrFunc":{"type":"an","summary":"object scope for funcName or the name or reference to a function to be called when messages are delivered to the"},"funcName":{"type":"the","summary":"second half of the objOrFunc\/funcName pair for identifying"}}}},"cometd.unsubscribed":{"meta":{"summary":"","parameters":{"channel":{"type":"string"},"message":{"type":"obj"}},"src":" \tdojo.debug(channel);\n\t\tdojo.debugShallow(message);","instance":"cometd"}},"cometd.iframeTransport":{"meta":{"initialized":true,"summary":"","src":" this.connected = false;\n\tthis.connectionId = null;\n\tthis.rcvNode = null;\n\tthis.rcvNodeName = \"\";\n\tthis.phonyForm = null;\n\tthis.authToken = null;\n\tthis.lastTimestamp = null;\n\tthis.lastId = null;\n\tthis.backlog = [];\n\tthis.check = function(types, version, xdomain){\n\t\treturn ((!xdomain)&&\n\t\t\t\t(!dojo.render.html.safari)&&\n\t\t\t\t(dojo.lang.inArray(types, \"iframe\")));\n\t}\n\tthis.tunnelInit = function(){\n\t\t\/\/ we've gotten our initialization document back in the iframe, so\n\t\t\/\/ now open up a connection and start passing data!\n\t\tthis.postToIframe({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"iframe\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t}\n\tthis.tunnelCollapse = function(){\n\t\tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.postToIframe({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\tthis.deliver = function(message){\n\t\t\/\/ handle delivery details that this transport particularly cares\n\t\t\/\/ about. Most functions of should be handled by the main cometd object\n\t\t\/\/ with only transport-specific details and state being tracked here.\n\t\tif(message[\"timestamp\"]){\n\t\t\tthis.lastTimestamp = message.timestamp;\n\t\t}\n\t\tif(message[\"id\"]){\n\t\t\tthis.lastId = message.id;\n\t\t}\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/connect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd connection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connectionId = message.connectionId;\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tthis.processBacklog();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/reconnect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd reconnection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ this.subscribed(message.channel);\n\t\t\t\t\tdojo.debug(message.channel);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tthis.widenDomain = function(domainStr){\n\t\t\/\/ allow us to make reqests to the TLD\n\t\tvar cd = domainStr||document.domain;\n\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");\n\t\treturn document.domain;\n\t}\n\tthis.postToIframe = function(content, url){\n\t\tif(!this.phonyForm){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.phonyForm = document.createElement(\"<form enctype='application\/x-www-form-urlencoded' method='POST' style='display: none;'>\");\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t}else{\n\t\t\t\tthis.phonyForm = document.createElement(\"form\");\n\t\t\t\tthis.phonyForm.style.display = \"none\"; \/\/ FIXME: will this still work?\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t\tthis.phonyForm.enctype = \"application\/x-www-form-urlencoded\";\n\t\t\t\tthis.phonyForm.method = \"POST\";\n\t\t\t}\n\t\t}\n\t\tthis.phonyForm.action = url||cometd.url;\n\t\tthis.phonyForm.target = this.rcvNodeName;\n\t\tthis.phonyForm.setAttribute(\"target\", this.rcvNodeName);\n\t\twhile(this.phonyForm.firstChild){\n\t\t\tthis.phonyForm.removeChild(this.phonyForm.firstChild);\n\t\t}\n\t\tfor(var x in content){\n\t\t\tvar tn;\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t}else{\n\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t\ttn.type = \"hidden\";\n\t\t\t\ttn.name = x;\n\t\t\t\ttn.value = content[x];\n\t\t\t}\n\t\t}\n\t\tthis.phonyForm.submit();\n\t}\n\tthis.processBacklog = function(){\n\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}\n\t}\n\tthis.sendMessage = function(message, bypassBacklog){\n\t\t\/\/ FIXME: what about auth fields?\n\t\tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\t\/\/ FIXME: we should be able to do better than this given that we're sending an array!\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}\n\t}\n\tthis.startup = function(handshakeData){\n\t\tdojo.debug(\"startup!\");\n\t\tdojo.debug(dojo.json.serialize(handshakeData));\n\t\tif(this.connected){ return; }\n\t\t\/\/ this.widenDomain();\n\t\t\/\/ NOTE: we require the server to cooperate by hosting\n\t\t\/\/ cometdInit.html at the designated endpoint\n\t\tthis.rcvNodeName = \"cometdRcv_\"+cometd._getRandStr();\n\t\t\/\/ the \"forever frame\" approach\n\t\tvar initUrl = cometd.url+\"\/?tunnelInit=iframe\"; \/\/ &domain=\"+document.domain;\n\t\tif(false && dojo.render.html.ie){ \/\/ FIXME: DISALBED FOR NOW\n\t\t\t\/\/ use the \"htmlfile hack\" to prevent the background click junk\n\t\t\tthis.rcvNode = new ActiveXObject(\"htmlfile\");\n\t\t\tthis.rcvNode.open();\n\t\t\tthis.rcvNode.write(\"<html>\");\n\t\t\tthis.rcvNode.write(\"<script>document.domain = '\"+document.domain+\"'\");\n\t\t\tthis.rcvNode.write(\"<\/html>\");\n\t\t\tthis.rcvNode.close();\n\t\t\tvar ifrDiv = this.rcvNode.createElement(\"div\");\n\t\t\tthis.rcvNode.appendChild(ifrDiv);\n\t\t\tthis.rcvNode.parentWindow.dojo = dojo;\n\t\t\tifrDiv.innerHTML = \"<iframe src='\"+initUrl+\"'><\/iframe>\"\n\t\t}else{\n\t\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName, \"\", initUrl);\n\t\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, initUrl);\n\t\t\t\/\/ we're still waiting on the iframe to call back up to use and\n\t\t\t\/\/ advertise that it's been initialized via tunnelInit\n\t\t}\n\t}","instance_variables":["connected","connectionId","rcvNode","rcvNodeName","phonyForm","authToken","lastTimestamp","lastId","backlog","check","tunnelInit","tunnelCollapse","deliver","widenDomain","postToIframe","phonyForm.style.display","phonyForm.enctype","phonyForm.method","phonyForm.action","phonyForm.target","processBacklog","sendMessage","startup","rcvNode.parentWindow.dojo"],"returns":"mixed"}},"cometd.iframeTransport.check":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":" \treturn ((!xdomain)&&\n\t\t\t\t(!dojo.render.html.safari)&&\n\t\t\t\t(dojo.lang.inArray(types, \"iframe\")));","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.tunnelInit":{"meta":{"summary":"","src":" \tthis.postToIframe({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"iframe\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.tunnelCollapse":{"meta":{"summary":"","src":" \tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.postToIframe({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.deliver":{"meta":{"summary":"","parameters":{"message":{"type":""}},"src":" \tif(message[\"timestamp\"]){\n\t\t\tthis.lastTimestamp = message.timestamp;\n\t\t}\n\t\tif(message[\"id\"]){\n\t\t\tthis.lastId = message.id;\n\t\t}\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/connect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd connection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connectionId = message.connectionId;\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tthis.processBacklog();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/reconnect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd reconnection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ this.subscribed(message.channel);\n\t\t\t\t\tdojo.debug(message.channel);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.widenDomain":{"meta":{"summary":"","parameters":{"domainStr":{"type":""}},"src":" \tvar cd = domainStr||document.domain;\n\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");\n\t\treturn document.domain;","returns":"mixed","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.postToIframe":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":" \tif(!this.phonyForm){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.phonyForm = document.createElement(\"<form enctype='application\/x-www-form-urlencoded' method='POST' style='display: none;'>\");\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t}else{\n\t\t\t\tthis.phonyForm = document.createElement(\"form\");\n\t\t\t\tthis.phonyForm.style.display = \"none\"; \/\/ FIXME: will this still work?\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t\tthis.phonyForm.enctype = \"application\/x-www-form-urlencoded\";\n\t\t\t\tthis.phonyForm.method = \"POST\";\n\t\t\t}\n\t\t}\n\t\tthis.phonyForm.action = url||cometd.url;\n\t\tthis.phonyForm.target = this.rcvNodeName;\n\t\tthis.phonyForm.setAttribute(\"target\", this.rcvNodeName);\n\t\twhile(this.phonyForm.firstChild){\n\t\t\tthis.phonyForm.removeChild(this.phonyForm.firstChild);\n\t\t}\n\t\tfor(var x in content){\n\t\t\tvar tn;\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t}else{\n\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t\ttn.type = \"hidden\";\n\t\t\t\ttn.name = x;\n\t\t\t\ttn.value = content[x];\n\t\t\t}\n\t\t}\n\t\tthis.phonyForm.submit();","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.processBacklog":{"meta":{"summary":"","src":" \twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.sendMessage":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":" \tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\t\/\/ FIXME: we should be able to do better than this given that we're sending an array!\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}","instance":"cometd.iframeTransport"}},"cometd.iframeTransport.startup":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":" \tdojo.debug(\"startup!\");\n\t\tdojo.debug(dojo.json.serialize(handshakeData));\n\t\tif(this.connected){ return; }\n\t\t\/\/ this.widenDomain();\n\t\t\/\/ NOTE: we require the server to cooperate by hosting\n\t\t\/\/ cometdInit.html at the designated endpoint\n\t\tthis.rcvNodeName = \"cometdRcv_\"+cometd._getRandStr();\n\t\t\/\/ the \"forever frame\" approach\n\t\tvar initUrl = cometd.url+\"\/?tunnelInit=iframe\"; \/\/ &domain=\"+document.domain;\n\t\tif(false && dojo.render.html.ie){ \/\/ FIXME: DISALBED FOR NOW\n\t\t\t\/\/ use the \"htmlfile hack\" to prevent the background click junk\n\t\t\tthis.rcvNode = new ActiveXObject(\"htmlfile\");\n\t\t\tthis.rcvNode.open();\n\t\t\tthis.rcvNode.write(\"<html>\");\n\t\t\tthis.rcvNode.write(\"<script>document.domain = '\"+document.domain+\"'\");\n\t\t\tthis.rcvNode.write(\"<\/html>\");\n\t\t\tthis.rcvNode.close();\n\t\t\tvar ifrDiv = this.rcvNode.createElement(\"div\");\n\t\t\tthis.rcvNode.appendChild(ifrDiv);\n\t\t\tthis.rcvNode.parentWindow.dojo = dojo;\n\t\t\tifrDiv.innerHTML = \"<iframe src='\"+initUrl+\"'><\/iframe>\"\n\t\t}else{\n\t\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName, \"\", initUrl);\n\t\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, initUrl);\n\t\t\t\/\/ we're still waiting on the iframe to call back up to use and\n\t\t\t\/\/ advertise that it's been initialized via tunnelInit\n\t\t}","instance":"cometd.iframeTransport"}},"cometd.mimeReplaceTransport":{"meta":{"initialized":true,"summary":"","src":" this.connected = false;\n\tthis.connectionId = null;\n\tthis.xhr = null;\n\tthis.authToken = null;\n\tthis.lastTimestamp = null;\n\tthis.lastId = null;\n\tthis.backlog = [];\n\tthis.check = function(types, version, xdomain){\n\t\treturn ((!xdomain)&&\n\t\t\t\t(dojo.render.html.mozilla)&& \/\/ seems only Moz really supports this right now = (\n\t\t\t\t(dojo.lang.inArray(types, \"mime-message-block\")));\n\t}\n\tthis.tunnelInit = function(){\n\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"mime-message-block\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;\n\t}\n\tthis.tunnelCollapse = function(){\n\t\tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\tthis.deliver = cometd.iframeTransport.deliver;\n\t\/\/ the logic appears to be the same\n\tthis.handleOnLoad = function(resp){\n\t\tcometd.deliver(dojo.json.evalJson(this.xhr.responseText));\n\t}\n\tthis.openTunnelWith = function(content, url){\n\t\t\/\/ set up the XHR object and register the multipart callbacks\n\t\tthis.xhr = dojo.hostenv.getXmlhttpObject();\n\t\tthis.xhr.multipart = true; \/\/ FIXME: do Opera and Safari support this flag?\n\t\tif(dojo.render.html.mozilla){\n\t\t\tthis.xhr.addEventListener(\"load\", dojo.lang.hitch(this, \"handleOnLoad\"), false);\n\t\t}else if(dojo.render.html.safari){\n\t\t\t\/\/ Blah. WebKit doesn't actually populate responseText and\/or responseXML. Useless.\n\t\t\tdojo.debug(\"Webkit is broken with multipart responses over XHR = (\");\n\t\t\tthis.xhr.onreadystatechange = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}else{\n\t\t\tthis.xhr.onload = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}\n\t\tthis.xhr.open(\"POST\", (url||cometd.url), true); \/\/ async post\n\t\tthis.xhr.setRequestHeader(\"Content-Type\", \"application\/x-www-form-urlencoded\");\n\t\tdojo.debug(dojo.json.serialize(content));\n\t\tthis.xhr.send(dojo.io.argsFromMap(content, \"utf8\"));\n\t}\n\tthis.processBacklog = function(){\n\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}\n\t}\n\tthis.sendMessage = function(message, bypassBacklog){\n\t\t\/\/ FIXME: what about auth fields?\n\t\tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}\n\t}\n\tthis.startup = function(handshakeData){\n\t\tdojo.debugShallow(handshakeData);\n\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();\n\t}","instance_variables":["connected","connectionId","xhr","authToken","lastTimestamp","lastId","backlog","check","tunnelInit","tunnelCollapse","deliver","handleOnLoad","openTunnelWith","xhr.multipart","xhr.onreadystatechange","xhr.onload","processBacklog","sendMessage","startup"]}},"cometd.mimeReplaceTransport.check":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":" \treturn ((!xdomain)&&\n\t\t\t\t(dojo.render.html.mozilla)&& \/\/ seems only Moz really supports this right now = (\n\t\t\t\t(dojo.lang.inArray(types, \"mime-message-block\")));","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.tunnelInit":{"meta":{"summary":"","src":" \tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"mime-message-block\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.tunnelCollapse":{"meta":{"summary":"","src":" \tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.handleOnLoad":{"meta":{"summary":"","parameters":{"resp":{"type":""}},"src":" \tcometd.deliver(dojo.json.evalJson(this.xhr.responseText));","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.openTunnelWith":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":" \tthis.xhr = dojo.hostenv.getXmlhttpObject();\n\t\tthis.xhr.multipart = true; \/\/ FIXME: do Opera and Safari support this flag?\n\t\tif(dojo.render.html.mozilla){\n\t\t\tthis.xhr.addEventListener(\"load\", dojo.lang.hitch(this, \"handleOnLoad\"), false);\n\t\t}else if(dojo.render.html.safari){\n\t\t\t\/\/ Blah. WebKit doesn't actually populate responseText and\/or responseXML. Useless.\n\t\t\tdojo.debug(\"Webkit is broken with multipart responses over XHR = (\");\n\t\t\tthis.xhr.onreadystatechange = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}else{\n\t\t\tthis.xhr.onload = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}\n\t\tthis.xhr.open(\"POST\", (url||cometd.url), true); \/\/ async post\n\t\tthis.xhr.setRequestHeader(\"Content-Type\", \"application\/x-www-form-urlencoded\");\n\t\tdojo.debug(dojo.json.serialize(content));\n\t\tthis.xhr.send(dojo.io.argsFromMap(content, \"utf8\"));","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.processBacklog":{"meta":{"summary":"","src":" \twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.sendMessage":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":" \tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}","instance":"cometd.mimeReplaceTransport"}},"cometd.mimeReplaceTransport.startup":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":" \tdojo.debugShallow(handshakeData);\n\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();","instance":"cometd.mimeReplaceTransport"}},"cometd.longPollTransport":{"meta":{"initialized":true,"summary":"","src":" this.connected = false;\n\tthis.connectionId = null;\n\tthis.authToken = null;\n\tthis.lastTimestamp = null;\n\tthis.lastId = null;\n\tthis.backlog = [];\n\tthis.check = function(types, version, xdomain){\n\t\treturn ((!xdomain)&&(dojo.lang.inArray(types, \"long-polling\")));\n\t}\n\tthis.tunnelInit = function(){\n\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"long-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;\n\t}\n\tthis.tunnelCollapse = function(){\n\t\tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tdojo.debug(\"clientId:\", cometd.clientId);\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\tthis.deliver = cometd.iframeTransport.deliver;\n\t\/\/ the logic appears to be the same\n\tthis.openTunnelWith = function(content, url){\n\t\tdojo.io.bind({\n\t\t\turl: (url||cometd.url),\n\t\t\tmethod: \"post\",\n\t\t\tcontent: content,\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\t\/\/ dojo.debug(evt.responseText);\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;\n\t}\n\tthis.processBacklog = function(){\n\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}\n\t}\n\tthis.sendMessage = function(message, bypassBacklog){\n\t\t\/\/ FIXME: what about auth fields?\n\t\tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"post\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}\n\t}\n\tthis.startup = function(handshakeData){\n\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();\n\t}","instance_variables":["connected","connectionId","authToken","lastTimestamp","lastId","backlog","check","tunnelInit","tunnelCollapse","deliver","openTunnelWith","processBacklog","sendMessage","startup"]}},"cometd.longPollTransport.check":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":" \treturn ((!xdomain)&&(dojo.lang.inArray(types, \"long-polling\")));","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.tunnelInit":{"meta":{"summary":"","src":" \tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"long-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.tunnelCollapse":{"meta":{"summary":"","src":" \tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tdojo.debug(\"clientId:\", cometd.clientId);\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.openTunnelWith":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":" \tdojo.io.bind({\n\t\t\turl: (url||cometd.url),\n\t\t\tmethod: \"post\",\n\t\t\tcontent: content,\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\t\/\/ dojo.debug(evt.responseText);\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.processBacklog":{"meta":{"summary":"","src":" \twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.sendMessage":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":" \tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"post\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}","instance":"cometd.longPollTransport"}},"cometd.longPollTransport.startup":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":" \tif(this.connected){ return; }\n\t\tthis.tunnelInit();","instance":"cometd.longPollTransport"}},"cometd.callbackPollTransport":{"meta":{"initialized":true,"summary":"","src":" this.connected = false;\n\tthis.connectionId = null;\n\tthis.authToken = null;\n\tthis.lastTimestamp = null;\n\tthis.lastId = null;\n\tthis.backlog = [];\n\tthis.check = function(types, version, xdomain){\n\t\t\/\/ we handle x-domain!\n\t\treturn dojo.lang.inArray(types, \"callback-polling\");\n\t}\n\tthis.tunnelInit = function(){\n\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"callback-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;\n\t}\n\tthis.tunnelCollapse = function(){\n\t\tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}\n\t}\n\tthis.deliver = cometd.iframeTransport.deliver;\n\t\/\/ the logic appears to be the same\n\tthis.openTunnelWith = function(content, url){\n\t\t\/\/ create a <script> element to generate the request\n\t\tvar req = dojo.io.bind({\n\t\t\turl: (url||cometd.url),\n\t\t\tcontent: content,\n\t\t\tmimetype: \"text\/json\",\n\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\tjsonParamName: \"jsonp\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;\n\t}\n\tthis.processBacklog = function(){\n\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}\n\t}\n\tthis.sendMessage = function(message, bypassBacklog){\n\t\t\/\/ FIXME: what about auth fields?\n\t\tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\t\tjsonParamName: \"jsonp\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}\n\t}\n\tthis.startup = function(handshakeData){\n\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();\n\t}","instance_variables":["connected","connectionId","authToken","lastTimestamp","lastId","backlog","check","tunnelInit","tunnelCollapse","deliver","openTunnelWith","processBacklog","sendMessage","startup"]}},"cometd.callbackPollTransport.check":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":" \treturn dojo.lang.inArray(types, \"callback-polling\");","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.tunnelInit":{"meta":{"summary":"","src":" \tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"callback-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.tunnelCollapse":{"meta":{"summary":"","src":" \tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.openTunnelWith":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":" \tvar req = dojo.io.bind({\n\t\t\turl: (url||cometd.url),\n\t\t\tcontent: content,\n\t\t\tmimetype: \"text\/json\",\n\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\tjsonParamName: \"jsonp\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.processBacklog":{"meta":{"summary":"","src":" \twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.sendMessage":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":" \tif((bypassBacklog)||(this.connected)){\n\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\t\tjsonParamName: \"jsonp\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}","instance":"cometd.callbackPollTransport"}},"cometd.callbackPollTransport.startup":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":" \tif(this.connected){ return; }\n\t\tthis.tunnelInit();","instance":"cometd.callbackPollTransport"}}}}},"dojo.io.common":{"meta":{"requires":{"common":["dojo.string","dojo.lang.extras"]},"functions":{"dojo.io.Request":{"meta":{"summary":"Constructs a Request object that is used by dojo.io.bind().","parameters":{"url":{"type":"String"},"mimetype":{"type":"String"},"transport":{"type":"String"},"changeUrl":{"type":"String or Boolean"}},"src":" if((arguments.length == 1)&&(arguments[0].constructor == Object)){\n\t\tthis.fromKwArgs(arguments[0]);\n\t}else{\n\t\tthis.url = url;\n\t\tif(mimetype){ this.mimetype = mimetype; }\n\t\tif(transport){ this.transport = transport; }\n\t\tif(arguments.length >= 4){ this.changeUrl = changeUrl; }\n\t}","instance_variables":["url","mimetype","transport","changeUrl"],"description":"dojo.io.bind() will create one of these for you if you call dojo.io.bind() with an plain object containing the bind parameters. This method can either take the arguments specified, or an Object containing all of the parameters that you want to use to create the dojo.io.Request (similar to how dojo.io.bind() is called. The named parameters to this constructor represent the minimum set of parameters need","prototype_variables":["url","mimetype","method","content","transport","changeUrl","formNode","sync","bindSuccess","useCache","preventCache","timeoutSeconds"]}},"dojo.io.Error":{"meta":{"summary":"Constructs an object representing a bind error.","parameters":{"msg":{"type":"String"},"type":{"type":"String"},"num":{"type":"Number"}},"src":" this.message = msg;\n\tthis.type =  type || \"unknown\"; \/\/ must be one of \"io\", \"parse\", \"unknown\"\n\tthis.number = num || 0; \/\/ per-substrate error number, not normalized","instance_variables":["message","type","number"]}},"dojo.io.transports.addTransport":{"meta":{"summary":"Used to register transports that can support bind calls.","parameters":{"name":{"type":"String"}},"src":" this.push(name);\n\t\/\/ FIXME: do we need to handle things that aren't direct children of the\n\t\/\/ dojo.io module? (say, dojo.io.foo.fooTransport?)\n\tthis[name] = dojo.io[name];"}},"dojo.io.bind":{"meta":{"summary":"Binding interface for IO. Loading different IO transports, like dojo.io.BrowserIO or dojo.io.IframeIO, will register with bind to handle particular types of bind calls.","parameters":{"request":{"type":"dojo.io.Request or Object"}},"src":" if(!(request instanceof dojo.io.Request)){\n\t\ttry{\n\t\t\trequest = new dojo.io.Request(request);\n\t\t}catch(e){ dojo.debug(e); }\n\t}\n\t\/\/ if the request asks for a particular implementation, use it\n\tvar tsName = \"\";\n\tif(request[\"transport\"]){\n\t\ttsName = request[\"transport\"];\n\t\tif(!this[tsName]){\n\t\t\tdojo.io.sendBindError(request, \"No dojo.io.bind() transport with name '\"\n\t\t\t\t+ request[\"transport\"] + \"'.\");\n\t\t\treturn request; \/\/dojo.io.Request\n\t\t}\n\t\tif(!this[tsName].canHandle(request)){\n\t\t\tdojo.io.sendBindError(request, \"dojo.io.bind() transport with name '\"\n\t\t\t\t+ request[\"transport\"] + \"' cannot handle this type of request.\");\n\t\t\treturn request;\t\/\/dojo.io.Request\n\t\t}\n\t}else{\n\t\t\/\/ otherwise we do our best to auto-detect what available transports\n\t\t\/\/ will handle \n\t\tfor(var x=0; x<dojo.io.transports.length; x++){\n\t\t\tvar tmp = dojo.io.transports[x];\n\t\t\tif((this[tmp])&&(this[tmp].canHandle(request))){\n\t\t\t\ttsName = tmp;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(tsName == \"\"){\n\t\t\tdojo.io.sendBindError(request, \"None of the loaded transports for dojo.io.bind()\"\n\t\t\t\t+ \" can handle the request.\");\n\t\t\treturn request; \/\/dojo.io.Request\n\t\t}\n\t}\n\tthis[tsName].bind(request);\n\trequest.bindSuccess = true;\n\treturn request; \/\/dojo.io.Request","returns":"dojo.io.Request"},"extra":{"parameters":{"request":{"type":"Object","summary":"Object containing bind arguments. This object is converted to a dojo.io.Request object, and that request object is the return value for this method."}}}},"dojo.io.sendBindError":{"meta":{"summary":"Used internally by dojo.io.bind() to return\/raise a bind error.","parameters":{"request":{"type":"Object"},"message":{"type":"String"}},"src":"\t\/\/Need to be careful since not all hostenvs support setTimeout.\n\tif((typeof request.error == \"function\" || typeof request.handle == \"function\")\n\t\t&& (typeof setTimeout == \"function\" || typeof setTimeout == \"object\")){\n\t\tvar errorObject = new dojo.io.Error(message);\n\t\tsetTimeout(function(){\n\t\t\trequest[(typeof request.error == \"function\") ? \"error\" : \"handle\"](\"error\", errorObject, null, request);\n\t\t}, 50);\n\t}else{\n\t\tdojo.raise(message);\n\t}"}},"dojo.io.queueBind":{"meta":{"summary":"queueBind will use dojo.io.bind() but guarantee that only one bind call is handled at a time.","parameters":{"request":{"type":"dojo.io.Request or Object"}},"src":" if(!(request instanceof dojo.io.Request)){\n\t\ttry{\n\t\t\trequest = new dojo.io.Request(request);\n\t\t}catch(e){ dojo.debug(e); }\n\t}\n\t\/\/ make sure we get called if\/when we get a response\n\tvar oldLoad = request.load;\n\trequest.load = function(){\n\t\tdojo.io._queueBindInFlight = false;\n\t\tvar ret = oldLoad.apply(this, arguments);\n\t\tdojo.io._dispatchNextQueueBind();\n\t\treturn ret;\n\t}\n\tvar oldErr = request.error;\n\trequest.error = function(){\n\t\tdojo.io._queueBindInFlight = false;\n\t\tvar ret = oldErr.apply(this, arguments);\n\t\tdojo.io._dispatchNextQueueBind();\n\t\treturn ret;\n\t}\n\tdojo.io._bindQueue.push(request);\n\tdojo.io._dispatchNextQueueBind();\n\treturn request; \/\/dojo.io.Request","description":"If queueBind is called while a bind call is in process, it will queue up the other calls to bind and call them in order as bind calls complete.","returns":"dojo.io.Request","call_chain":["oldLoad","oldErr"]},"extra":{"parameters":{"request":{"type":"Object","summary":"Same sort of request object as used for dojo.io.bind()."}}}},"dojo.io._dispatchNextQueueBind":{"meta":{"summary":"Private method used by dojo.io.queueBind().","src":" if(!dojo.io._queueBindInFlight){\n\t\tdojo.io._queueBindInFlight = true;\n\t\tif(dojo.io._bindQueue.length > 0){\n\t\t\tdojo.io.bind(dojo.io._bindQueue.shift());\n\t\t}else{\n\t\t\tdojo.io._queueBindInFlight = false;\n\t\t}\n\t}"}},"dojo.io.argsFromMap":{"meta":{"summary":"Converts name\/values pairs in the map object to an URL-encoded string with format of name1=value1&name2=value2...","parameters":{"map":{"type":"Object"},"encoding":{"type":"String?"},"last":{"type":"String?"}},"src":" var enc = \/utf\/i.test(encoding||\"\") ? encodeURIComponent : dojo.string.encodeAscii;\n\tvar mapped = [];\n\tvar control = new Object();\n\tfor(var name in map){\n\t\tvar domap = function(elt){\n\t\t\tvar val = enc(name)+\"=\"+enc(elt);\n\t\t\tmapped[(last == name) ? \"push\" : \"unshift\"](val);\n\t\t}\n\t\tif(!control[name]){\n\t\t\tvar value = map[name];\n\t\t\t\/\/ FIXME: should be isArrayLike?\n\t\t\tif (dojo.lang.isArray(value)){\n\t\t\t\tdojo.lang.forEach(value, domap);\n\t\t\t}else{\n\t\t\t\tdomap(value);\n\t\t\t}\n\t\t}\n\t}\n\treturn mapped.join(\"&\"); \/\/String","returns":"String"},"extra":{"parameters":{"map":{"type":"Object","summary":"Object that has the contains the names and values."},"encoding":{"type":"String?","summary":"String to specify how to encode the name and value. If the encoding string contains \"utf\" (case-insensitive), then encodeURIComponent is used. Otherwise dojo.string.encodeAscii is used."},"last":{"type":"String?","summary":"The last parameter in the list. Helps with final string formatting?"}}}},"dojo.io.setIFrameSrc":{"meta":{"summary":"Sets the URL that is loaded in an IFrame. The replace parameter indicates whether location.replace() should be used when changing the location of the iframe.","parameters":{"iframe":{"type":"DOMNode"},"src":{"type":"String"},"replace":{"type":"Boolean"}},"src":" try{\n\t\tvar r = dojo.render.html;\n\t\t\/\/ dojo.debug(iframe);\n\t\tif(!replace){\n\t\t\tif(r.safari){\n\t\t\t\tiframe.location = src;\n\t\t\t}else{\n\t\t\t\tframes[iframe.name].location = src;\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/ Fun with DOM 0 incompatibilities!\n\t\t\tvar idoc;\n\t\t\tif(r.ie){\n\t\t\t\tidoc = iframe.contentWindow.document;\n\t\t\t}else if(r.safari){\n\t\t\t\tidoc = iframe.document;\n\t\t\t}else{ \/\/  if(r.moz){\n\t\t\t\tidoc = iframe.contentWindow;\n\t\t\t}\n\t\t\t\/\/For Safari (at least 2.0.3) and Opera, if the iframe\n\t\t\t\/\/has just been created but it doesn't have content\n\t\t\t\/\/yet, then iframe.document may be null. In that case,\n\t\t\t\/\/use iframe.location and return.\n\t\t\tif(!idoc){\n\t\t\t\tiframe.location = src;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tidoc.location.replace(src);\n\t\t\t}\n\t\t}\n\t}catch(e){ \n\t\tdojo.debug(e); \n\t\tdojo.debug(\"setIFrameSrc: \"+e); \n\t}"}},"dojo.io.Request.load":{"meta":{"summary":"Called on successful completion of a bind.","parameters":{"type":{"type":"String"},"data":{"type":"Object"},"transportImplementation":{"type":"Object"},"kwArgs":{"type":"Object"}},"src":"\t\t\/\/ summary:\n\t\t\/\/\t\tCalled on successful completion of a bind.\n\t\t\/\/\t\ttype: String\n\t\t\/\/\t\t\t\tA string with value \"load\"\n\t\t\/\/\t\tdata: Object\n\t\t\/\/\t\t\t\tThe object representing the result of the bind. The actual structure\n\t\t\/\/\t\t\t\tof the data object will depend on the mimetype that was given to bind\n\t\t\/\/\t\t\t\tin the bind arguments.\n\t\t\/\/\t\ttransportImplementation: Object\n\t\t\/\/\t\t\t\tThe object that implements a particular transport. Structure is depedent\n\t\t\/\/\t\t\t\ton the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the\n\t\t\/\/\t\t\t\tXMLHttpRequest object from the browser.\n\t\t\/\/\t\tkwArgs: Object\n\t\t\/\/\t\t\t\tObject that contains the request parameters that were given to the\n\t\t\/\/\t\t\t\tbind call. Useful for storing and retrieving state from when bind\n\t\t\/\/\t\t\t\twas called.","prototype":"dojo.io.Request"},"extra":{"parameters":{"type":{"type":"String","summary":"A string with value \"load\""},"data":{"type":"Object","summary":"The object representing the result of the bind. The actual structure of the data object will depend on the mimetype that was given to bind in the bind arguments."},"transportImplementation":{"type":"Object","summary":"The object that implements a particular transport. Structure is depedent on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the XMLHttpRequest object from the browser."},"kwArgs":{"type":"Object","summary":"Object that contains the request parameters that were given to the bind call. Useful for storing and retrieving state from when bind was called."}}}},"dojo.io.Request.error":{"meta":{"summary":"Called when there is an error with a bind.","parameters":{"type":{"type":"String"},"error":{"type":"Object"},"transportImplementation":{"type":"Object"},"kwArgs":{"type":"Object"}},"src":"\t\t\/\/ summary:\n\t\t\/\/\t\tCalled when there is an error with a bind.\n\t\t\/\/\t\ttype: String\n\t\t\/\/\t\t\t\tA string with value \"error\"\n\t\t\/\/\t\terror: Object\n\t\t\/\/\t\t\t\tThe error object. Should be a dojo.io.Error object, but not guaranteed.\n\t\t\/\/\t\ttransportImplementation: Object\n\t\t\/\/\t\t\t\tThe object that implements a particular transport. Structure is depedent\n\t\t\/\/\t\t\t\ton the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the\n\t\t\/\/\t\t\t\tXMLHttpRequest object from the browser.\n\t\t\/\/\t\tkwArgs: Object\n\t\t\/\/\t\t\t\tObject that contains the request parameters that were given to the\n\t\t\/\/\t\t\t\tbind call. Useful for storing and retrieving state from when bind\n\t\t\/\/\t\t\t\twas called.","prototype":"dojo.io.Request"},"extra":{"parameters":{"type":{"type":"String","summary":"A string with value \"error\""},"error":{"type":"Object","summary":"The error object. Should be a dojo.io.Error object, but not guaranteed."},"transportImplementation":{"type":"Object","summary":"The object that implements a particular transport. Structure is depedent on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the XMLHttpRequest object from the browser."},"kwArgs":{"type":"Object","summary":"Object that contains the request parameters that were given to the bind call. Useful for storing and retrieving state from when bind was called."}}}},"dojo.io.Request.timeout":{"meta":{"summary":"Called when there is an error with a bind. Only implemented in certain transports at this time.","parameters":{"type":{"type":"String"},"empty":{"type":"Object"},"transportImplementation":{"type":"Object"},"kwArgs":{"type":"Object"}},"src":"\t\t\/\/ summary:\n\t\t\/\/\t\tCalled when there is an error with a bind. Only implemented in certain transports at this time.\n\t\t\/\/\t\ttype: String\n\t\t\/\/\t\t\t\tA string with value \"timeout\"\n\t\t\/\/\t\tempty: Object\n\t\t\/\/\t\t\t\tShould be null. Just a spacer argument so that load, error, timeout and handle have the\n\t\t\/\/\t\t\t\tsame signatures.\n\t\t\/\/\t\ttransportImplementation: Object\n\t\t\/\/\t\t\t\tThe object that implements a particular transport. Structure is depedent\n\t\t\/\/\t\t\t\ton the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the\n\t\t\/\/\t\t\t\tXMLHttpRequest object from the browser. May be null for the timeout case for\n\t\t\/\/\t\t\t\tsome transports.\n\t\t\/\/\t\tkwArgs: Object\n\t\t\/\/\t\t\t\tObject that contains the request parameters that were given to the\n\t\t\/\/\t\t\t\tbind call. Useful for storing and retrieving state from when bind\n\t\t\/\/\t\t\t\twas called.","prototype":"dojo.io.Request"},"extra":{"parameters":{"type":{"type":"String","summary":"A string with value \"timeout\""},"empty":{"type":"Object","summary":"Should be null. Just a spacer argument so that load, error, timeout and handle have the same signatures."},"transportImplementation":{"type":"Object","summary":"The object that implements a particular transport. Structure is depedent on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the XMLHttpRequest object from the browser. May be null for the timeout case for some transports."},"kwArgs":{"type":"Object","summary":"Object that contains the request parameters that were given to the bind call. Useful for storing and retrieving state from when bind was called."}}}},"dojo.io.Request.handle":{"meta":{"summary":"The handle method can be defined instead of defining separate load, error and timeout callbacks.","parameters":{"type":{"type":"String"},"data":{"type":"Object"},"transportImplementation":{"type":"Object"},"kwArgs":{"type":"Object"}},"src":"\t\t\/\/ summary:\n\t\t\/\/\t\tThe handle method can be defined instead of defining separate load, error and timeout\n\t\t\/\/\t\tcallbacks.\n\t\t\/\/\t\ttype: String\n\t\t\/\/\t\t\t\tA string with the type of callback: \"load\", \"error\", or \"timeout\".\n\t\t\/\/\t\tdata: Object\n\t\t\/\/\t\t\t\tSee the above callbacks for what this parameter could be.\n\t\t\/\/\t\ttransportImplementation: Object\n\t\t\/\/\t\t\t\tThe object that implements a particular transport. Structure is depedent\n\t\t\/\/\t\t\t\ton the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the\n\t\t\/\/\t\t\t\tXMLHttpRequest object from the browser.\n\t\t\/\/\t\tkwArgs: Object\n\t\t\/\/\t\t\t\tObject that contains the request parameters that were given to the\n\t\t\/\/\t\t\t\tbind call. Useful for storing and retrieving state from when bind\n\t\t\/\/\t\t\t\twas called.\t","prototype":"dojo.io.Request"},"extra":{"parameters":{"type":{"type":"String","summary":"A string with the type of callback: \"load\", \"error\", or \"timeout\"."},"data":{"type":"Object","summary":"See the above callbacks for what this parameter could be."},"transportImplementation":{"type":"Object","summary":"The object that implements a particular transport. Structure is depedent on the transport. For XMLHTTPTransport (dojo.io.BrowserIO), it will be the XMLHttpRequest object from the browser."},"kwArgs":{"type":"Object","summary":"Object that contains the request parameters that were given to the bind call. Useful for storing and retrieving state from when bind was called."}}}},"dojo.io.Request.abort":{"meta":{"summary":"","src":"","prototype":"dojo.io.Request"}},"dojo.io.Request.fromKwArgs":{"meta":{"summary":"Creates a dojo.io.Request from a simple object (kwArgs object).","parameters":{"kwArgs":{"type":"Object"}},"src":"\t\t\/\/ normalize args\n\t\tif(kwArgs[\"url\"]){ kwArgs.url = kwArgs.url.toString(); }\n\t\tif(kwArgs[\"formNode\"]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }\n\t\tif(!kwArgs[\"method\"] && kwArgs[\"formNode\"] && kwArgs[\"formNode\"].method) {\n\t\t\tkwArgs.method = kwArgs[\"formNode\"].method;\n\t\t}\n\t\t\/\/ backwards compatibility\n\t\tif(!kwArgs[\"handle\"] && kwArgs[\"handler\"]){ kwArgs.handle = kwArgs.handler; }\n\t\tif(!kwArgs[\"load\"] && kwArgs[\"loaded\"]){ kwArgs.load = kwArgs.loaded; }\n\t\tif(!kwArgs[\"changeUrl\"] && kwArgs[\"changeURL\"]) { kwArgs.changeUrl = kwArgs.changeURL; }\n\t\t\/\/ encoding fun!\n\t\tkwArgs.encoding = dojo.lang.firstValued(kwArgs[\"encoding\"], djConfig[\"bindEncoding\"], \"\");\n\t\tkwArgs.sendTransport = dojo.lang.firstValued(kwArgs[\"sendTransport\"], djConfig[\"ioSendTransport\"], false);\n\t\tvar isFunction = dojo.lang.isFunction;\n\t\tfor(var x=0; x<dojo.io.hdlrFuncNames.length; x++){\n\t\t\tvar fn = dojo.io.hdlrFuncNames[x];\n\t\t\tif(kwArgs[fn] && isFunction(kwArgs[fn])){ continue; }\n\t\t\tif(kwArgs[\"handle\"] && isFunction(kwArgs[\"handle\"])){\n\t\t\t\tkwArgs[fn] = kwArgs.handle;\n\t\t\t}\n\t\t\t\/\/ handler is aliased above, shouldn't need this check\n\t\t\t\/* else if(dojo.lang.isObject(kwArgs.handler)){\n\t\t\t\tif(isFunction(kwArgs.handler[fn])){\n\t\t\t\t\tkwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler[\"handle\"]||function(){};\n\t\t\t\t}\n\t\t\t}*\/\n\t\t}\n\t\tdojo.lang.mixin(this, kwArgs);","prototype":"dojo.io.Request"}}}}},"dojo.io.cookie":{"meta":{"functions":{"dojo.io.cookie.setCookie":{"meta":{"summary":"sets a cookie.","parameters":{"name":{"type":"String"},"value":{"type":"String"},"days":{"type":"Number?"},"path":{"type":"String?"},"domain":{"type":"String?"},"secure":{"type":"boolean?"}},"src":" var expires = -1;\n\tif((typeof days == \"number\")&&(days >= 0)){\n\t\tvar d = new Date();\n\t\td.setTime(d.getTime()+(days*24*60*60*1000));\n\t\texpires = d.toGMTString();\n\t}\n\tvalue = escape(value);\n\tdocument.cookie = name + \"=\" + value + \";\"\n\t\t+ (expires != -1 ? \" expires=\" + expires + \";\" : \"\")\n\t\t+ (path ? \"path=\" + path : \"\")\n\t\t+ (domain ? \"; domain=\" + domain : \"\")\n\t\t+ (secure ? \"; secure\" : \"\");"}},"dojo.io.cookie.getCookie":{"meta":{"summary":"Gets a cookie with the given name.","parameters":{"name":{"type":"String"}},"src":"\t\/\/ FIXME: Which cookie should we return?\n\t\/\/        If there are cookies set for different sub domains in the current\n\t\/\/        scope there could be more than one cookie with the same name.\n\t\/\/        I think taking the last one in the list takes the one from the\n\t\/\/        deepest subdomain, which is what we're doing here.\n\tvar idx = document.cookie.lastIndexOf(name+'=');\n\tif(idx == -1) { return null; }\n\tvar value = document.cookie.substring(idx+name.length+1);\n\tvar end = value.indexOf(';');\n\tif(end == -1) { end = value.length; }\n\tvalue = value.substring(0, end);\n\tvalue = unescape(value);\n\treturn value; \/\/String","returns":"String"}},"dojo.io.cookie.deleteCookie":{"meta":{"summary":"Deletes a cookie with the given name.","parameters":{"name":{"type":"String"}},"src":" dojo.io.cookie.setCookie(name, \"-\", 0);"}},"dojo.io.cookie.setObjectCookie":{"meta":{"summary":"Takes an object, serializes it to a cookie value, and either sets a cookie with the serialized value.","parameters":{"name":{"type":"String"},"obj":{"type":"Object"},"days":{"type":"Number?"},"path":{"type":"String?"},"domain":{"type":"String?"},"secure":{"type":"boolean?"},"clearCurrent":{"type":"boolean?"}},"src":" if(arguments.length == 5){ \/\/ for backwards compat\n\t\tclearCurrent = domain;\n\t\tdomain = null;\n\t\tsecure = null;\n\t}\n\tvar pairs = [], cookie, value = \"\";\n\tif(!clearCurrent){\n\t\tcookie = dojo.io.cookie.getObjectCookie(name);\n\t}\n\tif(days >= 0){\n\t\tif(!cookie){ cookie = {}; }\n\t\tfor(var prop in obj){\n\t\t\tif(obj[prop] == null){\n\t\t\t\tdelete cookie[prop];\n\t\t\t}else if((typeof obj[prop] == \"string\")||(typeof obj[prop] == \"number\")){\n\t\t\t\tcookie[prop] = obj[prop];\n\t\t\t}\n\t\t}\n\t\tprop = null;\n\t\tfor(var prop in cookie){\n\t\t\tpairs.push(escape(prop) + \"=\" + escape(cookie[prop]));\n\t\t}\n\t\tvalue = pairs.join(\"&\");\n\t}\n\tdojo.io.cookie.setCookie(name, value, days, path, domain, secure);","description":"If clearCurrent is true, then any current cookie value for this object will be replaced with the the new serialized object value. If clearCurrent is false, then the existing cookie value will be modified with any changes from the new object value. Objects must be simple name\/value pairs where the value is either a string or a number. Any other value will be ignored."}},"dojo.io.cookie.getObjectCookie":{"meta":{"summary":"Gets an object value for the given cookie name. The complement of dojo.io.cookie.setObjectCookie().","parameters":{"name":{"type":"String"}},"src":" var values = null, cookie = dojo.io.cookie.getCookie(name);\n\tif(cookie){\n\t\tvalues = {};\n\t\tvar pairs = cookie.split(\"&\");\n\t\tfor(var i = 0; i < pairs.length; i++){\n\t\t\tvar pair = pairs[i].split(\"=\");\n\t\t\tvar value = pair[1];\n\t\t\tif( isNaN(value) ){ value = unescape(pair[1]); }\n\t\t\tvalues[ unescape(pair[0]) ] = value;\n\t\t}\n\t}\n\treturn values;"}},"dojo.io.cookie.isSupported":{"meta":{"summary":"Tests the browser to see if cookies are enabled.","src":" if(typeof navigator.cookieEnabled != \"boolean\"){\n\t\tdojo.io.cookie.setCookie(\"__TestingYourBrowserForCookieSupport__\",\n\t\t\t\"CookiesAllowed\", 90, null);\n\t\tvar cookieVal = dojo.io.cookie.getCookie(\"__TestingYourBrowserForCookieSupport__\");\n\t\tnavigator.cookieEnabled = (cookieVal == \"CookiesAllowed\");\n\t\tif(navigator.cookieEnabled){\n\t\t\t\/\/ FIXME: should we leave this around?\n\t\t\tthis.deleteCookie(\"__TestingYourBrowserForCookieSupport__\");\n\t\t}\n\t}\n\treturn navigator.cookieEnabled; \/\/boolean","returns":"boolean"}}}}},"dojo.io":{"meta":{"requires":{"common":["dojo.io.*"]}}}}