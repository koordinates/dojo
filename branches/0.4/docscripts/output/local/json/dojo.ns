{"dojo.ns":{"meta":{"functions":{"dojo.ns.Ns":{"meta":{"summary":"this object simply encapsulates namespace data","parameters":{"name":{"type":"String"},"module":{"type":"String"},"resolver":{"type":"Function?"}},"src":" this.name = name;\r\n\tthis.module = module;\r\n\tthis.resolver = resolver;\r\n\tthis._loaded = [ ];\r\n\tthis._failed = [ ];\r","instance_variables":["name","module","resolver","_loaded","_failed"]}},"dojo.ns.Ns.resolve":{"meta":{"summary":"map component with 'name' and 'domain' to a module via namespace resolver, if specified","parameters":{"name":{"type":"String"},"domain":{"type":"String"},"omitModuleCheck":{"type":"Boolean?"}},"src":" if(!this.resolver || djConfig[\"skipAutoRequire\"]){return false;} \/\/ Boolean\r\n\tvar fullName = this.resolver(name, domain);\r\n\t\/\/only load a widget once. This is a quicker check than dojo.require does\r\n\tif((fullName)&&(!this._loaded[fullName])&&(!this._failed[fullName])){\r\n\t\t\/\/workaround so we don't break the build system\r\n\t\tvar req = dojo.require;\r\n\t\treq(fullName, false, true); \/\/omit the module check, we'll do it ourselves.\r\n\t\tif(dojo.hostenv.findModule(fullName, false)){\r\n\t\t\tthis._loaded[fullName] = true;\r\n\t\t}else{\r\n\t\t\tif(!omitModuleCheck){dojo.raise(\"dojo.ns.Ns.resolve: module '\" + fullName + \"' not found after loading via namespace '\" + this.name + \"'\");} \r\n\t\t\tthis._failed[fullName] = true;\r\n\t\t}\r\n\t}\r\n\treturn Boolean(this._loaded[fullName]); \/\/ Boolean\r","returns":"Boolean","prototype":"dojo.ns.Ns"}},"dojo.registerNamespace":{"meta":{"summary":"maps a module name to a namespace for widgets, and optionally maps widget names to modules for auto-loading","parameters":{"name":{"type":"String"},"module":{"type":"String"},"resolver":{"type":"Function?"}},"src":" dojo.ns.register.apply(dojo.ns, arguments);\r","description":"An unregistered namespace is mapped to an eponymous module. For example, namespace acme is mapped to module acme, and widgets are assumed to belong to acme.widget. If you want to use a different widget","call_chain":["dojo.ns.register"]},"extra":{"parameters":{"module":{"type":"use","summary":"dojo.registerNamespace."}}}},"dojo.registerNamespaceResolver":{"meta":{"summary":"a resolver function maps widget names to modules, so the widget manager can auto-load needed widget implementations","parameters":{"name":{"type":"String"},"resolver":{"type":"Function"}},"src":" var n = dojo.ns.namespaces[name];\r\n\tif(n){\r\n\t\tn.resolver = resolver;\r\n\t}\r","description":"The resolver provides information to allow Dojo to load widget modules on demand. When a widget is created, a namespace resolver can tell Dojo what module to require to ensure that the widget implementation code is loaded."},"extra":{"parameters":{"name":{"type":"will","summary":"always be lower-case. example: dojo.registerNamespaceResolver(\"acme\", function(name){ return \"acme.widget.\"+dojo.string.capitalize(name); } );"}}}},"dojo.registerNamespaceManifest":{"meta":{"summary":"convenience function to register a module path, a namespace, and optionally a resolver all at once.","parameters":{"module":{"type":"String"},"path":{"type":"String"},"name":{"type":"String"},"widgetModule":{"type":"String"},"resolver":{"type":"Function?"}},"src":" dojo.registerModulePath(name, path);\r\n\tdojo.registerNamespace(name, widgetModule, resolver);\r"}},"dojo.ns.register":{"meta":{"summary":"creates and registers a dojo.ns.Ns object","parameters":{"name":{"type":"String"},"module":{"type":"String"},"resolver":{"type":"Function?"},"noOverride":{"type":"Boolean?"}},"src":" \tif(!noOverride || !this.namespaces[name]){\r\n\t\t\tthis.namespaces[name] = new dojo.ns.Ns(name, module, resolver);\r\n\t\t}\r"}},"dojo.ns.allow":{"meta":{"summary":"Returns false if 'name' is filtered by configuration or has failed to load, true otherwise","parameters":{"name":{"type":"String"}},"src":" \tif(this.failed[name]){return false;} \/\/ Boolean\r\n\t\tif((djConfig.excludeNamespace)&&(dojo.lang.inArray(djConfig.excludeNamespace, name))){return false;} \/\/ Boolean\r\n\t\t\/\/ If the namespace is \"dojo\", or the user has not specified allowed namespaces return true.\r\n\t\t\/\/ Otherwise, if the user has specifically allowed this namespace, return true, otherwise false.\r\n\t\treturn((name==this.dojo)||(!djConfig.includeNamespace)||(dojo.lang.inArray(djConfig.includeNamespace, name))); \/\/ Boolean\r","returns":"Boolean"}},"dojo.ns.get":{"meta":{"summary":"Return Ns object registered to 'name', if any","parameters":{"name":{"type":"String"}},"src":" \treturn this.namespaces[name]; \/\/ Ns\r","returns":"Ns"}},"dojo.ns.require":{"meta":{"summary":"Try to ensure that 'name' is registered, loading a namespace manifest if necessary","parameters":{"name":{"type":"String"}},"src":" \tvar ns = this.namespaces[name];\r\n\t\tif((ns)&&(this.loaded[name])){return ns;} \/\/ Ns\r\n\t\tif(!this.allow(name)){return false;} \/\/ Boolean\r\n \t\tif(this.loading[name]){\r\n\t\t\t\/\/ FIXME: do we really ever have re-entrancy situation? this would appear to be really bad\r\n\t\t\t\/\/ original code did not throw an exception, although that seems the only course\r\n\t\t\t\/\/ adding debug output here to track if this occurs.\r\n\t\t\tdojo.debug('dojo.namespace.require: re-entrant request to load namespace \"' + name + '\" must fail.'); \r\n\t\t\treturn false; \/\/ Boolean\r\n\t\t}\r\n\t\t\/\/ workaround so we don't break the build system\r\n\t\tvar req = dojo.require;\r\n\t\tthis.loading[name] = true;\r\n\t\ttry {\r\n\t\t\t\/\/dojo namespace file is always in the Dojo namespaces folder, not any custom folder\r\n\t\t\tif(name==\"dojo\"){\r\n\t\t\t\treq(\"dojo.namespaces.dojo\");\r\n\t\t\t}else{\r\n\t\t\t\t\/\/ if no registered module prefix, use ..\/<name> by convention\r\n\t\t\t\tif(!dojo.hostenv.moduleHasPrefix(name)){\r\n\t\t\t\t\tdojo.registerModulePath(name, \"..\/\" + name);\r\n\t\t\t\t}\r\n\t\t\t\treq([name, 'manifest'].join('.'), false, true);\r\n\t\t\t}\r\n\t\t\tif(!this.namespaces[name]){\r\n\t\t\t\tthis.failed[name] = true; \/\/only look for a namespace once\r\n\t\t\t}\r\n\t\t}finally{\r\n\t\t\tthis.loading[name]=false;\r\n\t\t}\r\n\t\treturn this.namespaces[name]; \/\/ Ns\r","returns":"mixed"}}},"objects":{"dojo.ns":{"meta":{"summary":"private object that implements widget namespace management"}}}}}}