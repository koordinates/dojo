{"dojo.loader_xd":{"meta":{"functions":{"dojo.hostenv.resetXd":{"meta":{"summary":"Internal xd loader function. Resets the xd state.","src":"\t\/\/This flag indicates where or not we have crossed into xdomain territory. Once any package says\n\t\/\/it is cross domain, then the rest of the packages have to be treated as xdomain because we need\n\t\/\/to evaluate packages in order. If there is a xdomain package followed by a xhr package, we can't load\n\t\/\/the xhr package until the one before it finishes loading. The text of the xhr package will be converted\n\t\/\/to match the format for a xd package and put in the xd load queue.\n\t\/\/You can force all packages to be treated as xd by setting the djConfig.forceXDomain.\n\tthis.isXDomain = djConfig.forceXDomain || false;\n\tthis.xdTimer = 0;\n\tthis.xdInFlight = {};\n\tthis.xdOrderedReqs = [];\n\tthis.xdDepMap = {};\n\tthis.xdContents = [];","instance_variables":["isXDomain","xdTimer","xdInFlight","xdOrderedReqs","xdDepMap","xdContents"]}},"dojo.hostenv.createXdPackage":{"meta":{"summary":"Internal xd loader function. Creates an xd module source given an non-xd module contents.","parameters":{"contents":{"type":"String"}},"src":"\t\/\/Find dependencies.\n\tvar deps = [];\n    var depRegExp = \/dojo.(require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\\.conditionalLoadModule|.hostenv\\.loadModule|hostenv\\.moduleLoaded)\\(([\\w\\W]*?)\\)\/mg;\n    var match;\n\twhile((match = depRegExp.exec(contents)) != null){\n\t\tdeps.push(\"\\\"\" + match[1] + \"\\\", \" + match[2]);\n\t}\n\t\/\/Create package object and the call to packageLoaded.\n\tvar output = [];\n\toutput.push(\"dojo.hostenv.packageLoaded({\\n\");\n\t\/\/Add dependencies\n\tif(deps.length > 0){\n\t\toutput.push(\"depends: [\");\n\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\tif(i > 0){\n\t\t\t\toutput.push(\",\\n\");\n\t\t\t}\n\t\t\toutput.push(\"[\" + deps[i] + \"]\");\n\t\t}\n\t\toutput.push(\"],\");\n\t}\n\t\/\/Add the contents of the file inside a function.\n\t\/\/Pass in dojo as an argument to the function to help with\n\t\/\/allowing multiple versions of dojo in a page.\n\toutput.push(\"\\ndefinePackage: function(dojo){\");\n\toutput.push(contents);\n\toutput.push(\"\\n}});\");\n\treturn output.join(\"\"); \/\/String","returns":"String"}},"dojo.hostenv.loadPath":{"meta":{"summary":"Internal xd loader function. Overrides loadPath() from loader.js. xd loading requires slightly different behavior from loadPath().","parameters":{"relpath":{"type":"String"},"module":{"type":"String?"},"cb":{"type":"Function?"}},"src":"\t\/\/Only do getBaseScriptUri if path does not start with a URL with a protocol.\n\t\/\/If there is a colon before the first \/ then, we have a URL with a protocol.\n\tvar colonIndex = relpath.indexOf(\":\");\n\tvar slashIndex = relpath.indexOf(\"\/\");\n\tvar uri;\n\tvar currentIsXDomain = false;\n\tif(colonIndex > 0 && colonIndex < slashIndex){\n\t\turi = relpath;\n\t\tthis.isXDomain = currentIsXDomain = true;\n\t}else{\n\t\turi = this.getBaseScriptUri() + relpath;\n\t\t\/\/Is ithe base script URI-based URL a cross domain URL?\n\t\tcolonIndex = uri.indexOf(\":\");\n\t\tslashIndex = uri.indexOf(\"\/\");\n\t\tif(colonIndex > 0 && colonIndex < slashIndex && (!location.host || uri.indexOf(\"http:\/\/\" + location.host) != 0)){\n\t\t\tthis.isXDomain = currentIsXDomain = true;\n\t\t}\n\t}\n\tif(djConfig.cacheBust && dojo.render.html.capable) { uri += \"?\" + String(djConfig.cacheBust).replace(\/\\W+\/g,\"\"); }\n\ttry{\n\t\treturn ((!module || this.isXDomain) ? this.loadUri(uri, cb, currentIsXDomain, module) : this.loadUriAndCheck(uri, module, cb)); \/\/boolean\n\t}catch(e){\n\t\tdojo.debug(e);\n\t\treturn false; \/\/boolean\n\t}","instance_variables":["isXDomain"],"returns":"boolean"}},"dojo.hostenv.loadUri":{"meta":{"summary":"Internal xd loader function. Overrides loadUri() from loader.js. xd loading requires slightly different behavior from loadPath().","parameters":{"uri":{"type":"String"},"cb":{"type":"Function?"},"currentIsXDomain":{"type":"boolean"},"module":{"type":"String?"}},"src":" if(this.loadedUris[uri]){\n\t\treturn 1; \/\/boolean\n\t}\n\t\/\/Add the module (package) to the list of modules.\n\tif(this.isXDomain){\n\t\t\/\/Curious: is this array going to get whacked with multiple access since scripts\n\t\t\/\/load asynchronously and may be accessing the array at the same time?\n\t\t\/\/JS is single-threaded supposedly, so it should be ok. And we don't need\n\t\t\/\/a precise ordering.\n\t\tthis.xdOrderedReqs.push(module);\n\t\t\/\/Add to waiting packages.\n\t\t\/\/If this is a __package__.js file, then this must be\n\t\t\/\/a package.* request (since xdomain can only work with the first\n\t\t\/\/path in a package search list. However, .* module names are not\n\t\t\/\/passed to this function, so do an adjustment here.\n\t\tif(uri.indexOf(\"__package__\") != -1){\n\t\t\tmodule += \".*\";\n\t\t}\n\t\tthis.xdInFlight[module] = true;\n\t\t\/\/Increment inFlightCount\n\t\t\/\/This will stop the modulesLoaded from firing all the way.\n\t\tthis.inFlightCount++;\n\t\t\/\/Start timer\n\t\tif(!this.xdTimer){\n\t\t\tthis.xdTimer = setInterval(\"dojo.hostenv.watchInFlightXDomain();\", 100);\n\t\t}\n\t\tthis.xdStartTime = (new Date()).getTime();\n\t}\n\tif (currentIsXDomain){\n\t\t\/\/Fix name to be a .xd.fileextension name.\n\t\tvar lastIndex = uri.lastIndexOf('.');\n\t\tif(lastIndex <= 0){\n\t\t\tlastIndex = uri.length - 1;\n\t\t}\n\t\tvar xdUri = uri.substring(0, lastIndex) + \".xd\";\n\t\tif(lastIndex != uri.length - 1){\n\t\t\txdUri += uri.substring(lastIndex, uri.length);\n\t\t}\n\t\t\/\/Add to script src\n\t\tvar element = document.createElement(\"script\");\n\t\telement.type = \"text\/javascript\";\n\t\telement.src = xdUri;\n\t\tif(!this.headElement){\n\t\t\tthis.headElement = document.getElementsByTagName(\"head\")[0];\n\t\t}\n\t\tthis.headElement.appendChild(element);\n\t}else{\n\t\tvar contents = this.getText(uri, null, true);\n\t\tif(contents == null){ return 0; \/*boolean*\/}\n\t\tif(this.isXDomain){\n\t\t\tvar pkg = this.createXdPackage(contents);\n\t\t\tdj_eval(pkg);\n\t\t}else{\n\t\t\tif(cb){ contents = '('+contents+')'; }\n\t\t\tvar value = dj_eval(contents);\n\t\t\tif(cb){\n\t\t\t\tcb(value);\n\t\t\t}\n\t\t}\n\t}\n\t\/\/These steps are done in the non-xd loader version of this function.\n\t\/\/Maintain these steps to fit in with the existing system.\n\tthis.loadedUris[uri] = true;\n\treturn 1; \/\/boolean","instance_variables":["xdTimer","xdStartTime","headElement"],"description":"Wanted to override getText(), but it is used by the widget code in too many, synchronous ways right now.","returns":"boolean"}},"dojo.hostenv.packageLoaded":{"meta":{"summary":"Internal xd loader function. Called by an xd module when it has been loaded via a script tag.","parameters":{"pkg":{"type":"Object"}},"src":" var deps = pkg.depends;\n\tvar requireList = null;\n\tvar requireAfterList = null;\n\tvar provideList = [];\n\tif(deps && deps.length > 0){\n\t\tvar dep = null;\n\t\tvar insertHint = 0;\n\t\tvar attachedPackage = false;\n\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\tdep = deps[i];\n\t\t\t\/\/Look for specific dependency indicators.\n\t\t\tif (dep[0] == \"provide\" || dep[0] == \"hostenv.moduleLoaded\"){\n\t\t\t\tprovideList.push(dep[1]);\n\t\t\t}else{\n\t\t\t\tif(!requireList){\n\t\t\t\t\trequireList = [];\n\t\t\t\t}\n\t\t\t\tif(!requireAfterList){\n\t\t\t\t\trequireAfterList = [];\n\t\t\t\t}\n\t\t\t\tvar unpackedDeps = this.unpackXdDependency(dep);\n\t\t\t\tif(unpackedDeps.requires){\n\t\t\t\t\trequireList = requireList.concat(unpackedDeps.requires);\n\t\t\t\t}\n\t\t\t\tif(unpackedDeps.requiresAfter){\n\t\t\t\t\trequireAfterList = requireAfterList.concat(unpackedDeps.requiresAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/Call the dependency indicator to allow for the normal dojo setup.\n\t\t\t\/\/Only allow for one dot reference, for the hostenv.* type calls.\n\t\t\tvar depType = dep[0];\n\t\t\tvar objPath = depType.split(\".\");\n\t\t\tif(objPath.length == 2){\n\t\t\t\tdojo[objPath[0]][objPath[1]].apply(dojo[objPath[0]], dep.slice(1));\n\t\t\t}else{\n\t\t\t\tdojo[depType].apply(dojo, dep.slice(1));\n\t\t\t}\n\t\t}\n\t\t\/\/Save off the package contents for definition later.\n\t\tvar contentIndex = this.xdContents.push({content: pkg.definePackage, isDefined: false}) - 1;\n\t\t\/\/Add provide\/requires to dependency map.\n\t\tfor(var i = 0; i < provideList.length; i++){\n\t\t\tthis.xdDepMap[provideList[i]] = { requires: requireList, requiresAfter: requireAfterList, contentIndex: contentIndex };\n\t\t}\n\t\t\/\/Now update the inflight status for any provided packages in this loaded package.\n\t\t\/\/Do this at the very end (in a *separate* for loop) to avoid shutting down the \n\t\t\/\/inflight timer check too soon.\n\t\tfor(var i = 0; i < provideList.length; i++){\n\t\t\tthis.xdInFlight[provideList[i]] = false;\n\t\t}\n\t}"}},"dojo.hostenv.xdLoadFlattenedBundle":{"meta":{"summary":"Internal xd loader function. Used when loading a flattened localized bundle via a script tag.","parameters":{"moduleName":{"type":"String"},"bundleName":{"type":"String"},"locale":{"type":"String?"},"bundleData":{"type":"Object"}},"src":" locale = locale || \"root\";\n\tvar jsLoc = dojo.hostenv.normalizeLocale(locale).replace('-', '_');\n \tvar bundlePackage = [moduleName, \"nls\", bundleName].join(\".\");\n\tvar bundle = dojo.hostenv.startPackage(bundlePackage);\n\tbundle[jsLoc] = bundleData;\n\t\/\/Assign the bundle for the original locale(s) we wanted.\n\tvar mapName = [moduleName, jsLoc, bundleName].join(\".\");\n\tvar bundleMap = dojo.hostenv.xdBundleMap[mapName];\n\tif(bundleMap){\n\t\tfor(var param in bundleMap){\n\t\t\tbundle[param] = bundleData;\n\t\t}\n\t}"}},"dojo.xdRequireLocalization":{"meta":{"summary":"","parameters":{"m":{"type":""},"b":{"type":""},"locale":{"type":""},"fLocales":{"type":""}},"src":" \t\tdojo._xdReqLoc(m,b,locale, fLocales);\n\t\t\tif(locale){return;}\n\t\t\tfor(var i=0; i<extra.length; i++){\n\t\t\t\tdojo._xdReqLoc(m,b,extra[i], fLocales);\n\t\t\t}"}},"dojo.hostenv.unpackXdDependency":{"meta":{"summary":"Internal xd loader function. Determines what to do with a dependency that was listed in an xd version of a module contents.","parameters":{"dep":{"type":""}},"src":"\t\/\/Extract the dependency(ies).\n\tvar newDeps = null;\n\tvar newAfterDeps = null;\n\tswitch(dep[0]){\n\t\tcase \"requireIf\":\n\t\tcase \"requireAfterIf\":\n\t\tcase \"conditionalRequire\":\n\t\t\t\/\/First arg (dep[1]) is the test. Depedency is dep[2].\n\t\t\tif((dep[1] === true)||(dep[1]==\"common\")||(dep[1] && dojo.render[dep[1]].capable)){\n\t\t\t\tnewDeps = [{name: dep[2], content: null}];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"requireAll\":\n\t\t\t\/\/the arguments are an array, each element a call to require.\n\t\t\t\/\/Get rid of first item, which is \"requireAll\".\n\t\t\tdep.shift();\n\t\t\tnewDeps = dep;\n\t\t\tdojo.hostenv.flattenRequireArray(newDeps);\n\t\t\tbreak;\n\t\tcase \"kwCompoundRequire\":\n\t\tcase \"hostenv.conditionalLoadModule\":\n\t\t\tvar modMap = dep[1];\n\t\t\tvar common = modMap[\"common\"]||[];\n\t\t\tvar newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[\"default\"]||[]);\t\n\t\t\tdojo.hostenv.flattenRequireArray(newDeps);\n\t\t\tbreak;\n\t\tcase \"require\":\n\t\tcase \"requireAfter\":\n\t\tcase \"hostenv.loadModule\":\n\t\t\t\/\/Just worry about dep[1]\n\t\t\tnewDeps = [{name: dep[1], content: null}];\n\t\t\tbreak;\n\t}\n\t\/\/The requireAfterIf or requireAfter needs to be evaluated after the current package is evaluated.\n\tif(dep[0] == \"requireAfterIf\"){\n\t\tnewAfterDeps = newDeps;\n\t\tnewDeps = null;\n\t}\n\treturn {requires: newDeps, requiresAfter: newAfterDeps}; \/\/Object","returns":"Object"}},"dojo.hostenv.xdWalkReqs":{"meta":{"summary":"Internal xd loader function. Walks the requires and evaluates package contents in the right order.","src":" var reqChain = null;\n\tvar req;\n\tfor(var i = 0; i < this.xdOrderedReqs.length; i++){\n\t\treq = this.xdOrderedReqs[i];\n\t\tif(this.xdDepMap[req]){\n\t\t\treqChain = [req];\n\t\t\treqChain[req] = true; \/\/Allow for fast lookup of the req in the array\n\t\t\tthis.xdEvalReqs(reqChain);\n\t\t}\n\t}"}},"dojo.hostenv.xdTraceReqs":{"meta":{"summary":"Internal xd loader function. Trace the requires to chain the correct order of required modules.","parameters":{"reqs":{"type":"Object"},"reqChain":{"type":"Array"}},"src":" if(reqs && reqs.length > 0){\n\t\tvar nextReq;\n\t\tfor(var i = 0; i < reqs.length; i++){\n\t\t\tnextReq = reqs[i].name;\n\t\t\tif(nextReq && !reqChain[nextReq]){\n\t\t\t\t\/\/New req depedency. Follow it down.\n\t\t\t\treqChain.push(nextReq);\n\t\t\t\treqChain[nextReq] = true;\n\t\t\t\tthis.xdEvalReqs(reqChain);\n\t\t\t}\n\t\t}\n\t}"}},"dojo.hostenv.xdEvalReqs":{"meta":{"summary":"Internal xd loader function. Does a depth first, breadth second search and eval of required modules.","parameters":{"reqChain":{"type":"Array"}},"src":" if(reqChain.length > 0){\n\t\tvar req = reqChain[reqChain.length - 1];\n\t\tvar pkg = this.xdDepMap[req];\n\t\tif(pkg){\n\t\t\t\/\/Trace down any requires for this package.\n\t\t\tthis.xdTraceReqs(pkg.requires, reqChain);\n\t\t\t\/\/Evaluate the package.\n\t\t\tvar contents = this.xdContents[pkg.contentIndex];\n\t\t\tif(!contents.isDefined){\n\t\t\t\t\/\/Evaluate the package to bring it into being.\n\t\t\t\t\/\/Pass dojo in so that later, to support multiple versions of dojo\n\t\t\t\t\/\/in a page, we can pass which version of dojo to use.\n\t\t\t\tcontents.content(dojo);\n\t\t\t\tcontents.isDefined = true;\n\t\t\t}\n\t\t\tthis.xdDepMap[req] = null;\n\t\t\t\/\/Trace down any requireAfters for this package..\n\t\t\tthis.xdTraceReqs(pkg.requiresAfter, reqChain);\n\t\t}\n\t\t\/\/Done with that require. Remove it and go to the next one.\n\t\treqChain.pop();\n\t\tthis.xdEvalReqs(reqChain);\n\t}"}},"dojo.hostenv.clearXdInterval":{"meta":{"summary":"Internal xd loader function. Clears the interval timer used to check on the status of in-flight xd module resource requests.","src":" clearInterval(this.xdTimer);\n\tthis.xdTimer = 0;","instance_variables":["xdTimer"]}},"dojo.hostenv.watchInFlightXDomain":{"meta":{"summary":"Internal xd loader function. Monitors in-flight requests for xd module resources.","src":"\t\/\/Make sure we haven't waited timed out.\n\tvar waitInterval = (djConfig.xdWaitSeconds || 30) * 1000;\n\tif(this.xdStartTime + waitInterval < (new Date()).getTime()){\n\t\tthis.clearXdInterval();\n\t\tvar noLoads = \"\";\n\t\tfor(var param in this.xdInFlight){\n\t\t\tif(this.xdInFlight[param]){\n\t\t\t\tnoLoads += param + \" \";\n\t\t\t}\n\t\t}\n\t\tdojo.raise(\"Could not load cross-domain packages: \" + noLoads);\n\t}\n\t\/\/If any are true, then still waiting.\n\t\/\/Come back later.\t\n\tfor(var param in this.xdInFlight){\n\t\tif(this.xdInFlight[param]){\n\t\t\treturn;\n\t\t}\n\t}\n\t\/\/All done loading. Clean up and notify that we are loaded.\n\tthis.clearXdInterval();\n\tthis.xdWalkReqs();\n\t\/\/Evaluate any packages that were not evaled before.\n\t\/\/This normally shouldn't happen with proper dojo.provide and dojo.require\n\t\/\/usage, but providing it just in case. Note that these may not be executed\n\t\/\/in the original order that the developer intended.\n\t\/\/Pass dojo in so that later, to support multiple versions of dojo\n\t\/\/in a page, we can pass which version of dojo to use.\n\tfor(var i = 0; i < this.xdContents.length; i++){\n\t\tvar current = this.xdContents[i];\n\t\tif(current.content && !current.isDefined){\n\t\t\tcurrent.content(dojo);\n\t\t}\n\t}\n\t\/\/Clean up for the next round of xd loading.\n\tthis.resetXd();\n\t\/\/Clear inflight count so we will finally do finish work.\n\tthis.inFlightCount = 0; \n\tthis.callLoaded();","instance_variables":["inFlightCount"]}},"dojo.hostenv.flattenRequireArray":{"meta":{"summary":"Internal xd loader function. Flattens an array of arrays into a one-level deep array.","parameters":{"target":{"type":"Array"}},"src":"\t\/\/Each result could be an array of 3 elements  (the 3 arguments to dojo.require).\n\t\/\/We only need the first one.\n\tif(target){\n\t\tfor(var i = 0; i < target.length; i++){\n\t\t\tif(target[i] instanceof Array){\n\t\t\t\ttarget[i] = {name: target[i][0], content: null};\n\t\t\t}else{\n\t\t\t\ttarget[i] = {name: target[i], content: null};\n\t\t\t}\n\t\t}\n\t}"}},"dojo.hostenv.callLoaded":{"meta":{"summary":"Internal xd loader function. Overrides callLoaded() from loader.js","src":"\t\/\/If getModulePrefix for dojo returns anything other than \"src\", that means\n\t\/\/there is a path registered for dojo, with implies that dojo was xdomain loaded.\n\tif(this.xdHasCalledPreload || dojo.hostenv.getModulePrefix(\"dojo\") == \"src\" || !this.localesGenerated){\n\t\tthis.xdRealCallLoaded();\n\t\tthis.xdHasCalledPreload = true;\n\t}else{\n\t\tif(this.localesGenerated){\n\t\t\tthis.registerNlsPrefix = function(){\n\t\t\t\t\/\/Need to set the nls prefix to be the xd location.\n\t\t\t\tdojo.registerModulePath(\"nls\", dojo.hostenv.getModulePrefix(\"dojo\") + \"\/..\/nls\");\t\n\t\t\t};\n\t\t\tthis.preloadLocalizations();\n\t\t}\n\t\tthis.xdHasCalledPreload = true;\n\t}","instance_variables":["xdHasCalledPreload","registerNlsPrefix"],"description":"The method is overridden because xd loading needs to preload any flattened i18n bundles before dojo starts executing code, since xd loading cannot do it synchronously, as the i18n code normally expects."}},"dojo.hostenv.callLoaded.registerNlsPrefix":{"meta":{"summary":"","src":" \t\t\tdojo.registerModulePath(\"nls\", dojo.hostenv.getModulePrefix(\"dojo\") + \"\/..\/nls\");\t","instance":"dojo.hostenv.callLoaded"}}}}}}