{"dojo.uuid.LightweightGenerator":{"meta":{"functions":{"dojo.uuid.LightweightGenerator":{"meta":{"initialized":true,"summary":"","src":" var HEX_RADIX = 16;\n\tfunction _generateRandomEightCharacterHexString() {\n\t\t\/\/ Make random32bitNumber be a randomly generated floating point number\n\t\t\/\/ between 0 and (4,294,967,296 - 1), inclusive.\n\t\tvar random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );\n\t\tvar eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);\n\t\twhile (eightCharacterHexString.length < 8) {\n\t\t\teightCharacterHexString = \"0\" + eightCharacterHexString;\n\t\t}\n\t\treturn eightCharacterHexString; \/\/ for example: \"3B12F1DF\"\n\t}\n\tthis.generate = function(\/* constructor? *\/ returnType) {\n\t\t\/\/ summary: \n\t\t\/\/   This function generates random UUIDs, meaning \"version 4\" UUIDs.\n\t\t\/\/ description: \n\t\t\/\/   A typical generated value would be something like this:\n\t\t\/\/   \"3b12f1df-5232-4804-897e-917bf397618a\"\n\t\t\/\/ returnType: The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.LightweightGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.LightweightGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.LightweightGenerator.generate(dojo.uuid.Uuid);\n\t\tvar hyphen = \"-\";\n\t\tvar versionCodeForRandomlyGeneratedUuids = \"4\"; \/\/ 8 == binary2hex(\"0100\")\n\t\tvar variantCodeForDCEUuids = \"8\"; \/\/ 8 == binary2hex(\"1000\")\n\t\tvar a = _generateRandomEightCharacterHexString();\n\t\tvar b = _generateRandomEightCharacterHexString();\n\t\tb = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);\n\t\tvar c = _generateRandomEightCharacterHexString();\n\t\tc = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);\n\t\tvar d = _generateRandomEightCharacterHexString();\n\t\tvar returnValue = a + hyphen + b + hyphen + c + d;\n\t\treturnValue = returnValue.toLowerCase();\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue;\n\t};","instance_variables":["generate"],"returns":"for example: \"3B12F1DF\""}},"dojo.uuid.LightweightGenerator.generate":{"meta":{"summary":"This function generates random UUIDs, meaning \"version 4\" UUIDs.","parameters":{"returnType":{"type":"constructor?"}},"src":"\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.LightweightGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.LightweightGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.LightweightGenerator.generate(dojo.uuid.Uuid);\n\t\tvar hyphen = \"-\";\n\t\tvar versionCodeForRandomlyGeneratedUuids = \"4\"; \/\/ 8 == binary2hex(\"0100\")\n\t\tvar variantCodeForDCEUuids = \"8\"; \/\/ 8 == binary2hex(\"1000\")\n\t\tvar a = _generateRandomEightCharacterHexString();\n\t\tvar b = _generateRandomEightCharacterHexString();\n\t\tb = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);\n\t\tvar c = _generateRandomEightCharacterHexString();\n\t\tc = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);\n\t\tvar d = _generateRandomEightCharacterHexString();\n\t\tvar returnValue = a + hyphen + b + hyphen + c + d;\n\t\treturnValue = returnValue.toLowerCase();\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue;","description":"A typical generated value would be something like this: \"3b12f1df-5232-4804-897e-917bf397618a\"","instance":"dojo.uuid.LightweightGenerator"},"extra":{"parameters":{"returnType":{"type":"The","summary":"type of object to return. Usually String or dojo.uuid.Uuid"}}}}}}},"dojo.uuid.NameBasedGenerator":{"meta":{"functions":{"dojo.uuid.NameBasedGenerator":{"meta":{"initialized":true,"summary":"","src":" this.generate = function(\/* constructor? *\/ returnType) {\n\t\t\/\/ summary: \n\t\t\/\/   This function generates name-based UUIDs, meaning \"version 3\" \n\t\t\/\/   and \"version 5\" UUIDs.\n\t\t\/\/ returnType: The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.NameBasedGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.NameBasedGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.NameBasedGenerator.generate(dojo.uuid.Uuid);\n\t\tdojo.unimplemented('dojo.uuid.NameBasedGenerator.generate');\n\t\t\/\/ FIXME:\n\t\t\/\/ For an algorithm to generate name-based UUIDs, \n\t\t\/\/ see sections 4.3 of RFC 4122:\n\t\t\/\/  http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\"; \/\/ FIXME\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object\n\t};","instance_variables":["generate"],"returns":"mixed"}},"dojo.uuid.NameBasedGenerator.generate":{"meta":{"summary":"This function generates name-based UUIDs, meaning \"version 3\" and \"version 5\" UUIDs.","parameters":{"returnType":{"type":"constructor?"}},"src":"\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.NameBasedGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.NameBasedGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.NameBasedGenerator.generate(dojo.uuid.Uuid);\n\t\tdojo.unimplemented('dojo.uuid.NameBasedGenerator.generate');\n\t\t\/\/ FIXME:\n\t\t\/\/ For an algorithm to generate name-based UUIDs, \n\t\t\/\/ see sections 4.3 of RFC 4122:\n\t\t\/\/  http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\"; \/\/ FIXME\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object","returns":"mixed","instance":"dojo.uuid.NameBasedGenerator"},"extra":{"parameters":{"returnType":{"type":"The","summary":"type of object to return. Usually String or dojo.uuid.Uuid"}}}}}}},"dojo.uuid.NilGenerator":{"meta":{"functions":{"dojo.uuid.NilGenerator":{"meta":{"initialized":true,"summary":"","src":" this.generate = function(\/* constructor? *\/ returnType) {\n\t\t\/\/ summary: \n\t\t\/\/   This function returns the Nil UUID: \"00000000-0000-0000-0000-000000000000\".\n\t\t\/\/ description: \n\t\t\/\/   The Nil UUID is described in section 4.1.7 of\n\t\t\/\/   RFC 4122: http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n\t\t\/\/ returnType: The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.NilGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.NilGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.NilGenerator.generate(dojo.uuid.Uuid);\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\";\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object\n\t};","instance_variables":["generate"],"returns":"object"}},"dojo.uuid.NilGenerator.generate":{"meta":{"summary":"This function returns the Nil UUID: \"00000000-0000-0000-0000-000000000000\".","parameters":{"returnType":{"type":"constructor?"}},"src":"\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.NilGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.NilGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.NilGenerator.generate(dojo.uuid.Uuid);\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\";\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object","description":"The Nil UUID is described in section 4.1.7 of RFC 4122: http: \/\/ www.ietf.org\/rfc\/rfc4122.txt","returns":"object","instance":"dojo.uuid.NilGenerator"},"extra":{"parameters":{"returnType":{"type":"The","summary":"type of object to return. Usually String or dojo.uuid.Uuid"}}}}}}},"dojo.uuid.RandomGenerator":{"meta":{"functions":{"dojo.uuid.RandomGenerator":{"meta":{"initialized":true,"summary":"","src":" this.generate = function(\/* constructor? *\/ returnType) {\n\t\t\/\/ summary: \n\t\t\/\/   This function generates random UUIDs, meaning \"version 4\" UUIDs.\n\t\t\/\/ description: \n\t\t\/\/   A typical generated value would be something like this:\n\t\t\/\/   \"3b12f1df-5232-4804-897e-917bf397618a\"\n\t\t\/\/ returnType: The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.RandomGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.RandomGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.RandomGenerator.generate(dojo.uuid.Uuid);\n\t\tdojo.unimplemented('dojo.uuid.RandomGenerator.generate');\n\t\t\/\/ FIXME:\n\t\t\/\/ For an algorithm to generate a random UUID, see\n\t\t\/\/ sections 4.4 and 4.5 of RFC 4122:\n\t\t\/\/  http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\"; \/\/ FIXME\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object\n\t};","instance_variables":["generate"],"returns":"mixed"}},"dojo.uuid.RandomGenerator.generate":{"meta":{"summary":"This function generates random UUIDs, meaning \"version 4\" UUIDs.","parameters":{"returnType":{"type":"constructor?"}},"src":"\t\t\/\/ examples: \n\t\t\/\/   var string = dojo.uuid.RandomGenerator.generate();\n\t\t\/\/   var string = dojo.uuid.RandomGenerator.generate(String);\n\t\t\/\/   var uuid   = dojo.uuid.RandomGenerator.generate(dojo.uuid.Uuid);\n\t\tdojo.unimplemented('dojo.uuid.RandomGenerator.generate');\n\t\t\/\/ FIXME:\n\t\t\/\/ For an algorithm to generate a random UUID, see\n\t\t\/\/ sections 4.4 and 4.5 of RFC 4122:\n\t\t\/\/  http:\/\/www.ietf.org\/rfc\/rfc4122.txt\n\t\tvar returnValue = \"00000000-0000-0000-0000-000000000000\"; \/\/ FIXME\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(returnValue);\n\t\t}\n\t\treturn returnValue; \/\/ object","description":"A typical generated value would be something like this: \"3b12f1df-5232-4804-897e-917bf397618a\"","returns":"mixed","instance":"dojo.uuid.RandomGenerator"},"extra":{"parameters":{"returnType":{"type":"The","summary":"type of object to return. Usually String or dojo.uuid.Uuid"}}}}}}},"dojo.uuid.TimeBasedGenerator":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.type","dojo.lang.assert"]},"functions":{"dojo.uuid.TimeBasedGenerator":{"meta":{"initialized":true,"summary":"","src":" this.GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;\n\t\/\/ Number of seconds between October 15, 1582 and January 1, 1970:\n\t\/\/   this.GREGORIAN_CHANGE_OFFSET_IN_SECONDS = 12219292800;\t\n\t\/\/ --------------------------------------------------\n\t\/\/ Private variables:\n\tvar _uuidPseudoNodeString = null;\n\tvar _uuidClockSeqString = null;\n\tvar _dateValueOfPreviousUuid = null;\n\tvar _nextIntraMillisecondIncrement = 0;\n\tvar _cachedMillisecondsBetween1582and1970 = null;\n\tvar _cachedHundredNanosecondIntervalsPerMillisecond = null;\n\tvar _uniformNode = null;\n\t\/\/ --------------------------------------------------\n\t\/\/ Private constants:\n\tvar HEX_RADIX = 16;\n\tfunction _carry(\/* array *\/ arrayA) {\n\t\t\/\/ summary: \n\t\t\/\/   Given an array which holds a 64-bit number broken into 4 16-bit \n\t\t\/\/   elements, this method carries any excess bits (greater than 16-bits) \n\t\t\/\/   from each array element into the next.\n\t\t\/\/ arrayA: An array with 4 elements, each of which is a 16-bit number.\n\t\tarrayA[2] += arrayA[3] >>> 16;\n\t\tarrayA[3] &= 0xFFFF;\n\t\tarrayA[1] += arrayA[2] >>> 16;\n\t\tarrayA[2] &= 0xFFFF;\n\t\tarrayA[0] += arrayA[1] >>> 16;\n\t\tarrayA[1] &= 0xFFFF;\n\t\tdojo.lang.assert((arrayA[0] >>> 16) === 0);\n\t}\n\tfunction _get64bitArrayFromFloat(\/* float *\/ x) {\n\t\t\/\/ summary: \n\t\t\/\/   Given a floating point number, this method returns an array which \n\t\t\/\/   holds a 64-bit number broken into 4 16-bit elements.\n\t\tvar result = new Array(0, 0, 0, 0);\n\t\tresult[3] = x % 0x10000;\n\t\tx -= result[3];\n\t\tx \/= 0x10000;\n\t\tresult[2] = x % 0x10000;\n\t\tx -= result[2];\n\t\tx \/= 0x10000;\n\t\tresult[1] = x % 0x10000;\n\t\tx -= result[1];\n\t\tx \/= 0x10000;\n\t\tresult[0] = x;\n\t\treturn result; \/\/ Array with 4 elements, each of which is a 16-bit number.\n\t}\n\tfunction _addTwo64bitArrays(\/* array *\/ arrayA, \/* array *\/ arrayB) {\n\t\t\/\/ summary: \n\t\t\/\/   Takes two arrays, each of which holds a 64-bit number broken into 4\n\t\t\/\/   16-bit elements, and returns a new array that holds a 64-bit number\n\t\t\/\/   that is the sum of the two original numbers.\n\t\t\/\/ arrayA: An array with 4 elements, each of which is a 16-bit number.\n\t\t\/\/ arrayB: An array with 4 elements, each of which is a 16-bit number.\n\t\tdojo.lang.assertType(arrayA, Array);\n\t\tdojo.lang.assertType(arrayB, Array);\n\t\tdojo.lang.assert(arrayA.length == 4);\n\t\tdojo.lang.assert(arrayB.length == 4);\n\t\tvar result = new Array(0, 0, 0, 0);\n\t\tresult[3] = arrayA[3] + arrayB[3];\n\t\tresult[2] = arrayA[2] + arrayB[2];\n\t\tresult[1] = arrayA[1] + arrayB[1];\n\t\tresult[0] = arrayA[0] + arrayB[0];\n\t\t_carry(result);\n\t\treturn result; \/\/ Array with 4 elements, each of which is a 16-bit number.\n\t}\n\tfunction _multiplyTwo64bitArrays(\/* array *\/ arrayA, \/* array *\/ arrayB) {\n\t\t\/\/ summary: \n\t\t\/\/   Takes two arrays, each of which holds a 64-bit number broken into 4\n\t\t\/\/   16-bit elements, and returns a new array that holds a 64-bit number\n\t\t\/\/   that is the product of the two original numbers.\n\t\t\/\/ arrayA: An array with 4 elements, each of which is a 16-bit number.\n\t\t\/\/ arrayB: An array with 4 elements, each of which is a 16-bit number.\n\t\tdojo.lang.assertType(arrayA, Array);\n\t\tdojo.lang.assertType(arrayB, Array);\n\t\tdojo.lang.assert(arrayA.length == 4);\n\t\tdojo.lang.assert(arrayB.length == 4);\n\t\tvar overflow = false;\n\t\tif (arrayA[0] * arrayB[0] !== 0) { overflow = true; }\n\t\tif (arrayA[0] * arrayB[1] !== 0) { overflow = true; }\n\t\tif (arrayA[0] * arrayB[2] !== 0) { overflow = true; }\n\t\tif (arrayA[1] * arrayB[0] !== 0) { overflow = true; }\n\t\tif (arrayA[1] * arrayB[1] !== 0) { overflow = true; }\n\t\tif (arrayA[2] * arrayB[0] !== 0) { overflow = true; }\n\t\tdojo.lang.assert(!overflow);\n\t\tvar result = new Array(0, 0, 0, 0);\n\t\tresult[0] += arrayA[0] * arrayB[3];\n\t\t_carry(result);\n\t\tresult[0] += arrayA[1] * arrayB[2];\n\t\t_carry(result);\n\t\tresult[0] += arrayA[2] * arrayB[1];\n\t\t_carry(result);\n\t\tresult[0] += arrayA[3] * arrayB[0];\n\t\t_carry(result);\n\t\tresult[1] += arrayA[1] * arrayB[3];\n\t\t_carry(result);\n\t\tresult[1] += arrayA[2] * arrayB[2];\n\t\t_carry(result);\n\t\tresult[1] += arrayA[3] * arrayB[1];\n\t\t_carry(result);\n\t\tresult[2] += arrayA[2] * arrayB[3];\n\t\t_carry(result);\n\t\tresult[2] += arrayA[3] * arrayB[2];\n\t\t_carry(result);\n\t\tresult[3] += arrayA[3] * arrayB[3];\n\t\t_carry(result);\n\t\treturn result; \/\/ Array with 4 elements, each of which is a 16-bit number.\n\t}\n\tfunction _padWithLeadingZeros(\/* string *\/ string, \/* int *\/ desiredLength) {\n\t\t\/\/ summary: \n\t\t\/\/   Pads a string with leading zeros and returns the result.\n\t\t\/\/ string: A string to add padding to.\n\t\t\/\/ desiredLength: The number of characters the return string should have.\n\t\t\/\/ examples: \n\t\t\/\/   result = _padWithLeadingZeros(\"abc\", 6);\n\t\t\/\/   dojo.lang.assert(result == \"000abc\");\n\t\twhile (string.length < desiredLength) {\n\t\t\tstring = \"0\" + string;\n\t\t}\n\t\treturn string; \/\/ string\n\t}\n\tfunction _generateRandomEightCharacterHexString() {\n\t\t\/\/ summary: \n\t\t\/\/   Returns a randomly generated 8-character string of hex digits.\n\t\t\/\/ FIXME: This probably isn't a very high quality random number.\n\t\t\/\/ Make random32bitNumber be a randomly generated floating point number\n\t\t\/\/ between 0 and (4,294,967,296 - 1), inclusive.\n\t\tvar random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );\n\t\tvar eightCharacterString = random32bitNumber.toString(HEX_RADIX);\n\t\twhile (eightCharacterString.length < 8) {\n\t\t\teightCharacterString = \"0\" + eightCharacterString;\n\t\t}\n\t\treturn eightCharacterString; \/\/ String (an 8-character hex string)\n\t}\n\tfunction _generateUuidString(\/* string? *\/ node) {\n\t\t\/\/ summary: \n\t\t\/\/   Generates a time-based UUID, meaning a version 1 UUID.  \n\t\t\/\/ description: \n\t\t\/\/   JavaScript code running in a browser doesn't have access to the \n\t\t\/\/   IEEE 802.3 address of the computer, so if a node value isn't \n\t\t\/\/   supplied, we generate a random pseudonode value instead.\n\t\t\/\/ node: An optional 12-character string to use as the node in the new UUID.\n\t\tdojo.lang.assertType(node, String, {optional: true});\n\t\tif (node) {\n\t\t\tdojo.lang.assert(node.length == 12);\n\t\t} else {\n\t\t\tif (_uniformNode) {\n\t\t\t\tnode = _uniformNode;\n\t\t\t} else {\n\t\t\t\tif (!_uuidPseudoNodeString) {\n\t\t\t\t\tvar pseudoNodeIndicatorBit = 0x8000;\n\t\t\t\t\tvar random15bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 15) );\n\t\t\t\t\tvar leftmost4HexCharacters = (pseudoNodeIndicatorBit | random15bitNumber).toString(HEX_RADIX);\n\t\t\t\t\t_uuidPseudoNodeString = leftmost4HexCharacters + _generateRandomEightCharacterHexString();\n\t\t\t\t}\n\t\t\t\tnode = _uuidPseudoNodeString;\n\t\t\t}\n\t\t}\n\t\tif (!_uuidClockSeqString) {\n\t\t\tvar variantCodeForDCEUuids = 0x8000; \/\/ 10--------------, i.e. uses only first two of 16 bits.\n\t\t\tvar random14bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 14) );\n\t\t\t_uuidClockSeqString = (variantCodeForDCEUuids | random14bitNumber).toString(HEX_RADIX);\n\t\t}\n\t\t\/\/ Maybe we should think about trying to make the code more readable to\n\t\t\/\/ newcomers by creating a class called \"WholeNumber\" that encapsulates\n\t\t\/\/ the methods and data structures for working with these arrays that\n\t\t\/\/ hold 4 16-bit numbers?  And then these variables below have names\n\t\t\/\/ like \"wholeSecondsPerHour\" rather than \"arraySecondsPerHour\"?\n\t\tvar now = new Date();\n\t\tvar millisecondsSince1970 = now.valueOf(); \/\/ milliseconds since midnight 01 January, 1970 UTC.\n\t\tvar nowArray = _get64bitArrayFromFloat(millisecondsSince1970);\n\t\tif (!_cachedMillisecondsBetween1582and1970) {\n\t\t\tvar arraySecondsPerHour = _get64bitArrayFromFloat(60 * 60);\n\t\t\tvar arrayHoursBetween1582and1970 = _get64bitArrayFromFloat(dojo.uuid.TimeBasedGenerator.GREGORIAN_CHANGE_OFFSET_IN_HOURS);\n\t\t\tvar arraySecondsBetween1582and1970 = _multiplyTwo64bitArrays(arrayHoursBetween1582and1970, arraySecondsPerHour);\n\t\t\tvar arrayMillisecondsPerSecond = _get64bitArrayFromFloat(1000);\n\t\t\t_cachedMillisecondsBetween1582and1970 = _multiplyTwo64bitArrays(arraySecondsBetween1582and1970, arrayMillisecondsPerSecond);\n\t\t\t_cachedHundredNanosecondIntervalsPerMillisecond = _get64bitArrayFromFloat(10000);\n\t\t}\n\t\tvar arrayMillisecondsSince1970 = nowArray;\n\t\tvar arrayMillisecondsSince1582 = _addTwo64bitArrays(_cachedMillisecondsBetween1582and1970, arrayMillisecondsSince1970);\n\t\tvar arrayHundredNanosecondIntervalsSince1582 = _multiplyTwo64bitArrays(arrayMillisecondsSince1582, _cachedHundredNanosecondIntervalsPerMillisecond);\n\t\tif (now.valueOf() == _dateValueOfPreviousUuid) {\n\t\t\tarrayHundredNanosecondIntervalsSince1582[3] += _nextIntraMillisecondIncrement;\n\t\t\t_carry(arrayHundredNanosecondIntervalsSince1582);\n\t\t\t_nextIntraMillisecondIncrement += 1;\n\t\t\tif (_nextIntraMillisecondIncrement == 10000) {\n\t\t\t\t\/\/ If we've gotten to here, it means we've already generated 10,000\n\t\t\t\t\/\/ UUIDs in this single millisecond, which is the most that the UUID\n\t\t\t\t\/\/ timestamp field allows for.  So now we'll just sit here and wait\n\t\t\t\t\/\/ for a fraction of a millisecond, so as to ensure that the next\n\t\t\t\t\/\/ time this method is called there will be a different millisecond\n\t\t\t\t\/\/ value in the timestamp field.\n\t\t\t\twhile (now.valueOf() == _dateValueOfPreviousUuid) {\n\t\t\t\t\tnow = new Date();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t_dateValueOfPreviousUuid = now.valueOf();\n\t\t\t_nextIntraMillisecondIncrement = 1;\n\t\t}\n\t\tvar hexTimeLowLeftHalf  = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);\n\t\tvar hexTimeLowRightHalf = arrayHundredNanosecondIntervalsSince1582[3].toString(HEX_RADIX);\n\t\tvar hexTimeLow = _padWithLeadingZeros(hexTimeLowLeftHalf, 4) + _padWithLeadingZeros(hexTimeLowRightHalf, 4);\n\t\tvar hexTimeMid = arrayHundredNanosecondIntervalsSince1582[1].toString(HEX_RADIX);\n\t\thexTimeMid = _padWithLeadingZeros(hexTimeMid, 4);\n\t\tvar hexTimeHigh = arrayHundredNanosecondIntervalsSince1582[0].toString(HEX_RADIX);\n\t\thexTimeHigh = _padWithLeadingZeros(hexTimeHigh, 3);\n\t\tvar hyphen = \"-\";\n\t\tvar versionCodeForTimeBasedUuids = \"1\"; \/\/ binary2hex(\"0001\")\n\t\tvar resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen +\n\t\t\t\t\tversionCodeForTimeBasedUuids + hexTimeHigh + hyphen +\n\t\t\t\t\t_uuidClockSeqString + hyphen + node;\n\t\tresultUuid = resultUuid.toLowerCase();\n\t\treturn resultUuid; \/\/ String (a 36 character string, which will look something like \"b4308fb0-86cd-11da-a72b-0800200c9a66\")\n\t}\n\tthis.setNode = function(\/* string? *\/ node) {\n\t\t\/\/ summary: \n\t\t\/\/   Sets the 'node' value that will be included in generated UUIDs.\n\t\t\/\/ node: A 12-character hex string representing a pseudoNode or hardwareNode.\n\t\tdojo.lang.assert((node === null) || (node.length == 12));\n\t\t_uniformNode = node;\n\t};\n\tthis.getNode = function() {\n\t\t\/\/ summary: \n\t\t\/\/   Returns the 'node' value that will be included in generated UUIDs.\n\t\treturn _uniformNode; \/\/ String (a 12-character hex string representing a pseudoNode or hardwareNode)\n\t};\n\tthis.generate = function(\/* misc? *\/ input) {\n\t\t\/\/ summary: \n\t\t\/\/   This function generates time-based UUIDs, meaning \"version 1\" UUIDs. \n\t\t\/\/ description: \n\t\t\/\/ For more info, see\n\t\t\/\/   http:\/\/www.webdav.org\/specs\/draft-leach-uuids-guids-01.txt\n\t\t\/\/   http:\/\/www.infonuovo.com\/dma\/csdocs\/sketch\/instidid.htm\n\t\t\/\/   http:\/\/kruithof.xs4all.nl\/uuid\/uuidgen\n\t\t\/\/   http:\/\/www.opengroup.org\/onlinepubs\/009629399\/apdxa.htm#tagcjh_20\n\t\t\/\/   http:\/\/jakarta.apache.org\/commons\/sandbox\/id\/apidocs\/org\/apache\/commons\/id\/uuid\/clock\/Clock.html\n\t\t\/\/ examples: \n\t\t\/\/   var generate = dojo.uuid.TimeBasedGenerator.generate;\n\t\t\/\/   var uuid;   \/\/ an instance of dojo.uuid.Uuid\n\t\t\/\/   var string; \/\/ a simple string literal\n\t\t\/\/   string = generate();\n\t\t\/\/   string = generate(String);\n\t\t\/\/   uuid   = generate(dojo.uuid.Uuid);\n\t\t\/\/   string = generate(\"017bf397618a\");\n\t\t\/\/   string = generate({node: \"017bf397618a\"});         \/\/ hardwareNode\n\t\t\/\/   string = generate({node: \"f17bf397618a\"});         \/\/ pseudoNode\n\t\t\/\/   string = generate({hardwareNode: \"017bf397618a\"});\n\t\t\/\/   string = generate({pseudoNode:   \"f17bf397618a\"});\n\t\t\/\/   string = generate({node: \"017bf397618a\", returnType: String});\n\t\t\/\/   uuid   = generate({node: \"017bf397618a\", returnType: dojo.uuid.Uuid});\n\t\t\/\/   dojo.uuid.TimeBasedGenerator.setNode(\"017bf397618a\");\n\t\t\/\/   string = generate(); \/\/ the generated UUID has node == \"017bf397618a\"\n\t\t\/\/   uuid   = generate(dojo.uuid.Uuid); \/\/ the generated UUID has node == \"017bf397618a\"\n\t\tvar nodeString = null;\n\t\tvar returnType = null;\n\t\tif (input) {\n\t\t\tif (dojo.lang.isObject(input) && !dojo.lang.isBuiltIn(input)) {\n\t\t\t\t\/\/ input: object {node: string, hardwareNode: string, pseudoNode: string}\n\t\t\t\t\/\/ node: A 12-character hex string representing a pseudoNode or hardwareNode.\n\t\t\t\t\/\/ hardwareNode: A 12-character hex string containing an IEEE 802.3 network node identificator.\n\t\t\t\t\/\/ pseudoNode: A 12-character hex string representing a pseudoNode.\n\t\t\t\tvar namedParameters = input;\n\t\t\t\tdojo.lang.assertValidKeywords(namedParameters, [\"node\", \"hardwareNode\", \"pseudoNode\", \"returnType\"]);\n\t\t\t\tvar node = namedParameters[\"node\"];\n\t\t\t\tvar hardwareNode = namedParameters[\"hardwareNode\"];\n\t\t\t\tvar pseudoNode = namedParameters[\"pseudoNode\"];\n\t\t\t\tnodeString = (node || pseudoNode || hardwareNode);\n\t\t\t\tif (nodeString) {\n\t\t\t\t\tvar firstCharacter = nodeString.charAt(0);\n\t\t\t\t\tvar firstDigit = parseInt(firstCharacter, HEX_RADIX);\n\t\t\t\t\tif (hardwareNode) {\n\t\t\t\t\t\tdojo.lang.assert((firstDigit >= 0x0) && (firstDigit <= 0x7));\n\t\t\t\t\t}\n\t\t\t\t\tif (pseudoNode) {\n\t\t\t\t\t\tdojo.lang.assert((firstDigit >= 0x8) && (firstDigit <= 0xF));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturnType = namedParameters[\"returnType\"];\n\t\t\t\tdojo.lang.assertType(returnType, Function, {optional: true});\n\t\t\t} else {\n\t\t\t\tif (dojo.lang.isString(input)) {\n\t\t\t\t\t\/\/ input: string A 12-character hex string representing a pseudoNode or hardwareNode.\n\t\t\t\t\tnodeString = input;\n\t\t\t\t\treturnType = null;\n\t\t\t\t} else {\n\t\t\t\t\tif (dojo.lang.isFunction(input)) {\n\t\t\t\t\t\t\/\/ input: constructor The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\t\t\t\tnodeString = null;\n\t\t\t\t\t\treturnType = input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodeString) {\n\t\t\t\tdojo.lang.assert(nodeString.length == 12);\n\t\t\t\tvar integer = parseInt(nodeString, HEX_RADIX);\n\t\t\t\tdojo.lang.assert(isFinite(integer));\n\t\t\t}\n\t\t\tdojo.lang.assertType(returnType, Function, {optional: true});\n\t\t}\n\t\tvar uuidString = _generateUuidString(nodeString);\n\t\tvar returnValue;\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(uuidString);\n\t\t} else {\n\t\t\treturnValue = uuidString;\n\t\t}\n\t\treturn returnValue; \/\/ object\n\t};","instance_variables":["GREGORIAN_CHANGE_OFFSET_IN_HOURS","setNode","getNode","generate"],"returns":"mixed"}},"dojo.uuid.TimeBasedGenerator.setNode":{"meta":{"summary":"Sets the 'node' value that will be included in generated UUIDs.","parameters":{"node":{"type":"string?"}},"src":" \tdojo.lang.assert((node === null) || (node.length == 12));\n\t\t_uniformNode = node;","instance":"dojo.uuid.TimeBasedGenerator"},"extra":{"parameters":{"node":{"type":"A","summary":"12-character hex string representing a pseudoNode or hardwareNode."}}}},"dojo.uuid.TimeBasedGenerator.getNode":{"meta":{"summary":"Returns the 'node' value that will be included in generated UUIDs.","src":" \treturn _uniformNode; \/\/ String (a 12-character hex string representing a pseudoNode or hardwareNode)","returns":"String (a 12-character hex string representing a pseudoNode or hardwareNode)","instance":"dojo.uuid.TimeBasedGenerator"}},"dojo.uuid.TimeBasedGenerator.generate":{"meta":{"summary":"This function generates time-based UUIDs, meaning \"version 1\" UUIDs.","parameters":{"input":{"type":"misc?"}},"src":"\t\t\/\/ examples: \n\t\t\/\/   var generate = dojo.uuid.TimeBasedGenerator.generate;\n\t\t\/\/   var uuid;   \/\/ an instance of dojo.uuid.Uuid\n\t\t\/\/   var string; \/\/ a simple string literal\n\t\t\/\/   string = generate();\n\t\t\/\/   string = generate(String);\n\t\t\/\/   uuid   = generate(dojo.uuid.Uuid);\n\t\t\/\/   string = generate(\"017bf397618a\");\n\t\t\/\/   string = generate({node: \"017bf397618a\"});         \/\/ hardwareNode\n\t\t\/\/   string = generate({node: \"f17bf397618a\"});         \/\/ pseudoNode\n\t\t\/\/   string = generate({hardwareNode: \"017bf397618a\"});\n\t\t\/\/   string = generate({pseudoNode:   \"f17bf397618a\"});\n\t\t\/\/   string = generate({node: \"017bf397618a\", returnType: String});\n\t\t\/\/   uuid   = generate({node: \"017bf397618a\", returnType: dojo.uuid.Uuid});\n\t\t\/\/   dojo.uuid.TimeBasedGenerator.setNode(\"017bf397618a\");\n\t\t\/\/   string = generate(); \/\/ the generated UUID has node == \"017bf397618a\"\n\t\t\/\/   uuid   = generate(dojo.uuid.Uuid); \/\/ the generated UUID has node == \"017bf397618a\"\n\t\tvar nodeString = null;\n\t\tvar returnType = null;\n\t\tif (input) {\n\t\t\tif (dojo.lang.isObject(input) && !dojo.lang.isBuiltIn(input)) {\n\t\t\t\t\/\/ input: object {node: string, hardwareNode: string, pseudoNode: string}\n\t\t\t\t\/\/ node: A 12-character hex string representing a pseudoNode or hardwareNode.\n\t\t\t\t\/\/ hardwareNode: A 12-character hex string containing an IEEE 802.3 network node identificator.\n\t\t\t\t\/\/ pseudoNode: A 12-character hex string representing a pseudoNode.\n\t\t\t\tvar namedParameters = input;\n\t\t\t\tdojo.lang.assertValidKeywords(namedParameters, [\"node\", \"hardwareNode\", \"pseudoNode\", \"returnType\"]);\n\t\t\t\tvar node = namedParameters[\"node\"];\n\t\t\t\tvar hardwareNode = namedParameters[\"hardwareNode\"];\n\t\t\t\tvar pseudoNode = namedParameters[\"pseudoNode\"];\n\t\t\t\tnodeString = (node || pseudoNode || hardwareNode);\n\t\t\t\tif (nodeString) {\n\t\t\t\t\tvar firstCharacter = nodeString.charAt(0);\n\t\t\t\t\tvar firstDigit = parseInt(firstCharacter, HEX_RADIX);\n\t\t\t\t\tif (hardwareNode) {\n\t\t\t\t\t\tdojo.lang.assert((firstDigit >= 0x0) && (firstDigit <= 0x7));\n\t\t\t\t\t}\n\t\t\t\t\tif (pseudoNode) {\n\t\t\t\t\t\tdojo.lang.assert((firstDigit >= 0x8) && (firstDigit <= 0xF));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturnType = namedParameters[\"returnType\"];\n\t\t\t\tdojo.lang.assertType(returnType, Function, {optional: true});\n\t\t\t} else {\n\t\t\t\tif (dojo.lang.isString(input)) {\n\t\t\t\t\t\/\/ input: string A 12-character hex string representing a pseudoNode or hardwareNode.\n\t\t\t\t\tnodeString = input;\n\t\t\t\t\treturnType = null;\n\t\t\t\t} else {\n\t\t\t\t\tif (dojo.lang.isFunction(input)) {\n\t\t\t\t\t\t\/\/ input: constructor The type of object to return. Usually String or dojo.uuid.Uuid\n\t\t\t\t\t\tnodeString = null;\n\t\t\t\t\t\treturnType = input;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (nodeString) {\n\t\t\t\tdojo.lang.assert(nodeString.length == 12);\n\t\t\t\tvar integer = parseInt(nodeString, HEX_RADIX);\n\t\t\t\tdojo.lang.assert(isFinite(integer));\n\t\t\t}\n\t\t\tdojo.lang.assertType(returnType, Function, {optional: true});\n\t\t}\n\t\tvar uuidString = _generateUuidString(nodeString);\n\t\tvar returnValue;\n\t\tif (returnType && (returnType != String)) {\n\t\t\treturnValue = new returnType(uuidString);\n\t\t} else {\n\t\t\treturnValue = uuidString;\n\t\t}\n\t\treturn returnValue; \/\/ object","description":"For more info, see http: \/\/ www.webdav.org\/specs\/draft-leach-uuids-guids-01.txt http: \/\/ www.infonuovo.com\/dma\/csdocs\/sketch\/instidid.htm http: \/\/ kruithof.xs4all.nl\/uuid\/uuidgen http: \/\/ www.opengroup.org\/onlinepubs\/009629399\/apdxa.htm#tagcjh_20 http: \/\/ jakarta.apache.org\/commons\/sandbox\/id\/apidocs\/org\/apache\/commons\/id\/uuid\/clock\/Clock.html","returns":"object","instance":"dojo.uuid.TimeBasedGenerator"}}}}},"dojo.uuid.Uuid":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.assert"]},"functions":{"dojo.uuid.Uuid":{"meta":{"summary":"This is the constructor for the Uuid class. The Uuid class offers methods for inspecting existing UUIDs. examples: var uuid; uuid = new dojo.uuid.Uuid(\"3b12f1df-5232-4804-897e-917bf397618a\"); uuid = new dojo.uuid.Uuid(); \/\/ \"00000000-0000-0000-0000-000000000000\" uuid = new dojo.uuid.Uuid(dojo.uuid.RandomGenerator); uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator); dojo.uuid.Uuid.setGenerator(dojo.uuid.RandomGenerator); uuid = new dojo.uuid.Uuid(); dojo.lang.assert(!uuid.isEqual(dojo.uuid.Uuid.NIL_UUID));","parameters":{"input":{"type":"string || generator"}},"src":" this._uuidString = dojo.uuid.Uuid.NIL_UUID;\n\tif (input) {\n\t\tif (dojo.lang.isString(input)) {\n\t\t\t\/\/ input: string? A 36-character string that conforms to the UUID spec.\n\t\t\tthis._uuidString = input.toLowerCase();\n\t\t\tdojo.lang.assert(this.isValid());\n\t\t} else {\n\t\t\tif (dojo.lang.isObject(input) && input.generate) {\n\t\t\t\t\/\/ input: generator A UUID generator, such as dojo.uuid.TimeBasedGenerator.\n\t\t\t\tvar generator = input;\n\t\t\t\tthis._uuidString = generator.generate();\n\t\t\t\tdojo.lang.assert(this.isValid());\n\t\t\t} else {\n\t\t\t\t\/\/ we got passed something other than a string\n\t\t\t\tdojo.lang.assert(false, \"The dojo.uuid.Uuid() constructor must be initializated with a UUID string.\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvar ourGenerator = dojo.uuid.Uuid.getGenerator();\n\t\tif (ourGenerator) {\n\t\t\tthis._uuidString = ourGenerator.generate();\n\t\t\tdojo.lang.assert(this.isValid());\n\t\t}\n\t}","instance_variables":["_uuidString","_uuidString.length","_versionNumber","_nodeString","_timestampAsHexString","_timestampAsHexString.length","_timestampAsDate"]}},"dojo.uuid.Uuid.compare":{"meta":{"summary":"Compares this UUID to another UUID, and returns 0, 1, or -1.","parameters":{"otherUuid":{"type":"dojo.uuid.Uuid"}},"src":" return dojo.uuid.Uuid.compare(this, otherUuid); \/\/ integer (either 0, 1, or -1)","description":"This implementation is intended to match the sample implementation in IETF RFC 4122: http: \/\/ www.ietf.org\/rfc\/rfc4122.txt","returns":"integer (either 0, 1, or -1)","prototype":"dojo.uuid.Uuid"},"extra":{"parameters":{"otherUuid":{"type":"Any","summary":"object that has toString() method that returns a 36-character string that conforms to the UUID spec."}}}},"dojo.uuid.Uuid.setGenerator":{"meta":{"summary":"Sets the default generator, which will be used by the \"new dojo.uuid.Uuid()\" constructor if no parameters are passed in.","parameters":{"generator":{"type":"generator?"}},"src":" dojo.lang.assert(!generator || (dojo.lang.isObject(generator) && generator.generate));\n\tdojo.uuid.Uuid._ourGenerator = generator;"},"extra":{"parameters":{"generator":{"type":"A","summary":"UUID generator, such as dojo.uuid.TimeBasedGenerator."}}}},"dojo.uuid.Uuid.getGenerator":{"meta":{"summary":"Returns the default generator. See setGenerator().","src":" return dojo.uuid.Uuid._ourGenerator; \/\/ generator (A UUID generator, such as dojo.uuid.TimeBasedGenerator).","returns":"generator (A UUID generator, such as dojo.uuid.TimeBasedGenerator)."}},"dojo.uuid.Uuid.toString":{"meta":{"summary":"By default this method returns a standard 36-character string representing the UUID, such as \"3b12f1df-5232-4804-897e-917bf397618a\". You can also pass in an optional format specifier to request the output in any of a half dozen slight variations.","parameters":{"format":{"type":"string?"}},"src":"\t\/\/ examples:\n\t\/\/   var uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);\n\t\/\/   var s;\n\t\/\/   s = uuid.toString();       \/\/  eb529fec-6498-11d7-b236-000629ba5445\n\t\/\/   s = uuid.toString('{}');   \/\/ {eb529fec-6498-11d7-b236-000629ba5445}\n\t\/\/   s = uuid.toString('()');   \/\/ (eb529fec-6498-11d7-b236-000629ba5445)\n\t\/\/   s = uuid.toString('\"\"');   \/\/ \"eb529fec-6498-11d7-b236-000629ba5445\"\n\t\/\/   s = uuid.toString(\"''\");   \/\/ 'eb529fec-6498-11d7-b236-000629ba5445'\n\t\/\/   s = uuid.toString('!-');   \/\/  eb529fec649811d7b236000629ba5445\n\t\/\/   s = uuid.toString('urn');  \/\/  urn:uuid:eb529fec-6498-11d7-b236-000629ba5445\n\tif (format) {\n\t\tswitch (format) {\n\t\t\tcase '{}':\n\t\t\t\treturn '{' + this._uuidString + '}';\n\t\t\t\tbreak;\n\t\t\tcase '()':\n\t\t\t\treturn '(' + this._uuidString + ')';\n\t\t\t\tbreak;\n\t\t\tcase '\"\"':\n\t\t\t\treturn '\"' + this._uuidString + '\"';\n\t\t\t\tbreak;\n\t\t\tcase \"''\":\n\t\t\t\treturn \"'\" + this._uuidString + \"'\";\n\t\t\t\tbreak;\n\t\t\tcase 'urn':\n\t\t\t\treturn 'urn:uuid:' + this._uuidString;\n\t\t\t\tbreak;\n\t\t\tcase '!-':\n\t\t\t\treturn this._uuidString.split('-').join('');\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\/\/ we got passed something other than what we expected\n\t\t\t\tdojo.lang.assert(false, \"The toString() method of dojo.uuid.Uuid was passed a bogus format.\");\n\t\t}\n\t} else {\n\t\treturn this._uuidString; \/\/ string\n\t}","returns":"string","prototype":"dojo.uuid.Uuid"},"extra":{"parameters":{"format":{"type":"One","summary":"of these strings: '{}', '()', '\"\"', \"''\", 'urn', '!-'"}}}},"dojo.uuid.Uuid.isEqual":{"meta":{"summary":"Returns true if this UUID is equal to the otherUuid, or false otherwise.","parameters":{"otherUuid":{"type":"dojo.uuid.Uuid"}},"src":" return (this.compare(otherUuid) == 0); \/\/ boolean","returns":"boolean","prototype":"dojo.uuid.Uuid"},"extra":{"parameters":{"otherUuid":{"type":"Any","summary":"object that has toString() method that returns a 36-character string that conforms to the UUID spec."}}}},"dojo.uuid.Uuid.isValid":{"meta":{"summary":"Returns true if the UUID was initialized with a valid value.","src":" try {\n\t\tdojo.lang.assertType(this._uuidString, String);\n\t\tdojo.lang.assert(this._uuidString.length == 36);\n\t\tdojo.lang.assert(this._uuidString == this._uuidString.toLowerCase());\n\t\tvar arrayOfParts = this._uuidString.split(\"-\");\n\t\tdojo.lang.assert(arrayOfParts.length == 5);\n\t\tdojo.lang.assert(arrayOfParts[0].length == 8);\n\t\tdojo.lang.assert(arrayOfParts[1].length == 4);\n\t\tdojo.lang.assert(arrayOfParts[2].length == 4);\n\t\tdojo.lang.assert(arrayOfParts[3].length == 4);\n\t\tdojo.lang.assert(arrayOfParts[4].length == 12);\n\t\tfor (var i in arrayOfParts) {\n\t\t\tvar part = arrayOfParts[i];\n\t\t\tvar integer = parseInt(part, dojo.uuid.Uuid.HEX_RADIX);\n\t\t\tdojo.lang.assert(isFinite(integer));\n\t\t}\n\t\treturn true; \/\/ boolean\n\t} catch (e) {\n\t\treturn false; \/\/ boolean\n\t}","returns":"boolean","prototype":"dojo.uuid.Uuid"}},"dojo.uuid.Uuid.getVariant":{"meta":{"summary":"Returns a variant code that indicates what type of UUID this is. Returns one of the enumerated dojo.uuid.Uuid.Variant values.","src":"\t\/\/ example: \n\t\/\/   var uuid = new dojo.uuid.Uuid(\"3b12f1df-5232-4804-897e-917bf397618a\");\n\t\/\/   var variant = uuid.getVariant();\n\t\/\/   dojo.lang.assert(variant == dojo.uuid.Uuid.Variant.DCE);\n\t\/\/ example: \n\t\/\/ \"3b12f1df-5232-4804-897e-917bf397618a\"\n\t\/\/                     ^\n\t\/\/                     |\n\t\/\/         (variant \"10__\" == DCE)\n\tvar variantCharacter = this._uuidString.charAt(19);\n\tvar variantNumber = parseInt(variantCharacter, dojo.uuid.Uuid.HEX_RADIX);\n\tdojo.lang.assert((variantNumber >= 0) && (variantNumber <= 16));\n\tif (!dojo.uuid.Uuid._ourVariantLookupTable) {\n\t\tvar Variant = dojo.uuid.Uuid.Variant;\n\t\tvar lookupTable = [];\n\t\tlookupTable[0x0] = Variant.NCS;       \/\/ 0000\n\t\tlookupTable[0x1] = Variant.NCS;       \/\/ 0001\n\t\tlookupTable[0x2] = Variant.NCS;       \/\/ 0010\n\t\tlookupTable[0x3] = Variant.NCS;       \/\/ 0011\n\t\tlookupTable[0x4] = Variant.NCS;       \/\/ 0100\n\t\tlookupTable[0x5] = Variant.NCS;       \/\/ 0101\n\t\tlookupTable[0x6] = Variant.NCS;       \/\/ 0110\n\t\tlookupTable[0x7] = Variant.NCS;       \/\/ 0111\n\t\tlookupTable[0x8] = Variant.DCE;       \/\/ 1000\n\t\tlookupTable[0x9] = Variant.DCE;       \/\/ 1001\n\t\tlookupTable[0xA] = Variant.DCE;       \/\/ 1010\n\t\tlookupTable[0xB] = Variant.DCE;       \/\/ 1011\n\t\tlookupTable[0xC] = Variant.MICROSOFT; \/\/ 1100\n\t\tlookupTable[0xD] = Variant.MICROSOFT; \/\/ 1101\n\t\tlookupTable[0xE] = Variant.UNKNOWN;   \/\/ 1110\n\t\tlookupTable[0xF] = Variant.UNKNOWN;   \/\/ 1111\n\t\tdojo.uuid.Uuid._ourVariantLookupTable = lookupTable;\n\t}\n\treturn dojo.uuid.Uuid._ourVariantLookupTable[variantNumber]; \/\/ dojo.uuid.Uuid.Variant","returns":"dojo.uuid.Uuid.Variant","prototype":"dojo.uuid.Uuid"}},"dojo.uuid.Uuid.getVersion":{"meta":{"summary":"Returns a version number that indicates what type of UUID this is. Returns one of the enumerated dojo.uuid.Uuid.Version values.","src":"\t\/\/ example: \n\t\/\/   var uuid = new dojo.uuid.Uuid(\"b4308fb0-86cd-11da-a72b-0800200c9a66\");\n\t\/\/   var version = uuid.getVersion();\n\t\/\/   dojo.lang.assert(version == dojo.uuid.Uuid.Version.TIME_BASED);\n\t\/\/ exceptions: \n\t\/\/   Throws an Error if this is not a DCE Variant UUID.\n\tif (!this._versionNumber) {\n\t\tvar errorMessage = \"Called getVersion() on a dojo.uuid.Uuid that was not a DCE Variant UUID.\";\n\t\tdojo.lang.assert(this.getVariant() == dojo.uuid.Uuid.Variant.DCE, errorMessage);\n\t\t\/\/ \"b4308fb0-86cd-11da-a72b-0800200c9a66\"\n\t\t\/\/                ^\n\t\t\/\/                |\n\t\t\/\/       (version 1 == TIME_BASED)\n\t\tvar versionCharacter = this._uuidString.charAt(14);\n\t\tthis._versionNumber = parseInt(versionCharacter, dojo.uuid.Uuid.HEX_RADIX);\n\t}\n\treturn this._versionNumber; \/\/ dojo.uuid.Uuid.Version","returns":"dojo.uuid.Uuid.Version","prototype":"dojo.uuid.Uuid"}},"dojo.uuid.Uuid.getNode":{"meta":{"summary":"If this is a version 1 UUID (a time-based UUID), getNode() returns a 12-character string with the \"node\" or \"pseudonode\" portion of the UUID, which is the rightmost 12 characters.","src":"\t\/\/ exceptions: \n\t\/\/   Throws an Error if this is not a version 1 UUID.\n\tif (!this._nodeString) {\n\t\tvar errorMessage = \"Called getNode() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.\";\n\t\tdojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);\n\t\tvar arrayOfStrings = this._uuidString.split('-');\n\t\tthis._nodeString = arrayOfStrings[4];\n\t}\n\treturn this._nodeString; \/\/ String (a 12-character string, which will look something like \"917bf397618a\")","returns":"String (a 12-character string, which will look something like \"917bf397618a\")","prototype":"dojo.uuid.Uuid"}},"dojo.uuid.Uuid.getTimestamp":{"meta":{"summary":"If this is a version 1 UUID (a time-based UUID), this method returns the timestamp value encoded in the UUID. The caller can ask for the timestamp to be returned either as a JavaScript Date object or as a 15-character string of hex digits.","parameters":{"returnType":{"type":"misc."}},"src":"\t\/\/ returns: \n\t\/\/   Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.\n\t\/\/ examples: \n\t\/\/   var uuid = new dojo.uuid.Uuid(\"b4308fb0-86cd-11da-a72b-0800200c9a66\");\n\t\/\/   var date, string, hexString;\n\t\/\/   date   = uuid.getTimestamp();         \/\/ returns a JavaScript Date\n\t\/\/   date   = uuid.getTimestamp(Date);     \/\/ \n\t\/\/   string = uuid.getTimestamp(String);   \/\/ \"Mon, 16 Jan 2006 20:21:41 GMT\"\n\t\/\/   hexString = uuid.getTimestamp(\"hex\"); \/\/ \"1da86cdb4308fb0\"\n\t\/\/ exceptions: \n\t\/\/   Throws an Error if this is not a version 1 UUID.\n\tvar errorMessage = \"Called getTimestamp() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.\";\n\tdojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);\n\tif (!returnType) {returnType = null};\n\tswitch (returnType) {\n\t\tcase \"string\":\n\t\tcase String:\n\t\t\treturn this.getTimestamp(Date).toUTCString(); \/\/ String (e.g. \"Mon, 16 Jan 2006 20:21:41 GMT\")\n\t\t\tbreak;\n\t\tcase \"hex\":\n\t\t\t\/\/ Return a 15-character string of hex digits containing the \n\t\t\t\/\/ timestamp for this UUID, with the high-order bits first.\n\t\t\tif (!this._timestampAsHexString) {\n\t\t\t\tvar arrayOfStrings = this._uuidString.split('-');\n\t\t\t\tvar hexTimeLow = arrayOfStrings[0];\n\t\t\t\tvar hexTimeMid = arrayOfStrings[1];\n\t\t\t\tvar hexTimeHigh = arrayOfStrings[2];\n\t\t\t\t\/\/ Chop off the leading \"1\" character, which is the UUID \n\t\t\t\t\/\/ version number for time-based UUIDs.\n\t\t\t\thexTimeHigh = hexTimeHigh.slice(1);\n\t\t\t\tthis._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;\n\t\t\t\tdojo.lang.assert(this._timestampAsHexString.length == 15);\n\t\t\t}\n\t\t\treturn this._timestampAsHexString; \/\/ String (e.g. \"1da86cdb4308fb0\")\n\t\t\tbreak;\n\t\tcase null: \/\/ no returnType was specified, so default to Date\n\t\tcase \"date\":\n\t\tcase Date:\n\t\t\t\/\/ Return a JavaScript Date object. \n\t\t\tif (!this._timestampAsDate) {\n\t\t\t\tvar GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;\n\t\t\t\tvar arrayOfParts = this._uuidString.split('-');\n\t\t\t\tvar timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);\n\t\t\t\tvar timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);\n\t\t\t\tvar timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);\n\t\t\t\tvar hundredNanosecondIntervalsSince1582 = timeHigh & 0x0FFF;\n\t\t\t\thundredNanosecondIntervalsSince1582 <<= 16;\n\t\t\t\thundredNanosecondIntervalsSince1582 += timeMid;\n\t\t\t\t\/\/ What we really want to do next is shift left 32 bits, but the \n\t\t\t\t\/\/ result will be too big to fit in an int, so we'll multiply by 2^32,\n\t\t\t\t\/\/ and the result will be a floating point approximation.\n\t\t\t\thundredNanosecondIntervalsSince1582 *= 0x100000000;\n\t\t\t\thundredNanosecondIntervalsSince1582 += timeLow;\n\t\t\t\tvar millisecondsSince1582 = hundredNanosecondIntervalsSince1582 \/ 10000;\n\t\t\t\t\/\/ Again, this will be a floating point approximation.\n\t\t\t\t\/\/ We can make things exact later if we need to.\n\t\t\t\tvar secondsPerHour = 60 * 60;\n\t\t\t\tvar hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;\n\t\t\t\tvar secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;\n\t\t\t\tvar millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;\n\t\t\t\tvar millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;\n\t\t\t\tthis._timestampAsDate = new Date(millisecondsSince1970);\n\t\t\t}\n\t\t\treturn this._timestampAsDate; \/\/ Date\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\/\/ we got passed something other than a valid returnType\n\t\t\tdojo.lang.assert(false, \"The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: \" + returnType);\n\t\t\tbreak;\n\t}","returns":"mixed","prototype":"dojo.uuid.Uuid"},"extra":{"parameters":{"returnType":{"type":"Any","summary":"of these five values: \"string\", String, \"hex\", \"date\", Date"}}}}},"objects":{"dojo.uuid.Uuid.Version":{"meta":{"variables":["UNKNOWN","TIME_BASED","DCE_SECURITY","NAME_BASED_MD5","RANDOM","NAME_BASED_SHA1"]}},"dojo.uuid.Uuid.Variant":{"meta":{"variables":["NCS","DCE","MICROSOFT","UNKNOWN"]}}}}},"dojo.uuid._":{"meta":{"requires":{"common":["dojo.uuid.Uuid","dojo.uuid.LightweightGenerator","dojo.uuid.RandomGenerator","dojo.uuid.TimeBasedGenerator","dojo.uuid.NameBasedGenerator","dojo.uuid.NilGenerator"]}}}}