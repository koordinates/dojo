{"dojo.hostenv_adobesvg":{"meta":{"functions":{"dojo.hostenv.println":{"meta":{"summary":"","parameters":{"s":{"type":""}},"src":" try{\n    \/\/ FIXME: this may not work with adobe's viewer, as we may first need a \n\t\t\/\/ reference to the svgDocument\n\t\t\/\/ FIXME: need a way to determine where to position the text for this\n    var ti = document.createElement(\"text\");\n    ti.setAttribute(\"x\",\"50\");\n\t\tvar yPos = 25 + 15*document.getElementsByTagName(\"text\").length;\n    ti.setAttribute(\"y\",yPos);\n\t\tvar tn = document.createTextNode(s);\n\t\tti.appendChild(tn);\n\t\tdocument.documentElement.appendChild(ti);\n\t}catch(e){\n\t}"}},"dojo.debug":{"meta":{"summary":"","src":" if (!djConfig.isDebug) { return; }\n\tvar args = arguments;\n\tif(typeof dojo.hostenv.println != 'function'){\n\t\tdojo.raise(\"attempt to call dojo.debug when there is no dojo.hostenv println implementation (yet?)\");\n\t}\n\tvar isJUM = dj_global[\"jum\"];\n\tvar s = isJUM ? \"\": \"DEBUG: \";\n\tfor(var i=0;i<args.length;++i){ s += args[i]; }\n\tif(isJUM){ \/\/ this seems to be the only way to get JUM to \"play nice\"\n\t\tjum.debug(s);\n\t}else{\n\t\tdojo.hostenv.println(s);\n\t}"}},"dojo.hostenv.nameAnonFunc":{"meta":{"summary":"","parameters":{"anonFuncPtr":{"type":""},"namespaceObj":{"type":""}},"src":" var ret = \"_\"+this.anonCtr++;\n\tvar nso = (namespaceObj || this.anon);\n\twhile(typeof nso[ret] != \"undefined\"){\n\t\tret = \"_\"+this.anonCtr++;\n\t}\n\tnso[ret] = anonFuncPtr;\n\treturn ret;"}},"dojo.hostenv.modulesLoaded":{"meta":{"summary":"","src":" if(this.modulesLoadedFired){ return; }\n\tif((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){\n\t\tif(this.inFlightCount > 0){ \n\t\t\tdojo.debug(\"couldn't initialize, there are files still in flight\");\n\t\t\treturn;\n\t\t}\n\t\tthis.modulesLoadedFired = true;\n\t\tvar mll = this.modulesLoadedListeners;\n\t\tfor(var x=0; x<mll.length; x++){\n\t\t\tmll[x]();\n\t\t}\n\t}","instance_variables":["loadUriStack.length","modulesLoadedFired"]}},"dojo.hostenv.getNewAnonFunc":{"meta":{"summary":"","src":" var ret = \"_\"+this.anonCtr++;\n\twhile(typeof this.anon[ret] != \"undefined\"){\n\t\tret = \"_\"+this.anonCtr++;\n\t}\n\t\/\/ this.anon[ret] = function(){};\n\teval(\"dojo.nostenv.anon.\"+ret+\" = function(){};\");\n\treturn [ret, this.anon[ret]];"}},"dojo.hostenv.displayStack":{"meta":{"summary":"","src":" var oa = [];\n\tvar stack = this.loadUriStack;\n\tfor(var x=0; x<stack.length; x++){\n\t\toa.unshift([stack[x][0], (typeof stack[x][2])]);\n\t}\n\tdojo.debug(\"<pre>\"+oa.join(\"\\n\")+\"<\/pre>\");"}},"dojo.hostenv.unwindUriStack":{"meta":{"summary":"","src":" var stack = this.loadUriStack;\n\tfor(var x in dojo.hostenv.loadedUris){\n\t\tfor(var y=stack.length-1; y>=0; y--){\n\t\t\tif(stack[y][0]==x){\n\t\t\t\tstack.splice(y, 1);\n\t\t\t}\n\t\t}\n\t}\n\tvar next = stack.pop();\n\tif((!next)&&(stack.length==0)){ \n\t\treturn;\n\t}\n\tfor(var x=0; x<stack.length; x++){\n\t\tif((stack[x][0]==next[0])&&(stack[x][2])){\n\t\t\tnext[2] == stack[x][2]\n\t\t}\n\t}\n\tvar last = next;\n\twhile(dojo.hostenv.loadedUris[next[0]]){\n\t\tlast = next;\n\t\tnext = stack.pop();\n\t}\n\twhile(typeof next[2] == \"string\"){ \/\/ unwind as far as we can\n\t\ttry{\n\t\t\t\/\/ dojo.debug(\"<pre><![CDATA[\"+next[2]+\"]]><\/pre>\");\n\t\t\tdj_eval(next[2]);\n\t\t\tnext[1](true);\n\t\t}catch(e){\n\t\t\tdojo.debug(\"we got an error when loading \"+next[0]);\n\t\t\tdojo.debug(\"error: \"+e);\n\t\t\t\/\/ for(var x in e){ alert(x+\" \"+e[x]); }\n\t\t}\n\t\tdojo.hostenv.loadedUris[next[0]] = true;\n\t\tdojo.hostenv.loadedUris.push(next[0]);\n\t\tlast = next;\n\t\tnext = stack.pop();\n\t\tif((!next)&&(stack.length==0)){ break; }\n\t\twhile(dojo.hostenv.loadedUris[next[0]]){\n\t\t\tlast = next;\n\t\t\tnext = stack.pop();\n\t\t}\n\t}\n\tif(next){\n\t\tstack.push(next);\n\t\tdojo.debug(\"### CHOKED ON: \"+next[0]);\n\t}"}},"dojo.hostenv.loadUri":{"meta":{"summary":"","parameters":{"uri":{"type":""},"cb":{"type":""}},"src":" if(dojo.hostenv.loadedUris[uri]){\n\t\treturn;\n\t}\n\tvar stack = this.loadUriStack;\n\tstack.push([uri, cb, null]);\n\tvar tcb = function(contents){\n\t\t\/\/ gratuitous hack for Adobe SVG 3\n\t\tif(contents.content){\n\t\t\tcontents = contents.content;\n\t\t}\n\t\t\/\/ stack management\n\t\tvar next = stack.pop();\n\t\tif((!next)&&(stack.length==0)){ \n\t\t\tdojo.hostenv.modulesLoaded();\n\t\t\treturn;\n\t\t}\n\t\tif(typeof contents == \"string\"){\n\t\t\tstack.push(next);\n\t\t\tfor(var x=0; x<stack.length; x++){\n\t\t\t\tif(stack[x][0]==uri){\n\t\t\t\t\tstack[x][2] = contents;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnext = stack.pop();\n\t\t}\n\t\tif(dojo.hostenv.loadedUris[next[0]]){ \n\t\t\t\/\/ dojo.debug(\"WE ALREADY HAD: \"+next[0]);\n\t\t\tdojo.hostenv.unwindUriStack();\n\t\t\treturn;\n\t\t}\n\t\t\/\/ push back onto stack\n\t\tstack.push(next);\n\t\tif(next[0]!=uri){\n\t\t\t\/\/  and then unwind as far as we can\n\t\t\tif(typeof next[2] == \"string\"){\n\t\t\t\tdojo.hostenv.unwindUriStack();\n\t\t\t}\n\t\t}else{\n\t\t\tif(!contents){ \n\t\t\t\tnext[1](false);\n\t\t\t}else{\n\t\t\t\tvar deps = dojo.hostenv.getDepsForEval(next[2]);\n\t\t\t\tif(deps.length>0){\n\t\t\t\t\teval(deps.join(\";\"));\n\t\t\t\t}else{\n\t\t\t\t\tdojo.hostenv.unwindUriStack();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tthis.getText(uri, tcb, true);"}},"dojo.hostenv.loadModule":{"meta":{"summary":"","parameters":{"modulename":{"type":""},"exact_only":{"type":""},"omit_module_check":{"type":""}},"src":" var module = this.findModule(modulename, 0);\n\tif(module){\n\t\treturn module;\n\t}\n\t\/\/ dojo.debug(\"dojo.hostenv.loadModule('\"+modulename+\"');\");\n\t\/\/ protect against infinite recursion from mutual dependencies\n\tif (typeof this.loading_modules_[modulename] !== 'undefined'){\n\t\t\/\/ NOTE: this should never throw an exception!! \"recursive\" includes\n\t\t\/\/ are normal in the course of app and module building, so blow out of\n\t\t\/\/ it gracefully, but log it in debug mode\n\t\t\/\/ dojo.raise(\"recursive attempt to load module '\" + modulename + \"'\");\n\t\tdojo.debug(\"recursive attempt to load module '\" + modulename + \"'\");\n\t}else{\n\t\tthis.addedToLoadingCount.push(modulename);\n\t}\n\tthis.loading_modules_[modulename] = 1;\n\t\/\/ convert periods to slashes\n\tvar relpath = modulename.replace(\/\\.\/g, '\/') + '.js';\n\tvar syms = modulename.split(\".\");\n\tvar nsyms = modulename.split(\".\");\n\tif(syms[0]==\"dojo\"){ \/\/ FIXME: need a smarter way to do this!\n\t\tsyms[0] = \"src\"; \n\t}\n\tvar last = syms.pop();\n\tsyms.push(last);\n\t\/\/ figure out if we're looking for a full package, if so, we want to do\n\t\/\/ things slightly diffrently\n\tvar _this = this;\n\tvar pfn = this.pkgFileName;\n\tif(last==\"*\"){\n\t\tmodulename = (nsyms.slice(0, -1)).join('.');\n\t\tvar module = this.findModule(modulename, 0);\n\t\t\/\/ dojo.debug(\"found: \"+modulename+\"=\"+module);\n\t\tif(module){\n\t\t\t_this.removedFromLoadingCount.push(modulename);\n\t\t\treturn module;\n\t\t}\n\t\tvar nextTry = function(lastStatus){\n\t\t\tif(lastStatus){ \n\t\t\t\tmodule = _this.findModule(modulename, false); \/\/ pass in false so we can give better error\n\t\t\t\tif((!module)&&(syms[syms.length-1]!=pfn)){\n\t\t\t\t\tdojo.raise(\"Module symbol '\" + modulename + \"' is not defined after loading '\" + relpath + \"'\"); \n\t\t\t\t}\n\t\t\t\tif(module){\n\t\t\t\t\t_this.removedFromLoadingCount.push(modulename);\n\t\t\t\t\tdojo.hostenv.modulesLoaded();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsyms.pop();\n\t\t\tsyms.push(pfn);\n\t\t\t\/\/ dojo.debug(\"syms: \"+syms);\n\t\t\trelpath = syms.join(\"\/\") + '.js';\n\t\t\tif(relpath.charAt(0)==\"\/\"){\n\t\t\t\trelpath = relpath.slice(1);\n\t\t\t}\n\t\t\t\/\/ dojo.debug(\"relpath: \"+relpath);\n\t\t\t_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);\n\t\t}\n\t\tnextTry();\n\t}else{\n\t\trelpath = syms.join(\"\/\") + '.js';\n\t\tmodulename = nsyms.join('.');\n\t\tvar nextTry = function(lastStatus){\n\t\t\t\/\/ dojo.debug(\"lastStatus: \"+lastStatus);\n\t\t\tif(lastStatus){ \n\t\t\t\t\/\/ dojo.debug(\"inital relpath: \"+relpath);\n\t\t\t\tmodule = _this.findModule(modulename, false); \/\/ pass in false so we can give better error\n\t\t\t\t\/\/ if(!module){\n\t\t\t\tif((!module)&&(syms[syms.length-1]!=pfn)){\n\t\t\t\t\tdojo.raise(\"Module symbol '\" + modulename + \"' is not defined after loading '\" + relpath + \"'\"); \n\t\t\t\t}\n\t\t\t\tif(module){\n\t\t\t\t\t_this.removedFromLoadingCount.push(modulename);\n\t\t\t\t\tdojo.hostenv.modulesLoaded();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar setPKG = (syms[syms.length-1]==pfn) ? false : true;\n\t\t\tsyms.pop();\n\t\t\tif(setPKG){\n\t\t\t\tsyms.push(pfn);\n\t\t\t}\n\t\t\trelpath = syms.join(\"\/\") + '.js';\n\t\t\tif(relpath.charAt(0)==\"\/\"){\n\t\t\t\trelpath = relpath.slice(1);\n\t\t\t}\n\t\t\t\/\/ dojo.debug(\"relpath: \"+relpath);\n\t\t\t_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);\n\t\t}\n\t\tthis.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);\n\t}\n\treturn;"}},"dojo.hostenv.unWindGetTextStack":{"meta":{"summary":"","src":" if(dojo.hostenv.inFlightCount>0){\n\t\tsetTimeout(\"dojo.hostenv.unWindGetTextStack()\", 100);\n\t\treturn;\n\t}\n\t\/\/ we serialize because this environment is too messed up\n\t\/\/ to know how to do anything else\n\tdojo.hostenv.inFlightCount++;\n\tvar next = dojo.hostenv.getTextStack.pop();\n\tif((!next)&&(dojo.hostenv.getTextStack.length==0)){ \n\t\tdojo.hostenv.inFlightCount--;\n\t\tdojo.hostenv.async_cb = function(){};\n\t\treturn;\n\t}\n\tdojo.hostenv.async_cb = next[1];\n\t\/\/ http = window.getURL(uri, dojo.hostenv.anon[cbn]);\n\twindow.getURL(next[0], function(result){ \n\t\tdojo.hostenv.inFlightCount--;\n\t\tdojo.hostenv.async_cb(result.content);\n\t\tdojo.hostenv.unWindGetTextStack();\n\t});"}},"dojo.hostenv.getText":{"meta":{"summary":"","parameters":{"uri":{"type":""},"async_cb":{"type":""},"fail_ok":{"type":""}},"src":" try{\n\t\tif(async_cb){\n\t\t\tdojo.hostenv.getTextStack.push([uri, async_cb, fail_ok]);\n\t\t\tdojo.hostenv.unWindGetTextStack();\n\t\t}else{\n\t\t\treturn dojo.raise(\"No synchronous XMLHTTP implementation available, for uri \" + uri);\n\t\t}\n\t}catch(e){\n\t\treturn dojo.raise(\"No XMLHTTP implementation available, for uri \" + uri);\n\t}"}},"dojo.hostenv.postText":{"meta":{"summary":"","parameters":{"uri":{"type":""},"async_cb":{"type":""},"text":{"type":""},"fail_ok":{"type":""},"mime_type":{"type":""},"encoding":{"type":""}},"src":" var http = null;\n\tvar async_callback = function(httpResponse){\n\t\tif (!httpResponse.success) {\n\t\t\tdojo.raise(\"Request for uri '\" + uri + \"' resulted in \" + httpResponse.status);\n\t\t}\n\t\tif(!httpResponse.content) {\n\t\t\tif (!fail_ok) dojo.raise(\"Request for uri '\" + uri + \"' resulted in no content\");\n\t\t\treturn null;\n\t\t}\n\t\t\/\/ FIXME: wtf, I'm losing a reference to async_cb\n\t\tasync_cb(httpResponse.content);\n\t}\n\ttry {\n\t\tif(async_cb) {\n\t\t\thttp = window.postURL(uri, text, async_callback, mimeType, encoding);\n\t\t} else {\n\t\treturn dojo.raise(\"No synchronous XMLHTTP post implementation available, for uri \" + uri);\n\t\t}\n\t} catch(e) {\n\t\treturn dojo.raise(\"No XMLHTTP post implementation available, for uri \" + uri);\n\t}"}},"dj_last_script_src":{"meta":{"summary":"","src":" var scripts = window.document.getElementsByTagName('script');\n\tif(scripts.length < 1){ \n\t\tdojo.raise(\"No script elements in window.document, so can't figure out my script src\"); \n\t}\n\tvar li = scripts.length-1;\n\tvar xlinkNS = \"http:\/\/www.w3.org\/1999\/xlink\";\n\tvar src = null;\n\tvar script = null;\n\twhile(!src){\n\t\tscript = scripts.item(li);\n\t\tsrc = script.getAttributeNS(xlinkNS,\"href\");\n\t\tli--;\n\t\tif(li<0){ break; }\n\t\t\/\/ break;\n\t}\n\tif(!src){\n\t\tdojo.raise(\"Last script element (out of \" + scripts.length + \") has no src\");\n\t}\n\treturn src;"}}}}}}