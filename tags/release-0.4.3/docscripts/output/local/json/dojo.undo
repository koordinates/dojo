{"dojo.undo.Manager":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.undo.Manager":{"meta":{"summary":"Constructor for a dojo.undo.Manager object.","parameters":{"parent":{"type":"dojo.undo.Manager Object"}},"src":" this.clear();\n\tthis._parent = parent;","instance_variables":["_parent"],"prototype_variables":["_parent","_undoStack","_redoStack","_currentManager","canUndo","canRedo","isUndoing","isRedoing"]}},"dojo.undo.Manager.onUndo":{"meta":{"summary":"An event that fires when undo is called. It allows you to hook in and update your code (UI?) as necessary.","parameters":{"manager":{"type":"Object"},"item":{"type":"Object"}},"src":"\t\t\/\/manager: Object: the dojo.undo.Manager instance.\n\t\t\/\/item: Object: The object stored by the undo stack. It has the following properties:\n\t\t\/\/\t\tundo: Function: the undo function for this item in the stack.\n\t\t\/\/\t\tredo: Function: the redo function for this item in the stack. May be null.\n\t\t\/\/\t\tdescription: String: description of this item. May be null."}},"dojo.undo.Manager.onRedo":{"meta":{"summary":"An event that fires when redo is called. It allows you to hook in and update your code (UI?) as necessary.","parameters":{"manager":{"type":"Object"},"item":{"type":"Object"}},"src":"\t\t\/\/manager: Object: the dojo.undo.Manager instance.\n\t\t\/\/item: Object: The object stored by the redo stack. It has the following properties:\n\t\t\/\/\t\tundo: Function: the undo function for this item in the stack.\n\t\t\/\/\t\tredo: Function: the redo function for this item in the stack. May be null.\n\t\t\/\/\t\tdescription: String: description of this item. May be null."}},"dojo.undo.Manager.onUndoAny":{"meta":{"summary":"An event that fires when *any* undo action is done, which means you'll have one for every item in a transaction. This is usually only useful for debugging. See notes for onUndo for info on the function parameters.","parameters":{"manager":{"type":"Object"},"item":{"type":"Object"}},"src":"\t\t\/\/summary: An event that fires when *any* undo action is done, \n\t\t\/\/which means you'll have one for every item\n\t\t\/\/in a transaction. This is usually only useful for debugging.\n\t\t\/\/See notes for onUndo for info on the function parameters."}},"dojo.undo.Manager.onRedoAny":{"meta":{"summary":"An event that fires when *any* redo action is done, which means you'll have one for every item in a transaction. This is usually only useful for debugging. See notes for onRedo for info on the function parameters.","parameters":{"manager":{"type":"Object"},"item":{"type":"Object"}},"src":"\t\t\/\/summary: An event that fires when *any* redo action is done, \n\t\t\/\/which means you'll have one for every item\n\t\t\/\/in a transaction. This is usually only useful for debugging.\n\t\t\/\/See notes for onRedo for info on the function parameters."}},"dojo.undo.Manager._updateStatus":{"meta":{"summary":"Private method used to set some internal state.","src":" \tthis.canUndo = this._undoStack.length > 0;\n\t\tthis.canRedo = this._redoStack.length > 0;","instance_variables":["canUndo","canRedo"]}},"dojo.undo.Manager.clear":{"meta":{"summary":"Clears this instance of dojo.undo.Manager.","src":" \tthis._undoStack = [];\n\t\tthis._redoStack = [];\n\t\tthis._currentManager = this;\n\t\tthis.isUndoing = false;\n\t\tthis.isRedoing = false;\n\t\tthis._updateStatus();","instance_variables":["_undoStack","_redoStack","_currentManager","isUndoing","isRedoing"]}},"dojo.undo.Manager.undo":{"meta":{"summary":"Call this method to go one place back in the undo stack. Returns true if the manager successfully completed the undo step.","src":" \tif(!this.canUndo) { return false; \/*boolean*\/}\n\t\tthis.endAllTransactions();\n\t\tthis.isUndoing = true;\n\t\tvar top = this._undoStack.pop();\n\t\tif(top instanceof dojo.undo.Manager){\n\t\t\ttop.undoAll();\n\t\t}else{\n\t\t\ttop.undo();\n\t\t}\n\t\tif(top.redo){\n\t\t\tthis._redoStack.push(top);\n\t\t}\n\t\tthis.isUndoing = false;\n\t\tthis._updateStatus();\n\t\tthis.onUndo(this, top);\n\t\tif(!(top instanceof dojo.undo.Manager)) {\n\t\t\tthis.getTop().onUndoAny(this, top);\n\t\t}\n\t\treturn true; \/\/boolean","instance_variables":["isUndoing"],"returns":"boolean"}},"dojo.undo.Manager.redo":{"meta":{"summary":"Call this method to go one place forward in the redo stack. Returns true if the manager successfully completed the redo step.","src":" \tif(!this.canRedo){ return false; \/*boolean*\/}\n\t\tthis.isRedoing = true;\n\t\tvar top = this._redoStack.pop();\n\t\tif(top instanceof dojo.undo.Manager) {\n\t\t\ttop.redoAll();\n\t\t}else{\n\t\t\ttop.redo();\n\t\t}\n\t\tthis._undoStack.push(top);\n\t\tthis.isRedoing = false;\n\t\tthis._updateStatus();\n\t\tthis.onRedo(this, top);\n\t\tif(!(top instanceof dojo.undo.Manager)){\n\t\t\tthis.getTop().onRedoAny(this, top);\n\t\t}\n\t\treturn true; \/\/boolean","instance_variables":["isRedoing"],"returns":"boolean"}},"dojo.undo.Manager.undoAll":{"meta":{"summary":"Call undo as many times as it takes to get all the way through the undo stack.","src":" \twhile(this._undoStack.length > 0) {\n\t\t\tthis.undo();\n\t\t}"}},"dojo.undo.Manager.redoAll":{"meta":{"summary":"Call redo as many times as it takes to get all the way through the redo stack.","src":" \twhile(this._redoStack.length > 0) {\n\t\t\tthis.redo();\n\t\t}"}},"dojo.undo.Manager.push":{"meta":{"summary":"add something to the undo manager.","parameters":{"undo":{"type":"Function"},"redo":{"type":"Function?"},"description":{"type":"String?"}},"src":" \tif(!undo) { return; }\n\t\tif(this._currentManager == this) {\n\t\t\tthis._undoStack.push({\n\t\t\t\tundo: undo,\n\t\t\t\tredo: redo,\n\t\t\t\tdescription: description\n\t\t\t});\n\t\t} else {\n\t\t\tthis._currentManager.push.apply(this._currentManager, arguments);\n\t\t}\n\t\t\/\/ adding a new undo-able item clears out the redo stack\n\t\tthis._redoStack = [];\n\t\tthis._updateStatus();","instance_variables":["_currentManager","_redoStack"],"call_chain":["this._currentManager.push"]}},"dojo.undo.Manager.concat":{"meta":{"summary":"Adds all undo and redo stack items to another dojo.undo.Manager instance.","parameters":{"manager":{"type":"Object"}},"src":" \tif ( !manager ) { return; }\n\t\tif (this._currentManager == this ) {\n\t\t\tfor(var x=0; x < manager._undoStack.length; x++) {\n\t\t\t\tthis._undoStack.push(manager._undoStack[x]);\n\t\t\t}\n\t\t\t\/\/ adding a new undo-able item clears out the redo stack\n\t\t\tif (manager._undoStack.length > 0) {\n\t\t\t\tthis._redoStack = [];\n\t\t\t}\n\t\t\tthis._updateStatus();\n\t\t} else {\n\t\t\tthis._currentManager.concat.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager","_redoStack"],"call_chain":["this._currentManager.concat"]}},"dojo.undo.Manager.beginTransaction":{"meta":{"summary":"All undo\/redo items added via push() after this call is made but before endTransaction() is called are treated as one item in the undo and redo stacks. When undo() or redo() is called then undo\/redo is called on all of the items in the transaction. Transactions can be nested.","parameters":{"description":{"type":"String?"}},"src":" \tif(this._currentManager == this) {\n\t\t\tvar mgr = new dojo.undo.Manager(this);\n\t\t\tmgr.description = description ? description : \"\";\n\t\t\tthis._undoStack.push(mgr);\n\t\t\tthis._currentManager = mgr;\n\t\t\treturn mgr;\n\t\t} else {\n\t\t\t\/\/for nested transactions need to make sure the top level _currentManager is set\n\t\t\tthis._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager"],"call_chain":["this._currentManager.beginTransaction"]}},"dojo.undo.Manager.endTransaction":{"meta":{"summary":"Ends a transaction started by beginTransaction(). See beginTransaction() for details.","parameters":{"flatten":{"type":"optional"}},"src":" \tif(this._currentManager == this) {\n\t\t\tif(this._parent) {\n\t\t\t\tthis._parent._currentManager = this._parent;\n\t\t\t\t\/\/ don't leave empty transactions hangin' around\n\t\t\t\tif(this._undoStack.length == 0 || flatten) {\n\t\t\t\t\tvar idx = dojo.lang.find(this._parent._undoStack, this);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tthis._parent._undoStack.splice(idx, 1);\n\t\t\t\t\t\t\/\/add the current transaction to parents undo stack\n\t\t\t\t\t\tif (flatten) {\n\t\t\t\t\t\t\tfor(var x=0; x < this._undoStack.length; x++){\n\t\t\t\t\t\t\t\tthis._parent._undoStack.splice(idx++, 0, this._undoStack[x]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._updateStatus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this._parent;\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/for nested transactions need to make sure the top level _currentManager is set\n\t\t\tthis._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager","_parent._currentManager","_undoStack.length"],"call_chain":["this._currentManager.endTransaction"]},"extra":{"parameters":{"flatten":{"type":"boolean","summary":"If true, adds the current transaction to the parent's undo stack."}}}},"dojo.undo.Manager.endAllTransactions":{"meta":{"summary":"Ends all nested transactions.","src":" \twhile(this._currentManager != this) {\n\t\t\tthis.endTransaction();\n\t\t}"}},"dojo.undo.Manager.getTop":{"meta":{"summary":"Finds the top parent of an undo manager.","src":" \tif(this._parent) {\n\t\t\treturn this._parent.getTop();\n\t\t} else {\n\t\t\treturn this;\n\t\t}"}}}}},"dojo.undo._":{"meta":{"requires":{"common":["dojo.undo.Manager"]}}},"dojo.undo.browser":{"meta":{"requires":{"common":["dojo.io.common"]},"functions":{"tcb":{"meta":{"summary":"","parameters":{"handleName":{"type":""}},"src":" \t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"';\", 1);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\toldCB.apply(this, [handleName]);","call_chain":["oldCB"]}},"tfw":{"meta":{"summary":"","parameters":{"handleName":{"type":""}},"src":" \t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\twindow.location.href = hash;\n\t\t\t\t\t}\n\t\t\t\t\tif(oldFW){ \/\/ we might not actually have one\n\t\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\n\t\t\t\t\t}","call_chain":["oldFW"]}},"dojo.undo.browser.setInitialState":{"meta":{"summary":"Sets the state object and back callback for the very first page that is loaded.","parameters":{"args":{"type":"Object"}},"src":" \tthis.initialState = this._createState(this.initialHref, args, this.initialHash);","instance_variables":["initialState"],"description":"It is recommended that you call this method as part of an event listener that is registered via dojo.addOnLoad()."},"extra":{"parameters":{"args":{"type":"Object","summary":"See the addToHistory() function for the list of valid args properties."}}}},"dojo.undo.browser.addToHistory":{"meta":{"summary":"adds a state object (args) to the history list. You must set djConfig.preventBackButtonFix = false to use dojo.undo.browser.","parameters":{"args":{"type":""}},"src":"\t\t\/\/args: Object\n\t\t\/\/\t\targs can have the following properties:\n\t\t\/\/\t\tTo support getting back button notifications, the object argument should implement a\n\t\t\/\/\t\tfunction called either \"back\", \"backButton\", or \"handle\". The string \"back\" will be\n\t\t\/\/\t\tpassed as the first and only argument to this callback.\n\t\t\/\/\t\t- To support getting forward button notifications, the object argument should implement a\n\t\t\/\/\t\tfunction called either \"forward\", \"forwardButton\", or \"handle\". The string \"forward\" will be\n\t\t\/\/\t\tpassed as the first and only argument to this callback.\n\t\t\/\/\t\t- If you want the browser location string to change, define \"changeUrl\" on the object. If the\n\t\t\/\/\t\tvalue of \"changeUrl\" is true, then a unique number will be appended to the URL as a fragment\n\t\t\/\/\t\tidentifier (http:\/\/some.domain.com\/path#uniquenumber). If it is any other value that does\n\t\t\/\/\t\tnot evaluate to false, that value will be used as the fragment identifier. For example,\n\t\t\/\/\t\tif changeUrl: 'page1', then the URL will look like: http:\/\/some.domain.com\/path#page1\n\t \t\/\/\t\tFull example:\n\t\t\/\/\t\tdojo.undo.browser.addToHistory({\n\t\t\/\/\t\t  back: function() { alert('back pressed'); },\n\t\t\/\/\t\t  forward: function() { alert('forward pressed'); },\n\t\t\/\/\t\t  changeUrl: true\n\t\t\/\/\t\t});\n\t\t\/\/\n\t\t\/\/\tBROWSER NOTES:\n\t\t\/\/  Safari 1.2: \n\t\t\/\/\tback button \"works\" fine, however it's not possible to actually\n\t\t\/\/\tDETECT that you've moved backwards by inspecting window.location.\n\t\t\/\/\tUnless there is some other means of locating.\n\t\t\/\/\tFIXME: perhaps we can poll on history.length?\n\t\t\/\/\tSafari 2.0.3+ (and probably 1.3.2+):\n\t\t\/\/\tworks fine, except when changeUrl is used. When changeUrl is used,\n\t\t\/\/\tSafari jumps all the way back to whatever page was shown before\n\t\t\/\/\tthe page that uses dojo.undo.browser support.\n\t\t\/\/\tIE 5.5 SP2:\n\t\t\/\/\tback button behavior is macro. It does not move back to the\n\t\t\/\/\tprevious hash value, but to the last full page load. This suggests\n\t\t\/\/\tthat the iframe is the correct way to capture the back button in\n\t\t\/\/\tthese cases.\n\t\t\/\/\tDon't test this page using local disk for MSIE. MSIE will not create \n\t\t\/\/\ta history list for iframe_history.html if served from a file: URL. \n\t\t\/\/\tThe XML served back from the XHR tests will also not be properly \n\t\t\/\/\tcreated if served from local disk. Serve the test pages from a web \n\t\t\/\/\tserver to test in that browser.\n\t\t\/\/\tIE 6.0:\n\t\t\/\/\tsame behavior as IE 5.5 SP2\n\t\t\/\/\tFirefox 1.0+:\n\t\t\/\/\tthe back button will return us to the previous hash on the same\n\t\t\/\/\tpage, thereby not requiring an iframe hack, although we do then\n\t\t\/\/\tneed to run a timer to detect inter-page movement.\n\t\t\/\/If addToHistory is called, then that means we prune the\n\t\t\/\/forward stack -- the user went back, then wanted to\n\t\t\/\/start a new forward path.\n\t\tthis.forwardStack = []; \n\t\tvar hash = null;\n\t\tvar url = null;\n\t\tif(!this.historyIframe){\n\t\t\tthis.historyIframe = window.frames[\"djhistory\"];\n\t\t}\n\t\tif(!this.bookmarkAnchor){\n\t\t\tthis.bookmarkAnchor = document.createElement(\"a\");\n\t\t\tdojo.body().appendChild(this.bookmarkAnchor);\n\t\t\tthis.bookmarkAnchor.style.display = \"none\";\n\t\t}\n\t\tif(args[\"changeUrl\"]){\n\t\t\thash = \"#\"+ ((args[\"changeUrl\"]!==true) ? args[\"changeUrl\"] : (new Date()).getTime());\n\t\t\t\/\/If the current hash matches the new one, just replace the history object with\n\t\t\t\/\/this new one. It doesn't make sense to track different state objects for the same\n\t\t\t\/\/logical URL. This matches the browser behavior of only putting in one history\n\t\t\t\/\/item no matter how many times you click on the same #hash link, at least in Firefox\n\t\t\t\/\/and Safari, and there is no reliable way in those browsers to know if a #hash link\n\t\t\t\/\/has been clicked on multiple times. So making this the standard behavior in all browsers\n\t\t\t\/\/so that dojo.undo.browser's behavior is the same in all browsers.\n\t\t\tif(this.historyStack.length == 0 && this.initialState.urlHash == hash){\n\t\t\t\tthis.initialState = this._createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}else if(this.historyStack.length > 0 && this.historyStack[this.historyStack.length - 1].urlHash == hash){\n\t\t\t\tthis.historyStack[this.historyStack.length - 1] = this._createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.changingUrl = true;\n\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"'; dojo.undo.browser.changingUrl = false;\", 1);\n\t\t\tthis.bookmarkAnchor.href = hash;\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\turl = this._loadIframeHistory();\n\t\t\t\tvar oldCB = args[\"back\"]||args[\"backButton\"]||args[\"handle\"];\n\t\t\t\t\/\/The function takes handleName as a parameter, in case the\n\t\t\t\t\/\/callback we are overriding was \"handle\". In that case,\n\t\t\t\t\/\/we will need to pass the handle name to handle.\n\t\t\t\tvar tcb = function(handleName){\n\t\t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"';\", 1);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\toldCB.apply(this, [handleName]);\n\t\t\t\t}\n\t\t\t\t\/\/Set interceptor function in the right place.\n\t\t\t\tif(args[\"back\"]){\n\t\t\t\t\targs.back = tcb;\n\t\t\t\t}else if(args[\"backButton\"]){\n\t\t\t\t\targs.backButton = tcb;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tcb;\n\t\t\t\t}\n\t\t\t\tvar oldFW = args[\"forward\"]||args[\"forwardButton\"]||args[\"handle\"];\n\t\t\t\t\/\/The function takes handleName as a parameter, in case the\n\t\t\t\t\/\/callback we are overriding was \"handle\". In that case,\n\t\t\t\t\/\/we will need to pass the handle name to handle.\n\t\t\t\tvar tfw = function(handleName){\n\t\t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\twindow.location.href = hash;\n\t\t\t\t\t}\n\t\t\t\t\tif(oldFW){ \/\/ we might not actually have one\n\t\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/Set interceptor function in the right place.\n\t\t\t\tif(args[\"forward\"]){\n\t\t\t\t\targs.forward = tfw;\n\t\t\t\t}else if(args[\"forwardButton\"]){\n\t\t\t\t\targs.forwardButton = tfw;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tfw;\n\t\t\t\t}\n\t\t\t}else if(dojo.render.html.moz){\n\t\t\t\t\/\/ start the timer\n\t\t\t\tif(!this.locationTimer){\n\t\t\t\t\tthis.locationTimer = setInterval(\"dojo.undo.browser.checkLocation();\", 200);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\turl = this._loadIframeHistory();\n\t\t}\n\t\tthis.historyStack.push(this._createState(url, args, hash));","instance_variables":["forwardStack","historyIframe","bookmarkAnchor","bookmarkAnchor.style.display","historyStack.length","initialState","changingUrl","bookmarkAnchor.href","locationTimer"],"call_chain":["oldCB","oldFW"]}},"dojo.undo.browser.checkLocation":{"meta":{"summary":"private method. Do not call this directly.","src":" \tif (!this.changingUrl){\n\t\t\tvar hsl = this.historyStack.length;\n\t\t\tif((window.location.hash == this.initialHash||window.location.href == this.initialHref)&&(hsl == 1)){\n\t\t\t\t\/\/ FIXME: could this ever be a forward button?\n\t\t\t\t\/\/ we can't clear it because we still need to check for forwards. Ugg.\n\t\t\t\t\/\/ clearInterval(this.locationTimer);\n\t\t\t\tthis.handleBackButton();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ first check to see if we could have gone forward. We always halt on\n\t\t\t\/\/ a no-hash item.\n\t\t\tif(this.forwardStack.length > 0){\n\t\t\t\tif(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){\n\t\t\t\t\tthis.handleForwardButton();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ ok, that didn't work, try someplace back in the history stack\n\t\t\tif((hsl >= 2)&&(this.historyStack[hsl-2])){\n\t\t\t\tif(this.historyStack[hsl-2].urlHash==window.location.hash){\n\t\t\t\t\tthis.handleBackButton();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}"}},"dojo.undo.browser.iframeLoaded":{"meta":{"summary":"private method. Do not call this directly.","parameters":{"evt":{"type":""},"ifrLoc":{"type":""}},"src":" \tif(!dojo.render.html.opera){\n\t\t\tvar query = this._getUrlQuery(ifrLoc.href);\n\t\t\tif(query == null){ \n\t\t\t\t\/\/ alert(\"iframeLoaded\");\n\t\t\t\t\/\/ we hit the end of the history, so we should go back\n\t\t\t\tif(this.historyStack.length == 1){\n\t\t\t\t\tthis.handleBackButton();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(this.moveForward){\n\t\t\t\t\/\/ we were expecting it, so it's not either a forward or backward movement\n\t\t\t\tthis.moveForward = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/Check the back stack first, since it is more likely.\n\t\t\t\/\/Note that only one step back or forward is supported.\n\t\t\tif(this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){\n\t\t\t\tthis.handleBackButton();\n\t\t\t}\n\t\t\telse if(this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){\n\t\t\t\tthis.handleForwardButton();\n\t\t\t}\n\t\t}","instance_variables":["historyStack.length","moveForward"]}},"dojo.undo.browser.handleBackButton":{"meta":{"summary":"private method. Do not call this directly.","src":"\t\t\/\/The \"current\" page is always at the top of the history stack.\n\t\tvar current = this.historyStack.pop();\n\t\tif(!current){ return; }\n\t\tvar last = this.historyStack[this.historyStack.length-1];\n\t\tif(!last && this.historyStack.length == 0){\n\t\t\tlast = this.initialState;\n\t\t}\n\t\tif (last){\n\t\t\tif(last.kwArgs[\"back\"]){\n\t\t\t\tlast.kwArgs[\"back\"]();\n\t\t\t}else if(last.kwArgs[\"backButton\"]){\n\t\t\t\tlast.kwArgs[\"backButton\"]();\n\t\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\t\tlast.kwArgs.handle(\"back\");\n\t\t\t}\n\t\t}\n\t\tthis.forwardStack.push(current);","instance_variables":["historyStack.length"]}},"dojo.undo.browser.handleForwardButton":{"meta":{"summary":"private method. Do not call this directly.","src":"\t\tvar last = this.forwardStack.pop();\n\t\tif(!last){ return; }\n\t\tif(last.kwArgs[\"forward\"]){\n\t\t\tlast.kwArgs.forward();\n\t\t}else if(last.kwArgs[\"forwardButton\"]){\n\t\t\tlast.kwArgs.forwardButton();\n\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\tlast.kwArgs.handle(\"forward\");\n\t\t}\n\t\tthis.historyStack.push(last);"}},"dojo.undo.browser._createState":{"meta":{"summary":"private method. Do not call this directly.","parameters":{"url":{"type":""},"args":{"type":""},"hash":{"type":""}},"src":"\t\treturn {\"url\": url, \"kwArgs\": args, \"urlHash\": hash};\t\/\/Object","returns":"Object"}},"dojo.undo.browser._getUrlQuery":{"meta":{"summary":"private method. Do not call this directly.","parameters":{"url":{"type":""}},"src":" \tvar segments = url.split(\"?\");\n\t\tif (segments.length < 2){\n\t\t\treturn null; \/\/null\n\t\t}\n\t\telse{\n\t\t\treturn segments[1]; \/\/String\n\t\t}","returns":"mixed"}},"dojo.undo.browser._loadIframeHistory":{"meta":{"summary":"private method. Do not call this directly.","src":" \tvar url = dojo.hostenv.getBaseScriptUri()+\"iframe_history.html?\"+(new Date()).getTime();\n\t\tthis.moveForward = true;\n\t\tdojo.io.setIFrameSrc(this.historyIframe, url, false);\t\n\t\treturn url; \/\/String","instance_variables":["moveForward"],"returns":"String"}}},"objects":{"dojo.undo.browser":{"meta":{"variables":["initialHref","initialHash","moveForward","historyStack","forwardStack","historyIframe","bookmarkAnchor","locationTimer"]}}}}}}