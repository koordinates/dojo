<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>What's new in TreeV3</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1a"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1"></a>What's new in TreeV3</h2></div></div><hr></div><div class="toc"><ul><li><span class="section"><a href="#d0e4">New HTML/CSS structure</a></span><ul><li><span class="section"><a href="#d0e7">Nested divs</a></span></li><li><span class="section"><a href="#d0e12">All design in CSS through classes and class combinations</a></span></li><li><span class="section"><a href="#d0e17">Different trees be styled with different CSS class families</a></span></li><li><span class="section"><a href="#d0e22">Multiline content support</a></span></li></ul></li><li><span class="section"><a href="#d0e27">Event system modified</a></span></li><li><span class="section"><a href="#d0e46">Lazy widget creation</a></span></li><li><span class="section"><a href="#d0e65">Tree extensions</a></span></li><li><span class="section"><a href="#d0e80">Implicit helpers  removed</a></span></li><li><span class="section"><a href="#d0e85">RPC has both sync/async modes</a></span></li><li><span class="section"><a href="#d0e90">Drag'n'drop changes</a></span><ul><li><span class="section"><a href="#d0e93">Multiple selection and multiple drag'n'drop (not ready yet)</a></span></li><li><span class="section"><a href="#d0e104">Drop of any source, not just tree node</a></span></li></ul></li><li><span class="section"><a href="#d0e118">Inline node editing</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4"></a>New HTML/CSS structure</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e7">Nested divs</a></span></li><li><span class="section"><a href="#d0e12">All design in CSS through classes and class combinations</a></span></li><li><span class="section"><a href="#d0e17">Different trees be styled with different CSS class families</a></span></li><li><span class="section"><a href="#d0e22">Multiline content support</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e7"></a>Nested divs</h4></div></div></div><p>Previous tree used a list of divs, each of them was indented  with grid and spacers to right level. The new tree uses
                natural nested divs structure (children' divs inside parent's div). Grid is contigous and structure is displayed correctly for any
                node/font size</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e12"></a>All design in CSS through classes and class combinations</h4></div></div></div><p>All image and size information was removed from JS code. There is a bunch of classes applied to nodes, that may denote
                node folder state, node type, show if there are children, etc. CSS moves this logical classes into style</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e17"></a>Different trees be styled with different CSS class families</h4></div></div></div><p>Want to put 2 differently styled trees on a page? Give them different classPrefix.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e22"></a>Multiline content support</h4></div></div></div><p>Rich content support was incomplete, because list-of-divs model could not handle arbitrary-sized nodes. Now
                you may have &lt;br&gt;, &lt;p&gt; and any other width/height modifiers.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e27"></a>Event system modified</h3></div></div></div><p><code class="methodname">nodeDOMCreated</code> event was removed. That's because listeners are bound to tree and may want to modify the new node,
            but that's only possible when the node is being bound to the tree, not when it was created and hanging around. 
            <code class="methodname">afterTreeChange</code> was introduced to help listeners to (un)bind nodes the right moment
        </p><p>All events were renamed to better reflect the moment of their publishing</p><p><code class="methodname">afterExpand</code>, <code class="methodname">afterCollapse</code> events now fire
            when the animation (e.g fading in or out) finishes, not when the actual expand/collapse is called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e46"></a>Lazy widget creation</h3></div></div></div><p>Before TreeV3, all nodes must be widgets. A node is added  - hence graphical widget is created. For performance reasons
            that behavior was altered. Now when you add a node, you may actually add a "data object", containing node data, e.g
            {title:"new node"}. You may want to add a large nested branch of such data objects, like {title:"new", children:[...data objects..]}.
        </p><p>Data objects will become real members of children array (you may recursively search them, modify etc), but graphical widgets
            will be created only when visitor expands them.</p><p>The compatibility drawback of such behavior is that old code may erroneously call *widget* methods on *data objects* 
            while recursively traversing a tree, e.g with Widget#getDescendants. You should change such code to use TreeCommon#processDescendants,
            or handle data objects in special way.            
        </p><p> There are no special mechanisms to add laziliy instantiated "data objects". 
            You may manipulate them simply modifying <code class="methodname">children</code> array, but no events are thrown until a
            real widget appears on the scene. In most cases that is fine, but you are free to "disable" lazy widget creation - do not modify
            <code class="methodname">children</code> directly and enable <code class="methodname">tree.eagerWidgetInstantiation</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e65"></a>Tree extensions</h3></div></div></div><p>Many features were moved from core into extensions</p><div class="itemizedlist"><ul type="disc"><li>Added TreeDocIconExtension instead of builtin childIcon support</li><li>Selector now only throws events, not doing anything with nodes</li><li>Out-of-the box extensions introduced to be examples and handle well-known requirements</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e80"></a>Implicit helpers  removed</h3></div></div></div><p>The Tree is actually a pack of loosely coupled components, connected through events. To keep things simple and also
            for compatibility reasons, such components(controller,selector...) were created implicitly, if not declared. But actually this proved to be a source of 
            questions and misunderstandings. So now nothing is created implicitly, read how-to and declare things.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e85"></a>RPC has both sync/async modes</h3></div></div></div><p>Old callbacks code was removed in favor to dojo.Deferred. Now all operations may be async and run your callbacks at the end.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e90"></a>Drag'n'drop changes</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e93">Multiple selection and multiple drag'n'drop (not ready yet)</a></span></li><li><span class="section"><a href="#d0e104">Drop of any source, not just tree node</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e93"></a>Multiple selection and multiple drag'n'drop (not ready yet)</h4></div></div></div><p>Sounds simple enough.. Select multiple nodes with ctrl and get them with <code class="methodname">selector.selectedNodes</code>.
                instead of removed <code class="methodname">selectorNode</code> call.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e104"></a>Drop of any source, not just tree node</h4></div></div></div><p>If <code class="methodname">treeNode</code> property is empty, tree will create a new node from the data returned by
                <code class="methodname">source.getTreeNode</code>, then <code class="methodname">source.onDrop</code> will be called to remove old node.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e118"></a>Inline node editing</h3></div></div></div><p>It became possible to edit nodes inline, using TreeEditor. Base variant uses RichText widget, you can make another wrapper though.
                Remote calls can be made on save only, or on start/cancel too e.g for locking purposes.
            </p></div></div></body></html>