{"dojo":{"meta":{"functions":{"dj_undef":{"meta":{"summary":"Returns true if 'name' is defined on 'object' (or globally if 'object' is null).","parameters":{"name":{"type":"String"},"object":{"type":"Object?"}},"src":" return (typeof (object || dj_currentContext)[name] == \"undefined\");\t\/\/ Boolean","description":"Note that 'defined' and 'exists' are not the same concept.","returns":"Boolean"}},"dojo.global":{"meta":{"summary":"return the current global context object (e.g., the window object in a browser).","src":" return dj_currentContext;","description":"Refer to 'dojo.global()' rather than referring to window to ensure your code runs correctly in contexts other than web browsers (eg: Rhino on a server)."}},"dojo.evalProp":{"meta":{"summary":"Returns 'object[name]'. If not defined and 'create' is true, will return a new Object.","parameters":{"name":{"type":"String"},"object":{"type":"Object"},"create":{"type":"Boolean?"}},"src":" if((!object)||(!name)) return undefined; \/\/ undefined\n\tif(!dj_undef(name, object)) return object[name]; \/\/ mixed\n\treturn (create ? (object[name]={}) : undefined);\t\/\/ mixed","description":"Returns null if 'object[name]' is not defined and 'create' is not true. Note: 'defined' and 'exists' are not the same concept.","returns":"mixed"}},"dojo.parseObjPath":{"meta":{"summary":"Parse string path to an object, and return corresponding object reference and property name.","parameters":{"path":{"type":"String"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"src":" var object = (context || dojo.global());\n\tvar names = path.split('.');\n\tvar prop = names.pop();\n\tfor (var i=0,l=names.length;i<l && object;i++){\n\t\tobject = dojo.evalProp(names[i], object, create);\n\t}\n\treturn {obj: object, prop: prop};\t\/\/ Object: {obj: Object, prop: String}","description":"Returns an object with two properties, 'obj' and 'prop'. 'obj[prop]' is the reference indicated by 'path'.","returns":"Object: {obj: Object, prop: String}"},"extra":{"parameters":{"path":{"type":"Path","summary":"to an object, in the form \"A.B.C\"."},"context":{"type":"Object","summary":"to use as root of path. Defaults to 'dojo.global()'."},"create":{"type":"If","summary":"true, Objects will be created at any point along the 'path' that is undefined."}}}},"dojo.evalObjPath":{"meta":{"summary":"Return the value of object at 'path' in the global scope, without using 'eval()'.","parameters":{"path":{"type":"String"},"create":{"type":"Boolean?"}},"src":" if(typeof path != \"string\"){\n\t\treturn dojo.global();\n\t}\n\t\/\/ fast path for no periods\n\tif(path.indexOf('.') == -1){\n\t\treturn dojo.evalProp(path, dojo.global(), create);\t\t\/\/ mixed\n\t}\n\t\/\/MOW: old 'with' syntax was confusing and would throw an error if parseObjPath returned null.\n\tvar ref = dojo.parseObjPath(path, dojo.global(), create);\n\tif(ref){\n\t\treturn dojo.evalProp(ref.prop, ref.obj, create);\t\/\/ mixed\n\t}\n\treturn null;","returns":"mixed"},"extra":{"parameters":{"path":{"type":"Path","summary":"to an object, in the form \"A.B.C\"."},"create":{"type":"If","summary":"true, Objects will be created at any point along the 'path' that is undefined."}}}},"dojo.errorToString":{"meta":{"summary":"Return an exception's 'message', 'description' or text.","parameters":{"exception":{"type":"Error"}},"src":"\t\/\/ TODO: overriding Error.prototype.toString won't accomplish this?\n \t\/\/ \t\t... since natively generated Error objects do not always reflect such things?\n\tif(!dj_undef(\"message\", exception)){\n\t\treturn exception.message;\t\t\/\/ String\n\t}else if(!dj_undef(\"description\", exception)){\n\t\treturn exception.description;\t\/\/ String\n\t}else{\n\t\treturn exception;\t\t\t\t\/\/ Error\n\t}","returns":"mixed"}},"dojo.raise":{"meta":{"summary":"Common point for raising exceptions in Dojo to enable logging. Throws an error message with text of 'exception' if provided, or rethrows exception object.","parameters":{"message":{"type":"String"},"exception":{"type":"Error?"}},"src":"\tif(exception){\n\t\tmessage = message + \": \"+dojo.errorToString(exception);\n\t}else{\n\t\tmessage = dojo.errorToString(message);\n\t}\n\t\/\/ print the message to the user if hostenv.println is defined\n\ttry { if(djConfig.isDebug){ dojo.hostenv.println(\"FATAL exception raised: \"+message); } } catch (e) {}\n\tthrow exception || Error(message);"}},"dojo.debug":{"meta":{"summary":"","src":""}},"dojo.debugShallow":{"meta":{"summary":"","parameters":{"obj":{"type":""}},"src":""}},"dj_eval":{"meta":{"summary":"Perform an evaluation in the global scope. Use this rather than calling 'eval()' directly.","parameters":{"scriptFragment":{"type":"String"}},"src":" return dj_global.eval ? dj_global.eval(scriptFragment) : eval(scriptFragment); \t\/\/ mixed","description":"Placed in a separate function to minimize size of trapped evaluation context. note: - JSC eval() takes an optional second argument which can be 'unsafe'. - Mozilla\/SpiderMonkey eval() takes an optional second argument which is the scope object for new symbols.","returns":"mixed"}},"dojo.unimplemented":{"meta":{"summary":"Throw an exception because some function is not implemented.","parameters":{"funcname":{"type":"String"},"extra":{"type":"String?"}},"src":" var message = \"'\" + funcname + \"' not implemented\";\n\tif (extra != null) { message += \" \" + extra; }\n\tdojo.raise(message);"},"extra":{"parameters":{"extra":{"type":"Text","summary":"to append to the exception message."}}}},"dojo.deprecated":{"meta":{"summary":"Log a debug message to indicate that a behavior has been deprecated.","parameters":{"behaviour":{"type":"String"},"extra":{"type":"String?"},"removal":{"type":"String?"}},"src":" var message = \"DEPRECATED: \" + behaviour;\n\tif(extra){ message += \" \" + extra; }\n\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\tdojo.debug(message);"},"extra":{"parameters":{"extra":{"type":"Text","summary":"to append to the message."},"removal":{"type":"Text","summary":"to indicate when in the future the behavior will be removed."}}}},"vscaffold":{"meta":{"summary":"","parameters":{"prefs":{"type":""},"names":{"type":""}},"src":" \tvar tmp = {\n\t\t\tcapable: false,\n\t\t\tsupport: {\n\t\t\t\tbuiltin: false,\n\t\t\t\tplugin: false\n\t\t\t},\n\t\t\tprefixes: prefs\n\t\t};\n\t\tfor(var i=0; i<names.length; i++){\n\t\t\ttmp[names[i]] = false;\n\t\t}\n\t\treturn tmp;"}},"dojo.hostenv.getBaseScriptUri":{"meta":{"summary":"Return the base script uri that other scripts are found relative to. TODOC: HUH? This comment means nothing to me. What other scripts? Is this the path to other dojo libraries? MAYBE: Return the base uri to scripts in the dojo library. ??? return: Empty string or a path ending in '\/'.","src":" if(djConfig.baseScriptUri.length){\n\t\treturn djConfig.baseScriptUri;\n\t}\n\t\/\/ MOW: Why not:\n\t\/\/\t\t\turi = djConfig.libraryScriptUri || djConfig.baseRelativePath\n\t\/\/\t\t??? Why 'new String(...)'\n\tvar uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);\n\tif (!uri) { dojo.raise(\"Nothing returned by getLibraryScriptUri(): \" + uri); }\n\t\/\/ MOW: uri seems to not be actually used.  Seems to be hard-coding to djConfig.baseRelativePath... ???\n\tvar lastslash = uri.lastIndexOf('\/');\t\t\/\/ MOW ???\n\tdjConfig.baseScriptUri = djConfig.baseRelativePath;\n\treturn djConfig.baseScriptUri;\t\/\/ String","returns":"String"}},"dojo.version.toString":{"meta":{"summary":"","src":" \twith(dojo.version){\n\t\t\treturn major + \".\" + minor + \".\" + patch + flag + \" (\" + revision + \")\";\t\/\/ String\n\t\t}","returns":"String"}},"dojo.profile.start":{"meta":{"summary":"","src":""}},"dojo.profile.end":{"meta":{"summary":"","src":""}},"dojo.profile.stop":{"meta":{"summary":"","src":""}},"dojo.profile.dump":{"meta":{"summary":"","src":""}},"dojo.hostenv.loadPath":{"meta":{"summary":"Load a Javascript module given a relative path","parameters":{"relpath":{"type":"String"},"module":{"type":"String?"},"cb":{"type":"Function?"}},"src":"\tvar uri;\n\tif(relpath.charAt(0) == '\/' || relpath.match(\/^\\w+:\/)){\n\t\t\/\/ dojo.raise(\"relpath '\" + relpath + \"'; must be relative\");\n\t\turi = relpath;\n\t}else{\n\t\turi = this.getBaseScriptUri() + relpath;\n\t}\n\tif(djConfig.cacheBust && dojo.render.html.capable){\n\t\turi += \"?\" + String(djConfig.cacheBust).replace(\/\\W+\/g,\"\");\n\t}\n\ttry{\n\t\treturn !module ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb); \/\/ Boolean\n\t}catch(e){\n\t\tdojo.debug(e);\n\t\treturn false; \/\/ Boolean\n\t}","description":"Loads and interprets the script located at relpath, which is relative to the script root directory. If the script is found but its interpretation causes a runtime exception, that exception is not caught by us, so the caller will see it. We return a true value if and only if the script is found. For now, we do not have an implementation of a true search path. We consider only the single base script uri, as returned by getBaseScriptUri().","returns":"Boolean"},"extra":{"parameters":{"relpath":{"type":"A","summary":"relative path to a script (no leading '\/', and typically ending in '.js')."},"module":{"type":"A","summary":"module whose existance to check for after loading a path. Can be used to determine success or failure of the load."},"cb":{"type":"a","summary":"callback function to pass the result of evaluating the script"}}}},"dojo.hostenv.loadUri":{"meta":{"summary":"Loads JavaScript from a URI","parameters":{"uri":{"type":"String (URL)"},"cb":{"type":"Function?"}},"src":"\tif(this.loadedUris[uri]){\n\t\treturn true; \/\/ Boolean\n\t}\n\tvar contents = this.getText(uri, null, true);\n\tif(!contents){ return false; } \/\/ Boolean\n\tthis.loadedUris[uri] = true;\n\tif(cb){ contents = '('+contents+')'; }\n\tvar value = dj_eval(contents);\n\tif(cb){ cb(value); }\n\treturn true; \/\/ Boolean","description":"Reads the contents of the URI, and evaluates the contents. This is used to load modules as well as resource bundles. Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.","returns":"Boolean"},"extra":{"parameters":{"uri":{"type":"a","summary":"uri which points at the script to be loaded"},"cb":{"type":"a","summary":"callback function to process the result of evaluating the script as an expression, typically used by the resource bundle loader to load JSON-style resources"}}}},"dojo.hostenv.loadUriAndCheck":{"meta":{"summary":"calls loadUri then findModule and returns true if both succeed","parameters":{"uri":{"type":"String (URL)"},"moduleName":{"type":"String"},"cb":{"type":"Function?"}},"src":" var ok = true;\n\ttry{\n\t\tok = this.loadUri(uri, cb);\n\t}catch(e){\n\t\tdojo.debug(\"failed loading \", uri, \" with error: \", e);\n\t}\n\treturn Boolean(ok && this.findModule(moduleName, false)); \/\/ Boolean","returns":"Boolean"}},"dojo.loaded":{"meta":{"summary":"","src":""}},"dojo.unloaded":{"meta":{"summary":"","src":""}},"dojo.hostenv.loaded":{"meta":{"summary":"","src":" this.loadNotifying = true;\n\tthis.post_load_ = true;\n\tvar mll = this.modulesLoadedListeners;\n\tfor(var x=0; x<mll.length; x++){\n\t\tmll[x]();\n\t}\n\t\/\/Clear listeners so new ones can be added\n\t\/\/For other xdomain package loads after the initial load.\n\tthis.modulesLoadedListeners = [];\n\tthis.loadNotifying = false;\n\tdojo.loaded();","instance_variables":["loadNotifying","post_load_","modulesLoadedListeners"]}},"dojo.hostenv.unloaded":{"meta":{"summary":"","src":" var mll = this.unloadListeners;\n\twhile(mll.length){\n\t\t(mll.pop())();\n\t}\n\tdojo.unloaded();"}},"dojo.addOnLoad":{"meta":{"summary":"Registers a function to be triggered after the DOM has finished loading and widgets declared in markup have been instantiated. Images and CSS files may or may not have finished downloading when the specified function is called. (Note that widgets' CSS and HTML code is guaranteed to be downloaded before said widgets are instantiated.) usage: dojo.addOnLoad(functionPointer) dojo.addOnLoad(object, \"functionName\")","parameters":{"obj":{"type":"Object?"}},"src":"\tvar dh = dojo.hostenv;\n\tif(arguments.length == 1) {\n\t\tdh.modulesLoadedListeners.push(obj);\n\t} else if(arguments.length > 1) {\n\t\tdh.modulesLoadedListeners.push(function() {\n\t\t\tobj[functionName]();\n\t\t});\n\t}\n\t\/\/Added for xdomain loading. dojo.addOnLoad is used to\n\t\/\/indicate callbacks after doing some dojo.require() statements.\n\t\/\/In the xdomain case, if all the requires are loaded (after initial\n\t\/\/page load), then immediately call any listeners.\n\tif(dh.post_load_ && dh.inFlightCount == 0 && !dh.loadNotifying){\n\t\tdh.callLoaded();\n\t}"}},"dojo.addOnUnload":{"meta":{"summary":"registers a function to be triggered when the page unloads usage: dojo.addOnLoad(functionPointer) dojo.addOnLoad(object, \"functionName\")","parameters":{"obj":{"type":"Object?"}},"src":" var dh = dojo.hostenv;\n\tif(arguments.length == 1){\n\t\tdh.unloadListeners.push(obj);\n\t} else if(arguments.length > 1) {\n\t\tdh.unloadListeners.push(function() {\n\t\t\tobj[functionName]();\n\t\t});\n\t}"}},"dojo.hostenv.modulesLoaded":{"meta":{"summary":"","src":" if(this.post_load_){ return; }\n\tif(this.loadUriStack.length==0 && this.getTextStack.length==0){\n\t\tif(this.inFlightCount > 0){ \n\t\t\tdojo.debug(\"files still in flight!\");\n\t\t\treturn;\n\t\t}\n\t\tdojo.hostenv.callLoaded();\n\t}","instance_variables":["loadUriStack.length"]}},"dojo.hostenv.callLoaded":{"meta":{"summary":"","src":" if(typeof setTimeout == \"object\"){\n\t\tsetTimeout(\"dojo.hostenv.loaded();\", 0);\n\t}else{\n\t\tdojo.hostenv.loaded();\n\t}"}},"dojo.hostenv.getModuleSymbols":{"meta":{"summary":"Converts a module name in dotted JS notation to an array representing the path in the source tree","parameters":{"modulename":{"type":"String"}},"src":" var syms = modulename.split(\".\");\n\tfor(var i = syms.length; i>0; i--){\n\t\tvar parentModule = syms.slice(0, i).join(\".\");\n\t\tif((i==1) && !this.moduleHasPrefix(parentModule)){\t\t\n\t\t\t\/\/ Support default module directory (sibling of dojo) for top-level modules \n\t\t\tsyms[0] = \"..\/\" + syms[0];\n\t\t}else{\n\t\t\tvar parentModulePath = this.getModulePrefix(parentModule);\n\t\t\tif(parentModulePath != parentModule){\n\t\t\t\tsyms.splice(0, i, parentModulePath);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn syms; \/\/ Array","returns":"Array"}},"dojo.hostenv.loadModule":{"meta":{"summary":"loads a Javascript module from the appropriate URI","parameters":{"moduleName":{"type":"String"},"exactOnly":{"type":"Boolean?"},"omitModuleCheck":{"type":"Boolean?"}},"src":"\tif(!moduleName){ return; }\n\tomitModuleCheck = this._global_omit_module_check || omitModuleCheck;\n\tvar module = this.findModule(moduleName, false);\n\tif(module){\n\t\treturn module;\n\t}\n\t\/\/ protect against infinite recursion from mutual dependencies\n\tif(dj_undef(moduleName, this.loading_modules_)){\n\t\tthis.addedToLoadingCount.push(moduleName);\n\t}\n\tthis.loading_modules_[moduleName] = 1;\n\t\/\/ convert periods to slashes\n\tvar relpath = moduleName.replace(\/\\.\/g, '\/') + '.js';\n\tvar nsyms = moduleName.split(\".\");\n\t\/\/ this line allowed loading of a module manifest as if it were a namespace\n\t\/\/ it's an interesting idea, but shouldn't be combined with 'namespaces' proper\n\t\/\/ and leads to unwanted dependencies\n\t\/\/ the effect can be achieved in other (albeit less-flexible) ways now, so I am\n\t\/\/ removing this pending further design work\n\t\/\/ perhaps we can explicitly define this idea of a 'module manifest', and subclass\n\t\/\/ 'namespace manifest' from that\n\t\/\/dojo.getNamespace(nsyms[0]);\n\tvar syms = this.getModuleSymbols(moduleName);\n\tvar startedRelative = ((syms[0].charAt(0) != '\/') && !syms[0].match(\/^\\w+:\/));\n\tvar last = syms[syms.length - 1];\n\tvar ok;\n\t\/\/ figure out if we're looking for a full package, if so, we want to do\n\t\/\/ things slightly diffrently\n\tif(last==\"*\"){\n\t\tmoduleName = nsyms.slice(0, -1).join('.');\n\t\twhile(syms.length){\n\t\t\tsyms.pop();\n\t\t\tsyms.push(this.pkgFileName);\n\t\t\trelpath = syms.join(\"\/\") + '.js';\n\t\t\tif(startedRelative && relpath.charAt(0)==\"\/\"){\n\t\t\t\trelpath = relpath.slice(1);\n\t\t\t}\n\t\t\tok = this.loadPath(relpath, !omitModuleCheck ? moduleName : null);\n\t\t\tif(ok){ break; }\n\t\t\tsyms.pop();\n\t\t}\n\t}else{\n\t\trelpath = syms.join(\"\/\") + '.js';\n\t\tmoduleName = nsyms.join('.');\n\t\tvar modArg = !omitModuleCheck ? moduleName : null;\n\t\tok = this.loadPath(relpath, modArg);\n\t\tif(!ok && !exactOnly){\n\t\t\tsyms.pop();\n\t\t\twhile(syms.length){\n\t\t\t\trelpath = syms.join('\/') + '.js';\n\t\t\t\tok = this.loadPath(relpath, modArg);\n\t\t\t\tif(ok){ break; }\n\t\t\t\tsyms.pop();\n\t\t\t\trelpath = syms.join('\/') + '\/'+this.pkgFileName+'.js';\n\t\t\t\tif(startedRelative && relpath.charAt(0)==\"\/\"){\n\t\t\t\t\trelpath = relpath.slice(1);\n\t\t\t\t}\n\t\t\t\tok = this.loadPath(relpath, modArg);\n\t\t\t\tif(ok){ break; }\n\t\t\t}\n\t\t}\n\t\tif(!ok && !omitModuleCheck){\n\t\t\tdojo.raise(\"Could not load '\" + moduleName + \"'; last tried '\" + relpath + \"'\");\n\t\t}\n\t}\n\t\/\/ check that the symbol was defined\n\t\/\/Don't bother if we're doing xdomain (asynchronous) loading.\n\tif(!omitModuleCheck && !this[\"isXDomain\"]){\n\t\t\/\/ pass in false so we can give better error\n\t\tmodule = this.findModule(moduleName, false);\n\t\tif(!module){\n\t\t\tdojo.raise(\"symbol '\" + moduleName + \"' is not defined after loading '\" + relpath + \"'\"); \n\t\t}\n\t}\n\treturn module;","description":"loadModule(\"A.B\") first checks to see if symbol A.B is defined. If it is, it is simply returned (nothing to do). If it is not defined, it will look for \"A\/B.js\" in the script root directory, followed by \"A.js\". It throws if it cannot find a file to load, or if the symbol A.B is not defined after loading. It returns the object A.B. This does nothing about importing symbols into the current package. It is presumed that the caller will take care of that. For example, to import all symbols: with (dojo.hostenv.loadModule(\"A.B\")) { ... } And to import just the leaf symbol: var B = dojo.hostenv.loadModule(\"A.B\"); ... dj_load is an alias for dojo.hostenv.loadModule"}},"dojo.hostenv.startPackage":{"meta":{"summary":"Creates a JavaScript package","parameters":{"packageName":{"type":"String"}},"src":"\t\/\/Make sure we have a string.\n\tvar fullPkgName = String(packageName);\n\tvar strippedPkgName = fullPkgName;\n\tvar syms = packageName.split(\/\\.\/);\n\tif(syms[syms.length-1]==\"*\"){\n\t\tsyms.pop();\n\t\tstrippedPkgName = syms.join(\".\");\n\t}\n\tvar evaledPkg = dojo.evalObjPath(strippedPkgName, true);\n\tthis.loaded_modules_[fullPkgName] = evaledPkg;\n\tthis.loaded_modules_[strippedPkgName] = evaledPkg;\n\treturn evaledPkg; \/\/ Object","description":"startPackage(\"A.B\") follows the path, and at each level creates a new empty object or uses what already exists. It returns the result.","returns":"Object"},"extra":{"parameters":{"packageName":{"type":"the","summary":"package to be created as a String in dot notation"}}}},"dojo.hostenv.findModule":{"meta":{"summary":"Returns the Object representing the module, if it exists, otherwise null.","parameters":{"moduleName":{"type":"String"},"mustExist":{"type":"Boolean?"}},"src":"\tvar lmn = String(moduleName);\n\tif(this.loaded_modules_[lmn]){\n\t\treturn this.loaded_modules_[lmn]; \/\/ Object\n\t}\n\tif(mustExist){\n\t\tdojo.raise(\"no loaded module named '\" + moduleName + \"'\");\n\t}\n\treturn null; \/\/ null","returns":"mixed"},"extra":{"parameters":{"moduleName":{"type":"A","summary":"fully qualified module including package name, like 'A.B'."},"mustExist":{"type":"Optional","summary":"default false. throw instead of returning null if the module does not currently exist."}}}},"dojo.kwCompoundRequire":{"meta":{"summary":"","parameters":{"modMap":{"type":"Object containing Arrays"}},"src":"\tvar common = modMap[\"common\"]||[];\n\tvar result = modMap[dojo.hostenv.name_] ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[\"default\"]||[]);\n\tfor(var x=0; x<result.length; x++){\n\t\tvar curr = result[x];\n\t\tif(curr.constructor == Array){\n\t\t\tdojo.hostenv.loadModule.apply(dojo.hostenv, curr);\n\t\t}else{\n\t\t\tdojo.hostenv.loadModule(curr);\n\t\t}\n\t}","description":"This method taks a \"map\" of arrays which one can use to optionally load dojo modules. The map is indexed by the possible dojo.hostenv.name_ values, with two additional values: \"default\" and \"common\". The items in the \"default\" array will be loaded if none of the other items have been choosen based on the hostenv.name_ item. The items in the \"common\" array will _always_ be loaded, regardless of which list is chosen. Here's how it's normally called: dojo.kwCompoundRequire({ browser: [ [\"foo.bar.baz\", true, true], \/\/ an example that passes multiple args to loadModule() \"foo.sample.*\", \"foo.test, ], default: [ \"foo.sample.*\" ], common: [ \"really.important.module.*\" ] });","call_chain":["dojo.hostenv.loadModule"]}},"dojo.require":{"meta":{"summary":"Ensure that the given resource (ie, javascript source file) has been loaded.","parameters":{"resourceName":{"type":"String"}},"src":" dojo.hostenv.loadModule.apply(dojo.hostenv, arguments);","description":"dojo.require() is similar to C's #include command or java's \"import\" command. You call dojo.require() to pull in the resources (ie, javascript source files) that define the functions you are using. Note that in the case of a build, many resources have already been included into dojo.js (ie, many of the javascript source files have been compressed and concatened into dojo.js), so many dojo.require() calls will simply return without downloading anything.","call_chain":["dojo.hostenv.loadModule"]}},"dojo.requireIf":{"meta":{"summary":"If the condition is true then call dojo.require() for the specified resource","parameters":{"condition":{"type":"Boolean"},"resourceName":{"type":"String"}},"src":" var arg0 = arguments[0];\n\tif((arg0 === true)||(arg0==\"common\")||(arg0 && dojo.render[arg0].capable)){\n\t\tvar args = [];\n\t\tfor (var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }\n\t\tdojo.require.apply(dojo, args);\n\t}","call_chain":["dojo.require"]}},"dojo.provide":{"meta":{"summary":"Each javascript source file must have (exactly) one dojo.provide() call at the top of the file, corresponding to the file name. For example, dojo\/src\/foo.js must have dojo.provide(\"dojo.foo\"); at the top of the file.","parameters":{"resourceName":{"type":"String"}},"src":" return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);","description":"Each javascript source file is called a resource. When a resource is loaded by the browser, dojo.provide() registers that it has been loaded. For backwards compatibility reasons, in addition to registering the resource, dojo.provide() also ensures that the javascript object for the module exists. For example, dojo.provide(\"dojo.html.common\"), in addition to registering that common.js is a resource for the dojo.html module, will ensure that the dojo.html javascript object exists, so that calls like dojo.html.foo = function(){ ... } don't fail. In the case of a build (or in the future, a rollup), where multiple javascript source files are combined into one bigger file (similar to a .lib or .jar file), that file will contain multiple dojo.provide() calls, to note that it includes multiple resources.","call_chain":["dojo.hostenv.startPackage"]}},"dojo.registerModulePath":{"meta":{"summary":"maps a module name to a path","parameters":{"module":{"type":"String"},"prefix":{"type":"String"}},"src":" return dojo.hostenv.setModulePrefix(module, prefix);","description":"An unregistered module is given the default path of ..\/<module>, relative to Dojo root. For example, module acme is mapped to ..\/acme. If you want to use a different module name, use dojo.registerModulePath."}},"dojo.setModulePrefix":{"meta":{"summary":"maps a module name to a path","parameters":{"module":{"type":"String"},"prefix":{"type":"String"}},"src":" dojo.deprecated('dojo.setModulePrefix(\"' + module + '\", \"' + prefix + '\")', \"replaced by dojo.registerModulePath\", \"0.5\");\n\treturn dojo.registerModulePath(module, prefix);"}},"dojo.exists":{"meta":{"summary":"determine if an object supports a given method","parameters":{"obj":{"type":"Object"},"name":{"type":"String"}},"src":" var p = name.split(\".\");\n\tfor(var i = 0; i < p.length; i++){\n\t\tif(!obj[p[i]]){ return false; } \/\/ Boolean\n\t\tobj = obj[p[i]];\n\t}\n\treturn true; \/\/ Boolean","description":"useful for longer api chains where you have to test each object in the chain","returns":"Boolean"}},"dojo.hostenv.normalizeLocale":{"meta":{"summary":"Returns canonical form of locale, as used by Dojo. All variants are case-insensitive and are separated by '-' as specified in RFC 3066. If no locale is specified, the user agent's default is returned.","parameters":{"locale":{"type":"String?"}},"src":"\tvar result = locale ? locale.toLowerCase() : dojo.locale;\n\tif(result == \"root\"){\n\t\tresult = \"ROOT\";\n\t}\n\treturn result;\/\/ String","returns":"String"}},"dojo.hostenv.searchLocalePath":{"meta":{"summary":"A helper method to assist in searching for locale-based resources. Will iterate through the variants of a particular locale, either up or down, executing a callback function. For example, \"en-us\" and true will try \"en-us\" followed by \"en\" and finally \"ROOT\".","parameters":{"locale":{"type":"String"},"down":{"type":"Boolean"},"searchFunc":{"type":"Function"}},"src":"\tlocale = dojo.hostenv.normalizeLocale(locale);\n\tvar elements = locale.split('-');\n\tvar searchlist = [];\n\tfor(var i = elements.length; i > 0; i--){\n\t\tsearchlist.push(elements.slice(0, i).join('-'));\n\t}\n\tsearchlist.push(false);\n\tif(down){searchlist.reverse();}\n\tfor(var j = searchlist.length - 1; j >= 0; j--){\n\t\tvar loc = searchlist[j] || \"ROOT\";\n\t\tvar stop = searchFunc(loc);\n\t\tif(stop){ break; }\n\t}"}},"dojo.hostenv.registerNlsPrefix":{"meta":{"summary":"Register module \"nls\" to point where Dojo can find pre-built localization files","src":" dojo.registerModulePath(\"nls\",\"nls\");\t"}},"dojo.hostenv.preloadLocalizations":{"meta":{"summary":"Load built, flattened resource bundles, if available for all locales used in the page. Execute only once. Note that this is a no-op unless there is a build.","src":"\tif(dojo.hostenv.localesGenerated){\n\t\tdojo.hostenv.registerNlsPrefix();\n\t\tfunction preload(locale){\n\t\t\tlocale = dojo.hostenv.normalizeLocale(locale);\n\t\t\tdojo.hostenv.searchLocalePath(locale, true, function(loc){\n\t\t\t\tfor(var i=0; i<dojo.hostenv.localesGenerated.length;i++){\n\t\t\t\t\tif(dojo.hostenv.localesGenerated[i] == loc){\n\t\t\t\t\t\tdojo[\"require\"](\"nls.dojo_\"+loc);\n\t\t\t\t\t\treturn true; \/\/ Boolean\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false; \/\/ Boolean\n\t\t\t});\n\t\t}\n\t\tpreload();\n\t\tvar extra = djConfig.extraLocale||[];\n\t\tfor(var i=0; i<extra.length; i++){\n\t\t\tpreload(extra[i]);\n\t\t}\n\t}\n\tdojo.hostenv.preloadLocalizations = function(){};","returns":"Boolean"}},"dojo.requireLocalization":{"meta":{"summary":"","parameters":{"m":{"type":""},"b":{"type":""},"locale":{"type":""},"availableFlatLocales":{"type":""}},"src":" \t\treq(m,b,locale, availableFlatLocales);\n\t\t\tif(locale){return;}\n\t\t\tfor(var i=0; i<extra.length; i++){\n\t\t\t\treq(m,b,extra[i], availableFlatLocales);\n\t\t\t}"}}},"objects":{"dojo.version":{"meta":{"variables":["major","minor","patch","flag","revision"],"summary":"version number of this instance of dojo."}}}}}}