{"dojo.event._":{"meta":{"requires":{"common":["dojo.event.common","dojo.event.topic"],"browser":["dojo.event.browser"],"dashboard":["dojo.event.browser"]}}},"dojo.event.browser":{"meta":{"requires":{"common":["dojo.event.common"]},"functions":{"dojo._ie_clobber":{"meta":{"initialized":true,"summary":"","src":" this.clobberNodes = [];\n\tfunction nukeProp(node, prop){\n\t\t\/\/ try{ node.removeAttribute(prop); \t}catch(e){ \/* squelch *\/ }\n\t\ttry{ node[prop] = null; \t\t\t}catch(e){ \/* squelch *\/ }\n\t\ttry{ delete node[prop]; \t\t\t}catch(e){ \/* squelch *\/ }\n\t\t\/\/ FIXME: JotLive needs this, but I'm not sure if it's too slow or not\n\t\ttry{ node.removeAttribute(prop);\t}catch(e){ \/* squelch *\/ }\n\t}\n\tthis.clobber = function(nodeRef){\n\t\tvar na;\n\t\tvar tna;\n\t\tif(nodeRef){\n\t\t\ttna = nodeRef.all || nodeRef.getElementsByTagName(\"*\");\n\t\t\tna = [nodeRef];\n\t\t\tfor(var x=0; x<tna.length; x++){\n\t\t\t\t\/\/ if we're gonna be clobbering the thing, at least make sure\n\t\t\t\t\/\/ we aren't trying to do it twice\n\t\t\t\tif(tna[x][\"__doClobber__\"]){\n\t\t\t\t\tna.push(tna[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\ttry{ window.onload = null; }catch(e){}\n\t\t\tna = (this.clobberNodes.length) ? this.clobberNodes : document.all;\n\t\t}\n\t\ttna = null;\n\t\tvar basis = {};\n\t\tfor(var i = na.length-1; i>=0; i=i-1){\n\t\t\tvar el = na[i];\n\t\t\ttry{\n\t\t\t\tif(el && el[\"__clobberAttrs__\"]){\n\t\t\t\t\tfor(var j=0; j<el.__clobberAttrs__.length; j++){\n\t\t\t\t\t\tnukeProp(el, el.__clobberAttrs__[j]);\n\t\t\t\t\t}\n\t\t\t\t\tnukeProp(el, \"__clobberAttrs__\");\n\t\t\t\t\tnukeProp(el, \"__doClobber__\");\n\t\t\t\t}\n\t\t\t}catch(e){ \/* squelch! *\/};\n\t\t}\n\t\tna = null;\n\t}","instance_variables":["clobberNodes","clobber"]}},"dojo._ie_clobber.clobber":{"meta":{"summary":"","parameters":{"nodeRef":{"type":""}},"src":" \tvar na;\n\t\tvar tna;\n\t\tif(nodeRef){\n\t\t\ttna = nodeRef.all || nodeRef.getElementsByTagName(\"*\");\n\t\t\tna = [nodeRef];\n\t\t\tfor(var x=0; x<tna.length; x++){\n\t\t\t\t\/\/ if we're gonna be clobbering the thing, at least make sure\n\t\t\t\t\/\/ we aren't trying to do it twice\n\t\t\t\tif(tna[x][\"__doClobber__\"]){\n\t\t\t\t\tna.push(tna[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\ttry{ window.onload = null; }catch(e){}\n\t\t\tna = (this.clobberNodes.length) ? this.clobberNodes : document.all;\n\t\t}\n\t\ttna = null;\n\t\tvar basis = {};\n\t\tfor(var i = na.length-1; i>=0; i=i-1){\n\t\t\tvar el = na[i];\n\t\t\ttry{\n\t\t\t\tif(el && el[\"__clobberAttrs__\"]){\n\t\t\t\t\tfor(var j=0; j<el.__clobberAttrs__.length; j++){\n\t\t\t\t\t\tnukeProp(el, el.__clobberAttrs__[j]);\n\t\t\t\t\t}\n\t\t\t\t\tnukeProp(el, \"__clobberAttrs__\");\n\t\t\t\t\tnukeProp(el, \"__doClobber__\");\n\t\t\t\t}\n\t\t\t}catch(e){ \/* squelch! *\/};\n\t\t}\n\t\tna = null;","instance":"dojo._ie_clobber"}},"dojo.event.browser":{"meta":{"initialized":true,"summary":"","src":" var clobberIdx = 0;\n\tthis.normalizedEventName = function(\/*String*\/eventName){\n\t\tswitch(eventName){\n\t\t\tcase \"CheckboxStateChange\":\n\t\t\tcase \"DOMAttrModified\":\n\t\t\tcase \"DOMMenuItemActive\":\n\t\t\tcase \"DOMMenuItemInactive\":\n\t\t\tcase \"DOMMouseScroll\":\n\t\t\tcase \"DOMNodeInserted\":\n\t\t\tcase \"DOMNodeRemoved\":\n\t\t\tcase \"RadioStateChange\":\n\t\t\t\treturn eventName;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn eventName.toLowerCase();\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tthis.clean = function(\/*DOMNode*\/node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tremoves native event handlers so that destruction of the node\n\t\t\/\/\t\twill not leak memory. On most browsers this is a no-op, but\n\t\t\/\/\t\tit's critical for manual node removal on IE.\n\t\t\/\/ node:\n\t\t\/\/\t\tA DOM node. All of it's children will also be cleaned.\n\t\tif(dojo.render.html.ie){ \n\t\t\tdojo._ie_clobber.clobber(node);\n\t\t}\n\t}\n\tthis.addClobberNode = function(\/*DOMNode*\/node){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregister the passed node to support event stripping\n\t\t\/\/ node:\n\t\t\/\/\t\tA DOM node\n\t\tif(!dojo.render.html.ie){ return; }\n\t\tif(!node[\"__doClobber__\"]){\n\t\t\tnode.__doClobber__ = true;\n\t\t\tdojo._ie_clobber.clobberNodes.push(node);\n\t\t\t\/\/ this might not be the most efficient thing to do, but it's\n\t\t\t\/\/ much less error prone than other approaches which were\n\t\t\t\/\/ previously tried and failed\n\t\t\tnode.__clobberAttrs__ = [];\n\t\t}\n\t}\n\tthis.addClobberNodeAttrs = function(\/*DOMNode*\/node, \/*Array*\/props){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregister the passed node to support event stripping\n\t\t\/\/ node:\n\t\t\/\/\t\tA DOM node to stip properties from later\n\t\t\/\/ props:\n\t\t\/\/\t\tA list of propeties to strip from the node\n\t\tif(!dojo.render.html.ie){ return; }\n\t\tthis.addClobberNode(node);\n\t\tfor(var x=0; x<props.length; x++){\n\t\t\tnode.__clobberAttrs__.push(props[x]);\n\t\t}\n\t}\n\tthis.removeListener = function(\t\/*DOMNode*\/ node, \n\t\t\t\t\t\t\t\t\t\/*String*\/\tevtName, \n\t\t\t\t\t\t\t\t\t\/*Function*\/fp, \n\t\t\t\t\t\t\t\t\t\/*Boolean*\/\tcapture){\n\t\t\/\/ summary:\n\t\t\/\/\t\tclobbers the listener from the node\n\t\t\/\/ evtName:\n\t\t\/\/\t\tthe name of the handler to remove the function from\n\t\t\/\/ node:\n\t\t\/\/\t\tDOM node to attach the event to\n\t\t\/\/ fp:\n\t\t\/\/\t\tthe function to register\n\t\t\/\/ capture:\n\t\t\/\/\t\tOptional. should this listener prevent propigation?\n\t\tif(!capture){ var capture = false; }\n\t\tevtName = dojo.event.browser.normalizedEventName(evtName);\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.removeListener(node, \"onkeydown\", fp, capture);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)==\"on\"){ evtName = evtName.substr(2); }\n\t\t\/\/ FIXME: this is mostly a punt, we aren't actually doing anything on IE\n\t\tif(node.removeEventListener){\n\t\t\tnode.removeEventListener(evtName, fp, capture);\n\t\t}\n\t}\n\tthis.addListener = function(\/*DOMNode*\/node, \/*String*\/evtName, \/*Function*\/fp, \/*Boolean*\/capture, \/*Boolean*\/dontFix){\n\t\t\/\/ summary:\n\t\t\/\/\t\tadds a listener to the node\n\t\t\/\/ evtName:\n\t\t\/\/\t\tthe name of the handler to add the listener to can be either of\n\t\t\/\/\t\tthe form \"onclick\" or \"click\"\n\t\t\/\/ node:\n\t\t\/\/\t\tDOM node to attach the event to\n\t\t\/\/ fp:\n\t\t\/\/\t\tthe function to register\n\t\t\/\/ capture:\n\t\t\/\/\t\tOptional. Should this listener prevent propigation?\n\t\t\/\/ dontFix:\n\t\t\/\/\t\tOptional. Should we avoid registering a new closure around the\n\t\t\/\/\t\tlistener to enable fixEvent for dispatch of the registered\n\t\t\/\/\t\tfunction?\n\t\tif(!node){ return; } \/\/ FIXME: log and\/or bail?\n\t\tif(!capture){ var capture = false; }\n\t\tevtName = dojo.event.browser.normalizedEventName(evtName);\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addListener(node, \"onkeydown\", fp, capture, dontFix);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)!=\"on\"){ evtName = \"on\"+evtName; }\n\t\tif(!dontFix){\n\t\t\t\/\/ build yet another closure around fp in order to inject fixEvent\n\t\t\t\/\/ around the resulting event\n\t\t\tvar newfp = function(evt){\n\t\t\t\tif(!evt){ evt = window.event; }\n\t\t\t\tvar ret = fp(dojo.event.browser.fixEvent(evt, this));\n\t\t\t\tif(capture){\n\t\t\t\t\tdojo.event.browser.stopEvent(evt);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tnewfp = fp;\n\t\t}\n\t\tif(node.addEventListener){ \n\t\t\tnode.addEventListener(evtName.substr(2), newfp, capture);\n\t\t\treturn newfp;\n\t\t}else{\n\t\t\tif(typeof node[evtName] == \"function\" ){\n\t\t\t\tvar oldEvt = node[evtName];\n\t\t\t\tnode[evtName] = function(e){\n\t\t\t\t\toldEvt(e);\n\t\t\t\t\treturn newfp(e);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnode[evtName]=newfp;\n\t\t\t}\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addClobberNodeAttrs(node, [evtName]);\n\t\t\t}\n\t\t\treturn newfp;\n\t\t}\n\t}\n\tthis.isEvent = function(\/*Object*\/obj){\n\t\t\/\/ summary: \n\t\t\/\/\t\tTries to determine whether or not the object is a DOM event.\n\t\t\/\/ FIXME: event detection hack ... could test for additional attributes\n\t\t\/\/ if necessary\n\t\treturn (typeof obj != \"undefined\")&&(obj)&&(typeof Event != \"undefined\")&&(obj.eventPhase); \/\/ Boolean\n\t\t\/\/ Event does not support instanceof in Opera, otherwise:\n\t\t\/\/return (typeof Event != \"undefined\")&&(obj instanceof Event);\n\t}\n\tthis.currentEvent = null;\n\tthis.callListener = function(\/*Function*\/listener, \/*DOMNode*\/curTarget){\n\t\t\/\/ summary:\n\t\t\/\/\t\tcalls the specified listener in the context of the passed node\n\t\t\/\/\t\twith the current DOM event object as the only parameter\n\t\t\/\/ listener:\n\t\t\/\/\t\tthe function to call\n\t\t\/\/ curTarget:\n\t\t\/\/\t\tthe Node to call the function in the scope of\n\t\tif(typeof listener != 'function'){\n\t\t\tdojo.raise(\"listener not a function: \" + listener);\n\t\t}\n\t\tdojo.event.browser.currentEvent.currentTarget = curTarget;\n\t\treturn listener.call(curTarget, dojo.event.browser.currentEvent);\n\t}\n\tthis._stopPropagation = function(){\n\t\tdojo.event.browser.currentEvent.cancelBubble = true; \n\t}\n\tthis._preventDefault = function(){\n\t\tdojo.event.browser.currentEvent.returnValue = false;\n\t}\n\tthis.keys = {\n\t\tKEY_BACKSPACE: 8,\n\t\tKEY_TAB: 9,\n\t\tKEY_CLEAR: 12,\n\t\tKEY_ENTER: 13,\n\t\tKEY_SHIFT: 16,\n\t\tKEY_CTRL: 17,\n\t\tKEY_ALT: 18,\n\t\tKEY_PAUSE: 19,\n\t\tKEY_CAPS_LOCK: 20,\n\t\tKEY_ESCAPE: 27,\n\t\tKEY_SPACE: 32,\n\t\tKEY_PAGE_UP: 33,\n\t\tKEY_PAGE_DOWN: 34,\n\t\tKEY_END: 35,\n\t\tKEY_HOME: 36,\n\t\tKEY_LEFT_ARROW: 37,\n\t\tKEY_UP_ARROW: 38,\n\t\tKEY_RIGHT_ARROW: 39,\n\t\tKEY_DOWN_ARROW: 40,\n\t\tKEY_INSERT: 45,\n\t\tKEY_DELETE: 46,\n\t\tKEY_HELP: 47,\n\t\tKEY_LEFT_WINDOW: 91,\n\t\tKEY_RIGHT_WINDOW: 92,\n\t\tKEY_SELECT: 93,\n\t\tKEY_NUMPAD_0: 96,\n\t\tKEY_NUMPAD_1: 97,\n\t\tKEY_NUMPAD_2: 98,\n\t\tKEY_NUMPAD_3: 99,\n\t\tKEY_NUMPAD_4: 100,\n\t\tKEY_NUMPAD_5: 101,\n\t\tKEY_NUMPAD_6: 102,\n\t\tKEY_NUMPAD_7: 103,\n\t\tKEY_NUMPAD_8: 104,\n\t\tKEY_NUMPAD_9: 105,\n\t\tKEY_NUMPAD_MULTIPLY: 106,\n\t\tKEY_NUMPAD_PLUS: 107,\n\t\tKEY_NUMPAD_ENTER: 108,\n\t\tKEY_NUMPAD_MINUS: 109,\n\t\tKEY_NUMPAD_PERIOD: 110,\n\t\tKEY_NUMPAD_DIVIDE: 111,\n\t\tKEY_F1: 112,\n\t\tKEY_F2: 113,\n\t\tKEY_F3: 114,\n\t\tKEY_F4: 115,\n\t\tKEY_F5: 116,\n\t\tKEY_F6: 117,\n\t\tKEY_F7: 118,\n\t\tKEY_F8: 119,\n\t\tKEY_F9: 120,\n\t\tKEY_F10: 121,\n\t\tKEY_F11: 122,\n\t\tKEY_F12: 123,\n\t\tKEY_F13: 124,\n\t\tKEY_F14: 125,\n\t\tKEY_F15: 126,\n\t\tKEY_NUM_LOCK: 144,\n\t\tKEY_SCROLL_LOCK: 145\n\t};\n\t\/\/ reverse lookup\n\tthis.revKeys = [];\n\tfor(var key in this.keys){\n\t\tthis.revKeys[this.keys[key]] = key;\n\t}\n\tthis.fixEvent = function(\/*Event*\/evt, \/*DOMNode*\/sender){\n\t\t\/\/ summary:\n\t\t\/\/\t\tnormalizes properties on the event object including event\n\t\t\/\/\t\tbubbling methods, keystroke normalization, and x\/y positions\n\t\t\/\/ evt: the native event object\n\t\t\/\/ sender: the node to treat as \"currentTarget\"\n\t\tif(!evt){\n\t\t\tif(window[\"event\"]){\n\t\t\t\tevt = window.event;\n\t\t\t}\n\t\t}\n\t\tif((evt[\"type\"])&&(evt[\"type\"].indexOf(\"key\") == 0)){ \/\/ key events\n\t\t\tevt.keys = this.revKeys;\n\t\t\t\/\/ FIXME: how can we eliminate this iteration?\n\t\t\tfor(var key in this.keys){\n\t\t\t\tevt[key] = this.keys[key];\n\t\t\t}\n\t\t\tif(evt[\"type\"] == \"keydown\" && dojo.render.html.ie){\n\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\tcase evt.KEY_LEFT_WINDOW:\n\t\t\t\t\tcase evt.KEY_RIGHT_WINDOW:\n\t\t\t\t\tcase evt.KEY_SELECT:\n\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\/\/ I'll get these in keypress after the OS munges them based on numlock\n\t\t\t\t\tcase evt.KEY_NUMPAD_0:\n\t\t\t\t\tcase evt.KEY_NUMPAD_1:\n\t\t\t\t\tcase evt.KEY_NUMPAD_2:\n\t\t\t\t\tcase evt.KEY_NUMPAD_3:\n\t\t\t\t\tcase evt.KEY_NUMPAD_4:\n\t\t\t\t\tcase evt.KEY_NUMPAD_5:\n\t\t\t\t\tcase evt.KEY_NUMPAD_6:\n\t\t\t\t\tcase evt.KEY_NUMPAD_7:\n\t\t\t\t\tcase evt.KEY_NUMPAD_8:\n\t\t\t\t\tcase evt.KEY_NUMPAD_9:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PERIOD:\n\t\t\t\t\t\tbreak; \/\/ just ignore the keys that can morph\n\t\t\t\t\tcase evt.KEY_NUMPAD_MULTIPLY:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PLUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_ENTER:\n\t\t\t\t\tcase evt.KEY_NUMPAD_MINUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_DIVIDE:\n\t\t\t\t\t\tbreak; \/\/ I could handle these but just pick them up in keypress\n\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\tcase evt.KEY_PAGE_UP:\n\t\t\t\t\tcase evt.KEY_PAGE_DOWN:\n\t\t\t\t\tcase evt.KEY_END:\n\t\t\t\t\tcase evt.KEY_HOME:\n\t\t\t\t\tcase evt.KEY_LEFT_ARROW:\n\t\t\t\t\tcase evt.KEY_UP_ARROW:\n\t\t\t\t\tcase evt.KEY_RIGHT_ARROW:\n\t\t\t\t\tcase evt.KEY_DOWN_ARROW:\n\t\t\t\t\tcase evt.KEY_INSERT:\n\t\t\t\t\tcase evt.KEY_DELETE:\n\t\t\t\t\tcase evt.KEY_F1:\n\t\t\t\t\tcase evt.KEY_F2:\n\t\t\t\t\tcase evt.KEY_F3:\n\t\t\t\t\tcase evt.KEY_F4:\n\t\t\t\t\tcase evt.KEY_F5:\n\t\t\t\t\tcase evt.KEY_F6:\n\t\t\t\t\tcase evt.KEY_F7:\n\t\t\t\t\tcase evt.KEY_F8:\n\t\t\t\t\tcase evt.KEY_F9:\n\t\t\t\t\tcase evt.KEY_F10:\n\t\t\t\t\tcase evt.KEY_F11:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F13:\n\t\t\t\t\tcase evt.KEY_F14:\n\t\t\t\t\tcase evt.KEY_F15:\n\t\t\t\t\tcase evt.KEY_CLEAR:\n\t\t\t\t\tcase evt.KEY_HELP:\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(evt.ctrlKey || evt.altKey){\n\t\t\t\t\t\t\tvar unifiedCharCode = evt.keyCode;\n\t\t\t\t\t\t\t\/\/ if lower case but keycode is uppercase, convert it\n\t\t\t\t\t\t\tif(unifiedCharCode >= 65 && unifiedCharCode <= 90 && evt.shiftKey == false){\n\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(unifiedCharCode >= 1 && unifiedCharCode <= 26 && evt.ctrlKey){\n\t\t\t\t\t\t\t\tunifiedCharCode += 96; \/\/ 001-032 = ctrl+[a-z]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(evt[\"type\"] == \"keypress\"){\n\t\t\t\tif(dojo.render.html.opera){\n\t\t\t\t\tif(evt.which == 0){\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t}else if(evt.which > 0){\n\t\t\t\t\t\tswitch(evt.which){\n\t\t\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\t\t\t\tevt.key = evt.which;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tvar unifiedCharCode = evt.which;\n\t\t\t\t\t\t\t\tif((evt.ctrlKey || evt.altKey || evt.metaKey) && (evt.which >= 65 && evt.which <= 90 && evt.shiftKey == false)){\n\t\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.ie){ \/\/ catch some IE keys that are hard to get in keyDown\n\t\t\t\t\t\/\/ key combinations were handled in onKeyDown\n\t\t\t\t\tif(!evt.ctrlKey && !evt.altKey && evt.keyCode >= evt.KEY_SPACE){\n\t\t\t\t\t\tevt.key = String.fromCharCode(evt.keyCode);\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.safari){\n\t\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\t\tcase 25: evt.key = evt.KEY_TAB; evt.shift = true;break;\n\t\t\t\t\t\tcase 63232: evt.key = evt.KEY_UP_ARROW; break;\n\t\t\t\t\t\tcase 63233: evt.key = evt.KEY_DOWN_ARROW; break;\n\t\t\t\t\t\tcase 63234: evt.key = evt.KEY_LEFT_ARROW; break;\n\t\t\t\t\t\tcase 63235: evt.key = evt.KEY_RIGHT_ARROW; break;\n\t\t\t\t\t\tcase 63236: evt.key = evt.KEY_F1; break;\n\t\t\t\t\t\tcase 63237: evt.key = evt.KEY_F2; break;\n\t\t\t\t\t\tcase 63238: evt.key = evt.KEY_F3; break;\n\t\t\t\t\t\tcase 63239: evt.key = evt.KEY_F4; break;\n\t\t\t\t\t\tcase 63240: evt.key = evt.KEY_F5; break;\n\t\t\t\t\t\tcase 63241: evt.key = evt.KEY_F6; break;\n\t\t\t\t\t\tcase 63242: evt.key = evt.KEY_F7; break;\n\t\t\t\t\t\tcase 63243: evt.key = evt.KEY_F8; break;\n\t\t\t\t\t\tcase 63244: evt.key = evt.KEY_F9; break;\n\t\t\t\t\t\tcase 63245: evt.key = evt.KEY_F10; break;\n\t\t\t\t\t\tcase 63246: evt.key = evt.KEY_F11; break;\n\t\t\t\t\t\tcase 63247: evt.key = evt.KEY_F12; break;\n\t\t\t\t\t\tcase 63250: evt.key = evt.KEY_PAUSE; break;\n\t\t\t\t\t\tcase 63272: evt.key = evt.KEY_DELETE; break;\n\t\t\t\t\t\tcase 63273: evt.key = evt.KEY_HOME; break;\n\t\t\t\t\t\tcase 63275: evt.key = evt.KEY_END; break;\n\t\t\t\t\t\tcase 63276: evt.key = evt.KEY_PAGE_UP; break;\n\t\t\t\t\t\tcase 63277: evt.key = evt.KEY_PAGE_DOWN; break;\n\t\t\t\t\t\tcase 63302: evt.key = evt.KEY_INSERT; break;\n\t\t\t\t\t\tcase 63248:\/\/prtscr\n\t\t\t\t\t\tcase 63249:\/\/scrolllock\n\t\t\t\t\t\tcase 63289:\/\/numlock\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: \n\t\t\t\t\t\t\tevt.key = evt.charCode >= evt.KEY_SPACE ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tevt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dojo.render.html.ie){\n\t\t\tif(!evt.target){ evt.target = evt.srcElement; }\n\t\t\tif(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }\n\t\t\tif(!evt.layerX){ evt.layerX = evt.offsetX; }\n\t\t\tif(!evt.layerY){ evt.layerY = evt.offsetY; }\n\t\t\t\/\/ FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module\n\t\t\t\/\/ DONOT replace the following to use dojo.body(), in IE, document.documentElement should be used\n\t\t\t\/\/ here rather than document.body\n\t\t\tvar doc = (evt.srcElement && evt.srcElement.ownerDocument) ? evt.srcElement.ownerDocument : document;\n\t\t\tvar docBody = ((dojo.render.html.ie55)||(doc[\"compatMode\"] == \"BackCompat\")) ? doc.body : doc.documentElement;\n\t\t\tif(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }\n\t\t\tif(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }\n\t\t\t\/\/ mouseover\n\t\t\tif(evt.type == \"mouseover\"){ evt.relatedTarget = evt.fromElement; }\n\t\t\t\/\/ mouseout\n\t\t\tif(evt.type == \"mouseout\"){ evt.relatedTarget = evt.toElement; }\n\t\t\tthis.currentEvent = evt;\n\t\t\tevt.callListener = this.callListener;\n\t\t\tevt.stopPropagation = this._stopPropagation;\n\t\t\tevt.preventDefault = this._preventDefault;\n\t\t}\n\t\treturn evt; \/\/ Event\n\t}\n\tthis.stopEvent = function(\/*Event*\/evt){\n\t\t\/\/ summary:\n\t\t\/\/\t\tprevents propigation and clobbers the default action of the\n\t\t\/\/\t\tpassed event\n\t\t\/\/ evt: Optional for IE. The native event object.\n\t\tif(window.event){\n\t\t\tevt.cancelBubble = true;\n\t\t\tevt.returnValue = false;\n\t\t}else{\n\t\t\tevt.preventDefault();\n\t\t\tevt.stopPropagation();\n\t\t}\n\t}","instance_variables":["normalizedEventName","clean","addClobberNode","addClobberNodeAttrs","removeListener","addListener","isEvent","currentEvent","callListener","_stopPropagation","_preventDefault","keys","revKeys","fixEvent","stopEvent"],"returns":"mixed","call_chain":["listener"]}},"dojo.event.browser.normalizedEventName":{"meta":{"summary":"","parameters":{"eventName":{"type":"String"}},"src":" \tswitch(eventName){\n\t\t\tcase \"CheckboxStateChange\":\n\t\t\tcase \"DOMAttrModified\":\n\t\t\tcase \"DOMMenuItemActive\":\n\t\t\tcase \"DOMMenuItemInactive\":\n\t\t\tcase \"DOMMouseScroll\":\n\t\t\tcase \"DOMNodeInserted\":\n\t\t\tcase \"DOMNodeRemoved\":\n\t\t\tcase \"RadioStateChange\":\n\t\t\t\treturn eventName;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn eventName.toLowerCase();\n\t\t\t\tbreak;\n\t\t}","instance":"dojo.event.browser"}},"dojo.event.browser.clean":{"meta":{"summary":"removes native event handlers so that destruction of the node will not leak memory. On most browsers this is a no-op, but it's critical for manual node removal on IE.","parameters":{"node":{"type":"DOMNode"}},"src":" \tif(dojo.render.html.ie){ \n\t\t\tdojo._ie_clobber.clobber(node);\n\t\t}","instance":"dojo.event.browser"},"extra":{"parameters":{"node":{"type":"A","summary":"DOM node. All of it's children will also be cleaned."}}}},"dojo.event.browser.addClobberNode":{"meta":{"summary":"register the passed node to support event stripping","parameters":{"node":{"type":"DOMNode"}},"src":" \tif(!dojo.render.html.ie){ return; }\n\t\tif(!node[\"__doClobber__\"]){\n\t\t\tnode.__doClobber__ = true;\n\t\t\tdojo._ie_clobber.clobberNodes.push(node);\n\t\t\t\/\/ this might not be the most efficient thing to do, but it's\n\t\t\t\/\/ much less error prone than other approaches which were\n\t\t\t\/\/ previously tried and failed\n\t\t\tnode.__clobberAttrs__ = [];\n\t\t}","instance":"dojo.event.browser"},"extra":{"parameters":{"node":{"type":"A","summary":"DOM node"}}}},"dojo.event.browser.addClobberNodeAttrs":{"meta":{"summary":"register the passed node to support event stripping","parameters":{"node":{"type":"DOMNode"},"props":{"type":"Array"}},"src":" \tif(!dojo.render.html.ie){ return; }\n\t\tthis.addClobberNode(node);\n\t\tfor(var x=0; x<props.length; x++){\n\t\t\tnode.__clobberAttrs__.push(props[x]);\n\t\t}","instance":"dojo.event.browser"},"extra":{"parameters":{"node":{"type":"A","summary":"DOM node to stip properties from later"},"props":{"type":"A","summary":"list of propeties to strip from the node"}}}},"dojo.event.browser.removeListener":{"meta":{"summary":"clobbers the listener from the node","parameters":{"node":{"type":"DOMNode"},"evtName":{"type":"String"},"fp":{"type":"Function"},"capture":{"type":"Boolean"}},"src":" \tif(!capture){ var capture = false; }\n\t\tevtName = dojo.event.browser.normalizedEventName(evtName);\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.removeListener(node, \"onkeydown\", fp, capture);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)==\"on\"){ evtName = evtName.substr(2); }\n\t\t\/\/ FIXME: this is mostly a punt, we aren't actually doing anything on IE\n\t\tif(node.removeEventListener){\n\t\t\tnode.removeEventListener(evtName, fp, capture);\n\t\t}","instance":"dojo.event.browser"},"extra":{"parameters":{"evtName":{"type":"the","summary":"name of the handler to remove the function from"},"node":{"type":"DOM","summary":"node to attach the event to"},"fp":{"type":"the","summary":"function to register"},"capture":{"type":"Optional.","summary":"should this listener prevent propigation?"}}}},"dojo.event.browser.addListener":{"meta":{"summary":"adds a listener to the node","parameters":{"node":{"type":"DOMNode"},"evtName":{"type":"String"},"fp":{"type":"Function"},"capture":{"type":"Boolean"},"dontFix":{"type":"Boolean"}},"src":" \tif(!node){ return; } \/\/ FIXME: log and\/or bail?\n\t\tif(!capture){ var capture = false; }\n\t\tevtName = dojo.event.browser.normalizedEventName(evtName);\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addListener(node, \"onkeydown\", fp, capture, dontFix);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)!=\"on\"){ evtName = \"on\"+evtName; }\n\t\tif(!dontFix){\n\t\t\t\/\/ build yet another closure around fp in order to inject fixEvent\n\t\t\t\/\/ around the resulting event\n\t\t\tvar newfp = function(evt){\n\t\t\t\tif(!evt){ evt = window.event; }\n\t\t\t\tvar ret = fp(dojo.event.browser.fixEvent(evt, this));\n\t\t\t\tif(capture){\n\t\t\t\t\tdojo.event.browser.stopEvent(evt);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tnewfp = fp;\n\t\t}\n\t\tif(node.addEventListener){ \n\t\t\tnode.addEventListener(evtName.substr(2), newfp, capture);\n\t\t\treturn newfp;\n\t\t}else{\n\t\t\tif(typeof node[evtName] == \"function\" ){\n\t\t\t\tvar oldEvt = node[evtName];\n\t\t\t\tnode[evtName] = function(e){\n\t\t\t\t\toldEvt(e);\n\t\t\t\t\treturn newfp(e);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnode[evtName]=newfp;\n\t\t\t}\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addClobberNodeAttrs(node, [evtName]);\n\t\t\t}\n\t\t\treturn newfp;\n\t\t}","returns":"FIXME: log and\/or bail?","instance":"dojo.event.browser"},"extra":{"parameters":{"evtName":{"type":"the","summary":"name of the handler to add the listener to can be either of the form \"onclick\" or \"click\""},"node":{"type":"DOM","summary":"node to attach the event to"},"fp":{"type":"the","summary":"function to register"},"capture":{"type":"Optional.","summary":"Should this listener prevent propigation?"},"dontFix":{"type":"Optional.","summary":"Should we avoid registering a new closure around the listener to enable fixEvent for dispatch of the registered function?"}}}},"dojo.event.browser.isEvent":{"meta":{"summary":"Tries to determine whether or not the object is a DOM event.","parameters":{"obj":{"type":"Object"}},"src":"\t\t\/\/ FIXME: event detection hack ... could test for additional attributes\n\t\t\/\/ if necessary\n\t\treturn (typeof obj != \"undefined\")&&(obj)&&(typeof Event != \"undefined\")&&(obj.eventPhase); \/\/ Boolean\n\t\t\/\/ Event does not support instanceof in Opera, otherwise:\n\t\t\/\/return (typeof Event != \"undefined\")&&(obj instanceof Event);","returns":"Boolean","instance":"dojo.event.browser"}},"dojo.event.browser.callListener":{"meta":{"summary":"calls the specified listener in the context of the passed node with the current DOM event object as the only parameter","parameters":{"listener":{"type":"Function"},"curTarget":{"type":"DOMNode"}},"src":" \tif(typeof listener != 'function'){\n\t\t\tdojo.raise(\"listener not a function: \" + listener);\n\t\t}\n\t\tdojo.event.browser.currentEvent.currentTarget = curTarget;\n\t\treturn listener.call(curTarget, dojo.event.browser.currentEvent);","call_chain":["listener"],"instance":"dojo.event.browser"},"extra":{"parameters":{"listener":{"type":"the","summary":"function to call"},"curTarget":{"type":"the","summary":"Node to call the function in the scope of"}}}},"dojo.event.browser._stopPropagation":{"meta":{"summary":"","src":" \tdojo.event.browser.currentEvent.cancelBubble = true; ","instance":"dojo.event.browser"}},"dojo.event.browser._preventDefault":{"meta":{"summary":"","src":" \tdojo.event.browser.currentEvent.returnValue = false;","instance":"dojo.event.browser"}},"dojo.event.browser.fixEvent":{"meta":{"summary":"normalizes properties on the event object including event bubbling methods, keystroke normalization, and x\/y positions","parameters":{"evt":{"type":"Event"},"sender":{"type":"DOMNode"}},"src":" \tif(!evt){\n\t\t\tif(window[\"event\"]){\n\t\t\t\tevt = window.event;\n\t\t\t}\n\t\t}\n\t\tif((evt[\"type\"])&&(evt[\"type\"].indexOf(\"key\") == 0)){ \/\/ key events\n\t\t\tevt.keys = this.revKeys;\n\t\t\t\/\/ FIXME: how can we eliminate this iteration?\n\t\t\tfor(var key in this.keys){\n\t\t\t\tevt[key] = this.keys[key];\n\t\t\t}\n\t\t\tif(evt[\"type\"] == \"keydown\" && dojo.render.html.ie){\n\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\tcase evt.KEY_LEFT_WINDOW:\n\t\t\t\t\tcase evt.KEY_RIGHT_WINDOW:\n\t\t\t\t\tcase evt.KEY_SELECT:\n\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\/\/ I'll get these in keypress after the OS munges them based on numlock\n\t\t\t\t\tcase evt.KEY_NUMPAD_0:\n\t\t\t\t\tcase evt.KEY_NUMPAD_1:\n\t\t\t\t\tcase evt.KEY_NUMPAD_2:\n\t\t\t\t\tcase evt.KEY_NUMPAD_3:\n\t\t\t\t\tcase evt.KEY_NUMPAD_4:\n\t\t\t\t\tcase evt.KEY_NUMPAD_5:\n\t\t\t\t\tcase evt.KEY_NUMPAD_6:\n\t\t\t\t\tcase evt.KEY_NUMPAD_7:\n\t\t\t\t\tcase evt.KEY_NUMPAD_8:\n\t\t\t\t\tcase evt.KEY_NUMPAD_9:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PERIOD:\n\t\t\t\t\t\tbreak; \/\/ just ignore the keys that can morph\n\t\t\t\t\tcase evt.KEY_NUMPAD_MULTIPLY:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PLUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_ENTER:\n\t\t\t\t\tcase evt.KEY_NUMPAD_MINUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_DIVIDE:\n\t\t\t\t\t\tbreak; \/\/ I could handle these but just pick them up in keypress\n\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\tcase evt.KEY_PAGE_UP:\n\t\t\t\t\tcase evt.KEY_PAGE_DOWN:\n\t\t\t\t\tcase evt.KEY_END:\n\t\t\t\t\tcase evt.KEY_HOME:\n\t\t\t\t\tcase evt.KEY_LEFT_ARROW:\n\t\t\t\t\tcase evt.KEY_UP_ARROW:\n\t\t\t\t\tcase evt.KEY_RIGHT_ARROW:\n\t\t\t\t\tcase evt.KEY_DOWN_ARROW:\n\t\t\t\t\tcase evt.KEY_INSERT:\n\t\t\t\t\tcase evt.KEY_DELETE:\n\t\t\t\t\tcase evt.KEY_F1:\n\t\t\t\t\tcase evt.KEY_F2:\n\t\t\t\t\tcase evt.KEY_F3:\n\t\t\t\t\tcase evt.KEY_F4:\n\t\t\t\t\tcase evt.KEY_F5:\n\t\t\t\t\tcase evt.KEY_F6:\n\t\t\t\t\tcase evt.KEY_F7:\n\t\t\t\t\tcase evt.KEY_F8:\n\t\t\t\t\tcase evt.KEY_F9:\n\t\t\t\t\tcase evt.KEY_F10:\n\t\t\t\t\tcase evt.KEY_F11:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F13:\n\t\t\t\t\tcase evt.KEY_F14:\n\t\t\t\t\tcase evt.KEY_F15:\n\t\t\t\t\tcase evt.KEY_CLEAR:\n\t\t\t\t\tcase evt.KEY_HELP:\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(evt.ctrlKey || evt.altKey){\n\t\t\t\t\t\t\tvar unifiedCharCode = evt.keyCode;\n\t\t\t\t\t\t\t\/\/ if lower case but keycode is uppercase, convert it\n\t\t\t\t\t\t\tif(unifiedCharCode >= 65 && unifiedCharCode <= 90 && evt.shiftKey == false){\n\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(unifiedCharCode >= 1 && unifiedCharCode <= 26 && evt.ctrlKey){\n\t\t\t\t\t\t\t\tunifiedCharCode += 96; \/\/ 001-032 = ctrl+[a-z]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(evt[\"type\"] == \"keypress\"){\n\t\t\t\tif(dojo.render.html.opera){\n\t\t\t\t\tif(evt.which == 0){\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t}else if(evt.which > 0){\n\t\t\t\t\t\tswitch(evt.which){\n\t\t\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\t\t\t\tevt.key = evt.which;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tvar unifiedCharCode = evt.which;\n\t\t\t\t\t\t\t\tif((evt.ctrlKey || evt.altKey || evt.metaKey) && (evt.which >= 65 && evt.which <= 90 && evt.shiftKey == false)){\n\t\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.ie){ \/\/ catch some IE keys that are hard to get in keyDown\n\t\t\t\t\t\/\/ key combinations were handled in onKeyDown\n\t\t\t\t\tif(!evt.ctrlKey && !evt.altKey && evt.keyCode >= evt.KEY_SPACE){\n\t\t\t\t\t\tevt.key = String.fromCharCode(evt.keyCode);\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.safari){\n\t\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\t\tcase 25: evt.key = evt.KEY_TAB; evt.shift = true;break;\n\t\t\t\t\t\tcase 63232: evt.key = evt.KEY_UP_ARROW; break;\n\t\t\t\t\t\tcase 63233: evt.key = evt.KEY_DOWN_ARROW; break;\n\t\t\t\t\t\tcase 63234: evt.key = evt.KEY_LEFT_ARROW; break;\n\t\t\t\t\t\tcase 63235: evt.key = evt.KEY_RIGHT_ARROW; break;\n\t\t\t\t\t\tcase 63236: evt.key = evt.KEY_F1; break;\n\t\t\t\t\t\tcase 63237: evt.key = evt.KEY_F2; break;\n\t\t\t\t\t\tcase 63238: evt.key = evt.KEY_F3; break;\n\t\t\t\t\t\tcase 63239: evt.key = evt.KEY_F4; break;\n\t\t\t\t\t\tcase 63240: evt.key = evt.KEY_F5; break;\n\t\t\t\t\t\tcase 63241: evt.key = evt.KEY_F6; break;\n\t\t\t\t\t\tcase 63242: evt.key = evt.KEY_F7; break;\n\t\t\t\t\t\tcase 63243: evt.key = evt.KEY_F8; break;\n\t\t\t\t\t\tcase 63244: evt.key = evt.KEY_F9; break;\n\t\t\t\t\t\tcase 63245: evt.key = evt.KEY_F10; break;\n\t\t\t\t\t\tcase 63246: evt.key = evt.KEY_F11; break;\n\t\t\t\t\t\tcase 63247: evt.key = evt.KEY_F12; break;\n\t\t\t\t\t\tcase 63250: evt.key = evt.KEY_PAUSE; break;\n\t\t\t\t\t\tcase 63272: evt.key = evt.KEY_DELETE; break;\n\t\t\t\t\t\tcase 63273: evt.key = evt.KEY_HOME; break;\n\t\t\t\t\t\tcase 63275: evt.key = evt.KEY_END; break;\n\t\t\t\t\t\tcase 63276: evt.key = evt.KEY_PAGE_UP; break;\n\t\t\t\t\t\tcase 63277: evt.key = evt.KEY_PAGE_DOWN; break;\n\t\t\t\t\t\tcase 63302: evt.key = evt.KEY_INSERT; break;\n\t\t\t\t\t\tcase 63248:\/\/prtscr\n\t\t\t\t\t\tcase 63249:\/\/scrolllock\n\t\t\t\t\t\tcase 63289:\/\/numlock\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault: \n\t\t\t\t\t\t\tevt.key = evt.charCode >= evt.KEY_SPACE ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tevt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dojo.render.html.ie){\n\t\t\tif(!evt.target){ evt.target = evt.srcElement; }\n\t\t\tif(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }\n\t\t\tif(!evt.layerX){ evt.layerX = evt.offsetX; }\n\t\t\tif(!evt.layerY){ evt.layerY = evt.offsetY; }\n\t\t\t\/\/ FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module\n\t\t\t\/\/ DONOT replace the following to use dojo.body(), in IE, document.documentElement should be used\n\t\t\t\/\/ here rather than document.body\n\t\t\tvar doc = (evt.srcElement && evt.srcElement.ownerDocument) ? evt.srcElement.ownerDocument : document;\n\t\t\tvar docBody = ((dojo.render.html.ie55)||(doc[\"compatMode\"] == \"BackCompat\")) ? doc.body : doc.documentElement;\n\t\t\tif(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }\n\t\t\tif(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }\n\t\t\t\/\/ mouseover\n\t\t\tif(evt.type == \"mouseover\"){ evt.relatedTarget = evt.fromElement; }\n\t\t\t\/\/ mouseout\n\t\t\tif(evt.type == \"mouseout\"){ evt.relatedTarget = evt.toElement; }\n\t\t\tthis.currentEvent = evt;\n\t\t\tevt.callListener = this.callListener;\n\t\t\tevt.stopPropagation = this._stopPropagation;\n\t\t\tevt.preventDefault = this._preventDefault;\n\t\t}\n\t\treturn evt; \/\/ Event","returns":"Event","instance":"dojo.event.browser"},"extra":{"parameters":{"evt":{"type":"the","summary":"native event object"},"sender":{"type":"the","summary":"node to treat as \"currentTarget\""}}}},"dojo.event.browser.stopEvent":{"meta":{"summary":"prevents propigation and clobbers the default action of the passed event","parameters":{"evt":{"type":"Event"}},"src":" \tif(window.event){\n\t\t\tevt.cancelBubble = true;\n\t\t\tevt.returnValue = false;\n\t\t}else{\n\t\t\tevt.preventDefault();\n\t\t\tevt.stopPropagation();\n\t\t}","instance":"dojo.event.browser"},"extra":{"parameters":{"evt":{"type":"Optional","summary":"for IE. The native event object."}}}}}}},"dojo.event.common":{"meta":{"requires":{"common":["dojo.lang.array","dojo.lang.extras","dojo.lang.func"]},"functions":{"dojo.event":{"meta":{"initialized":true,"summary":"","src":" this._canTimeout = dojo.lang.isFunction(dj_global[\"setTimeout\"])||dojo.lang.isAlien(dj_global[\"setTimeout\"]);\n\t\/\/ FIXME: where should we put this method (not here!)?\n\tfunction interpolateArgs(args, searchForNames){\n\t\tvar dl = dojo.lang;\n\t\tvar ao = {\n\t\t\tsrcObj: dj_global,\n\t\t\tsrcFunc: null,\n\t\t\tadviceObj: dj_global,\n\t\t\tadviceFunc: null,\n\t\t\taroundObj: null,\n\t\t\taroundFunc: null,\n\t\t\tadviceType: (args.length>2) ? args[0] : \"after\",\n\t\t\tprecedence: \"last\",\n\t\t\tonce: false,\n\t\t\tdelay: null,\n\t\t\trate: 0,\n\t\t\tadviceMsg: false\n\t\t};\n\t\tswitch(args.length){\n\t\t\tcase 0: return;\n\t\t\tcase 1: return;\n\t\t\tcase 2:\n\t\t\t\tao.srcFunc = args[0];\n\t\t\t\tao.adviceFunc = args[1];\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tif((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isString(args[2]))){\n\t\t\t\t\tao.adviceType = \"after\";\n\t\t\t\t\tao.srcObj = args[0];\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceFunc = args[2];\n\t\t\t\t}else if((dl.isString(args[1]))&&(dl.isString(args[2]))){\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceFunc = args[2];\n\t\t\t\t}else if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isFunction(args[2]))){\n\t\t\t\t\tao.adviceType = \"after\";\n\t\t\t\t\tao.srcObj = args[0];\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tvar tmpName  = dl.nameAnonFunc(args[2], ao.adviceObj, searchForNames);\n\t\t\t\t\tao.adviceFunc = tmpName;\n\t\t\t\t}else if((dl.isFunction(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))){\n\t\t\t\t\tao.adviceType = \"after\";\n\t\t\t\t\tao.srcObj = dj_global;\n\t\t\t\t\tvar tmpName  = dl.nameAnonFunc(args[0], ao.srcObj, searchForNames);\n\t\t\t\t\tao.srcFunc = tmpName;\n\t\t\t\t\tao.adviceObj = args[1];\n\t\t\t\t\tao.adviceFunc = args[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif((dl.isObject(args[0]))&&(dl.isObject(args[2]))){\n\t\t\t\t\t\/\/ we can assume that we've got an old-style \"connect\" from\n\t\t\t\t\t\/\/ the sigslot school of event attachment. We therefore\n\t\t\t\t\t\/\/ assume after-advice.\n\t\t\t\t\tao.adviceType = \"after\";\n\t\t\t\t\tao.srcObj = args[0];\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceObj = args[2];\n\t\t\t\t\tao.adviceFunc = args[3];\n\t\t\t\t}else if((dl.isString(args[0]))&&(dl.isString(args[1]))&&(dl.isObject(args[2]))){\n\t\t\t\t\tao.adviceType = args[0];\n\t\t\t\t\tao.srcObj = dj_global;\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceObj = args[2];\n\t\t\t\t\tao.adviceFunc = args[3];\n\t\t\t\t}else if((dl.isString(args[0]))&&(dl.isFunction(args[1]))&&(dl.isObject(args[2]))){\n\t\t\t\t\tao.adviceType = args[0];\n\t\t\t\t\tao.srcObj = dj_global;\n\t\t\t\t\tvar tmpName  = dl.nameAnonFunc(args[1], dj_global, searchForNames);\n\t\t\t\t\tao.srcFunc = tmpName;\n\t\t\t\t\tao.adviceObj = args[2];\n\t\t\t\t\tao.adviceFunc = args[3];\n\t\t\t\t}else if((dl.isString(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))&&(dl.isFunction(args[3]))){\n\t\t\t\t\tao.srcObj = args[1];\n\t\t\t\t\tao.srcFunc = args[2];\n\t\t\t\t\tvar tmpName  = dl.nameAnonFunc(args[3], dj_global, searchForNames);\n\t\t\t\t\tao.adviceObj = dj_global;\n\t\t\t\t\tao.adviceFunc = tmpName;\n\t\t\t\t}else if(dl.isObject(args[1])){\n\t\t\t\t\tao.srcObj = args[1];\n\t\t\t\t\tao.srcFunc = args[2];\n\t\t\t\t\tao.adviceObj = dj_global;\n\t\t\t\t\tao.adviceFunc = args[3];\n\t\t\t\t}else if(dl.isObject(args[2])){\n\t\t\t\t\tao.srcObj = dj_global;\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceObj = args[2];\n\t\t\t\t\tao.adviceFunc = args[3];\n\t\t\t\t}else{\n\t\t\t\t\tao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;\n\t\t\t\t\tao.srcFunc = args[1];\n\t\t\t\t\tao.adviceFunc = args[2];\n\t\t\t\t\tao.aroundFunc = args[3];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tao.srcObj = args[1];\n\t\t\t\tao.srcFunc = args[2];\n\t\t\t\tao.adviceObj = args[3]\n\t\t\t\tao.adviceFunc = args[4];\n\t\t\t\tao.aroundFunc = args[5];\n\t\t\t\tao.aroundObj = dj_global;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tao.srcObj = args[1];\n\t\t\t\tao.srcFunc = args[2];\n\t\t\t\tao.adviceObj = args[3]\n\t\t\t\tao.adviceFunc = args[4];\n\t\t\t\tao.aroundObj = args[5];\n\t\t\t\tao.aroundFunc = args[6];\n\t\t\t\tao.once = args[7];\n\t\t\t\tao.delay = args[8];\n\t\t\t\tao.rate = args[9];\n\t\t\t\tao.adviceMsg = args[10];\n\t\t\t\tbreak;\n\t\t}\n\t\tif(dl.isFunction(ao.aroundFunc)){\n\t\t\tvar tmpName  = dl.nameAnonFunc(ao.aroundFunc, ao.aroundObj, searchForNames);\n\t\t\tao.aroundFunc = tmpName;\n\t\t}\n\t\tif(dl.isFunction(ao.srcFunc)){\n\t\t\tao.srcFunc = dl.getNameInObj(ao.srcObj, ao.srcFunc);\n\t\t}\n\t\tif(dl.isFunction(ao.adviceFunc)){\n\t\t\tao.adviceFunc = dl.getNameInObj(ao.adviceObj, ao.adviceFunc);\n\t\t}\n\t\tif((ao.aroundObj)&&(dl.isFunction(ao.aroundFunc))){\n\t\t\tao.aroundFunc = dl.getNameInObj(ao.aroundObj, ao.aroundFunc);\n\t\t}\n\t\tif(!ao.srcObj){\n\t\t\tdojo.raise(\"bad srcObj for srcFunc: \"+ao.srcFunc);\n\t\t}\n\t\tif(!ao.adviceObj){\n\t\t\tdojo.raise(\"bad adviceObj for adviceFunc: \"+ao.adviceFunc);\n\t\t}\n\t\tif(!ao.adviceFunc){\n\t\t\tdojo.debug(\"bad adviceFunc for srcFunc: \"+ao.srcFunc);\n\t\t\tdojo.debugShallow(ao);\n\t\t} \n\t\treturn ao;\n\t}\n\tthis.connect = function(\/*...*\/){\n\t\t\/\/ summary:\n\t\t\/\/\t\tdojo.event.connect is the glue that holds most Dojo-based\n\t\t\/\/\t\tapplications together. Most combinations of arguments are\n\t\t\/\/\t\tsupported, with the connect() method attempting to disambiguate\n\t\t\/\/\t\tthe implied types of positional parameters. The following will\n\t\t\/\/\t\tall work:\n\t\t\/\/\t\t\tdojo.event.connect(\"globalFunctionName1\", \"globalFunctionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(functionReference1, functionReference2);\n\t\t\/\/\t\t\tdojo.event.connect(\"globalFunctionName1\", functionReference2);\n\t\t\/\/\t\t\tdojo.event.connect(functionReference1, \"globalFunctionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(scope1, \"functionName1\", \"globalFunctionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(\"globalFunctionName1\", scope2, \"functionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(scope1, \"functionName1\", scope2, \"functionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(\"after\", scope1, \"functionName1\", scope2, \"functionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(\"before\", scope1, \"functionName1\", scope2, \"functionName2\");\n\t\t\/\/\t\t\tdojo.event.connect(\"around\", \tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\taroundFunctionReference);\n\t\t\/\/\t\t\tdojo.event.connect(\"around\", \tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope3, \"aroundFunctionName\");\n\t\t\/\/\t\t\tdojo.event.connect(\"before-around\", \tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\taroundFunctionReference);\n\t\t\/\/\t\t\tdojo.event.connect(\"after-around\", \t\tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\taroundFunctionReference);\n\t\t\/\/\t\t\tdojo.event.connect(\"after-around\", \t\tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\t\t\tscope3, \"aroundFunctionName\");\n\t\t\/\/\t\t\tdojo.event.connect(\"around\", \tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope3, \"aroundFunctionName\", true, 30);\n\t\t\/\/\t\t\tdojo.event.connect(\"around\", \tscope1, \"functionName1\", \n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope2, \"functionName2\",\n\t\t\/\/\t\t\t\t\t\t\t\t\t\t\tscope3, \"aroundFunctionName\", null, null, 10);\n\t\t\/\/ adviceType: \n\t\t\/\/\t\tOptional. String. One of \"before\", \"after\", \"around\",\n\t\t\/\/\t\t\"before-around\", or \"after-around\". FIXME\n\t\t\/\/ srcObj:\n\t\t\/\/\t\tthe scope in which to locate\/execute the named srcFunc. Along\n\t\t\/\/\t\twith srcFunc, this creates a way to dereference the function to\n\t\t\/\/\t\tcall. So if the function in question is \"foo.bar\", the\n\t\t\/\/\t\tsrcObj\/srcFunc pair would be foo and \"bar\", where \"bar\" is a\n\t\t\/\/\t\tstring and foo is an object reference.\n\t\t\/\/ srcFunc:\n\t\t\/\/\t\tthe name of the function to connect to. When it is executed,\n\t\t\/\/\t\tthe listener being registered with this call will be called.\n\t\t\/\/\t\tThe adviceType defines the call order between the source and\n\t\t\/\/\t\tthe target functions.\n\t\t\/\/ adviceObj:\n\t\t\/\/\t\tthe scope in which to locate\/execute the named adviceFunc.\n\t\t\/\/ adviceFunc:\n\t\t\/\/\t\tthe name of the function being conected to srcObj.srcFunc\n\t\t\/\/ aroundObj:\n\t\t\/\/\t\tthe scope in which to locate\/execute the named aroundFunc.\n\t\t\/\/ aroundFunc:\n\t\t\/\/\t\tthe name of, or a reference to, the function that will be used\n\t\t\/\/\t\tto mediate the advice call. Around advice requires a special\n\t\t\/\/\t\tunary function that will be passed a \"MethodInvocation\" object.\n\t\t\/\/\t\tThese objects have several important properties, namely:\n\t\t\/\/\t\t\t- args\n\t\t\/\/\t\t\t\ta mutable array of arguments to be passed into the\n\t\t\/\/\t\t\t\twrapped function\n\t\t\/\/\t\t\t- proceed\n\t\t\/\/\t\t\t\ta function that \"continues\" the invocation. The result\n\t\t\/\/\t\t\t\tof this function is the return of the wrapped function.\n\t\t\/\/\t\t\t\tYou can then manipulate this return before passing it\n\t\t\/\/\t\t\t\tback out (or take further action based on it).\n\t\t\/\/ once:\n\t\t\/\/\t\tboolean that determines whether or not this connect() will\n\t\t\/\/\t\tcreate a new connection if an identical connect() has already\n\t\t\/\/\t\tbeen made. Defaults to \"false\".\n\t\t\/\/ delay:\n\t\t\/\/\t\tan optional delay (in ms), as an integer, for dispatch of a\n\t\t\/\/\t\tlistener after the source has been fired.\n\t\t\/\/ rate:\n\t\t\/\/\t\tan optional rate throttling parameter (integer, in ms). When\n\t\t\/\/\t\tspecified, this particular connection will not fire more than\n\t\t\/\/\t\tonce in the interval specified by the rate\n\t\t\/\/ adviceMsg:\n\t\t\/\/\t\tboolean. Should the listener have all the parameters passed in\n\t\t\/\/\t\tas a single argument?\n\t\t\/*\n\t\t\t\tao.adviceType = args[0];\n\t\t\t\tao.srcObj = args[1];\n\t\t\t\tao.srcFunc = args[2];\n\t\t\t\tao.adviceObj = args[3]\n\t\t\t\tao.adviceFunc = args[4];\n\t\t\t\tao.aroundObj = args[5];\n\t\t\t\tao.aroundFunc = args[6];\n\t\t\t\tao.once = args[7];\n\t\t\t\tao.delay = args[8];\n\t\t\t\tao.rate = args[9];\n\t\t\t\tao.adviceMsg = args[10];\n\t\t*\/\n\t\tif(arguments.length == 1){\n\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.connect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\t\tif(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=\"\"){\n\t\t\tvar tmpAO = {};\n\t\t\tfor(var x in ao){\n\t\t\t\ttmpAO[x] = ao[x];\n\t\t\t}\n\t\t\tvar mjps = [];\n\t\t\tdojo.lang.forEach(ao.srcObj, function(src){\n\t\t\t\tif((dojo.render.html.capable)&&(dojo.lang.isString(src))){\n\t\t\t\t\tsrc = dojo.byId(src);\n\t\t\t\t\t\/\/ dojo.debug(src);\n\t\t\t\t}\n\t\t\t\ttmpAO.srcObj = src;\n\t\t\t\t\/\/ dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);\n\t\t\t\t\/\/ dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);\n\t\t\t\tmjps.push(dojo.event.connect.call(dojo.event, tmpAO));\n\t\t\t});\n\t\t\treturn mjps;\n\t\t}\n\t\t\/\/ FIXME: just doing a \"getForMethod()\" seems to be enough to put this into infinite recursion!!\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);\n\t\tif(ao.adviceFunc){\n\t\t\tvar mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);\n\t\t}\n\t\tmjp.kwAddAdvice(ao);\n\t\t\/\/ advanced users might want to fsck w\/ the join point manually\n\t\treturn mjp; \/\/ a MethodJoinPoint object\n\t}\n\tthis.log = function(\/*object or funcName*\/ a1, \/*funcName*\/ a2){\n\t\t\/\/ summary:\n\t\t\/\/\t\ta function that will wrap and log all calls to the specified\n\t\t\/\/\t\ta1.a2() function. If only a1 is passed, it'll be used as a\n\t\t\/\/\t\tfunction or function name on the global context. Logging will\n\t\t\/\/\t\tbe sent to dojo.debug\n\t\t\/\/ a1:\n\t\t\/\/\t\tif a2 is passed, this should be an object. If not, it can be a\n\t\t\/\/\t\tfunction or function name.\n\t\t\/\/ a2:\n\t\t\/\/\t\ta function name\n\t\tvar kwArgs;\n\t\tif((arguments.length == 1)&&(typeof a1 == \"object\")){\n\t\t\tkwArgs = a1;\n\t\t}else{\n\t\t\tkwArgs = {\n\t\t\t\tsrcObj: a1,\n\t\t\t\tsrcFunc: a2\n\t\t\t};\n\t\t}\n\t\tkwArgs.adviceFunc = function(){\n\t\t\tvar argsStr = [];\n\t\t\tfor(var x=0; x<arguments.length; x++){\n\t\t\t\targsStr.push(arguments[x]);\n\t\t\t}\n\t\t\tdojo.debug(\"(\"+kwArgs.srcObj+\").\"+kwArgs.srcFunc, \":\", argsStr.join(\", \"));\n\t\t}\n\t\tthis.kwConnect(kwArgs);\n\t}\n\tthis.connectBefore = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t \ttakes the same parameters as dojo.event.connect(), except that\n\t\t\/\/\t \tthe advice type will always be \"before\"\n\t\tvar args = [\"before\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args); \/\/ a MethodJoinPoint object\n\t}\n\tthis.connectAround = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t \ttakes the same parameters as dojo.event.connect(), except that\n\t\t\/\/\t \tthe advice type will always be \"around\"\n\t\tvar args = [\"around\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args); \/\/ a MethodJoinPoint object\n\t}\n\tthis.connectOnce = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t \ttakes the same parameters as dojo.event.connect(), except that\n\t\t\/\/\t \tthe \"once\" flag will always be set to \"true\"\n\t\tvar ao = interpolateArgs(arguments, true);\n\t\tao.once = true;\n\t\treturn this.connect(ao); \/\/ a MethodJoinPoint object\n\t}\n\tthis._kwConnectImpl = function(kwArgs, disconnect){\n\t\tvar fn = (disconnect) ? \"disconnect\" : \"connect\";\n\t\tif(typeof kwArgs[\"srcFunc\"] == \"function\"){\n\t\t\tkwArgs.srcObj = kwArgs[\"srcObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);\n\t\t\tkwArgs.srcFunc = tmpName;\n\t\t}\n\t\tif(typeof kwArgs[\"adviceFunc\"] == \"function\"){\n\t\t\tkwArgs.adviceObj = kwArgs[\"adviceObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);\n\t\t\tkwArgs.adviceFunc = tmpName;\n\t\t}\n\t\tkwArgs.srcObj = kwArgs[\"srcObj\"]||dj_global;\n\t\tkwArgs.adviceObj = kwArgs[\"adviceObj\"]||kwArgs[\"targetObj\"]||dj_global;\n\t\tkwArgs.adviceFunc = kwArgs[\"adviceFunc\"]||kwArgs[\"targetFunc\"];\n\t\t\/\/ pass kwargs to avoid unrolling\/repacking\n\t\treturn dojo.event[fn](kwArgs);\n\t}\n\tthis.kwConnect = function(\/*Object*\/ kwArgs){\n\t\t\/\/ summary:\n\t\t\/\/\t\tA version of dojo.event.connect() that takes a map of named\n\t\t\/\/\t\tparameters instead of the positional parameters that\n\t\t\/\/\t\tdojo.event.connect() uses. For many advanced connection types,\n\t\t\/\/\t\tthis can be a much more readable (and potentially faster)\n\t\t\/\/\t\talternative.\n\t\t\/\/ kwArgs:\n\t\t\/\/ \t\tAn object that can have the following properties:\n\t\t\/\/\t\t\t- adviceType\n\t\t\/\/\t\t\t- srcObj\n\t\t\/\/\t\t\t- srcFunc\n\t\t\/\/\t\t\t- adviceObj\n\t\t\/\/\t\t\t- adviceFunc \n\t\t\/\/\t\t\t- aroundObj\n\t\t\/\/\t\t\t- aroundFunc\n\t\t\/\/\t\t\t- once\n\t\t\/\/\t\t\t- delay\n\t\t\/\/\t\t\t- rate\n\t\t\/\/\t\t\t- adviceMsg\n\t\t\/\/\t\tAs with connect, only srcFunc and adviceFunc are generally\n\t\t\/\/\t\trequired\n\t\treturn this._kwConnectImpl(kwArgs, false); \/\/ a MethodJoinPoint object\n\t}\n\tthis.disconnect = function(){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTakes the same parameters as dojo.event.connect() but destroys\n\t\t\/\/\t\tan existing connection instead of building a new one. For\n\t\t\/\/\t\tmultiple identical connections, multiple disconnect() calls\n\t\t\/\/\t\twill unroll one each time it's called.\n\t\tif(arguments.length == 1){\n\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(!ao.adviceFunc){ return; } \/\/ nothing to disconnect\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.disconnect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\t\tif(!ao.srcObj[ao.srcFunc]){ return null; } \/\/ prevent un-necessaray joinpoint creation\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc, true);\n\t\tmjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once); \/\/ a MethodJoinPoint object\n\t\treturn mjp;\n\t}\n\tthis.kwDisconnect = function(kwArgs){\n\t\t\/\/ summary:\n\t\t\/\/\t\tTakes the same parameters as dojo.event.kwConnect() but\n\t\t\/\/\t\tdestroys an existing connection instead of building a new one.\n\t\treturn this._kwConnectImpl(kwArgs, true);\n\t}","instance_variables":["_canTimeout","connect","log","connectBefore","connectAround","connectOnce","_kwConnectImpl","kwConnect","disconnect","kwDisconnect"],"returns":"mixed","call_chain":["dojo.event.connect","this.connect"]}},"dojo.event.connect":{"meta":{"summary":"dojo.event.connect is the glue that holds most Dojo-based applications together. Most combinations of arguments are supported, with the connect() method attempting to disambiguate the implied types of positional parameters. The following will all work: dojo.event.connect(\"globalFunctionName1\", \"globalFunctionName2\"); dojo.event.connect(functionReference1, functionReference2); dojo.event.connect(\"globalFunctionName1\", functionReference2); dojo.event.connect(functionReference1, \"globalFunctionName2\"); dojo.event.connect(scope1, \"functionName1\", \"globalFunctionName2\"); dojo.event.connect(\"globalFunctionName1\", scope2, \"functionName2\"); dojo.event.connect(scope1, \"functionName1\", scope2, \"functionName2\"); dojo.event.connect(\"after\", scope1, \"functionName1\", scope2, \"functionName2\"); dojo.event.connect(\"before\", scope1, \"functionName1\", scope2, \"functionName2\"); dojo.event.connect(\"around\", scope1, \"functionName1\", scope2, \"functionName2\", aroundFunctionReference); dojo.event.connect(\"around\", scope1, \"functionName1\", scope2, \"functionName2\", scope3, \"aroundFunctionName\"); dojo.event.connect(\"before-around\", scope1, \"functionName1\", scope2, \"functionName2\", aroundFunctionReference); dojo.event.connect(\"after-around\", scope1, \"functionName1\", scope2, \"functionName2\", aroundFunctionReference); dojo.event.connect(\"after-around\", scope1, \"functionName1\", scope2, \"functionName2\", scope3, \"aroundFunctionName\"); dojo.event.connect(\"around\", scope1, \"functionName1\", scope2, \"functionName2\", scope3, \"aroundFunctionName\", true, 30); dojo.event.connect(\"around\", scope1, \"functionName1\", scope2, \"functionName2\", scope3, \"aroundFunctionName\", null, null, 10); adviceType: Optional. String. One of \"before\", \"after\", \"around\", \"before-around\", or \"after-around\". FIXME srcObj: the scope in which to locate\/execute the named srcFunc. Along with srcFunc, this creates a way to dereference the function to call. So if the function in question is \"foo.bar\", the srcObj\/srcFunc pair would be foo and \"bar\", where \"bar\" is a string and foo is an object reference. srcFunc: the name of the function to connect to. When it is executed, the listener being registered with this call will be called. The adviceType defines the call order between the source and the target functions. adviceObj: the scope in which to locate\/execute the named adviceFunc. adviceFunc: the name of the function being conected to srcObj.srcFunc aroundObj: the scope in which to locate\/execute the named aroundFunc. aroundFunc: the name of, or a reference to, the function that will be used to mediate the advice call. Around advice requires a special unary function that will be passed a \"MethodInvocation\" object. These objects have several important properties, namely: - args a mutable array of arguments to be passed into the wrapped function - proceed a function that \"continues\" the invocation. The result of this function is the return of the wrapped function. You can then manipulate this return before passing it back out (or take further action based on it). once: boolean that determines whether or not this connect() will create a new connection if an identical connect() has already been made. Defaults to \"false\". delay: an optional delay (in ms), as an integer, for dispatch of a listener after the source has been fired. rate: an optional rate throttling parameter (integer, in ms). When specified, this particular connection will not fire more than once in the interval specified by the rate adviceMsg: boolean. Should the listener have all the parameters passed in as a single argument?","src":"\t\t\/*\n\t\t\t\tao.adviceType = args[0];\n\t\t\t\tao.srcObj = args[1];\n\t\t\t\tao.srcFunc = args[2];\n\t\t\t\tao.adviceObj = args[3]\n\t\t\t\tao.adviceFunc = args[4];\n\t\t\t\tao.aroundObj = args[5];\n\t\t\t\tao.aroundFunc = args[6];\n\t\t\t\tao.once = args[7];\n\t\t\t\tao.delay = args[8];\n\t\t\t\tao.rate = args[9];\n\t\t\t\tao.adviceMsg = args[10];\n\t\t*\/\n\t\tif(arguments.length == 1){\n\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.connect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\t\tif(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=\"\"){\n\t\t\tvar tmpAO = {};\n\t\t\tfor(var x in ao){\n\t\t\t\ttmpAO[x] = ao[x];\n\t\t\t}\n\t\t\tvar mjps = [];\n\t\t\tdojo.lang.forEach(ao.srcObj, function(src){\n\t\t\t\tif((dojo.render.html.capable)&&(dojo.lang.isString(src))){\n\t\t\t\t\tsrc = dojo.byId(src);\n\t\t\t\t\t\/\/ dojo.debug(src);\n\t\t\t\t}\n\t\t\t\ttmpAO.srcObj = src;\n\t\t\t\t\/\/ dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);\n\t\t\t\t\/\/ dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);\n\t\t\t\tmjps.push(dojo.event.connect.call(dojo.event, tmpAO));\n\t\t\t});\n\t\t\treturn mjps;\n\t\t}\n\t\t\/\/ FIXME: just doing a \"getForMethod()\" seems to be enough to put this into infinite recursion!!\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);\n\t\tif(ao.adviceFunc){\n\t\t\tvar mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);\n\t\t}\n\t\tmjp.kwAddAdvice(ao);\n\t\t\/\/ advanced users might want to fsck w\/ the join point manually\n\t\treturn mjp; \/\/ a MethodJoinPoint object","returns":"a MethodJoinPoint object","call_chain":["dojo.event.connect"],"instance":"dojo.event"}},"dojo.event.log":{"meta":{"summary":"a function that will wrap and log all calls to the specified","parameters":{"a1":{"type":"object or funcName"},"a2":{"type":"funcName"}},"src":" \tvar kwArgs;\n\t\tif((arguments.length == 1)&&(typeof a1 == \"object\")){\n\t\t\tkwArgs = a1;\n\t\t}else{\n\t\t\tkwArgs = {\n\t\t\t\tsrcObj: a1,\n\t\t\t\tsrcFunc: a2\n\t\t\t};\n\t\t}\n\t\tkwArgs.adviceFunc = function(){\n\t\t\tvar argsStr = [];\n\t\t\tfor(var x=0; x<arguments.length; x++){\n\t\t\t\targsStr.push(arguments[x]);\n\t\t\t}\n\t\t\tdojo.debug(\"(\"+kwArgs.srcObj+\").\"+kwArgs.srcFunc, \":\", argsStr.join(\", \"));\n\t\t}\n\t\tthis.kwConnect(kwArgs);","instance":"dojo.event"},"extra":{"parameters":{"a1":{"type":"if","summary":"a2 is passed, this should be an object. If not, it can be a function or function name."},"a2":{"type":"a","summary":"function name"}}}},"dojo.event.connectBefore":{"meta":{"summary":"takes the same parameters as dojo.event.connect(), except that the advice type will always be \"before\"","src":" \tvar args = [\"before\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args); \/\/ a MethodJoinPoint object","returns":"a MethodJoinPoint object","call_chain":["this.connect"],"instance":"dojo.event"}},"dojo.event.connectAround":{"meta":{"summary":"takes the same parameters as dojo.event.connect(), except that the advice type will always be \"around\"","src":" \tvar args = [\"around\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args); \/\/ a MethodJoinPoint object","returns":"a MethodJoinPoint object","call_chain":["this.connect"],"instance":"dojo.event"}},"dojo.event.connectOnce":{"meta":{"summary":"takes the same parameters as dojo.event.connect(), except that the \"once\" flag will always be set to \"true\"","src":" \tvar ao = interpolateArgs(arguments, true);\n\t\tao.once = true;\n\t\treturn this.connect(ao); \/\/ a MethodJoinPoint object","returns":"a MethodJoinPoint object","instance":"dojo.event"}},"dojo.event._kwConnectImpl":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""},"disconnect":{"type":""}},"src":" \tvar fn = (disconnect) ? \"disconnect\" : \"connect\";\n\t\tif(typeof kwArgs[\"srcFunc\"] == \"function\"){\n\t\t\tkwArgs.srcObj = kwArgs[\"srcObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);\n\t\t\tkwArgs.srcFunc = tmpName;\n\t\t}\n\t\tif(typeof kwArgs[\"adviceFunc\"] == \"function\"){\n\t\t\tkwArgs.adviceObj = kwArgs[\"adviceObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);\n\t\t\tkwArgs.adviceFunc = tmpName;\n\t\t}\n\t\tkwArgs.srcObj = kwArgs[\"srcObj\"]||dj_global;\n\t\tkwArgs.adviceObj = kwArgs[\"adviceObj\"]||kwArgs[\"targetObj\"]||dj_global;\n\t\tkwArgs.adviceFunc = kwArgs[\"adviceFunc\"]||kwArgs[\"targetFunc\"];\n\t\t\/\/ pass kwargs to avoid unrolling\/repacking\n\t\treturn dojo.event[fn](kwArgs);","instance":"dojo.event"}},"dojo.event.kwConnect":{"meta":{"summary":"A version of dojo.event.connect() that takes a map of named parameters instead of the positional parameters that dojo.event.connect() uses. For many advanced connection types, this can be a much more readable (and potentially faster) alternative.","parameters":{"kwArgs":{"type":"Object"}},"src":"\t\treturn this._kwConnectImpl(kwArgs, false); \/\/ a MethodJoinPoint object","returns":"a MethodJoinPoint object","instance":"dojo.event"},"extra":{"parameters":{"kwArgs":{"type":"An","summary":"object that can have the following properties: - adviceType - srcObj - srcFunc - adviceObj - adviceFunc - aroundObj - aroundFunc - once - delay - rate - adviceMsg As with connect, only srcFunc and adviceFunc are generally required"}}}},"dojo.event.disconnect":{"meta":{"summary":"Takes the same parameters as dojo.event.connect() but destroys an existing connection instead of building a new one. For multiple identical connections, multiple disconnect() calls will unroll one each time it's called.","src":" \tif(arguments.length == 1){\n\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(!ao.adviceFunc){ return; } \/\/ nothing to disconnect\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.disconnect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\t\tif(!ao.srcObj[ao.srcFunc]){ return null; } \/\/ prevent un-necessaray joinpoint creation\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc, true);\n\t\tmjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once); \/\/ a MethodJoinPoint object\n\t\treturn mjp;","returns":"mixed","instance":"dojo.event"}},"dojo.event.kwDisconnect":{"meta":{"summary":"Takes the same parameters as dojo.event.kwConnect() but destroys an existing connection instead of building a new one.","parameters":{"kwArgs":{"type":""}},"src":" \treturn this._kwConnectImpl(kwArgs, true);","instance":"dojo.event"}},"dojo.event.MethodInvocation":{"meta":{"summary":"a class the models the call into a function. This is used under the covers for all method invocations on both ends of a connect()-wrapped function dispatch. This allows us to \"pickle\" calls, such as in the case of around advice.","parameters":{"join_point":{"type":"dojo.event.MethodJoinPoint"},"obj":{"type":"Object"},"args":{"type":"Array"}},"src":" this.jp_ = join_point;\n\tthis.object = obj;\n\tthis.args = [];\n\t\/\/ make sure we don't lock into a mutable object which can change under us.\n\t\/\/ It's ok if the individual items change, though.\n\tfor(var x=0; x<args.length; x++){\n\t\tthis.args[x] = args[x];\n\t}\n\t\/\/ the index of the 'around' that is currently being executed.\n\tthis.around_index = -1;","instance_variables":["jp_","object","args","around_index"]},"extra":{"parameters":{"join_point":{"type":"a","summary":"dojo.event.MethodJoinPoint object that represents a connection"},"obj":{"type":"the","summary":"scope the call will execute in"}},"variables":{"args":{"type":"an","summary":"array of parameters that will get passed to the callee"}}}},"dojo.event.MethodInvocation.proceed":{"meta":{"summary":"proceed with the method call that's represented by this invocation object","src":" this.around_index++;\n\tif(this.around_index >= this.jp_.around.length){\n\t\treturn this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);\n\t\t\/\/ return this.jp_.run_before_after(this.object, this.args);\n\t}else{\n\t\tvar ti = this.jp_.around[this.around_index];\n\t\tvar mobj = ti[0]||dj_global;\n\t\tvar meth = ti[1];\n\t\treturn mobj[meth].call(mobj, this);\n\t}","prototype":"dojo.event.MethodInvocation"}},"dojo.event.MethodJoinPoint":{"meta":{"summary":"","parameters":{"obj":{"type":"Object"},"funcName":{"type":"String"}},"src":" this.object = obj||dj_global;\n\tthis.methodname = funcName;\n\tthis.methodfunc = this.object[funcName];\n\tthis.squelch = false;\n\t\/\/ this.before = [];\n\t\/\/ this.after = [];\n\t\/\/ this.around = [];","instance_variables":["object","methodname","methodfunc","squelch","before","after","around"],"prototype_variables":["disconnect"]}},"dojo.event.MethodJoinPoint.getForMethod":{"meta":{"summary":"\"static\" class function for returning a MethodJoinPoint from a scoped function. If one doesn't exist, one is created.","parameters":{"obj":{"type":"Object"},"funcName":{"type":"String"}},"src":" if(!obj){ obj = dj_global; }\n\tif(!obj[funcName]){\n\t\t\/\/ supply a do-nothing method implementation\n\t\tobj[funcName] = function(){};\n\t\tif(!obj[funcName]){\n\t\t\t\/\/ e.g. cannot add to inbuilt objects in IE6\n\t\t\tdojo.raise(\"Cannot set do-nothing method on that object \"+funcName);\n\t\t}\n\t}else if((!dojo.lang.isFunction(obj[funcName]))&&(!dojo.lang.isAlien(obj[funcName]))){\n\t\t\/\/ FIXME: should we throw an exception here instead?\n\t\treturn null; \n\t}\n\t\/\/ we hide our joinpoint instance in obj[funcName + '$joinpoint']\n\tvar jpname = funcName + \"$joinpoint\";\n\tvar jpfuncname = funcName + \"$joinpoint$method\";\n\tvar joinpoint = obj[jpname];\n\tif(!joinpoint){\n\t\tvar isNode = false;\n\t\tif(dojo.event[\"browser\"]){\n\t\t\tif( (obj[\"attachEvent\"])||\n\t\t\t\t(obj[\"nodeType\"])||\n\t\t\t\t(obj[\"addEventListener\"]) ){\n\t\t\t\tisNode = true;\n\t\t\t\tdojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, funcName]);\n\t\t\t}\n\t\t}\n\t\tvar origArity = obj[funcName].length;\n\t\tobj[jpfuncname] = obj[funcName];\n\t\t\/\/ joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, funcName);\n\t\tjoinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);\n\t\tobj[funcName] = function(){ \n\t\t\tvar args = [];\n\t\t\tif((isNode)&&(!arguments.length)){\n\t\t\t\tvar evt = null;\n\t\t\t\ttry{\n\t\t\t\t\tif(obj.ownerDocument){\n\t\t\t\t\t\tevt = obj.ownerDocument.parentWindow.event;\n\t\t\t\t\t}else if(obj.documentElement){\n\t\t\t\t\t\tevt = obj.documentElement.ownerDocument.parentWindow.event;\n\t\t\t\t\t}else if(obj.event){ \/\/obj is a window\n\t\t\t\t\t\tevt = obj.event;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tevt = window.event;\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\tevt = window.event;\n\t\t\t\t}\n\t\t\t\tif(evt){\n\t\t\t\t\targs.push(dojo.event.browser.fixEvent(evt, this));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(var x=0; x<arguments.length; x++){\n\t\t\t\t\tif((x==0)&&(isNode)&&(dojo.event.browser.isEvent(arguments[x]))){\n\t\t\t\t\t\targs.push(dojo.event.browser.fixEvent(arguments[x], this));\n\t\t\t\t\t}else{\n\t\t\t\t\t\targs.push(arguments[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ return joinpoint.run.apply(joinpoint, arguments); \n\t\t\treturn joinpoint.run.apply(joinpoint, args); \n\t\t}\n\t\tobj[funcName].__preJoinArity = origArity;\n\t}\n\treturn joinpoint; \/\/ dojo.event.MethodJoinPoint","returns":"dojo.event.MethodJoinPoint","call_chain":["joinpoint.run"]},"extra":{"parameters":{"obj":{"type":"the","summary":"scope to search for the function in"},"funcName":{"type":"the","summary":"name of the function to return a MethodJoinPoint for"}}}},"dojo.event.MethodJoinPoint.unintercept":{"meta":{"summary":"destroy the connection to all listeners that may have been registered on this joinpoint","src":" \tthis.object[this.methodname] = this.methodfunc;\n\t\tthis.before = [];\n\t\tthis.after = [];\n\t\tthis.around = [];","prototype":"dojo.event.MethodJoinPoint"}},"dojo.event.MethodJoinPoint.run":{"meta":{"summary":"execute the connection represented by this join point. The arguments passed to run() will be passed to the function and its listeners.","src":" \tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event._canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar unRollSquelch = function(){\n\t\t\tif(this.squelch){\n\t\t\t\ttry{\n\t\t\t\t\treturn unrollAdvice.apply(this, arguments);\n\t\t\t\t}catch(e){ \n\t\t\t\t\tdojo.debug(e);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn unrollAdvice.apply(this, arguments);\n\t\t\t}\n\t\t}\n\t\tif((this[\"before\"])&&(this.before.length>0)){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unRollSquelch);\n\t\t}\n\t\tvar result;\n\t\ttry{\n\t\t\tif((this[\"around\"])&&(this.around.length>0)){\n\t\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\t\tresult = mi.proceed();\n\t\t\t}else if(this.methodfunc){\n\t\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t\t}\n\t\t}catch(e){ \n\t\t\tif(!this.squelch){ \n\t\t\t\tdojo.debug(e,\"when calling\",this.methodname,\"on\",this.object,\"with arguments\",args);\n\t\t\t\tdojo.raise(e);\n\t\t\t} \n\t\t}\n\t\tif((this[\"after\"])&&(this.after.length>0)){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unRollSquelch);\n\t\t}\n\t\treturn (this.methodfunc) ? result : null;","call_chain":["unrollAdvice"],"prototype":"dojo.event.MethodJoinPoint"}},"dojo.event.MethodJoinPoint.getArr":{"meta":{"summary":"return a list of listeners of the past \"kind\"","parameters":{"kind":{"type":"String"}},"src":" \tvar type = \"after\";\n\t\t\/\/ FIXME: we should be able to do this through props or Array.in()\n\t\tif((typeof kind == \"string\")&&(kind.indexOf(\"before\")!=-1)){\n\t\t\ttype = \"before\";\n\t\t}else if(kind==\"around\"){\n\t\t\ttype = \"around\";\n\t\t}\n\t\tif(!this[type]){ this[type] = []; }\n\t\treturn this[type]; \/\/ Array","returns":"Array","prototype":"dojo.event.MethodJoinPoint"},"extra":{"parameters":{"kind":{"type":"can","summary":"be one of: \"before\", \"after\", \"around\", \"before-around\", or \"after-around\""}}}},"dojo.event.MethodJoinPoint.kwAddAdvice":{"meta":{"summary":"adds advice to the joinpoint with arguments in a map","parameters":{"args":{"type":"Object"}},"src":" \tthis.addAdvice(\targs[\"adviceObj\"], args[\"adviceFunc\"], \n\t\t\t\t\t\targs[\"aroundObj\"], args[\"aroundFunc\"], \n\t\t\t\t\t\targs[\"adviceType\"], args[\"precedence\"], \n\t\t\t\t\t\targs[\"once\"], args[\"delay\"], args[\"rate\"], \n\t\t\t\t\t\targs[\"adviceMsg\"]);","prototype":"dojo.event.MethodJoinPoint"},"extra":{"parameters":{"args":{"type":"An","summary":"object that can have the following properties: - adviceType - adviceObj - adviceFunc - aroundObj - aroundFunc - once - delay - rate - adviceMsg"}}}},"dojo.event.MethodJoinPoint.addAdvice":{"meta":{"summary":"add advice to this joinpoint using positional parameters","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"thisAroundObj":{"type":""},"thisAround":{"type":""},"adviceType":{"type":""},"precedence":{"type":""},"once":{"type":""},"delay":{"type":""},"rate":{"type":""},"asMessage":{"type":""}},"src":" \tvar arr = this.getArr(adviceType);\n\t\tif(!arr){\n\t\t\tdojo.raise(\"bad this: \" + this);\n\t\t}\n\t\tvar ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage];\n\t\tif(once){\n\t\t\tif(this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr) >= 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif(precedence == \"first\"){\n\t\t\tarr.unshift(ao);\n\t\t}else{\n\t\t\tarr.push(ao);\n\t\t}","prototype":"dojo.event.MethodJoinPoint"},"extra":{"parameters":{"thisAdviceObj":{"type":"the","summary":"scope in which to locate\/execute the named adviceFunc. thisAdviceFunc: the name of the function being conected"},"thisAroundObj":{"type":"the","summary":"scope in which to locate\/execute the named aroundFunc. thisAroundFunc: the name of the function that will be used to mediate the advice call."},"adviceType":{"type":"Optional.","summary":"String. One of \"before\", \"after\", \"around\", \"before-around\", or \"after-around\". FIXME"},"once":{"type":"in","summary":"the interval specified by the rate adviceMsg: boolean. Should the listener have all the parameters passed in as a single argument?"},"delay":{"type":"an","summary":"optional delay (in ms), as an integer, for dispatch of a listener after the source has been fired."},"rate":{"type":"an","summary":"optional rate throttling parameter (integer, in ms). When specified, this particular connection will not fire more than"}}}},"dojo.event.MethodJoinPoint.hasAdvice":{"meta":{"summary":"","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"adviceType":{"type":""},"arr":{"type":""}},"src":" \tif(!arr){ arr = this.getArr(adviceType); }\n\t\tvar ind = -1;\n\t\tfor(var x=0; x<arr.length; x++){\n\t\t\tvar aao = (typeof thisAdvice == \"object\") ? (new String(thisAdvice)).toString() : thisAdvice;\n\t\t\tvar a1o = (typeof arr[x][1] == \"object\") ? (new String(arr[x][1])).toString() : arr[x][1];\n\t\t\tif((arr[x][0] == thisAdviceObj)&&(a1o == aao)){\n\t\t\t\tind = x;\n\t\t\t}\n\t\t}\n\t\treturn ind; \/\/ Integer","returns":"Integer","prototype":"dojo.event.MethodJoinPoint"},"extra":{"returns":"the array index of the first existing connection betweened the passed advice and this joinpoint. Will be -1 if none exists.","parameters":{"thisAdviceObj":{"type":"the","summary":"scope in which to locate\/execute the named adviceFunc. thisAdviceFunc: the name of the function being conected"},"adviceType":{"type":"if","summary":"not passed"},"arr":{"type":"Optional.","summary":"The list of advices to search. Will be found via"}}}},"dojo.event.MethodJoinPoint.removeAdvice":{"meta":{"summary":"","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"adviceType":{"type":""},"once":{"type":""}},"src":" \tvar arr = this.getArr(adviceType);\n\t\tvar ind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);\n\t\tif(ind == -1){\n\t\t\treturn false;\n\t\t}\n\t\twhile(ind != -1){\n\t\t\tarr.splice(ind, 1);\n\t\t\tif(once){ break; }\n\t\t\tind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);\n\t\t}\n\t\treturn true;","prototype":"dojo.event.MethodJoinPoint"},"extra":{"returns":"the array index of the first existing connection betweened the passed advice and this joinpoint. Will be -1 if none exists.","parameters":{"thisAdviceObj":{"type":"the","summary":"scope in which to locate\/execute the named adviceFunc. thisAdviceFunc: the name of the function being conected"},"adviceType":{"type":"Optional.","summary":"String. One of \"before\", \"after\", \"around\", \"before-around\", or \"after-around\". FIXME"},"once":{"type":"Optional.","summary":"Should this only remove the first occurance of the connection?"}}}}}}},"dojo.event.topic":{"meta":{"requires":{"common":["dojo.event.common"]},"functions":{"dojo.event.topic":{"meta":{"initialized":true,"summary":"","src":" this.topics = {};\n\tthis.getTopic = function(\/*String*\/topic){\n\t\t\/\/ summary:\n\t\t\/\/\t\treturns a topic implementation object of type\n\t\t\/\/\t\tdojo.event.topic.TopicImpl\n\t\t\/\/ topic:\n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\tif(!this.topics[topic]){\n\t\t\tthis.topics[topic] = new this.TopicImpl(topic);\n\t\t}\n\t\treturn this.topics[topic]; \/\/ a dojo.event.topic.TopicImpl object\n\t}\n\tthis.registerPublisher = function(\/*String*\/topic, \/*Object*\/obj, \/*String*\/funcName){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregisters a function as a publisher on a topic. Subsequent\n\t\t\/\/\t\tcalls to the function will cause a publish event on the topic\n\t\t\/\/\t\twith the arguments passed to the function passed to registered\n\t\t\/\/\t\tlisteners.\n\t\t\/\/ topic: \n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\t\/\/ obj:\n\t\t\/\/\t\tthe scope to locate the function in\n\t\t\/\/ funcName:\n\t\t\/\/\t\tthe name of the function to register\n\t\tvar topic = this.getTopic(topic);\n\t\ttopic.registerPublisher(obj, funcName);\n\t}\n\tthis.subscribe = function(\/*String*\/topic, \/*Object*\/obj, \/*String*\/funcName){\n\t\t\/\/ summary:\n\t\t\/\/\t\tsusbscribes the function to the topic. Subsequent events\n\t\t\/\/\t\tdispached to the topic will create a function call for the\n\t\t\/\/\t\tobj.funcName() function.\n\t\t\/\/ topic: \n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\t\/\/ obj:\n\t\t\/\/\t\tthe scope to locate the function in\n\t\t\/\/ funcName:\n\t\t\/\/\t\tthe name of the function to being registered as a listener\n\t\tvar topic = this.getTopic(topic);\n\t\ttopic.subscribe(obj, funcName);\n\t}\n\tthis.unsubscribe = function(\/*String*\/topic, \/*Object*\/obj, \/*String*\/funcName){\n\t\t\/\/ summary:\n\t\t\/\/\t\tunsubscribes the obj.funcName() from the topic\n\t\t\/\/ topic: \n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\t\/\/ obj:\n\t\t\/\/\t\tthe scope to locate the function in\n\t\t\/\/ funcName:\n\t\t\/\/\t\tthe name of the function to being unregistered as a listener\n\t\tvar topic = this.getTopic(topic);\n\t\ttopic.unsubscribe(obj, funcName);\n\t}\n\tthis.destroy = function(\/*String*\/topic){\n\t\t\/\/ summary: \n\t\t\/\/\t\tdestroys the topic and unregisters all listeners\n\t\t\/\/ topic:\n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\tthis.getTopic(topic).destroy();\n\t\tdelete this.topics[topic];\n\t}\n\tthis.publishApply = function(\/*String*\/topic, \/*Array*\/args){\n\t\t\/\/ summary: \n\t\t\/\/\t\tdispatches an event to the topic using the args array as the\n\t\t\/\/\t\tsource for the call arguments to each listener. This is similar\n\t\t\/\/\t\tto JavaScript's built-in Function.apply()\n\t\t\/\/ topic:\n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\t\/\/ args:\n\t\t\/\/\t\tthe arguments to be passed into listeners of the topic\n\t\tvar topic = this.getTopic(topic);\n\t\ttopic.sendMessage.apply(topic, args);\n\t}\n\tthis.publish = function(\/*String*\/topic, \/*Object*\/message){\n\t\t\/\/ summary: \n\t\t\/\/\t\tmanually \"publish\" to the passed topic\n\t\t\/\/ topic:\n\t\t\/\/\t\ta unique, opaque string that names the topic\n\t\t\/\/ message:\n\t\t\/\/\t\tcan be an array of parameters (similar to publishApply), or\n\t\t\/\/\t\twill be treated as one of many arguments to be passed along in\n\t\t\/\/\t\ta \"flat\" unrolling\n\t\tvar topic = this.getTopic(topic);\n\t\t\/\/ if message is an array, we treat it as a set of arguments,\n\t\t\/\/ otherwise, we just pass on the arguments passed in as-is\n\t\tvar args = [];\n\t\t\/\/ could we use concat instead here?\n\t\tfor(var x=1; x<arguments.length; x++){\n\t\t\targs.push(arguments[x]);\n\t\t}\n\t\ttopic.sendMessage.apply(topic, args);\n\t}","instance_variables":["topics","getTopic","registerPublisher","subscribe","unsubscribe","destroy","publishApply","publish"],"returns":"a dojo.event.topic.TopicImpl object","call_chain":["topic.sendMessage"]}},"dojo.event.topic.getTopic":{"meta":{"summary":"","parameters":{"topic":{"type":"String"}},"src":" \tif(!this.topics[topic]){\n\t\t\tthis.topics[topic] = new this.TopicImpl(topic);\n\t\t}\n\t\treturn this.topics[topic]; \/\/ a dojo.event.topic.TopicImpl object","returns":"a dojo.event.topic.TopicImpl object","instance":"dojo.event.topic"},"extra":{"returns":"a topic implementation object of type dojo.event.topic.TopicImpl","parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"}}}},"dojo.event.topic.registerPublisher":{"meta":{"summary":"registers a function as a publisher on a topic. Subsequent calls to the function will cause a publish event on the topic with the arguments passed to the function passed to registered listeners.","parameters":{"topic":{"type":"String"},"obj":{"type":"Object"},"funcName":{"type":"String"}},"src":" \tvar topic = this.getTopic(topic);\n\t\ttopic.registerPublisher(obj, funcName);","instance":"dojo.event.topic"},"extra":{"parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"},"obj":{"type":"the","summary":"scope to locate the function in"},"funcName":{"type":"the","summary":"name of the function to register"}}}},"dojo.event.topic.subscribe":{"meta":{"summary":"susbscribes the function to the topic. Subsequent events dispached to the topic will create a function call for the","parameters":{"topic":{"type":"String"},"obj":{"type":"Object"},"funcName":{"type":"String"}},"src":" \tvar topic = this.getTopic(topic);\n\t\ttopic.subscribe(obj, funcName);","instance":"dojo.event.topic"},"extra":{"parameters":{"obj":{"type":"the","summary":"scope to locate the function in"},"topic":{"type":"a","summary":"unique, opaque string that names the topic"},"funcName":{"type":"the","summary":"name of the function to being registered as a listener"}}}},"dojo.event.topic.unsubscribe":{"meta":{"summary":"unsubscribes the obj.funcName() from the topic","parameters":{"topic":{"type":"String"},"obj":{"type":"Object"},"funcName":{"type":"String"}},"src":" \tvar topic = this.getTopic(topic);\n\t\ttopic.unsubscribe(obj, funcName);","instance":"dojo.event.topic"},"extra":{"parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"},"obj":{"type":"the","summary":"scope to locate the function in"},"funcName":{"type":"the","summary":"name of the function to being unregistered as a listener"}}}},"dojo.event.topic.destroy":{"meta":{"summary":"destroys the topic and unregisters all listeners","parameters":{"topic":{"type":"String"}},"src":" \tthis.getTopic(topic).destroy();\n\t\tdelete this.topics[topic];","instance":"dojo.event.topic"},"extra":{"parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"}}}},"dojo.event.topic.publishApply":{"meta":{"summary":"dispatches an event to the topic using the args array as the source for the call arguments to each listener. This is similar to JavaScript's built-in Function.apply()","parameters":{"topic":{"type":"String"},"args":{"type":"Array"}},"src":" \tvar topic = this.getTopic(topic);\n\t\ttopic.sendMessage.apply(topic, args);","call_chain":["topic.sendMessage"],"instance":"dojo.event.topic"},"extra":{"parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"},"args":{"type":"the","summary":"arguments to be passed into listeners of the topic"}}}},"dojo.event.topic.publish":{"meta":{"summary":"manually \"publish\" to the passed topic","parameters":{"topic":{"type":"String"},"message":{"type":"Object"}},"src":" \tvar topic = this.getTopic(topic);\n\t\t\/\/ if message is an array, we treat it as a set of arguments,\n\t\t\/\/ otherwise, we just pass on the arguments passed in as-is\n\t\tvar args = [];\n\t\t\/\/ could we use concat instead here?\n\t\tfor(var x=1; x<arguments.length; x++){\n\t\t\targs.push(arguments[x]);\n\t\t}\n\t\ttopic.sendMessage.apply(topic, args);","call_chain":["topic.sendMessage"],"instance":"dojo.event.topic"},"extra":{"parameters":{"topic":{"type":"a","summary":"unique, opaque string that names the topic"},"message":{"type":"can","summary":"be an array of parameters (similar to publishApply), or will be treated as one of many arguments to be passed along in a \"flat\" unrolling"}}}},"dojo.event.topic.TopicImpl":{"meta":{"summary":"a class to represent topics","parameters":{"topicName":{"type":""}},"src":"\tthis.topicName = topicName;\n\tthis.subscribe = function(\/*Object*\/listenerObject, \/*Function or String*\/listenerMethod){\n\t\t\/\/ summary:\n\t\t\/\/\t\tuse dojo.event.connect() to attach the passed listener to the\n\t\t\/\/\t\ttopic represented by this object\n\t\t\/\/ listenerObject:\n\t\t\/\/\t\tif a string and listenerMethod is ommitted, this is treated as\n\t\t\/\/\t\tthe name of a function in the global namespace. If\n\t\t\/\/\t\tlistenerMethod is provided, this is the scope to find\/execute\n\t\t\/\/\t\tthe function in.\n\t\t\/\/ listenerMethod:\n\t\t\/\/\t\tOptional. The function to register.\n\t\tvar tf = listenerMethod||listenerObject;\n\t\tvar to = (!listenerMethod) ? dj_global : listenerObject;\n\t\treturn dojo.event.kwConnect({ \/\/ dojo.event.MethodJoinPoint\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});\n\t}\n\tthis.unsubscribe = function(\/*Object*\/listenerObject, \/*Function or String*\/listenerMethod){\n\t\t\/\/ summary:\n\t\t\/\/\t\tuse dojo.event.disconnect() to attach the passed listener to the\n\t\t\/\/\t\ttopic represented by this object\n\t\t\/\/ listenerObject:\n\t\t\/\/\t\tif a string and listenerMethod is ommitted, this is treated as\n\t\t\/\/\t\tthe name of a function in the global namespace. If\n\t\t\/\/\t\tlistenerMethod is provided, this is the scope to find the\n\t\t\/\/\t\tfunction in.\n\t\t\/\/ listenerMethod:\n\t\t\/\/\t\tOptional. The function to unregister.\n\t\tvar tf = (!listenerMethod) ? listenerObject : listenerMethod;\n\t\tvar to = (!listenerMethod) ? null : listenerObject;\n\t\treturn dojo.event.kwDisconnect({ \/\/ dojo.event.MethodJoinPoint\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});\n\t}\n\tthis._getJoinPoint = function(){\n\t\treturn dojo.event.MethodJoinPoint.getForMethod(this, \"sendMessage\");\n\t}\n\tthis.setSquelch = function(\/*Boolean*\/shouldSquelch){\n\t\t\/\/ summary: \n\t\t\/\/\t\tdetermine whether or not exceptions in the calling of a\n\t\t\/\/\t\tlistener in the chain should stop execution of the chain.\n\t\tthis._getJoinPoint().squelch = shouldSquelch;\n\t}\n\tthis.destroy = function(){\n\t\t\/\/ summary: disconnects all listeners from this topic\n\t\tthis._getJoinPoint().disconnect();\n\t}\n\tthis.registerPublisher = function(\t\/*Object*\/publisherObject, \n\t\t\t\t\t\t\t\t\t\t\/*Function or String*\/publisherMethod){\n\t\t\/\/ summary:\n\t\t\/\/\t\tregisters the passed function as a publisher on this topic.\n\t\t\/\/\t\tEach time the function is called, an event will be published on\n\t\t\/\/\t\tthis topic.\n\t\t\/\/ publisherObject:\n\t\t\/\/\t\tif a string and listenerMethod is ommitted, this is treated as\n\t\t\/\/\t\tthe name of a function in the global namespace. If\n\t\t\/\/\t\tlistenerMethod is provided, this is the scope to find the\n\t\t\/\/\t\tfunction in.\n\t\t\/\/ publisherMethod:\n\t\t\/\/\t\tOptional. The function to register.\n\t\tdojo.event.connect(publisherObject, publisherMethod, this, \"sendMessage\");\n\t}\n\tthis.sendMessage = function(message){\n\t\t\/\/ summary: a stub to be called when a message is sent to the topic.\n\t\t\/\/ The message has been propagated\n\t}","instance_variables":["topicName","subscribe","unsubscribe","_getJoinPoint","setSquelch","destroy","registerPublisher","sendMessage"],"returns":"dojo.event.MethodJoinPoint"}},"dojo.event.topic.TopicImpl.subscribe":{"meta":{"summary":"use dojo.event.connect() to attach the passed listener to the topic represented by this object","parameters":{"listenerObject":{"type":"Object"},"listenerMethod":{"type":"Function or String"}},"src":" \tvar tf = listenerMethod||listenerObject;\n\t\tvar to = (!listenerMethod) ? dj_global : listenerObject;\n\t\treturn dojo.event.kwConnect({ \/\/ dojo.event.MethodJoinPoint\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});","returns":"dojo.event.MethodJoinPoint","instance":"dojo.event.topic.TopicImpl"},"extra":{"parameters":{"listenerObject":{"type":"if","summary":"a string and listenerMethod is ommitted, this is treated as the name of a function in the global namespace. If"},"listenerMethod":{"type":"Optional.","summary":"The function to register."}}}},"dojo.event.topic.TopicImpl.unsubscribe":{"meta":{"summary":"use dojo.event.disconnect() to attach the passed listener to the topic represented by this object","parameters":{"listenerObject":{"type":"Object"},"listenerMethod":{"type":"Function or String"}},"src":" \tvar tf = (!listenerMethod) ? listenerObject : listenerMethod;\n\t\tvar to = (!listenerMethod) ? null : listenerObject;\n\t\treturn dojo.event.kwDisconnect({ \/\/ dojo.event.MethodJoinPoint\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});","returns":"dojo.event.MethodJoinPoint","instance":"dojo.event.topic.TopicImpl"},"extra":{"parameters":{"listenerObject":{"type":"if","summary":"a string and listenerMethod is ommitted, this is treated as the name of a function in the global namespace. If"},"listenerMethod":{"type":"Optional.","summary":"The function to unregister."}}}},"dojo.event.topic.TopicImpl._getJoinPoint":{"meta":{"summary":"","src":" \treturn dojo.event.MethodJoinPoint.getForMethod(this, \"sendMessage\");","instance":"dojo.event.topic.TopicImpl"}},"dojo.event.topic.TopicImpl.setSquelch":{"meta":{"summary":"determine whether or not exceptions in the calling of a listener in the chain should stop execution of the chain.","parameters":{"shouldSquelch":{"type":"Boolean"}},"src":" \tthis._getJoinPoint().squelch = shouldSquelch;","instance":"dojo.event.topic.TopicImpl"}},"dojo.event.topic.TopicImpl.destroy":{"meta":{"summary":"disconnects all listeners from this topic","src":" \tthis._getJoinPoint().disconnect();","instance":"dojo.event.topic.TopicImpl"}},"dojo.event.topic.TopicImpl.registerPublisher":{"meta":{"summary":"registers the passed function as a publisher on this topic. Each time the function is called, an event will be published on this topic.","parameters":{"publisherObject":{"type":"Object"},"publisherMethod":{"type":"Function or String"}},"src":" \tdojo.event.connect(publisherObject, publisherMethod, this, \"sendMessage\");","instance":"dojo.event.topic.TopicImpl"},"extra":{"parameters":{"publisherObject":{"type":"if","summary":"a string and listenerMethod is ommitted, this is treated as the name of a function in the global namespace. If listenerMethod is provided, this is the scope to find the function in."},"publisherMethod":{"type":"Optional.","summary":"The function to register."}}}},"dojo.event.topic.TopicImpl.sendMessage":{"meta":{"summary":"a stub to be called when a message is sent to the topic.","parameters":{"message":{"type":""}},"src":"\t\t\/\/ The message has been propagated","instance":"dojo.event.topic.TopicImpl"}}}}},"dojo.event":{"meta":{"requires":{"common":["dojo.event.*"]}}}}