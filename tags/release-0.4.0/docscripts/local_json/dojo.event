{"dojo.event._":{"meta":{"requires":{"common":["dojo.event.common","dojo.event.topic"],"browser":["dojo.event.browser"],"dashboard":["dojo.event.browser"]}}},"dojo.event.browser":{"meta":{"requires":{"common":["dojo.event.common"]},"functions":{"dojo._ie_clobber.clobber":{"_":{"meta":{"summary":"","parameters":{"nodeRef":{"type":""}},"src":"\t\tvar na;\n\t\tvar tna;\n\t\tif(nodeRef){\n\t\t\ttna = nodeRef.all || nodeRef.getElementsByTagName(\"*\");\n\t\t\tna = [nodeRef];\n\t\t\tfor(var x=0; x<tna.length; x++){\n\t\t\t\t\/\/ if we're gonna be clobbering the thing, at least make sure\n\t\t\t\t\/\/ we aren't trying to do it twice\n\t\t\t\tif(tna[x][\"__doClobber__\"]){\n\t\t\t\t\tna.push(tna[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\ttry{ window.onload = null; }catch(e){}\n\t\t\tna = (this.clobberNodes.length) ? this.clobberNodes : document.all;\n\t\t}\n\t\ttna = null;\n\t\tvar basis = {};\n\t\tfor(var i = na.length-1; i>=0; i=i-1){\n\t\t\tvar el = na[i];\n\t\t\ttry{\n\t\t\t\tif(el && el[\"__clobberAttrs__\"]){\n\t\t\t\t\tfor(var j=0; j<el.__clobberAttrs__.length; j++){\n\t\t\t\t\t\tnukeProp(el, el.__clobberAttrs__[j]);\n\t\t\t\t\t}\n\t\t\t\t\tnukeProp(el, \"__clobberAttrs__\");\n\t\t\t\t\tnukeProp(el, \"__doClobber__\");\n\t\t\t\t}\n\t\t\t}catch(e){ \/* squelch! *\/};\n\t\t}\n\t\tna = null;"}}},"dojo.event.browser.clean":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\tif(dojo.render.html.ie){ \n\t\t\tdojo._ie_clobber.clobber(node);\n\t\t}"}}},"dojo.event.browser.addClobberNode":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\tif(!dojo.render.html.ie){ return; }\n\t\tif(!node[\"__doClobber__\"]){\n\t\t\tnode.__doClobber__ = true;\n\t\t\tdojo._ie_clobber.clobberNodes.push(node);\n\t\t\t\/\/ this might not be the most efficient thing to do, but it's\n\t\t\t\/\/ much less error prone than other approaches which were\n\t\t\t\/\/ previously tried and failed\n\t\t\tnode.__clobberAttrs__ = [];\n\t\t}"}}},"dojo.event.browser.addClobberNodeAttrs":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"props":{"type":""}},"src":"\t\tif(!dojo.render.html.ie){ return; }\n\t\tthis.addClobberNode(node);\n\t\tfor(var x=0; x<props.length; x++){\n\t\t\tnode.__clobberAttrs__.push(props[x]);\n\t\t}"}}},"dojo.event.browser.removeListener":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"evtName":{"type":""},"fp":{"type":""},"capture":{"type":""}},"src":"\t\tif(!capture){ var capture = false; }\n\t\tevtName = evtName.toLowerCase();\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.removeListener(node, \"onkeydown\", fp, capture);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)==\"on\"){ evtName = evtName.substr(2); }\n\t\t\/\/ FIXME: this is mostly a punt, we aren't actually doing anything on IE\n\t\tif(node.removeEventListener){\n\t\t\tnode.removeEventListener(evtName, fp, capture);\n\t\t}"}}},"dojo.event.browser.addListener":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"evtName":{"type":""},"fp":{"type":""},"capture":{"type":""},"dontFix":{"type":""}},"src":"\t\tif(!node){ return; }                           \n\t\tif(!capture){ var capture = false; }\n\t\tevtName = evtName.toLowerCase();\n\t\tif( (evtName == \"onkey\") || (evtName == \"key\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addListener(node, \"onkeydown\", fp, capture, dontFix);\n\t\t\t}\n\t\t\tevtName = \"onkeypress\";\n\t\t}\n\t\tif(evtName.substr(0,2)!=\"on\"){ evtName = \"on\"+evtName; }\n\n\t\tif(!dontFix){\n\t\t\t\/\/ build yet another closure around fp in order to inject fixEvent\n\t\t\t\/\/ around the resulting event\n\t\t\tvar newfp = function(evt){\n\t\t\t\tif(!evt){ evt = window.event; }\n\t\t\t\tvar ret = fp(dojo.event.browser.fixEvent(evt, this));\n\t\t\t\tif(capture){\n\t\t\t\t\tdojo.event.browser.stopEvent(evt);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}else{\n\t\t\tnewfp = fp;\n\t\t}\n\n\t\tif(node.addEventListener){ \n\t\t\tnode.addEventListener(evtName.substr(2), newfp, capture);\n\t\t\treturn newfp;\n\t\t}else{\n\t\t\tif(typeof node[evtName] == \"function\" ){\n\t\t\t\tvar oldEvt = node[evtName];\n\t\t\t\tnode[evtName] = function(e){\n\t\t\t\t\toldEvt(e);\n\t\t\t\t\treturn newfp(e);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tnode[evtName]=newfp;\n\t\t\t}\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.addClobberNodeAttrs(node, [evtName]);\n\t\t\t}\n\t\t\treturn newfp;\n\t\t}","returns":"FIXME: log and\/or bail?"}}},"dojo.event.browser.isEvent":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""}},"src":"\t\t\/\/ Event does not support instanceof in Opera, otherwise:\n\t\t\/\/return (typeof Event != \"undefined\")&&(obj instanceof Event);"}}},"dojo.event.browser.callListener":{"_":{"meta":{"summary":"","parameters":{"listener":{"type":""},"curTarget":{"type":""}},"src":"\t\tif(typeof listener != 'function'){\n\t\t\tdojo.raise(\"listener not a function: \" + listener);\n\t\t}\n\t\tdojo.event.browser.currentEvent.currentTarget = curTarget;\n\t\treturn listener.call(curTarget, dojo.event.browser.currentEvent);"}}},"dojo.event.browser.stopPropagation":{"_":{"meta":{"summary":"","src":"\t\tdojo.event.browser.currentEvent.cancelBubble = true;"}}},"dojo.event.browser.preventDefault":{"_":{"meta":{"summary":"","src":"\t  dojo.event.browser.currentEvent.returnValue = false;"}}},"dojo.event.browser.fixEvent":{"_":{"meta":{"summary":"","parameters":{"evt":{"type":""},"sender":{"type":""}},"src":"\t\tif(!evt){\n\t\t\tif(window[\"event\"]){\n\t\t\t\tevt = window.event;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif((evt[\"type\"])&&(evt[\"type\"].indexOf(\"key\") == 0)){ \/\/ key events\n\t\t\tevt.keys = this.revKeys;\n\t\t\t\/\/ FIXME: how can we eliminate this iteration?\n\t\t\tfor(var key in this.keys){\n\t\t\t\tevt[key] = this.keys[key];\n\t\t\t}\n\t\t\tif(evt[\"type\"] == \"keydown\" && dojo.render.html.ie){\n\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\tcase evt.KEY_LEFT_WINDOW:\n\t\t\t\t\tcase evt.KEY_RIGHT_WINDOW:\n\t\t\t\t\tcase evt.KEY_SELECT:\n\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\/\/ I'll get these in keypress after the OS munges them based on numlock\n\t\t\t\t\tcase evt.KEY_NUMPAD_0:\n\t\t\t\t\tcase evt.KEY_NUMPAD_1:\n\t\t\t\t\tcase evt.KEY_NUMPAD_2:\n\t\t\t\t\tcase evt.KEY_NUMPAD_3:\n\t\t\t\t\tcase evt.KEY_NUMPAD_4:\n\t\t\t\t\tcase evt.KEY_NUMPAD_5:\n\t\t\t\t\tcase evt.KEY_NUMPAD_6:\n\t\t\t\t\tcase evt.KEY_NUMPAD_7:\n\t\t\t\t\tcase evt.KEY_NUMPAD_8:\n\t\t\t\t\tcase evt.KEY_NUMPAD_9:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PERIOD:\n\t\t\t\t\t\tbreak; \/\/ just ignore the keys that can morph\n\t\t\t\t\tcase evt.KEY_NUMPAD_MULTIPLY:\n\t\t\t\t\tcase evt.KEY_NUMPAD_PLUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_ENTER:\n\t\t\t\t\tcase evt.KEY_NUMPAD_MINUS:\n\t\t\t\t\tcase evt.KEY_NUMPAD_DIVIDE:\n\t\t\t\t\t\tbreak; \/\/ I could handle these but just pick them up in keypress\n\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\tcase evt.KEY_PAGE_UP:\n\t\t\t\t\tcase evt.KEY_PAGE_DOWN:\n\t\t\t\t\tcase evt.KEY_END:\n\t\t\t\t\tcase evt.KEY_HOME:\n\t\t\t\t\tcase evt.KEY_LEFT_ARROW:\n\t\t\t\t\tcase evt.KEY_UP_ARROW:\n\t\t\t\t\tcase evt.KEY_RIGHT_ARROW:\n\t\t\t\t\tcase evt.KEY_DOWN_ARROW:\n\t\t\t\t\tcase evt.KEY_INSERT:\n\t\t\t\t\tcase evt.KEY_DELETE:\n\t\t\t\t\tcase evt.KEY_F1:\n\t\t\t\t\tcase evt.KEY_F2:\n\t\t\t\t\tcase evt.KEY_F3:\n\t\t\t\t\tcase evt.KEY_F4:\n\t\t\t\t\tcase evt.KEY_F5:\n\t\t\t\t\tcase evt.KEY_F6:\n\t\t\t\t\tcase evt.KEY_F7:\n\t\t\t\t\tcase evt.KEY_F8:\n\t\t\t\t\tcase evt.KEY_F9:\n\t\t\t\t\tcase evt.KEY_F10:\n\t\t\t\t\tcase evt.KEY_F11:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F12:\n\t\t\t\t\tcase evt.KEY_F13:\n\t\t\t\t\tcase evt.KEY_F14:\n\t\t\t\t\tcase evt.KEY_F15:\n\t\t\t\t\tcase evt.KEY_CLEAR:\n\t\t\t\t\tcase evt.KEY_HELP:\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tif(evt.ctrlKey || evt.altKey){\n\t\t\t\t\t\t\tvar unifiedCharCode = evt.keyCode;\n\t\t\t\t\t\t\t\/\/ if lower case but keycode is uppercase, convert it\n\t\t\t\t\t\t\tif(unifiedCharCode >= 65 && unifiedCharCode <= 90 && evt.shiftKey == false){\n\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(unifiedCharCode >= 1 && unifiedCharCode <= 26 && evt.ctrlKey){\n\t\t\t\t\t\t\t\tunifiedCharCode += 96; \/\/ 001-032 = ctrl+[a-z]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if(evt[\"type\"] == \"keypress\"){\n\t\t\t\tif(dojo.render.html.opera){\n\t\t\t\t\tif(evt.which == 0){\n\t\t\t\t\t\tevt.key = evt.keyCode;\n\t\t\t\t\t}else if(evt.which > 0){\n\t\t\t\t\t\tswitch(evt.which){\n\t\t\t\t\t\t\tcase evt.KEY_SHIFT:\n\t\t\t\t\t\t\tcase evt.KEY_CTRL:\n\t\t\t\t\t\t\tcase evt.KEY_ALT:\n\t\t\t\t\t\t\tcase evt.KEY_CAPS_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_NUM_LOCK:\n\t\t\t\t\t\t\tcase evt.KEY_SCROLL_LOCK:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase evt.KEY_PAUSE:\n\t\t\t\t\t\t\tcase evt.KEY_TAB:\n\t\t\t\t\t\t\tcase evt.KEY_BACKSPACE:\n\t\t\t\t\t\t\tcase evt.KEY_ENTER:\n\t\t\t\t\t\t\tcase evt.KEY_ESCAPE:\n\t\t\t\t\t\t\t\tevt.key = evt.which;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tvar unifiedCharCode = evt.which;\n\t\t\t\t\t\t\t\tif((evt.ctrlKey || evt.altKey || evt.metaKey) && (evt.which >= 65 && evt.which <= 90 && evt.shiftKey == false)){\n\t\t\t\t\t\t\t\t\tunifiedCharCode += 32;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tevt.key = String.fromCharCode(unifiedCharCode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.ie){ \/\/ catch some IE keys that are hard to get in keyDown\n\t\t\t\t\t\/\/ key combinations were handled in onKeyDown\n\t\t\t\t\tif(!evt.ctrlKey && !evt.altKey && evt.keyCode >= evt.KEY_SPACE){\n\t\t\t\t\t\tevt.key = String.fromCharCode(evt.keyCode);\n\t\t\t\t\t}\n\t\t\t\t}else if(dojo.render.html.safari){\n\t\t\t\t\tswitch(evt.keyCode){\n\t\t\t\t\t\tcase 63232: evt.key = evt.KEY_UP_ARROW; break;\n\t\t\t\t\t\tcase 63233: evt.key = evt.KEY_DOWN_ARROW; break;\n\t\t\t\t\t\tcase 63234: evt.key = evt.KEY_LEFT_ARROW; break;\n\t\t\t\t\t\tcase 63235: evt.key = evt.KEY_RIGHT_ARROW; break;\n\t\t\t\t\t\tdefault: \n\t\t\t\t\t\t\tevt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tevt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dojo.render.html.ie){\n\t\t\tif(!evt.target){ evt.target = evt.srcElement; }\n\t\t\tif(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }\n\t\t\tif(!evt.layerX){ evt.layerX = evt.offsetX; }\n\t\t\tif(!evt.layerY){ evt.layerY = evt.offsetY; }\n\t\t\t\/\/ FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module\n\t\t\t\/\/ DONOT replace the following to use dojo.body(), in IE, document.documentElement should be used\n\t\t\t\/\/ here rather than document.body\n\t\t\tvar doc = (evt.srcElement && evt.srcElement.ownerDocument) ? evt.srcElement.ownerDocument : document;\n\t\t\tvar docBody = ((dojo.render.html.ie55)||(doc[\"compatMode\"] == \"BackCompat\")) ? doc.body : doc.documentElement;\n\t\t\tif(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }\n\t\t\tif(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }\n\t\t\t\/\/ mouseover\n\t\t\tif(evt.type == \"mouseover\"){ evt.relatedTarget = evt.fromElement; }\n\t\t\t\/\/ mouseout\n\t\t\tif(evt.type == \"mouseout\"){ evt.relatedTarget = evt.toElement; }\n\t\t\tthis.currentEvent = evt;\n\t\t\tevt.callListener = this.callListener;\n\t\t\tevt.stopPropagation = this.stopPropagation;\n\t\t\tevt.preventDefault = this.preventDefault;\n\t\t}\n\t\treturn evt;","this_variables":["currentEvent"]}}},"dojo.event.browser.stopEvent":{"_":{"meta":{"summary":"","parameters":{"ev":{"type":""}},"src":"\t\tif(window.event){\n\t\t\tev.returnValue = false;\n\t\t\tev.cancelBubble = true;\n\t\t}else{\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t}"}}}}}},"dojo.event.common":{"meta":{"requires":{"common":["dojo.lang.array","dojo.lang.extras","dojo.lang.func"]},"functions":{"dojo.event.connect":{"_":{"meta":{"summary":" dojo.event.connect is the glue that holds most Dojo-based applications together.","src":"\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.connect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\n\t\tif(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=\"\"){\n\t\t\tvar tmpAO = {};\n\t\t\tfor(var x in ao){\n\t\t\t\ttmpAO[x] = ao[x];\n\t\t\t}\n\t\t\tvar mjps = [];\n\t\t\tdojo.lang.forEach(ao.srcObj, function(src){\n\t\t\t\tif((dojo.render.html.capable)&&(dojo.lang.isString(src))){\n\t\t\t\t\tsrc = dojo.byId(src);\n\t\t\t\t\t\/\/ dojo.debug(src);\n\t\t\t\t}\n\t\t\t\ttmpAO.srcObj = src;\n\t\t\t\t\/\/ dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);\n\t\t\t\t\/\/ dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);\n\t\t\t\tmjps.push(dojo.event.connect.call(dojo.event, tmpAO));\n\t\t\t});\n\t\t\treturn mjps;\n\t\t}\n\n\t\t\/\/ FIXME: just doing a \"getForMethod()\" seems to be enough to put this into infinite recursion!!\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);\n\t\tif(ao.adviceFunc){\n\t\t\tvar mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);\n\t\t}\n\n\t\tmjp.kwAddAdvice(ao);\n\n\t\treturn mjp;\t\/\/ advanced users might want to fsck w\/ the join point\n\t\t\t\t\t\/\/ manually","returns":"advanced users might want to fsck w\/ the join point"}}},"dojo.event.log":{"_":{"meta":{"summary":"","parameters":{"a1":{"type":""},"a2":{"type":""}},"src":"\t\tvar kwArgs;\n\t\tif((arguments.length == 1)&&(typeof a1 == \"object\")){\n\t\t\tkwArgs = a1;\n\t\t}else{\n\t\t\tkwArgs = {\n\t\t\t\tsrcObj: a1,\n\t\t\t\tsrcFunc: a2\n\t\t\t};\n\t\t}\n\t\tkwArgs.adviceFunc = function(){\n\t\t\tvar argsStr = [];\n\t\t\tfor(var x=0; x<arguments.length; x++){\n\t\t\t\targsStr.push(arguments[x]);\n\t\t\t}\n\t\t\tdojo.debug(\"(\"+kwArgs.srcObj+\").\"+kwArgs.srcFunc, \":\", argsStr.join(\", \"));\n\t\t}\n\t\tthis.kwConnect(kwArgs);"}}},"dojo.event.connectBefore":{"_":{"meta":{"summary":"","src":"\t\tvar args = [\"before\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args);"}}},"dojo.event.connectAround":{"_":{"meta":{"summary":"","src":"\t\tvar args = [\"around\"];\n\t\tfor(var i = 0; i < arguments.length; i++){ args.push(arguments[i]); }\n\t\treturn this.connect.apply(this, args);"}}},"dojo.event.connectOnce":{"_":{"meta":{"summary":"","src":"\t\tvar ao = interpolateArgs(arguments, true);\n\t\tao.once = true;\n\t\treturn this.connect(ao);"}}},"dojo.event._kwConnectImpl":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""},"disconnect":{"type":""}},"src":"\t\tvar fn = (disconnect) ? \"disconnect\" : \"connect\";\n\t\tif(typeof kwArgs[\"srcFunc\"] == \"function\"){\n\t\t\tkwArgs.srcObj = kwArgs[\"srcObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);\n\t\t\tkwArgs.srcFunc = tmpName;\n\t\t}\n\t\tif(typeof kwArgs[\"adviceFunc\"] == \"function\"){\n\t\t\tkwArgs.adviceObj = kwArgs[\"adviceObj\"]||dj_global;\n\t\t\tvar tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);\n\t\t\tkwArgs.adviceFunc = tmpName;\n\t\t}\n\t\treturn dojo.event[fn](\t(kwArgs[\"type\"]||kwArgs[\"adviceType\"]||\"after\"),\n\t\t\t\t\t\t\t\t\tkwArgs[\"srcObj\"]||dj_global,\n\t\t\t\t\t\t\t\t\tkwArgs[\"srcFunc\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"adviceObj\"]||kwArgs[\"targetObj\"]||dj_global,\n\t\t\t\t\t\t\t\t\tkwArgs[\"adviceFunc\"]||kwArgs[\"targetFunc\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"aroundObj\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"aroundFunc\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"once\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"delay\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"rate\"],\n\t\t\t\t\t\t\t\t\tkwArgs[\"adviceMsg\"]||false );"}}},"dojo.event.kwConnect":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\treturn this._kwConnectImpl(kwArgs, false);"}}},"dojo.event.disconnect":{"_":{"meta":{"summary":"","src":"\t\tif(arguments.length == 1){\n\t\t\tvar ao = arguments[0];\n\t\t}else{\n\t\t\tvar ao = interpolateArgs(arguments, true);\n\t\t}\n\t\tif(!ao.adviceFunc){ return; } \/\/ nothing to disconnect\n\t\tif(dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == \"onkey\") ){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tao.srcFunc = \"onkeydown\";\n\t\t\t\tthis.disconnect(ao);\n\t\t\t}\n\t\t\tao.srcFunc = \"onkeypress\";\n\t\t}\n\t\tvar mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);\n\t\treturn mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once);","returns":"nothing to disconnect"}}},"dojo.event.kwDisconnect":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\treturn this._kwConnectImpl(kwArgs, true);"}}},"dojo.event.MethodJoinPoint.unintercept":{"_":{"meta":{"summary":"","src":"\t\tthis.object[this.methodname] = this.methodfunc;\n\t\tthis.before = [];\n\t\tthis.after = [];\n\t\tthis.around = [];","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint":{"_":{"meta":{"this_variables":["before","after","around"],"protovariables":{"disconnect":""}}}},"dojo.event.MethodJoinPoint.run":{"_":{"meta":{"summary":"","src":"\t\tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t  \n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\t\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event.canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.before.length>0){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\tvar result;\n\t\tif(this.around.length>0){\n\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\tresult = mi.proceed();\n\t\t}else if(this.methodfunc){\n\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t}\n\n\t\tif(this.after.length>0){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\treturn (this.methodfunc) ? result : null;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.args":{"_":{"meta":{"summary":"","src":"\t\tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t  \n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\t\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event.canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.before.length>0){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\tvar result;\n\t\tif(this.around.length>0){\n\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\tresult = mi.proceed();\n\t\t}else if(this.methodfunc){\n\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t}\n\n\t\tif(this.after.length>0){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\treturn (this.methodfunc) ? result : null;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.jp_":{"_":{"meta":{"summary":"","src":"\t\tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t  \n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\t\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event.canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.before.length>0){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\tvar result;\n\t\tif(this.around.length>0){\n\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\tresult = mi.proceed();\n\t\t}else if(this.methodfunc){\n\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t}\n\n\t\tif(this.after.length>0){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\treturn (this.methodfunc) ? result : null;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.object":{"_":{"meta":{"summary":"","src":"\t\tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t  \n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\t\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event.canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.before.length>0){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\tvar result;\n\t\tif(this.around.length>0){\n\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\tresult = mi.proceed();\n\t\t}else if(this.methodfunc){\n\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t}\n\n\t\tif(this.after.length>0){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\treturn (this.methodfunc) ? result : null;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.proceed":{"_":{"meta":{"summary":"","src":"\t\tvar obj = this.object||dj_global;\n\t\tvar args = arguments;\n\n\t\t\/\/ optimization. We only compute once the array version of the arguments\n\t\t\/\/ pseudo-arr in order to prevent building it each time advice is unrolled.\n\t\tvar aargs = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\taargs[x] = args[x];\n\t\t}\n\n\t\tvar unrollAdvice  = function(marr){ \n\t\t\tif(!marr){\n\t\t\t\tdojo.debug(\"Null argument to unrollAdvice()\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t  \n\t\t\tvar callObj = marr[0]||dj_global;\n\t\t\tvar callFunc = marr[1];\n\t\t\t\n\t\t\tif(!callObj[callFunc]){\n\t\t\t\tdojo.raise(\"function \\\"\" + callFunc + \"\\\" does not exist on \\\"\" + callObj + \"\\\"\");\n\t\t\t}\n\t\t\t\n\t\t\tvar aroundObj = marr[2]||dj_global;\n\t\t\tvar aroundFunc = marr[3];\n\t\t\tvar msg = marr[6];\n\t\t\tvar undef;\n\n\t\t\tvar to = {\n\t\t\t\targs: [],\n\t\t\t\tjp_: this,\n\t\t\t\tobject: obj,\n\t\t\t\tproceed: function(){\n\t\t\t\t\treturn callObj[callFunc].apply(callObj, to.args);\n\t\t\t\t}\n\t\t\t};\n\t\t\tto.args = aargs;\n\n\t\t\tvar delay = parseInt(marr[4]);\n\t\t\tvar hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != \"undefined\"));\n\t\t\tif(marr[5]){\n\t\t\t\tvar rate = parseInt(marr[5]);\n\t\t\t\tvar cur = new Date();\n\t\t\t\tvar timerSet = false;\n\t\t\t\tif((marr[\"last\"])&&((cur-marr.last)<=rate)){\n\t\t\t\t\tif(dojo.event.canTimeout){\n\t\t\t\t\t\tif(marr[\"delayTimer\"]){\n\t\t\t\t\t\t\tclearTimeout(marr.delayTimer);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar tod = parseInt(rate*2); \/\/ is rate*2 naive?\n\t\t\t\t\t\tvar mcpy = dojo.lang.shallowCopy(marr);\n\t\t\t\t\t\tmarr.delayTimer = setTimeout(function(){\n\t\t\t\t\t\t\t\/\/ FIXME: on IE at least, event objects from the\n\t\t\t\t\t\t\t\/\/ browser can go out of scope. How (or should?) we\n\t\t\t\t\t\t\t\/\/ deal with it?\n\t\t\t\t\t\t\tmcpy[5] = 0;\n\t\t\t\t\t\t\tunrollAdvice(mcpy);\n\t\t\t\t\t\t}, tod);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}else{\n\t\t\t\t\tmarr.last = cur;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\/\/ FIXME: need to enforce rates for a connection here!\n\n\t\t\tif(aroundFunc){\n\t\t\t\t\/\/ NOTE: around advice can't delay since we might otherwise depend\n\t\t\t\t\/\/ on execution order!\n\t\t\t\taroundObj[aroundFunc].call(aroundObj, to);\n\t\t\t}else{\n\t\t\t\t\/\/ var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);\n\t\t\t\tif((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  \/\/ FIXME: the render checks are grotty!\n\t\t\t\t\tdj_global[\"setTimeout\"](function(){\n\t\t\t\t\t\tif(msg){\n\t\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t\t}\n\t\t\t\t\t}, delay);\n\t\t\t\t}else{ \/\/ many environments can't support delay!\n\t\t\t\t\tif(msg){\n\t\t\t\t\t\tcallObj[callFunc].call(callObj, to); \n\t\t\t\t\t}else{\n\t\t\t\t\t\tcallObj[callFunc].apply(callObj, args); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(this.before.length>0){\n\t\t\t\/\/ pass a cloned array, if this event disconnects this event forEach on this.before wont work\n\t\t\tdojo.lang.forEach(this.before.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\tvar result;\n\t\tif(this.around.length>0){\n\t\t\tvar mi = new dojo.event.MethodInvocation(this, obj, args);\n\t\t\tresult = mi.proceed();\n\t\t}else if(this.methodfunc){\n\t\t\tresult = this.object[this.methodname].apply(this.object, args);\n\t\t}\n\n\t\tif(this.after.length>0){\n\t\t\t\/\/ see comment on this.before above\n\t\t\tdojo.lang.forEach(this.after.concat(new Array()), unrollAdvice);\n\t\t}\n\n\t\treturn (this.methodfunc) ? result : null;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.getArr":{"_":{"meta":{"summary":"","parameters":{"kind":{"type":""}},"src":"\t\tvar arr = this.after;\n\t\t\/\/ FIXME: we should be able to do this through props or Array.in()\n\t\tif((typeof kind == \"string\")&&(kind.indexOf(\"before\")!=-1)){\n\t\t\tarr = this.before;\n\t\t}else if(kind==\"around\"){\n\t\t\tarr = this.around;\n\t\t}\n\t\treturn arr;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.kwAddAdvice":{"_":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":"\t\tthis.addAdvice(\targs[\"adviceObj\"], args[\"adviceFunc\"], \n\t\t\t\t\t\targs[\"aroundObj\"], args[\"aroundFunc\"], \n\t\t\t\t\t\targs[\"adviceType\"], args[\"precedence\"], \n\t\t\t\t\t\targs[\"once\"], args[\"delay\"], args[\"rate\"], \n\t\t\t\t\t\targs[\"adviceMsg\"]);","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.addAdvice":{"_":{"meta":{"summary":"","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"thisAroundObj":{"type":""},"thisAround":{"type":""},"advice_kind":{"type":""},"precedence":{"type":""},"once":{"type":""},"delay":{"type":""},"rate":{"type":""},"asMessage":{"type":""}},"src":"\t\tvar arr = this.getArr(advice_kind);\n\t\tif(!arr){\n\t\t\tdojo.raise(\"bad this: \" + this);\n\t\t}\n\n\t\tvar ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage];\n\t\t\n\t\tif(once){\n\t\t\tif(this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr) >= 0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif(precedence == \"first\"){\n\t\t\tarr.unshift(ao);\n\t\t}else{\n\t\t\tarr.push(ao);\n\t\t}","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.hasAdvice":{"_":{"meta":{"summary":"","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"advice_kind":{"type":""},"arr":{"type":""}},"src":"\t\tif(!arr){ arr = this.getArr(advice_kind); }\n\t\tvar ind = -1;\n\t\tfor(var x=0; x<arr.length; x++){\n\t\t\tvar aao = (typeof thisAdvice == \"object\") ? (new String(thisAdvice)).toString() : thisAdvice;\n\t\t\tvar a1o = (typeof arr[x][1] == \"object\") ? (new String(arr[x][1])).toString() : arr[x][1];\n\t\t\tif((arr[x][0] == thisAdviceObj)&&(a1o == aao)){\n\t\t\t\tind = x;\n\t\t\t}\n\t\t}\n\t\treturn ind;","this":"dojo.event.MethodJoinPoint"}}},"dojo.event.MethodJoinPoint.removeAdvice":{"_":{"meta":{"summary":"","parameters":{"thisAdviceObj":{"type":""},"thisAdvice":{"type":""},"advice_kind":{"type":""},"once":{"type":""}},"src":"\t\tvar arr = this.getArr(advice_kind);\n\t\tvar ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);\n\t\tif(ind == -1){\n\t\t\treturn false;\n\t\t}\n\t\twhile(ind != -1){\n\t\t\tarr.splice(ind, 1);\n\t\t\tif(once){ break; }\n\t\t\tind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);\n\t\t}\n\t\treturn true;","this":"dojo.event.MethodJoinPoint"}}}}}},"dojo.event.topic":{"meta":{"requires":{"common":["dojo.event.common"]},"functions":{"dojo.event.topic.getTopic":{"_":{"meta":{"summary":"","parameters":{"topicName":{"type":""}},"src":"\t\tif(!this.topics[topicName]){\n\t\t\tthis.topics[topicName] = new this.TopicImpl(topicName);\n\t\t}\n\t\treturn this.topics[topicName];"}}},"dojo.event.topic.registerPublisher":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"obj":{"type":""},"funcName":{"type":""}},"src":"\t\tvar topic = this.getTopic(topic);\n\t\ttopic.registerPublisher(obj, funcName);"}}},"dojo.event.topic.subscribe":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"obj":{"type":""},"funcName":{"type":""}},"src":"\t\tvar topic = this.getTopic(topic);\n\t\ttopic.subscribe(obj, funcName);"}}},"dojo.event.topic.unsubscribe":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"obj":{"type":""},"funcName":{"type":""}},"src":"\t\tvar topic = this.getTopic(topic);\n\t\ttopic.unsubscribe(obj, funcName);"}}},"dojo.event.topic.destroy":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""}},"src":"\t\tthis.getTopic(topic).destroy();\n\t\tdelete this.topics[topic];"}}},"dojo.event.topic.publishApply":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"args":{"type":""}},"src":"\t\tvar topic = this.getTopic(topic);\n\t\ttopic.sendMessage.apply(topic, args);"}}},"dojo.event.topic.publish":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"message":{"type":""}},"src":"\t\tvar topic = this.getTopic(topic);\n\t\t\/\/ if message is an array, we treat it as a set of arguments,\n\t\t\/\/ otherwise, we just pass on the arguments passed in as-is\n\t\tvar args = [];\n\t\t\/\/ could we use concat instead here?\n\t\tfor(var x=1; x<arguments.length; x++){\n\t\t\targs.push(arguments[x]);\n\t\t}\n\t\ttopic.sendMessage.apply(topic, args);"}}},"dojo.event.topic.TopicImpl.subscribe":{"_":{"meta":{"summary":"","parameters":{"listenerObject":{"type":""},"listenerMethod":{"type":""}},"src":"\t\tvar tf = listenerMethod||listenerObject;\n\t\tvar to = (!listenerMethod) ? dj_global : listenerObject;\n\t\tdojo.event.kwConnect({\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});"}}},"dojo.event.topic.TopicImpl.unsubscribe":{"_":{"meta":{"summary":"","parameters":{"listenerObject":{"type":""},"listenerMethod":{"type":""}},"src":"\t\tvar tf = (!listenerMethod) ? listenerObject : listenerMethod;\n\t\tvar to = (!listenerMethod) ? null : listenerObject;\n\t\tdojo.event.kwDisconnect({\n\t\t\tsrcObj:\t\tthis, \n\t\t\tsrcFunc:\t\"sendMessage\", \n\t\t\tadviceObj:\tto,\n\t\t\tadviceFunc: tf\n\t\t});"}}},"dojo.event.topic.TopicImpl.destroy":{"_":{"meta":{"summary":"","src":"\t\tdojo.event.MethodJoinPoint.getForMethod(this, \"sendMessage\").disconnect();"}}},"dojo.event.topic.TopicImpl.registerPublisher":{"_":{"meta":{"summary":"","parameters":{"publisherObject":{"type":""},"publisherMethod":{"type":""}},"src":"\t\tdojo.event.connect(publisherObject, publisherMethod, this, \"sendMessage\");"}}},"dojo.event.topic.TopicImpl.sendMessage":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""}},"src":"\t\t\/\/ The message has been propagated"}}}}}},"dojo.event":{"meta":{"requires":{"common":["dojo.event.*"]}}}}