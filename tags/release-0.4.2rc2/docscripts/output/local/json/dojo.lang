{"dojo.lang._":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.assert","dojo.lang.array","dojo.lang.type","dojo.lang.func","dojo.lang.extras","dojo.lang.repr","dojo.lang.declare"]}}},"dojo.lang.array":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.has":{"meta":{"summary":"is there a property with the passed name in obj?","parameters":{"obj":{"type":"Object"},"name":{"type":"String"}},"src":" \ttry{\n\t\t\treturn typeof obj[name] != \"undefined\"; \/\/ Boolean\n\t\t}catch(e){ return false; } \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isEmpty":{"meta":{"summary":"can be used to determine if the passed object is \"empty\". In the case of array-like objects, the length, property is examined, but for other types of objects iteration is used to examine the iterable \"surface area\" to determine if any non-prototypal properties have been assigned. This iteration is prototype-extension safe.","parameters":{"obj":{"type":"Object"}},"src":" \tif(dojo.lang.isObject(obj)){\n\t\t\tvar tmp = {};\n\t\t\tvar count = 0;\n\t\t\tfor(var x in obj){\n\t\t\t\tif(obj[x] && (!tmp[x])){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn count == 0; \/\/ boolean\n\t\t}else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)){\n\t\t\treturn obj.length == 0; \/\/ boolean\n\t\t}","returns":"boolean"}},"dojo.lang.map":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"obj":{"type":"Object|Function"},"unary_func":{"type":"Function?"}},"src":" \tvar isString = dojo.lang.isString(arr);\n\t\tif(isString){\n\t\t\t\/\/ arr: String\n\t\t\tarr = arr.split(\"\");\n\t\t}\n\t\tif(dojo.lang.isFunction(obj)&&(!unary_func)){\n\t\t\tunary_func = obj;\n\t\t\tobj = dj_global;\n\t\t}else if(dojo.lang.isFunction(obj) && unary_func){\n\t\t\t\/\/ ff 1.5 compat\n\t\t\tvar tmpObj = obj;\n\t\t\tobj = unary_func;\n\t\t\tunary_func = tmpObj;\n\t\t}\n\t\tif(Array.map){\n\t\t\tvar outArr = Array.map(arr, unary_func, obj);\n\t\t}else{\n\t\t\tvar outArr = [];\n\t\t\tfor(var i=0;i<arr.length;++i){\n\t\t\t\toutArr.push(unary_func.call(obj, arr[i]));\n\t\t\t}\n\t\t}\n\t\tif(isString) {\n\t\t\treturn outArr.join(\"\"); \/\/ String\n\t\t} else {\n\t\t\treturn outArr; \/\/ Array\n\t\t}","returns":"mixed","call_chain":["unary_func"]},"extra":{"returns":"a new array constituded from the return values of passing each element of arr into unary_func. The obj parameter may be passed to enable the passed function to be called in that scope. In environments that support JavaScript 1.6, this function is a passthrough to the built-in map() function provided by Array instances. For details on this, see: http: \/\/ developer.mozilla.org\/en\/docs\/Core_JavaScript_1.5_Reference:Global_Objects:Array:map examples: dojo.lang.map([1, 2, 3, 4], function(item){ return item+1 }); \/\/ returns [2, 3, 4, 5]"}},"dojo.lang.reduce":{"meta":{"summary":"similar to Python's builtin reduce() function. The result of the previous computation is passed as the first argument to","parameters":{"arr":{"type":"Array"},"initialValue":{"type":""},"obj":{"type":"Object|Function"},"binary_func":{"type":"Function"}},"src":" \tvar reducedValue = initialValue;\n\t\tif(arguments.length == 1){\n\t\t\tdojo.debug(\"dojo.lang.reduce called with too few arguments!\");\n\t\t\treturn false;\n\t\t}else if(arguments.length == 2){\n\t\t\tbinary_func = initialValue;\n\t\t\treducedValue = arr.shift();\n\t\t}else if(arguments.lenght == 3){\n\t\t\tif(dojo.lang.isFunction(obj)){\n\t\t\t\tbinary_func = obj;\n\t\t\t\tobj = null;\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/ un-fsck the default order\n\t\t\t\/\/ FIXME:\n\t\t\t\/\/\t\tcould be wrong for some strange function object cases. Not\n\t\t\t\/\/\t\tsure how to test for them.\n\t\t\tif(dojo.lang.isFunction(obj)){\n\t\t\t\tvar tmp = binary_func;\n\t\t\t\tbinary_func = obj;\n\t\t\t\tobj = tmp;\n\t\t\t}\n\t\t}\n\t\tvar ob = obj ? obj : dj_global;\n\t\tdojo.lang.map(arr, \n\t\t\tfunction(val){\n\t\t\t\treducedValue = binary_func.call(ob, reducedValue, val);\n\t\t\t}\n\t\t);\n\t\treturn reducedValue;","call_chain":["binary_func"]},"extra":{"parameters":{"binary_func":{"type":"along","summary":"with the next value from arr. The result of this call is used along with the subsequent value from arr, and this continues until arr is exhausted. The return value is the last result. The \"obj\" and \"initialValue\" parameters may be safely omitted and the order of obj and binary_func may be reversed. The default order of the obj and binary_func argument will probably be reversed in a future release, and this call order is supported today. examples: dojo.lang.reduce([1, 2, 3, 4], function(last, next){ return last+next});"}},"returns":"10"}},"dojo.lang.forEach":{"meta":{"summary":"for every item in anArray, call callback with that item as its only parameter. Return values are ignored. This funciton corresponds (and wraps) the JavaScript 1.6 forEach method. For more details, see: http: \/\/ developer.mozilla.org\/en\/docs\/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach","parameters":{"anArray":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tif(dojo.lang.isString(anArray)){\n\t\t\t\/\/ anArray: String\n\t\t\tanArray = anArray.split(\"\"); \n\t\t}\n\t\tif(Array.forEach){\n\t\t\tArray.forEach(anArray, callback, thisObject);\n\t\t}else{\n\t\t\t\/\/ FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?\n\t\t\tif(!thisObject){\n\t\t\t\tthisObject=dj_global;\n\t\t\t}\n\t\t\tfor(var i=0,l=anArray.length; i<l; i++){ \n\t\t\t\tcallback.call(thisObject, anArray[i], i, anArray);\n\t\t\t}\n\t\t}","call_chain":["callback"]}},"dojo.lang._everyOrSome":{"meta":{"summary":"","parameters":{"every":{"type":"Boolean"},"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tif(dojo.lang.isString(arr)){ \n\t\t\t\/\/arr: String\n\t\t\tarr = arr.split(\"\"); \n\t\t}\n\t\tif(Array.every){\n\t\t\treturn Array[ every ? \"every\" : \"some\" ](arr, callback, thisObject);\n\t\t}else{\n\t\t\tif(!thisObject){\n\t\t\t\tthisObject = dj_global;\n\t\t\t}\n\t\t\tfor(var i=0,l=arr.length; i<l; i++){\n\t\t\t\tvar result = callback.call(thisObject, arr[i], i, arr);\n\t\t\t\tif(every && !result){\n\t\t\t\t\treturn false; \/\/ Boolean\n\t\t\t\t}else if((!every)&&(result)){\n\t\t\t\t\treturn true; \/\/ Boolean\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Boolean(every); \/\/ Boolean\n\t\t}","returns":"Boolean","call_chain":["callback"]}},"dojo.lang.every":{"meta":{"summary":"determines whether or not every item in the array satisfies the condition implemented by callback. thisObject may be used to scope the call to callback. The function signature is derived from the JavaScript 1.6 Array.every() function. More information on this can be found here: http: \/\/ developer.mozilla.org\/en\/docs\/Core_JavaScript_1.5_Reference:Global_Objects:Array:every examples: dojo.lang.every([1, 2, 3, 4], function(item){ return item>1; }); \/\/ returns false dojo.lang.every([1, 2, 3, 4], function(item){ return item>0; }); \/\/ returns true","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \treturn this._everyOrSome(true, arr, callback, thisObject); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.some":{"meta":{"summary":"determines whether or not any item in the array satisfies the condition implemented by callback. thisObject may be used to scope the call to callback. The function signature is derived from the JavaScript 1.6 Array.some() function. More information on this can be found here: http: \/\/ developer.mozilla.org\/en\/docs\/Core_JavaScript_1.5_Reference:Global_Objects:Array:some examples: dojo.lang.some([1, 2, 3, 4], function(item){ return item>1; }); \/\/ returns true dojo.lang.some([1, 2, 3, 4], function(item){ return item<1; }); \/\/ returns false","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \treturn this._everyOrSome(false, arr, callback, thisObject); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.filter":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tvar isString = dojo.lang.isString(arr);\n\t\tif(isString){ \/*arr: String*\/arr = arr.split(\"\"); }\n\t\tvar outArr;\n\t\tif(Array.filter){\n\t\t\toutArr = Array.filter(arr, callback, thisObject);\n\t\t}else{\n\t\t\tif(!thisObject){\n\t\t\t\tif(arguments.length >= 3){ dojo.raise(\"thisObject doesn't exist!\"); }\n\t\t\t\tthisObject = dj_global;\n\t\t\t}\n\t\t\toutArr = [];\n\t\t\tfor(var i = 0; i < arr.length; i++){\n\t\t\t\tif(callback.call(thisObject, arr[i], i, arr)){\n\t\t\t\t\toutArr.push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isString){\n\t\t\treturn outArr.join(\"\"); \/\/ String\n\t\t} else {\n\t\t\treturn outArr; \/\/ Array\n\t\t}","returns":"mixed","call_chain":["callback"]},"extra":{"returns":"a new Array with those items from arr that match the condition implemented by callback.thisObject may be used to scope the call to callback. The function signature is derived from the JavaScript 1.6 Array.filter() function, although special accomidation is made in our implementation for strings. More information on the JS 1.6 API can be found here: http: \/\/ developer.mozilla.org\/en\/docs\/Core_JavaScript_1.5_Reference:Global_Objects:Array:filter examples: dojo.lang.some([1, 2, 3, 4], function(item){ return item>1; }); \/\/ returns [2, 3, 4]"}},"dojo.lang.unnest":{"meta":{"summary":"Creates a 1-D array out of all the arguments passed, unravelling any array-like objects in the process usage: unnest(1, 2, 3) ==> [1, 2, 3] unnest(1, [2, [3], [[[4]]]]) ==> [1, 2, 3, 4]","src":"\t\tvar out = [];\n\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\tif(dojo.lang.isArrayLike(arguments[i])){\n\t\t\t\tvar add = dojo.lang.unnest.apply(this, arguments[i]);\n\t\t\t\tout = out.concat(add);\n\t\t\t}else{\n\t\t\t\tout.push(arguments[i]);\n\t\t\t}\n\t\t}\n\t\treturn out; \/\/ Array","returns":"Array","call_chain":["dojo.lang.unnest"]}},"dojo.lang.toArray":{"meta":{"summary":"Converts an array-like object (i.e. arguments, DOMCollection) to an array. Returns a new Array object.","parameters":{"arrayLike":{"type":"Object"},"startOffset":{"type":"Number"}},"src":" \tvar array = [];\n\t\tfor(var i = startOffset||0; i < arrayLike.length; i++){\n\t\t\tarray.push(arrayLike[i]);\n\t\t}\n\t\treturn array; \/\/ Array","returns":"Array"}}}}},"dojo.lang.assert":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.array","dojo.lang.type"]},"functions":{"dojo.lang.assert":{"meta":{"summary":"","parameters":{"booleanValue":{"type":"boolean"},"message":{"type":"string?"}},"src":"\t \/\/ throws: Throws an Error if 'booleanValue' is false.\n\t if(!booleanValue){\n\t\tvar errorMessage = \"An assert statement failed.\\n\" +\n\t\t\t\"The method dojo.lang.assert() was called with a 'false' value.\\n\";\n\t\tif(message){\n\t\t\terrorMessage += \"Here's the assert message:\\n\" + message + \"\\n\";\n\t\t}\n\t\t\/\/ Use throw instead of dojo.raise, until bug #264 is fixed:\n\t\t\/\/ dojo.raise(errorMessage);\n\t\tthrow new Error(errorMessage);\n\t}"}},"dojo.lang.assertType":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"},"type":{"type":"misc."},"keywordParameters":{"type":"object?"}},"src":" if (dojo.lang.isString(keywordParameters)) {\n\t\tdojo.deprecated('dojo.lang.assertType(value, type, \"message\")', 'use dojo.lang.assertType(value, type) instead', \"0.5\");\n\t}\n\tif(!dojo.lang.isOfType(value, type, keywordParameters)){\n\t\tif(!dojo.lang.assertType._errorMessage){\n\t\t\tdojo.lang.assertType._errorMessage = \"Type mismatch: dojo.lang.assertType() failed.\";\n\t\t}\n\t\tdojo.lang.assert(false, dojo.lang.assertType._errorMessage);\n\t}"}},"dojo.lang.assertValidKeywords":{"meta":{"summary":"examples:","parameters":{"object":{"type":"object"},"expectedProperties":{"type":"array"},"message":{"type":"string?"}},"src":" var key;\n\tif(!message){\n\t\tif(!dojo.lang.assertValidKeywords._errorMessage){\n\t\t\tdojo.lang.assertValidKeywords._errorMessage = \"In dojo.lang.assertValidKeywords(), found invalid keyword:\";\n\t\t}\n\t\tmessage = dojo.lang.assertValidKeywords._errorMessage;\n\t}\n\tif(dojo.lang.isArray(expectedProperties)){\n\t\tfor(key in object){\n\t\t\tif(!dojo.lang.inArray(expectedProperties, key)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(key in object){\n\t\t\tif(!(key in expectedProperties)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}"}}}}},"dojo.lang.common":{"meta":{"functions":{"dojo.lang.inherits":{"meta":{"summary":"Set up inheritance between two classes.","parameters":{"subclass":{"type":"Function"},"superclass":{"type":"Function"}},"src":" if(!dojo.lang.isFunction(superclass)){ \n\t\tdojo.raise(\"dojo.inherits: superclass argument [\"+superclass+\"] must be a function (subclass: [\"+subclass+\"']\");\n\t}\n\tsubclass.prototype = new superclass();\n\tsubclass.prototype.constructor = subclass;\n\tsubclass.superclass = superclass.prototype;\n\t\/\/ DEPRECATED: super is a reserved word, use 'superclass'\n\tsubclass['super'] = superclass.prototype;"}},"dojo.lang._mixin":{"meta":{"summary":"Adds all properties and methods of props to obj. This addition is \"prototype extension safe\", so that instances of objects will not pass along prototype defaults.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object"}},"src":" var tobj = {};\n\tfor(var x in props){\n\t\t\/\/ the \"tobj\" condition avoid copying properties in \"props\"\n\t\t\/\/ inherited from Object.prototype.  For example, if obj has a custom\n\t\t\/\/ toString() method, don't overwrite it with the toString() method\n\t\t\/\/ that props inherited from Object.protoype\n\t\tif((typeof tobj[x] == \"undefined\") || (tobj[x] != props[x])){\n\t\t\tobj[x] = props[x];\n\t\t}\n\t}\n\t\/\/ IE doesn't recognize custom toStrings in for..in\n\tif(dojo.render.html.ie \n\t\t&& (typeof(props[\"toString\"]) == \"function\")\n\t\t&& (props[\"toString\"] != obj[\"toString\"])\n\t\t&& (props[\"toString\"] != tobj[\"toString\"]))\n\t{\n\t\tobj.toString = props.toString;\n\t}\n\treturn obj; \/\/ Object","returns":"Object"}},"dojo.lang.mixin":{"meta":{"summary":"Adds all properties and methods of props to obj.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object..."}},"src":" for(var i=1, l=arguments.length; i<l; i++){\n\t\tdojo.lang._mixin(obj, arguments[i]);\n\t}\n\treturn obj; \/\/ Object","returns":"Object"}},"dojo.lang.extend":{"meta":{"summary":"Adds all properties and methods of props to constructor's prototype, making them available to all instances created with","parameters":{"constructor":{"type":"Object"},"props":{"type":"Object..."}},"src":" for(var i=1, l=arguments.length; i<l; i++){\n\t\tdojo.lang._mixin(constructor.prototype, arguments[i]);\n\t}\n\treturn constructor; \/\/ Object","returns":"Object"}},"dojo.lang.find":{"meta":{"summary":"Return the index of value in array, returning -1 if not found.","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"Boolean?"},"findLast":{"type":"Boolean?"}},"src":" if(!dojo.lang.isArrayLike(array) && dojo.lang.isArrayLike(value)) {\n\t\tdojo.deprecated('dojo.lang.find(value, array)', 'use dojo.lang.find(array, value) instead', \"0.5\");\n\t\tvar temp = array;\n\t\tarray = value;\n\t\tvalue = temp;\n\t}\n\tvar isString = dojo.lang.isString(array);\n\tif(isString) { array = array.split(\"\"); }\n\tif(findLast) {\n\t\tvar step = -1;\n\t\tvar i = array.length - 1;\n\t\tvar end = -1;\n\t} else {\n\t\tvar step = 1;\n\t\tvar i = 0;\n\t\tvar end = array.length;\n\t}\n\tif(identity){\n\t\twhile(i != end) {\n\t\t\tif(array[i] === value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}else{\n\t\twhile(i != end) {\n\t\t\tif(array[i] == value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}\n\treturn -1;\t\/\/ number","returns":"number"},"extra":{"parameters":{"array":{"type":"just","summary":"what you think"},"value":{"type":"the","summary":"value to locate"},"identity":{"type":"If","summary":"true, matches with identity comparison (===). If false, uses normal comparison (==)."},"findLast":{"type":"If","summary":"true, returns index of last instance of value. examples: find(array, value[, identity [findLast]]) \/\/ recommended find(value, array[, identity [findLast]]) \/\/ deprecated support both (array, value) and (value, array)"}}}},"dojo.lang.findLast":{"meta":{"summary":"Return index of last occurance of value in array, returning -1 if not found. This is a shortcut for dojo.lang.find() with a true","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"boolean?"}},"src":" return dojo.lang.find(array, value, identity, true); \/\/ number","returns":"number"},"extra":{"parameters":{"value":{"type":"for","summary":"its \"findLast\" parameter."},"identity":{"type":"If","summary":"true, matches with identity comparison (===). If false, uses normal comparison (==)."}}}},"dojo.lang.inArray":{"meta":{"summary":"Return true if value is present in array.","parameters":{"array":{"type":"Array"},"value":{"type":"Object"}},"src":" return dojo.lang.find(array, value) > -1; \/\/ boolean","returns":"boolean"}},"dojo.lang.isObject":{"meta":{"summary":"Return true if it is an Object, Array or Function.","parameters":{"it":{"type":"anything"}},"src":" if(typeof it == \"undefined\"){ return false; }\n\treturn (typeof it == \"object\" || it === null || dojo.lang.isArray(it) || dojo.lang.isFunction(it)); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isArray":{"meta":{"summary":"Return true if it is an Array.","parameters":{"it":{"type":"anything"}},"src":" return (it && it instanceof Array || typeof it == \"array\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isArrayLike":{"meta":{"summary":"Return true if it can be used as an array (i.e. is an object with an integer length property).","parameters":{"it":{"type":"anything"}},"src":" if((!it)||(dojo.lang.isUndefined(it))){ return false; }\n\tif(dojo.lang.isString(it)){ return false; }\n\tif(dojo.lang.isFunction(it)){ return false; } \/\/ keeps out built-in constructors (Number, String, ...) which have length properties\n\tif(dojo.lang.isArray(it)){ return true; }\n\t\/\/ form node itself is ArrayLike, but not always iterable. Use form.elements instead.\n\tif((it.tagName)&&(it.tagName.toLowerCase()=='form')){ return false; }\n\tif(dojo.lang.isNumber(it.length) && isFinite(it.length)){ return true; }\n\treturn false; \/\/ Boolean","returns":"mixed"}},"dojo.lang.isFunction":{"meta":{"summary":"","parameters":{"it":{"type":"anything"}},"src":" \t\tif((typeof(it) == \"function\") && (it == \"[object NodeList]\")) { return false; }\n\t\t\treturn (it instanceof Function || typeof it == \"function\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isString":{"meta":{"summary":"Return true if it is a String.","parameters":{"it":{"type":"anything"}},"src":" return (typeof it == \"string\" || it instanceof String);"}},"dojo.lang.isAlien":{"meta":{"summary":"Return true if it is not a built-in function. False if not.","parameters":{"it":{"type":"anything"}},"src":" if(!it){ return false; }\n\treturn !dojo.lang.isFunction(it) && \/\\{\\s*\\[native code\\]\\s*\\}\/.test(String(it)); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isBoolean":{"meta":{"summary":"Return true if it is a Boolean.","parameters":{"it":{"type":"anything"}},"src":" return (it instanceof Boolean || typeof it == \"boolean\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isNumber":{"meta":{"summary":"Return true if it is a number.","parameters":{"it":{"type":"anything"}},"src":" return (it instanceof Number || typeof it == \"number\"); \/\/ Boolean","description":"WARNING - In most cases, isNaN(it) is sufficient to determine whether or not something is a number or can be used as such. For example, a number or string can be used interchangably when accessing array items (array[\"1\"] is the same as array[1]) and isNaN will return false for both values (\"1\" and 1). However, isNumber(\"1\") will return false, which is generally not too useful. Also, isNumber(NaN) returns true, again, this isn't generally useful, but there are corner cases (like when you want to make sure that two things are really the same type of thing). That is really where isNumber \"shines\". Recommendation - Use isNaN(it) when possible","returns":"Boolean"}},"dojo.lang.isUndefined":{"meta":{"summary":"Return true if it is not defined.","parameters":{"it":{"type":"anything"}},"src":"\treturn ((typeof(it) == \"undefined\")&&(it == undefined)); \/\/ Boolean","description":"WARNING - In some cases, isUndefined will not behave as you might expect. If you do isUndefined(foo) and there is no earlier reference to foo, an error will be thrown before isUndefined is called. It behaves correctly if you scope yor object first, i.e. isUndefined(foo.bar) where foo is an object and bar isn't a property of the object. Recommendation - Use typeof foo == \"undefined\" when possible","returns":"Boolean"}}}}},"dojo.lang.declare":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.extras"]},"functions":{"dojo.lang.declare":{"meta":{"summary":"","parameters":{"className":{"type":"String"},"superclass":{"type":"Function|Array"},"init":{"type":"Function?"},"props":{"type":"Object|Array"}},"src":" if((dojo.lang.isFunction(props))||((!props)&&(!dojo.lang.isFunction(init)))){ \n\t\t\/\/ parameter juggling to support omitting init param (also allows\n\t\t\/\/ reordering init and props arguments)\n\t\tvar temp = props;\n\t\tprops = init;\n\t\tinit = temp;\n\t}\t\n\tvar mixins = [ ];\n\tif(dojo.lang.isArray(superclass)){\n\t\tmixins = superclass;\n\t\tsuperclass = mixins.shift();\n\t}\n\tif(!init){\n\t\tinit = dojo.evalObjPath(className, false);\n\t\tif((init)&&(!dojo.lang.isFunction(init))){ init = null };\n\t}\n\tvar ctor = dojo.lang.declare._makeConstructor();\n\tvar scp = (superclass ? superclass.prototype : null);\n\tif(scp){\n\t\tscp.prototyping = true;\n\t\tctor.prototype = new superclass();\n\t\tscp.prototyping = false; \n\t}\n\tctor.superclass = scp;\n\tctor.mixins = mixins;\n\tfor(var i=0,l=mixins.length; i<l; i++){\n\t\tdojo.lang.extend(ctor, mixins[i].prototype);\n\t}\n\tctor.prototype.initializer = null;\n\tctor.prototype.declaredClass = className;\n\tif(dojo.lang.isArray(props)){\n\t\tdojo.lang.extend.apply(dojo.lang, [ctor].concat(props));\n\t}else{\n\t\tdojo.lang.extend(ctor, (props)||{});\n\t}\n\tdojo.lang.extend(ctor, dojo.lang.declare._common);\n\tctor.prototype.constructor = ctor;\n\tctor.prototype.initializer = (ctor.prototype.initializer)||(init)||(function(){});\n\tvar created = dojo.parseObjPath(className, null, true);\n\tcreated.obj[created.prop] = ctor;\n\treturn ctor; \/\/ Function","returns":"Function","call_chain":["dojo.lang.extend"]}},"dojo.lang.declare._makeConstructor":{"meta":{"summary":"","src":" return function(){ \n\t\t\/\/ get the generational context (which object [or prototype] should be constructed)\n\t\tvar self = this._getPropContext();\n\t\tvar s = self.constructor.superclass;\n\t\tif((s)&&(s.constructor)){\n\t\t\tif(s.constructor==arguments.callee){\n\t\t\t\t\/\/ if this constructor is invoked directly (my.ancestor.call(this))\n\t\t\t\tthis._inherited(\"constructor\", arguments);\n\t\t\t}else{\n\t\t\t\tthis._contextMethod(s, \"constructor\", arguments);\n\t\t\t}\n\t\t}\n\t\tvar ms = (self.constructor.mixins)||([]);\n\t\tfor(var i=0, m; (m=ms[i]); i++) {\n\t\t\t(((m.prototype)&&(m.prototype.initializer))||(m)).apply(this, arguments);\n\t\t}\n\t\tif((!this.prototyping)&&(self.initializer)){\n\t\t\tself.initializer.apply(this, arguments);\n\t\t}\n\t}","call_chain":["self.initializer"]}},"dojo.lang.declare._common._getPropContext":{"meta":{"summary":"","src":" _getPropContext: function(){ return (this.___proto||this);    "}},"dojo.lang.declare._common._contextMethod":{"meta":{"summary":"","parameters":{"ptype":{"type":""},"method":{"type":""},"args":{"type":""}},"src":" \tvar result, stack = this.___proto;\n\t\tthis.___proto = ptype;\n\t\ttry { result = ptype[method].apply(this,(args||[])); }\n\t\tcatch(e) { throw e; }\t\n\t\tfinally { this.___proto = stack; }\n\t\treturn result;","instance_variables":["___proto"]}},"dojo.lang.declare._common._inherited":{"meta":{"summary":"Searches backward thru prototype chain to find nearest ancestral instance of prop. Internal use only.","parameters":{"prop":{"type":""},"args":{"type":""}},"src":" \tvar p = this._getPropContext();\n\t\tdo{\n\t\t\tif((!p.constructor)||(!p.constructor.superclass)){ return; }\n\t\t\tp = p.constructor.superclass;\n\t\t}while(!(prop in p));\n\t\treturn (dojo.lang.isFunction(p[prop]) ? this._contextMethod(p, prop, args) : p[prop]);"}},"dojo.lang.declare._common.inherited":{"meta":{"summary":"","parameters":{"prop":{"type":""},"args":{"type":""}},"src":" \tdojo.deprecated(\"'inherited' method is dangerous, do not up-call! 'inherited' is slated for removal in 0.5; name your super class (or use superclass property) instead.\", \"0.5\");\n\t\tthis._inherited(prop, args);"}}}}},"dojo.lang.extras":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.setTimeout":{"meta":{"summary":"Sets a timeout in milliseconds to execute a function in a given context with optional arguments. usage: dojo.lang.setTimeout(Object context, function func, number delay[, arg1[, ...]]); dojo.lang.setTimeout(function func, number delay[, arg1[, ...]]);","parameters":{"func":{"type":"Function"},"delay":{"type":"int , ..."}},"src":"\tvar context = window, argsStart = 2;\n\tif(!dojo.lang.isFunction(func)){\n\t\tcontext = func;\n\t\tfunc = delay;\n\t\tdelay = arguments[2];\n\t\targsStart++;\n\t}\n\tif(dojo.lang.isString(func)){\n\t\tfunc = context[func];\n\t}\n\tvar args = [];\n\tfor (var i = argsStart; i < arguments.length; i++){\n\t\targs.push(arguments[i]);\n\t}\n\treturn dojo.global().setTimeout(function(){ func.apply(context, args); }, delay); \/\/ int","returns":"int","call_chain":["func"]}},"dojo.lang.clearTimeout":{"meta":{"summary":"clears timer by number from the execution queue","parameters":{"timer":{"type":"int"}},"src":"\t\/\/ FIXME:\n\t\/\/\t\twhy do we have this function? It's not portable outside of browser\n\t\/\/\t\tenvironments and it's a stupid wrapper on something that browsers\n\t\/\/\t\tprovide anyway.\n\tdojo.global().clearTimeout(timer);"}},"dojo.lang.getNameInObj":{"meta":{"summary":"looks for a value in the object ns with a value matching item and","parameters":{"ns":{"type":"Object"},"item":{"type":"unknown"}},"src":" if(!ns){ ns = dj_global; }\n\tfor(var x in ns){\n\t\tif(ns[x] === item){\n\t\t\treturn new String(x); \/\/ String\n\t\t}\n\t}\n\treturn null; \/\/ null","returns":"mixed"},"extra":{"returns":"the property name","parameters":{"ns":{"type":"if","summary":"null, dj_global is used"},"item":{"type":"value","summary":"to return a name for"}}}},"dojo.lang.shallowCopy":{"meta":{"summary":"copies object obj one level deep, or full depth if deep is true","parameters":{"obj":{"type":"Object"},"deep":{"type":"Boolean?"}},"src":" var i, ret;\t\n\tif(obj === null){ \/*obj: null*\/ return null; } \/\/ null\n\tif(dojo.lang.isObject(obj)){\n\t\t\/\/ obj: Object\t\n\t\tret = new obj.constructor();\n\t\tfor(i in obj){\n\t\t\tif(dojo.lang.isUndefined(ret[i])){\n\t\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t\t}\n\t\t}\n\t}else if(dojo.lang.isArray(obj)){\n\t\t\/\/ obj: Array\n\t\tret = [];\n\t\tfor(i=0; i<obj.length; i++){\n\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t}\n\t}else{\n\t\t\/\/ obj: Object\n\t\tret = obj;\n\t}\n\treturn ret; \/\/ Object","returns":"mixed"}},"dojo.lang.firstValued":{"meta":{"summary":"Return the first argument that isn't undefined","src":"\tfor(var i = 0; i < arguments.length; i++){\n\t\tif(typeof arguments[i] != \"undefined\"){\n\t\t\treturn arguments[i]; \/\/ Object\n\t\t}\n\t}\n\treturn undefined; \/\/ undefined","returns":"mixed"}},"dojo.lang.getObjPathValue":{"meta":{"summary":"Gets a value from a reference specified as a string descriptor, (e.g. \"A.B\") in the given context.","parameters":{"objpath":{"type":"String"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"src":" with(dojo.parseObjPath(objpath, context, create)){\n\t\treturn dojo.evalProp(prop, obj, create); \/\/ Object\n\t}","returns":"Object"},"extra":{"parameters":{"context":{"type":"if","summary":"not specified, dj_global is used"},"create":{"type":"if","summary":"true, undefined objects in the path are created."}}}},"dojo.lang.setObjPathValue":{"meta":{"summary":"Sets a value on a reference specified as a string descriptor. (e.g. \"A.B\") in the given context. This is similar to straight assignment, except that the object structure in question can optionally be created if it does not exist.","parameters":{"objpath":{"type":"String"},"value":{"type":"anything"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"src":"\t\/\/ FIXME: why is this function valuable? It should be scheduled for\n\t\/\/ removal on the grounds that dojo.parseObjPath does most of it's work and\n\t\/\/ is more straightforward and has fewer dependencies. Also, the order of\n\t\/\/ arguments is bone-headed. \"context\" should clearly come after \"create\".\n\t\/\/ *sigh*\n\tdojo.deprecated(\"dojo.lang.setObjPathValue\", \"use dojo.parseObjPath and the '=' operator\", \"0.6\");\n\tif(arguments.length < 4){\n\t\tcreate = true;\n\t}\n\twith(dojo.parseObjPath(objpath, context, create)){\n\t\tif(obj && (create || (prop in obj))){\n\t\t\tobj[prop] = value;\n\t\t}\n\t}"},"extra":{"parameters":{"context":{"type":"if","summary":"not specified, dj_global is used"},"create":{"type":"if","summary":"true, undefined objects in the path are created."}}}}}}},"dojo.lang.func":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.hitch":{"meta":{"summary":"Returns a function that will only ever execute in the a given scope (thisObject). This allows for easy use of object member functions in callbacks and other places in which the \"this\" keyword may otherwise not reference the expected scope. Note that the order of arguments may be reversed in a future version.","parameters":{"thisObject":{"type":"Object"},"method":{"type":"Function|String"}},"src":"\t\/\/ FIXME:\n\t\/\/\t\tshould this be extended to \"fixate\" arguments in a manner similar\n\t\/\/\t\tto dojo.lang.curry, but without the default execution of curry()?\n\tvar fcn = (dojo.lang.isString(method) ? thisObject[method] : method) || function(){};\n\treturn function(){\n\t\treturn fcn.apply(thisObject, arguments); \/\/ Function\n\t};","returns":"Function","call_chain":["fcn"]},"extra":{"parameters":{"thisObject":{"type":"to","summary":"be used as the basis for the binding usage: dojo.lang.hitch(foo, \"bar\")(); \/\/ runs foo.bar() in the scope of foo dojo.lang.hitch(foo, myFunction); \/\/ returns a function that runs myFunction in the scope of foo"},"method":{"type":"a","summary":"function to be \"bound\" to thisObject or the name of the method in"}}}},"dojo.lang.nameAnonFunc":{"meta":{"summary":"Creates a reference to anonFuncPtr in thisObj with a completely unique name. The new name is returned as a String. If","parameters":{"anonFuncPtr":{"type":"Function"},"thisObj":{"type":"Object"},"searchForNames":{"type":"Boolean"}},"src":" var nso = (thisObj|| dojo.lang.anon);\n\tif( (searchForNames) ||\n\t\t((dj_global[\"djConfig\"])&&(djConfig[\"slowAnonFuncLookups\"] == true)) ){\n\t\tfor(var x in nso){\n\t\t\ttry{\n\t\t\t\tif(nso[x] === anonFuncPtr){\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}catch(e){} \/\/ window.external fails in IE embedded in Eclipse (Eclipse bug #151165)\n\t\t}\n\t}\n\tvar ret = \"__\"+dojo.lang.anonCtr++;\n\twhile(typeof nso[ret] != \"undefined\"){\n\t\tret = \"__\"+dojo.lang.anonCtr++;\n\t}\n\tnso[ret] = anonFuncPtr;\n\treturn ret; \/\/ String","returns":"String"},"extra":{"parameters":{"searchForNames":{"type":"to","summary":"be false."}}}},"dojo.lang.forward":{"meta":{"summary":"Returns a function that forwards a method call to this.funcName(...). Unlike dojo.lang.hitch(), the \"this\" scope is not fixed on a single object. Ported from MochiKit.","parameters":{"funcName":{"type":""}},"src":" return function(){\n\t\treturn this[funcName].apply(this, arguments);\n\t}; \/\/ Function"}},"dojo.lang.curry":{"meta":{"summary":"similar to the curry() method found in many functional programming environments, this function returns an \"argument accumulator\" function, bound to a particular scope, and \"primed\" with a variable number of arguments. The curry method is unique in that it returns a function that may return other \"partial\" function which can be called repeatedly. New functions are returned until the arity of the original function is reached, at which point the underlying function (func) is called in the scope thisObj with all of the accumulated arguments (plus any extras) in positional order. examples: assuming a function defined like this: var foo = { bar: function(arg1, arg2, arg3){ dojo.debug.apply(dojo, arguments); } }; dojo.lang.curry() can be used most simply in this way: tmp = dojo.lang.curry(foo, foo.bar, \"arg one\", \"thinger\"); tmp(\"blah\", \"this is superfluous\"); \/\/ debugs: \"arg one thinger blah this is superfluous\" tmp(\"blah\"); \/\/ debugs: \"arg one thinger blah\" tmp(); \/\/ returns a function exactly like tmp that expects one argument other intermittent functions could be created until the 3 positional arguments are filled: tmp = dojo.lang.curry(foo, foo.bar, \"arg one\"); tmp2 = tmp(\"arg two\"); tmp2(\"blah blah\"); \/\/ debugs: \"arg one arg two blah blah\" tmp2(\"oy\"); \/\/ debugs: \"arg one arg two oy\" curry() can also be used to call the function if enough arguments are passed in the initial invocation: dojo.lang.curry(foo, foo.bar, \"one\", \"two\", \"three\", \"four\"); \/\/ debugs: \"one two three four\" dojo.lang.curry(foo, foo.bar, \"one\", \"two\", \"three\"); \/\/ debugs: \"one two three\"","parameters":{"thisObj":{"type":""},"func":{"type":"args ..."}},"src":"\t\/\/ FIXME: the order of func and thisObj should be changed!!!\n\tvar outerArgs = [];\n\tthisObj = thisObj||dj_global;\n\tif(dojo.lang.isString(func)){\n\t\tfunc = thisObj[func];\n\t}\n\tfor(var x=2; x<arguments.length; x++){\n\t\touterArgs.push(arguments[x]);\n\t}\n\t\/\/ since the event system replaces the original function with a new\n\t\/\/ join-point runner with an arity of 0, we check to see if it's left us\n\t\/\/ any clues about the original arity in lieu of the function's actual\n\t\/\/ length property\n\tvar ecount = (func[\"__preJoinArity\"]||func.length) - outerArgs.length;\n\t\/\/ borrowed from svend tofte\n\tfunction gather(nextArgs, innerArgs, expected){\n\t\tvar texpected = expected;\n\t\tvar totalArgs = innerArgs.slice(0); \/\/ copy\n\t\tfor(var x=0; x<nextArgs.length; x++){\n\t\t\ttotalArgs.push(nextArgs[x]);\n\t\t}\n\t\t\/\/ check the list of provided nextArgs to see if it, plus the\n\t\t\/\/ number of innerArgs already supplied, meets the total\n\t\t\/\/ expected.\n\t\texpected = expected-nextArgs.length;\n\t\tif(expected<=0){\n\t\t\tvar res = func.apply(thisObj, totalArgs);\n\t\t\texpected = texpected;\n\t\t\treturn res;\n\t\t}else{\n\t\t\treturn function(){\n\t\t\t\treturn gather(arguments,\/\/ check to see if we've been run\n\t\t\t\t\t\t\t\t\t\t\/\/ with enough args\n\t\t\t\t\t\t\ttotalArgs,\t\/\/ a copy\n\t\t\t\t\t\t\texpected);\t\/\/ how many more do we need to run?;\n\t\t\t};\n\t\t}\n\t}\n\treturn gather([], outerArgs, ecount);","returns":"check to see if we've been run","call_chain":["func"]}},"dojo.lang.curryArguments":{"meta":{"summary":"similar to dojo.lang.curry(), except that a list of arguments to start the curry with may be provided as an array instead of as positional arguments. An offset may be specified from the 0 index to skip some elements in args.","parameters":{"thisObj":{"type":"Object"},"func":{"type":"Function"},"args":{"type":"Array"},"offset":{"type":"Integer, optional"}},"src":" var targs = [];\n\tvar x = offset||0;\n\tfor(x=offset; x<args.length; x++){\n\t\ttargs.push(args[x]); \/\/ ensure that it's an arr\n\t}\n\treturn dojo.lang.curry.apply(dojo.lang, [thisObj, func].concat(targs));","call_chain":["dojo.lang.curry"]}},"dojo.lang.tryThese":{"meta":{"summary":"executes each function argument in turn, returning the return value from the first one which does not throw an exception in execution. Any number of functions may be passed.","src":" for(var x=0; x<arguments.length; x++){\n\t\ttry{\n\t\t\tif(typeof arguments[x] == \"function\"){\n\t\t\t\tvar ret = (arguments[x]());\n\t\t\t\tif(ret){\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tdojo.debug(e);\n\t\t}\n\t}"}},"dojo.lang.delayThese":{"meta":{"summary":"executes a series of functions contained in farr, but spaces out calls to each function by the millisecond delay provided. If cb is provided, it will be called directly after each item in farr is called and if onend is passed, it will be called when all items have completed executing.","parameters":{"farr":{"type":"Array"},"cb":{"type":"Function, optional"},"delay":{"type":"Integer"},"onend":{"type":"Function, optional"}},"src":"\t\/**\n\t * alternate: (array funcArray, function callback, function onend)\n\t * alternate: (array funcArray, function callback)\n\t * alternate: (array funcArray)\n\t *\/\n\tif(!farr.length){ \n\t\tif(typeof onend == \"function\"){\n\t\t\tonend();\n\t\t}\n\t\treturn;\n\t}\n\tif((typeof delay == \"undefined\")&&(typeof cb == \"number\")){\n\t\tdelay = cb;\n\t\tcb = function(){};\n\t}else if(!cb){\n\t\tcb = function(){};\n\t\tif(!delay){ delay = 0; }\n\t}\n\tsetTimeout(function(){\n\t\t(farr.shift())();\n\t\tcb();\n\t\tdojo.lang.delayThese(farr, cb, delay, onend);\n\t}, delay);"}}}}},"dojo.lang.repr":{"meta":{"requires":{"common":["dojo.lang.common","dojo.AdapterRegistry","dojo.string.extras"]},"functions":{"dojo.lang.registerRepr":{"meta":{"summary":"Register a repr function. repr functions should take one argument and return a string representation of it suitable for developers, primarily used when debugging. If override is given, it is used as the highest priority repr, otherwise it will be used as the lowest.","parameters":{"name":{"type":"String"},"check":{"type":"Function"},"wrap":{"type":"Function"},"override":{"type":"Boolean?"}},"src":"\tdojo.lang.reprRegistry.register(name, check, wrap, override);"}},"dojo.lang.repr":{"meta":{"summary":"Return a \"programmer representation\" for an object","parameters":{"obj":{"type":"Object"}},"src":"\tif(typeof(obj) == \"undefined\"){\n\t\t\/\/ obj: undefined\n\t\treturn \"undefined\"; \/\/ String\n\t}else if(obj === null){\n\t\t\/\/ obj: null\n\t\treturn \"null\"; \/\/ String\n\t}\n\ttry{\n\t\tif(typeof(obj[\"__repr__\"]) == 'function'){\n\t\t\treturn obj[\"__repr__\"]();\n\t\t}else if((typeof(obj[\"repr\"]) == 'function')&&(obj.repr != arguments.callee)){\n\t\t\treturn obj[\"repr\"]();\n\t\t}\n\t\treturn dojo.lang.reprRegistry.match(obj);\n\t}catch(e){\n\t\tif(typeof(obj.NAME) == 'string' && (\n\t\t\t\tobj.toString == Function.prototype.toString ||\n\t\t\t\tobj.toString == Object.prototype.toString\n\t\t\t)){\n\t\t\treturn obj.NAME; \/\/ String\n\t\t}\n\t}\n\tif(typeof(obj) == \"function\"){\n\t\t\/\/ obj: Function\n\t\tobj = (obj + \"\").replace(\/^\\s+\/, \"\");\n\t\tvar idx = obj.indexOf(\"{\");\n\t\tif(idx != -1){\n\t\t\tobj = obj.substr(0, idx) + \"{...}\";\n\t\t}\n\t}\n\treturn obj + \"\"; \/\/ String","description":"returns a string representation of an object suitable for developers, primarily used when debugging","returns":"String"}},"dojo.lang.reprArrayLike":{"meta":{"summary":"Maps each element of arr to dojo.lang.repr and provides output in an array-like format","parameters":{"arr":{"type":"Array"}},"src":" try{\n\t\tvar na = dojo.lang.map(arr, dojo.lang.repr);\n\t\treturn \"[\" + na.join(\", \") + \"]\"; \/\/ String\n\t}catch(e){ }","description":"returns an array-like string representation of the provided array suitable for developers, primarily used when debugging","returns":"String"}}}}},"dojo.lang.timing.Streamer":{"meta":{"requires":{"common":["dojo.lang.timing.Timer"]},"functions":{"dojo.lang.timing.Streamer":{"meta":{"summary":"Streamer will take an input function that pushes N datapoints into a queue, and will pass the next point in that queue out to an","parameters":{"input":{"type":"function"},"output":{"type":"function"},"interval":{"type":"int"},"minimum":{"type":"int"},"initialData":{"type":"array"}},"src":"\tvar self = this;\n\tvar queue = [];\n\t\/\/\tpublic properties\n\tthis.interval = interval || 1000;\n\tthis.minimumSize = minimum || 10;\t\/\/\tlatency usually == interval * minimumSize\n\tthis.inputFunction = input || function(q){ };\n\tthis.outputFunction = output || function(point){ };\n\t\/\/\tmore setup\n\tvar timer = new dojo.lang.timing.Timer(this.interval);\n\tvar tick = function(){\n\t\tself.onTick(self);\n\t\tif(queue.length < self.minimumSize){\n\t\t\tself.inputFunction(queue);\n\t\t}\n\t\tvar obj = queue.shift();\n\t\twhile(typeof(obj) == \"undefined\" && queue.length > 0){\n\t\t\tobj = queue.shift();\n\t\t}\n\t\t\/\/\tcheck to see if the input function needs to be fired\n\t\t\/\/\tstop before firing the output function\n\t\t\/\/\tTODO: relegate this to the output function?\n\t\tif(typeof(obj) == \"undefined\"){\n\t\t\tself.stop();\n\t\t\treturn;\n\t\t}\n\t\t\/\/\tcall the output function.\n\t\tself.outputFunction(obj);\n\t};\n\tthis.setInterval = function(\/* int *\/ms){\n\t\t\/\/\tsummary\n\t\t\/\/\tsets the interval in milliseconds of the internal timer\n\t\tthis.interval = ms;\n\t\ttimer.setInterval(ms);\n\t};\n\tthis.onTick = function(\/* dojo.lang.timing.Streamer *\/obj){ };\n\t\/\/ wrap the timer functions so that we can connect to them if needed.\n\tthis.start = function(){\n\t\t\/\/\tsummary\n\t\t\/\/\tstarts the Streamer\n\t\tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\n\t\t\ttimer.start();\n\t\t\treturn;\n\t\t}\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");\n\t};\n\tthis.onStart = function(){ };\n\tthis.stop = function(){\n\t\t\/\/\tsummary\n\t\t\/\/\tstops the Streamer\n\t\ttimer.stop();\n\t};\n\tthis.onStop = function(){ };\n\t\/\/\tfinish initialization\n\ttimer.onTick = this.tick;\n\ttimer.onStart = this.onStart;\n\ttimer.onStop = this.onStop;\n\tif(initialData){\n\t\tqueue.concat(initialData);\n\t}","instance_variables":["interval","minimumSize","inputFunction","outputFunction","setInterval","onTick","start","onStart","stop","onStop"]},"extra":{"parameters":{"output":{"type":"the","summary":"function executed on internal tick"},"input":{"type":"the","summary":"function executed when the internal queue reaches minimumSize"},"minimum":{"type":"the","summary":"minimum number of elements in the internal queue."}},"variables":{"interval":{"type":"the","summary":"interval in ms at which the output function is fired."}}}},"dojo.lang.timing.Streamer.setInterval":{"meta":{"summary":"sets the interval in milliseconds of the internal timer","parameters":{"ms":{"type":"int"}},"src":" \tthis.interval = ms;\n\t\ttimer.setInterval(ms);","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onTick":{"meta":{"summary":"","parameters":{"obj":{"type":"dojo.lang.timing.Streamer"}},"src":"","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.start":{"meta":{"summary":"starts the Streamer","src":" \tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\n\t\t\ttimer.start();\n\t\t\treturn;\n\t\t}\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onStart":{"meta":{"summary":"","src":"","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.stop":{"meta":{"summary":"stops the Streamer","src":" \ttimer.stop();","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onStop":{"meta":{"summary":"","src":"","instance":"dojo.lang.timing.Streamer"}}}}},"dojo.lang.timing.Timer":{"meta":{"requires":{"common":["dojo.lang.func"]},"functions":{"dojo.lang.timing.Timer":{"meta":{"summary":"Timer object executes an \"onTick()\" method repeatedly at a specified interval. repeatedly at a given interval.","parameters":{"interval":{"type":"int"}},"src":" this.timer = null;\n\tthis.isRunning = false;\n\tthis.interval = interval;\n\tthis.onStart = null;\n\tthis.onStop = null;","instance_variables":["timer","isRunning","interval","onStart","onStop"]},"extra":{"variables":{"interval":{"type":"Interval","summary":"between function calls, in milliseconds."}}}}}}},"dojo.lang.type":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.whatAmI":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":" dojo.deprecated(\"dojo.lang.whatAmI\", \"use dojo.lang.getType instead\", \"0.5\");\n\treturn dojo.lang.getType(value);"}},"dojo.lang.getType":{"meta":{"summary":"Attempts to determine what type value is.","parameters":{"value":{"type":"anything"}},"src":" try{\n\t\tif(dojo.lang.isArray(value)){ \n\t\t\treturn \"array\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isFunction(value)){ \n\t\t\treturn \"function\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isString(value)){ \n\t\t\treturn \"string\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isNumber(value)){ \n\t\t\treturn \"number\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isBoolean(value)){ \n\t\t\treturn \"boolean\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isAlien(value)){ \n\t\t\treturn \"alien\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isUndefined(value)){ \n\t\t\treturn \"undefined\";\t\/\/\tstring \n\t\t}\n\t\t\/\/ FIXME: should this go first?\n\t\tfor(var name in dojo.lang.whatAmI.custom){\n\t\t\tif(dojo.lang.whatAmI.custom[name](value)){\n\t\t\t\treturn name;\t\/\/\tstring\n\t\t\t}\n\t\t}\n\t\tif(dojo.lang.isObject(value)){ \n\t\t\treturn \"object\";\t\/\/\tstring \n\t\t}\n\t}catch(e){}\n\treturn \"unknown\";\t\/\/\tstring","returns":"string"},"extra":{"parameters":{"value":{"type":"Any","summary":"literal value or object instance."}}}},"dojo.lang.isNumeric":{"meta":{"summary":"Returns true if value can be interpreted as a number","parameters":{"value":{"type":"anything"}},"src":" return (!isNaN(value) \n\t\t&& isFinite(value) \n\t\t&& (value != null) \n\t\t&& !dojo.lang.isBoolean(value) \n\t\t&& !dojo.lang.isArray(value) \n\t\t&& !\/^\\s*$\/.test(value)\n\t);\t\/\/\tboolean"},"extra":{"parameters":{"value":{"type":"Any","summary":"literal value or object instance. examples: dojo.lang.isNumeric(3); \/\/ returns true dojo.lang.isNumeric(\"3\"); \/\/ returns true dojo.lang.isNumeric(new Number(3)); \/\/ returns true dojo.lang.isNumeric(new String(\"3\")); \/\/ returns true dojo.lang.isNumeric(3\/0); \/\/ returns false dojo.lang.isNumeric(\"foo\"); \/\/ returns false dojo.lang.isNumeric(new Number(\"foo\")); \/\/ returns false dojo.lang.isNumeric(false); \/\/ returns false dojo.lang.isNumeric(true); \/\/ returns false"}}}},"dojo.lang.isBuiltIn":{"meta":{"summary":"Returns true if value is of a type provided by core JavaScript","parameters":{"value":{"type":"anything"}},"src":" return (dojo.lang.isArray(value)\n\t\t|| dojo.lang.isFunction(value)\t\n\t\t|| dojo.lang.isString(value)\n\t\t|| dojo.lang.isNumber(value)\n\t\t|| dojo.lang.isBoolean(value)\n\t\t|| (value == null)\n\t\t|| (value instanceof Error)\n\t\t|| (typeof value == \"error\") \n\t);\t\/\/\tboolean","description":"Returns true for any literal, and for any object that is an instance of a built-in type like String, Number, Boolean, Array, Function, or Error."},"extra":{"parameters":{"value":{"type":"Any","summary":"literal value or object instance."}}}},"dojo.lang.isPureObject":{"meta":{"summary":"Returns true for any value where the value of value.constructor == Object","parameters":{"value":{"type":"anything"}},"src":" return ((value != null) \n\t\t&& dojo.lang.isObject(value) \n\t\t&& value.constructor == Object\n\t);\t\/\/\tboolean","description":"Returns true for any literal, and for any object that is an instance of a built-in type like String, Number, Boolean, Array, Function, or Error."},"extra":{"parameters":{"value":{"type":"Any","summary":"literal value or object instance. examples: dojo.lang.isPureObject(new Object()); \/\/ returns true dojo.lang.isPureObject({a: 1, b: 2}); \/\/ returns true dojo.lang.isPureObject(new Date()); \/\/ returns false dojo.lang.isPureObject([11, 2, 3]); \/\/ returns false"}}}},"dojo.lang.isOfType":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"},"type":{"type":"function"},"keywordParameters":{"type":"object?"}},"src":" var optional = false;\n\tif(keywordParameters){\n\t\toptional = keywordParameters[\"optional\"];\n\t}\n\tif(optional && ((value === null) || dojo.lang.isUndefined(value))){\n\t\treturn true;\t\/\/\tboolean\n\t}\n\tif(dojo.lang.isArray(type)){\n\t\tvar arrayOfTypes = type;\n\t\tfor(var i in arrayOfTypes){\n\t\t\tvar aType = arrayOfTypes[i];\n\t\t\tif(dojo.lang.isOfType(value, aType)){\n\t\t\t\treturn true; \t\/\/\tboolean\n\t\t\t}\n\t\t}\n\t\treturn false;\t\/\/\tboolean\n\t}else{\n\t\tif(dojo.lang.isString(type)){\n\t\t\ttype = type.toLowerCase();\n\t\t}\n\t\tswitch (type) {\n\t\t\tcase Array:\n\t\t\tcase \"array\":\n\t\t\t\treturn dojo.lang.isArray(value);\t\/\/\tboolean\n\t\t\tcase Function:\n\t\t\tcase \"function\":\n\t\t\t\treturn dojo.lang.isFunction(value);\t\/\/\tboolean\n\t\t\tcase String:\n\t\t\tcase \"string\":\n\t\t\t\treturn dojo.lang.isString(value);\t\/\/\tboolean\n\t\t\tcase Number:\n\t\t\tcase \"number\":\n\t\t\t\treturn dojo.lang.isNumber(value);\t\/\/\tboolean\n\t\t\tcase \"numeric\":\n\t\t\t\treturn dojo.lang.isNumeric(value);\t\/\/\tboolean\n\t\t\tcase Boolean:\n\t\t\tcase \"boolean\":\n\t\t\t\treturn dojo.lang.isBoolean(value);\t\/\/\tboolean\n\t\t\tcase Object:\n\t\t\tcase \"object\":\n\t\t\t\treturn dojo.lang.isObject(value);\t\/\/\tboolean\n\t\t\tcase \"pureobject\":\n\t\t\t\treturn dojo.lang.isPureObject(value);\t\/\/\tboolean\n\t\t\tcase \"builtin\":\n\t\t\t\treturn dojo.lang.isBuiltIn(value);\t\/\/\tboolean\n\t\t\tcase \"alien\":\n\t\t\t\treturn dojo.lang.isAlien(value);\t\/\/\tboolean\n\t\t\tcase \"undefined\":\n\t\t\t\treturn dojo.lang.isUndefined(value);\t\/\/\tboolean\n\t\t\tcase null:\n\t\t\tcase \"null\":\n\t\t\t\treturn (value === null);\t\/\/\tboolean\n\t\t\tcase \"optional\":\n\t\t\t\tdojo.deprecated('dojo.lang.isOfType(value, [type, \"optional\"])', 'use dojo.lang.isOfType(value, type, {optional: true} ) instead', \"0.5\");\n\t\t\t\treturn ((value === null) || dojo.lang.isUndefined(value));\t\/\/\tboolean\n\t\t\tdefault:\n\t\t\t\tif(dojo.lang.isFunction(type)){\n\t\t\t\t\treturn (value instanceof type);\t\/\/\tboolean\n\t\t\t\t}else{\n\t\t\t\t\tdojo.raise(\"dojo.lang.isOfType() was passed an invalid type\");\n\t\t\t\t}\n\t\t}\n\t}\n\tdojo.raise(\"If we get here, it means a bug was introduced above.\");","returns":"boolean"}},"dojo.lang.getObject":{"meta":{"summary":"Will return an object, if it exists, based on the name in the passed string.","parameters":{"str":{"type":"String"}},"src":" var parts=str.split(\".\"), i=0, obj=dj_global; \n\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj!=dj_global)?obj:null;\t\/\/\tObject","returns":"Object"}},"dojo.lang.doesObjectExist":{"meta":{"summary":"Check to see if object [str] exists, based on the passed string.","parameters":{"str":{"type":"String"}},"src":" var parts=str.split(\".\"), i=0, obj=dj_global; \n\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj&&obj!=dj_global);\t\/\/\tboolean","returns":"boolean"}}}}},"dojo.lang":{"meta":{"requires":{"common":["dojo.lang.common"]}}}}