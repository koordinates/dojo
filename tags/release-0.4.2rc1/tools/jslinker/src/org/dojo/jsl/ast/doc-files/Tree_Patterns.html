<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
                                               
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
                                               
  <meta name="author" content="Uwe Hoffmann">
  <title>Tree Patterns</title>
</head>
 <body>
 
<h1>Abstract Syntax Tree Patterns</h1>
 
<h3>1.) Matching nodes</h3>
          When dealing with AST's (Abstract Syntax Trees) one usually finds 
 himself    writing Visitor classes that walk the trees and have methods that
 look similar   to the one below:<br>
 <small> 
<pre>    <br><br>    public Object visit(ASTCompositeReference node, Object data){<br>        SimpleNode scope = this.getScope();<br><br>        if(scope instanceof ASTProgram){<br>            if(node.jjtGetNumChildren() == 3){<br>                SimpleNode aNode = (SimpleNode) node.jjtGetChild(0);<br>                <br>                if((aNode instanceof ASTIdentifier) &amp;&amp; (((ASTIdentifier) aNode).getName().equals("CXClass"))){<br>                    aNode = (SimpleNode) node.jjtGetChild(1);<br>                    <br>                    if(aNode instanceof ASTPropertyIdentifierReference){<br>                        aNode = (SimpleNode) aNode.jjtGetChild(0);<br><br>                        if((aNode instanceof ASTIdentifier) <br>                           &amp;&amp; ((((ASTIdentifier) aNode).getName().equals("declare")) ||<br>                               (((ASTIdentifier) aNode).getName().equals("declareInterface")))){<br>                            aNode = (SimpleNode) node.jjtGetChild(2);<br><br>                            if(aNode instanceof ASTFunctionCallParameters){<br>                                aNode = (SimpleNode) aNode.jjtGetChild(0);<br>                                <br>                                if(aNode instanceof ASTLiteral){<br>                                    String className = (String) ((ASTLiteral) aNode).getValue();<br><br>                                    Comment comment = this.getComment((SimpleNode) node);<br>                                    JavaClass javaClass = this.getJavaClass(className);<br>                                    <br>                                    if(comment != null){<br>                                        javaClass.setComment(comment);<br>                                    }<br>                                    <br>                                    javaClass.setOriginatingFile((JSFile) data);<br>                                }<br>                            }<br>                        }<br>                    }<br>                }<br>            }          <br>        }<br><br></pre>
 </small> 
<p> Most of the code above deals with finding out if the node currently visited 
   is interesting for data extraction and/or further manipulation. Let's explain
   exactly what it means when a node "is interesting". Nodes in an AST belong
   to one of the AST types generated by jjtree (the tree generating tool
of   javacc), they are inside a given scope, have or don't have children, 
have   or don't have a parent (of a certain type), have a given value for 
an attribute   etc. All these properties are differentiating one node from 
another. Visitors   usually want to operate only on nodes with properties 
that fullfill some  defined conditions. Example:</p>
 
<blockquote>   
  <p><small>A visitor that wants to print out all the local variables of a
program. It is therefore interested in AST nodes whose properties match the
 following conditions:</small></p>
   
  <p><small>- node type is ASTVariableDeclaration</small><small><br>
   </small><small>- node scope is of type ASTBlock (that's the scope for
 local stuff)</small><small><br>
   </small><small>- number of children is 3</small><small><br>
   </small><small>- first child is of type ASTIdentifier</small><small><br>
   </small><small>- etc</small><br>
   </p>
   </blockquote>
   
  <p> The if-statements in the example above test for conditions like these. 
   But all these nested conditions look awkward and are probably hard to modify
   and to maintain.</p>
   
  <p>There is clearly a need to simplify the task of matching nodes according 
   to defined conditions.</p>
   
  <p>The idea behind tree patterns is defining the conditions in a declarative 
   fashion in a simple language. These declarations get transformed by a parser
   into tree template data structures that are used by a general tree matcher
   to match nodes. The result is that the if-statements get replaced by an
 easier  to read declaration of conditions and the tree matching code of
the  general  tree matcher gets reused in all instances where locating nodes
according   to conditions is needed.</p>
   
  <h3>2.) TreeTemplates</h3>
         TreeTemplates are the data structures that the general tree matcher
  uses  to match nodes.<br>
   <br>
       A tree template consists of a map of key-value pairs and a list of 
child   tree templates. The map defines how the node should look like and 
the list   of child templates defines how its children look like. <br>
   <br>
      The following keys are available for the node map:<br>
   <br>
           - <i>type</i> : the type of the node, value is an ASTLiteral with
  the unqualified  class name of the node as string<br>
    - <i>parent</i> :  a tree template or ASTLiteral.NULL<br>
  - <i>previous</i> : a tree template or ASTLiteral.NULL<br>
  - <i>next</i> : a tree template or ASTLiteral.NULL<br>
           - <i>scope</i> : the scope in which the node lives, value is the
 string "local" or "global"<br>
           - <i>value</i> : the node's value (only defined for nodes representing
  literals  or identifiers), value is an ASTLiteral<br>
   <br>
      If the tree template is defining a child (ie it is in the list of child 
  templates of another tree template) then one more key is available:<br>
           - <i>multi</i> : a quantifier specifying how many children should
  match this  template, value is an instance of Multi<br>
   <br>
      The keys listed above all define tree template conditions that a node 
 has to match.  They are <i>content keys</i>.<br>
   <br>
      In addition to the content keys there are two other keys available. 
These   two keys don't define conditions but control the behavior of the tree
matcher   and are therefore <i>control keys</i> :<br>
              - <i>name</i> :  identifies a node from the subtree that matched
  a template,  useful to easily get to children, grandchildren etc of matched
  nodes<br>
              - <i>stop</i> :  tells the tree matcher to not go deeper (ie
 ignore  the  children of this node)<br>
   <br>
      Example: <br>
   <br>
   
  <pre><small>Same visitor that prints out local variables of a program:<br>    <br>        // define template<br><br>        ASTLiteral literal;<br><br>        TreeTemplate treeTemplate = new TreeTemplate();<br>        treeTemplate.node = new HashMap();<br>        <br>        literal = new ASTLiteral();<br>        literal.setValue("ASTVariableDeclaration");<br>        treeTemplate.node.put("type", literal);<br><br>        treeTemplate.node.put("scope", "global");<br><br>        TreeTemplate childTemplate;<br><br>        treeTemplate.children = new ArrayList();<br><br>        childTemplate = new TreeTemplate();<br>        childTemplate.node = new HashMap();<br>        <br>        literal = new ASTLiteral();<br>        literal.setValue("ASTIdentifier");<br>        childTemplate.node.put("type", literal);<br><br>        literal = new ASTLiteral();<br>        literal.setValue("theIdentifier");<br>        childTemplate.node.put("name", literal);<br>        <br>        childTemplate.node.put("stop", Boolean.TRUE);<br>        <br>        treeTemplate.children.add(childTemplate);<br><br>         // etc.....<br><br>        // match<br>        TreeMatcher treeMatcher = new TreeMatcher();<br><br>        HashMap matchedNodes = new HashMap();<br>        if(treeMatcher.match(simpleNode, scope, treeTemplate, matchedNodes)){<br>              //matched<br>              ASTIdentifier theIdentifier = (ASTIdentifier) matchedNodes.get("theIdentifier");<br>        }<br><br> <br><br>   <br>  </small></pre>
   
  <p>   Note how the "name" key was used to mark a child node and then retrieve
  it from the matchedNodes map. For templates with the multi key in them
the   matchedNodes map contains a list of nodes under the name specified
in the   template.</p>
   
  <h3>3.) TreePattern language</h3>
   
  <p>It's not hard to see that constructing the TreeTemplate data structures
  by hand can get tiresome very quickly. An easier method is to define the
 tree templates in a simple and concise language and let a parser construct
 the tree template data structure from a "program" in that language. What
follows is an informal description of the tree pattern language. For a more
detailed and exact definition look at the javacc grammar file (TreePattern.jj)
describing the language.</p>
   
  <p>The lexical tokens of the language include all the javascript literals:<br>
         - strings (supported are both quoting types "foo", 'foo',  just
like  in javascript)<br>
         - numbers<br>
         - true, false, null<br>
         - regular expression literals<br>
   </p>
   
  <p> White-space is the same as in javascript, but no comments are supported.</p>
   
  <p>The reserved words are <i>value</i>, <i>type</i>, <i>name</i>, <i>stop</i>
    , <i>scope</i>, <i>parent</i>, <i>next</i>, <i>previous</i>, <i>local</i>
, <i>global</i> and <i>multi</i>.</p>
   
  <p>The separators are <i>{, }, [, ], (, )</i><i>, : </i>and comma itself. 
  </p>
   
  <p>The operators are <i>=, &lt;,  &gt;, !=, /=,&lt;=, &gt;=, +</i> and
  <i>*</i>.</p>
   
  <p>The grammatical productions are </p>
   
  <table>
     <tbody>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod2">Pattern</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( ( &lt;LPAREN&gt; <a href="#prod3">
 Node</a>
  ( &lt;COMMA&gt; ( <a href="#prod2">Pattern</a>
  )? )* &lt;RPAREN&gt; ) | <a href="#prod3">Node</a>
  )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod3">Node</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">&lt;LBRACE&gt; ( <a href="#prod4">
 FieldList</a>
  )? &lt;RBRACE&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod4">FieldList</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline"><a href="#prod5">Field</a>
  ( &lt;COMMA&gt; ( <a href="#prod5">Field</a>
  )? )*</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod5">Field</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline"><a href="#prod6">FieldKey</a>
         <a href="#prod7">Comparator</a>
         <a href="#prod1">Literal</a>
         </td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;MULTI&gt; <a href="#prod8">
 MExpr</a>
         </td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline"><a href="#prod9">NodeRefKey</a>
  &lt;EQUAL&gt; ( <a href="#prod2">Pattern</a>
  | &lt;NULL&gt; )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;STOP&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;NAME&gt; &lt;COLON&gt; <a href="#prod1">
 Literal</a>
         </td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;SCOPE&gt; &lt;EQUAL&gt; ( 
&lt;LOCAL&gt; | &lt;GLOBAL&gt; )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod6">FieldKey</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( &lt;TYPE&gt; | &lt;VALUE&gt; 
)</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod9">NodeRefKey</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( &lt;PREV&gt; | &lt;NEXT&gt; 
| &lt;PARENT&gt; )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod7">Comparator</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( &lt;EQUAL&gt; | &lt;NEQUAL&gt; 
| &lt;REGEQUAL&gt; | &lt;GT&gt; | &lt;LT&gt; | &lt;LE&gt; | &lt;GE&gt; )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod8">MExpr</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( ( &lt;GT&gt; | &lt;LT&gt; | 
&lt;GE&gt; | &lt;LE&gt; ) &lt;DECIMAL_LITERAL&gt; | &lt;EQUAL&gt; <a href="#prod10">
 MultiEqualFactor</a>
  )</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod10">MultiEqualFactor</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">&lt;DECIMAL_LITERAL&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;PLUS&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;STAR&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><br>
         </td>
         <td align="Center" valign="Baseline">|</td>
         <td align="Left" valign="Baseline">&lt;LBRACKET&gt; &lt;DECIMAL_LITERAL&gt; 
&lt;COMMA&gt; &lt;DECIMAL_LITERAL&gt; &lt;RBRACKET&gt;</td>
       </tr>
       <tr>
         <td align="Right" valign="Baseline"><a name="prod1">Literal</a>
         </td>
         <td align="Center" valign="Baseline">::=</td>
         <td align="Left" valign="Baseline">( &lt;DECIMAL_LITERAL&gt; | &lt;HEX_LITERAL&gt; 
| &lt;FLOATING_POINT_LITERAL&gt; | &lt;STRING_LITERAL&gt; | &lt;TRUE&gt; |
&lt;FALSE&gt; | &lt;NULL&gt; | &lt;REGEX_LITERAL&gt; | &lt;UNTERMINATED_STRING_LITERAL&gt; 
)</td>
       </tr>
     
    </tbody>   
  </table>
   
  <p></p>
   
  <p><br>
    Let's see some examples:</p>
   
  <p>First, the local variable example again:<br>
   <br>
   <b><font color="#3366ff"><small>( { type = 'ASTVariableDeclaration'  , 
scope = local }, { type = 'ASTIdentifier', name : 'theIdentifier',  stop}, 
{multi = *, stop} )  </small></font></b></p>
   
  <p>The last child template basically tells the matcher "match up any remaining 
 - zero or more - children, we're not interested in them". </p>
   
  <p>Here's a more complex example: we want function declaration nodes that 
 have between 2 and 5 formal arguments and that represent functions named
 "foo":</p>
   
  <p><b><small><font color="#3366ff">( {type='ASTFunctionDeclaration'},  {type='ASTIdentifier',
value='foo'},  ( {type= 'ASTFormalArgumentList</font></small></b><b><small><font color="#3366ff">
    '}, {multi=[2,5]</font></small></b><b><small><font color="#3366ff">,
stop}   ),  {type='ASTBlock'</font></small></b><b><small><font color="#3366ff">
  , stop})</font></small></b></p>
   
  <p><b><small><font color="#3366ff"><br>
   </font></small></b></p>
   
  <h3>4.) Multi</h3>
    A word about the quantifier specification used with key <i>multi</i>.<br>
   <br>
    The tree matcher doesn't use a backtracking algorithm to resolve <i>multi</i>
     constraints, instead it uses a greedy behavior and matches as many child
  nodes as possible to the current child template that has a <i>multi</i>
 key,  and then proceeds to the next child template (it is a little more
intelligent than that, if the multi constraint for the current child template
has been met it tries to leave a minimum amount of children for the following
templates). That means that one has to be a little careful when specifying
patterns with   <i>multi</i> in them. <br>
   <br>
    A good rule of thumb to deal with the present tree matcher is to define 
 as detailed as possible each child node template that has <i>multi</i> quantifiers.
  That minimizes the possibility of ambiguous mappings of children to child
  templates.<br>
   <br>
   <br>
   <br>
   <br>
   
  </body>
  </html>
