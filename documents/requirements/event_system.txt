Event System Requirements
=========================

:Author: Alex Russell
:Version: 0.1
:Copyright: Alex Russell, 2004
:Date: $Date:$

.. contents::

Purpose
-------

This document outlines the rationale and usage scenarios for the Dojo event
system.

Requirements
------------

DOM Events
**********

In a browser or SVG rendering environment, notification of user-driven
interaction will be received by the system from DOM nodes, whose event model
is outlined in the  `W3C DOM Event specification`_. Unfortunantly, the level of
standards compliance among Dojo-supported rendering contexts is something of a
crap-shoot, with some browsers and engines supporting all of the DOM 2 Events
spec, with others supporting some mix of DOM 0 and DOM 1 eventing. Even when
DOM 1 or DOM 2 Event support is implemented, it tends to be partial, with
proprietary interfaces filling in the gaps. Additionally, standard methods of
programmatic attachment to event handlers can induce memory leaks which are
difficult or impossible to track down.

This state of affairs crys out for abstraction.

In order to understand what we should build, we should explore the common usage
idioms for DOM event handling and come to a more complete picture of what the
developer _wants_ to do and contrast that with developers today are forced to
do. Out of this exercise, an idealized API for abstracing DOM Events should be
determined.

DOM Event Usage
###############

It is a common scenario that a user will want to attach an event handler (a
function that is called when an event fires) to a DOM node. For instance, to be
notified when a user clicks on a node, this is how assignment is typically done::

    function alertMe(){
        alert("item clicked");
    }

    var node = document.getElementById("testNode");
    node.onclick = alertMe;

This method of attachment allows the programmer to be informed when the user
interacts with the system, and this method of attachment works universally. The
obvious drawback to this method is that it does not allow multiple functions to
be informed of the action. Additionally, DOM events follow a bubbling model
which allows many events to be "cancled" after being intercepted by an event
handler assigned to a node. Being able to support cancelability is a large
requirement for any acceptable DOM event handling abstraction (if one is used).
Several approaches are available:

- create a callback system where one event handler can create multiple calls::
    
    // callbackHandler class
    function callbackHandler(node, eventname){
        this.callbackList = [];

        this.addCallback = function(object, functionPointer){
            this.callbackList.push([object, functionPointer]);
        }

        // this.rmCallback is not implemented here for simplicity

        this.call = function(){
            var args = [];
            for(var x=0; x<arguments.length; x++){
                args.push(arguments[x]);
            }

            for(var y=0; y<this.callbackList; y++){
                this.callbackList[y][1].apply(this.callbackList[y][0], args);
            }
        }

        this.wrapNodeCaller = function(node, eventname){
            node[eventname] = function(evt){ this.call(evt); }
        }

        if((node)&&(eventname)){
            this.wrapNodeCaller(node, eventname);
        }
    }

    var node = document.getElementById("testNode");
    var cbh = new callbackHandler(node, "onclick");

    function alertMe(){
        alert("item clicked");
    }
    cbh.addCallback(null, alertMe);
    cbh.addCallback(null, alertMe);
    // now when node.onclick is fired, we'll get alerted twice

- use or abstract away the differing methods used to do multiple-listener attachment::

    var node = document.getElementById("testNode");

    function alertMe(){
        alert("item clicked");
    }

    if(node.attachEvent){
        node.attachEvent("onclick", alertMe);
    }else if(node.addEventListener){
        node.attachEvent("click", alertMe, false);
    }

- determine a new, more abstract method for handling DOM Events. This API
  should be able to capture the semantics of what DOM events _should_ support
  as well as a method for synthesizing higher-order event types from
  lower-level events where this is required (e.g.: drag-and-drop on browsers
  which do not natively support this). 
  
  Breifly, the features that need to be supported by any such API would have to
  include:
    
    + allow multiple listeners for any event

    + allow listeners to "cancel" the bubbling of any event

    + handle keystroke events in a uniform way

    + provide higher-order event types to listen for (e.g., drag-and-drop)

    + allow for simple debugging and logging of events and their
      listeners/targets

    + provide the ability to modify the arguments passed to the listener, or
      "chain" listeners in a way that allows it

    + must not require that listener functions/methods conform to a particular
      call signature

    + must be able to make available to a listener all of the relevant
      information relating to an event (either in the calling context, or as an
      argument to the method/function)

  Ideally, all of the above functionality should be made available in such a
  way as to require a minimum of syntax until such time as an option is set to
  something other than its default value. Default values should be determined
  by what a developer does most often.

  Antecedent event handling systems in `nWidgets`_ and `f(m)`_ have provided
  methods for dealing with most of the of the above requirements, however each
  falls down in at least oen one way. The event system in `nWidgets`_ provides
  the ability to mangle function arguments, set defaults, and otherwise adapt
  the call from the event handler to match the expected call signature of the
  listener. Unfortunantly, the keystroke handling and bubbling handling in the
  `nWidgets`_ event system leave much to be desired. Likewise, keystroke event
  handling and drag-and-drop are not unifieid with the general event system,
  and instead rely on synthetic event types to be "thrown" from a global
  environment object. Since the event system in `nWidgets`_ is a hybrid between
  "normal" DOM event methods and a generic non-DOM event interface, some peices
  of necessaray plubming for DOM-specific attributes is unwisely re-created in
  differing ways in differing places.

  The event system in `f(m)`_, on the other hand, does a wonderful job of
  unifying the handling idiom for keystroke and other types of events.
  Likewise, it solves problems with bubbling and cancelation and allows
  multiple listeners but does impose a particular function signature onto
  listeners.

  The `burst`_ toolkit, on the other hand, avoids the creation of a unified or
  abstract event handling system, preferring to provide a standards-like API
  for setting up event listener registration. An advantage of this approach is
  that the idiom is familiar to those who know how to use the standard DOM.
  Similarly, it manages cross-frame context (which neither `f(m)`_ nor
  `nWidgets`_ explicitly handle). Where known problems with a particular
  browser environment are known, `burst`_ attempts to provide a uniform
  interface, spending some effort to correctly assign properties on DOM event
  objects which may not be present due to proprietary stopgaps extant in some
  browsers (*cough* IE *cough*).

.. _W3C DOM Event specification: http://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/
.. _nWidgets: http://nwidgets.org
.. _f(m): http://fm.dept-z.com
.. _burst: http://burstproject.org

Non-DOM Events
**************

Many types of "events" happen within a modern application. Very often, these
events (sometimes called "messages") happen as a second- or third-order
consequence of some user action. Loosely coupled system components should
therefore attempt to define only interfaces for these events or messages and
then allow the application author to stich them togeather in whatever manner is
most 

.. vim:ts=4:et:tw=0:shiftwidth=4:
