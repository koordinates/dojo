dojo.io.bind(): baking usability into XMLHTTP
=============================================

:Author: Alex Russell
:Version: 0.1
:Copyright: Dojo Foundation, 2005
:Date: 2005/03/09

.. contents::

Less "me too", more working code
----------------------------------

The Dojo project is seeking to build the best DHTML toolkit available, hands
down. Part of that effort includes paying attention to many of the neglected
and unpolished sharp edges of the DHTML programming and user experience. Over
the last several months, it's been hard not to notice the parade of fawning
articles about one particular part of the DHTML asynchronous IO toolbox: the
XMLHTTP object.  Some of the published information includes code, and some of
that code is even OK (a big change for DHTML articles). Unfortunantly, so far,
users of this code are left out on their own when it comes down to solving the
usability problems that come along with XMLHTTP. 

Dynamic, but at what price?
---------------------------

What usability problems?

Consider, for a moment, that most painful of topics for web application
developers: the back button. With a bit of copy-and-paste, a decent DOM
reference, and a lot of perserverence it's possible to build out a pretty
decent dynamic UI. One that doesn't jarringly destroy the user's in-page
experience for the most trivial of tasks (e.g.: adding an item to a list,
etc.), but when larger portions of an application are mediated in this way
(say, switching between a view and edit mode) the user naturally has more
desire to "go back" to some earlier state if things aren't working out the way
they had planned or if the action isn't what they expected.

As high-gloss web applications emerge, more and more of the interactions become
intra-page and not inter-page actions, which means that if the back button
doesn't function in a way that helps the user, more and more work can
potentially be lost from the user's perpsecitve when they hit the back button
and it returns them to the login screen (and not to the previous major UI
component that they were expecting). This is exactly the style of interface
construction that Dojo contributors (and others in the DHTML community) have
been advocating for years. The upside is that more developers now see this as a
feasible and pagmatic way to build interfaces. The downside is that their
weapon of choice (or ignorance), XMLHTTP, doesn't create a back-button entry.
In short, XMLHTTP breaks the back button.

If the situation with the back button has the potential to confound users, the
inability to bookmark or otherwise reference a "screen" is downright maddening.
Applications that dyanmically construct large sections of the UI (like Google
Maps) today resort to a link in an intermediate screen that the user can click
to return to their current state (and then, perhaps, bookmark) if and when they
consdier the "bookmarkability" problem at all. More common is an app that
simply refuses to acknowledge that the user might want to pass around a URL to
a friend and instead builds some heavyweight and non-standard state
serialization mechanism that is more akin to a desktop app's "save as" feature.
"Save-as" on the web is bookmarking, and usable apps recognize this (even if
they don't have great solutions for it today). Regardless of what serialiation
mechanism is in use, being able to represent the state of the app in a URL (or
a marker for serialized state) is a must. As is true to form, XMLHTTP doesn't
provide any solution to this problem either.

Introducing dojo.io.bind()
--------------------------

At Dojo, we're comitted to making DHTML applications usable, both for authors
and for users, and with a lot of help from our friends (big shout out to Aaron
Boodman of Google and Mark Anderson of Dojo) we have come up with solutions to
the usability problems outlined above. We're providing it in a single, easy to
use API and a package that requires only two files to function.

But first, a brief introduction to the ``bind()`` method. ``dojo.io.bind()`` is
a generic asynchronous request API that is provided Dojo to warp multiple
transport layers (queues of iframes, XMLHTTP, mod_pubsub, LivePage, etc.). Dojo
attempts to pick the best available transport for the request at hand, and in
the provided package file, only XMLHTTP will ever be chosen since no other
transports are rolled in. The API accepts a single anonymous object with known
attributes of that object acting as function arguments. To make a request that
returns raw text from a URL, you would call ``bind()`` like this::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.txt",
        load: function(type, data, evt){ /*do something w/ the data */ },
        mimetype: "text/plain"
    });

That's all there is to it. You provide the location of the data you want to get
and a callback function that you'd like to have called when you actually DO get
the data. But what about if something goes wrong with the request? Just
register an error handler too::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.txt",
        load: function(type, data, evt){ /*do something w/ the data */ },
        error: function(type, error){ /*do something w/ the error*/ },
        mimetype: "text/plain"
    });

It's possible to also register just a single handler that will figure out what
kind of event got passed and react accordingly instead of registering separate
load and error handlers::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.txt",
        handle: function(type, data, evt){
            if(type == "load"){
                // do something with the data object
            }else if(type == "error"){
                // here, "data" is our error object
                // respond to the error here
            }else{
                // other types of events might get passed, handle them here
            }
        },
        mimetype: "text/plain"
    });

One common idiom for dynamic content loading is (for performance reasons) to
request a JavaScript literal string and then evaluate it. That's also baked
into ``bind``, just provide a different expected response type with the mimetype
argument::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.js",
        load: function(type, evaldObj){ /* do something */ },
        mimetype: "text/javascript"
    });

And if you want to be DARN SURE you're using the XMLHTTP transport, you can
sepcify that too::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.js",
        load: function(type, evaldObj){ /* do something */ },
        mimetype: "text/plain", // get plain text, don't eval()
        transport: "XMLHTTPTransport"
    });

Being a jack-of-all-trades, ``bind()`` also supports the submission of forms via a
request (with the single caveat that it won't do file upload over XMLHTTP)::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.js",
        load: function(type, evaldObj){ /* do something */ },
        formNode: document.getElementById("formToSubmit")
    });

Phew.Think that about covers the basics. Good thing you weren't planning on
implementing all that stuff yourself, right?

So, about that thorny back button...
------------------------------------

None of the examples so far would have caused anything but the default
(sometimes undesireable) behavior to occur if the user subsequently hit the
back button. In a lot of applications with small interactions, it might never
transpire that one would want the back button to be intercepted. One could
happily build an app using ``dojo.io.bind()`` without ever knowing or caring
about bookmarking or the back button, but if you're reading this, the odds are
that you care. So here we go.

First, a note on browser support: all of the following techniques work on IE
and Mozilla/Firefox, but Safari is, sadly, a lost cause. That doesn't mean your
requests won't send correctly, but it does mean that the forward and back
buttons aren't interceptable. Even when Safari SHOULD support it,
implementation bugs in the browser prevent our code from doing the right thing.
This is, needless to say, really annoying.

For that great majority of browsers that can be supported, catching the back
button simply requires registering a callback that will fire when the user hits
the back button. Here's the above form submitting example that does a rollback
of the form-hide behavior when the back button is clicked::

    var sampleFormNode = document.getElementById("formToSubmit");

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.js",
        load: function(type, evaldObj){ 
            // hide the form when we hear back that it submitted successfully
            sampleFormNode.style.display = "none";
        },
        backButton: function(){ 
            // ...and then when the user hits "back", re-show the form
            sampleFormNode.style.display = "";
        },
        formNode: sampleFormNode
    });

That's it. Just provide that extra backButton argument and your users can now
hit the back button and count on your app doing something smarter than
destroying their work (with a little help from you, that is).

This naturally leads to the next question: what happens if they hit the forward
button after that? Without any intervention on your part, nothing. But, as I'm
sure you've come to expect by now, Dojo gives you a hook to handle that
situation as well.::

    var sampleFormNode = document.getElementById("formToSubmit");

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.js",
        load: function(type, evaldObj){ 
            // hide the form when we hear back that it submitted successfully
            sampleFormNode.style.display = "none";
        },
        backButton: function(){ 
            // ...and then when the user hits "back", re-show the form
            sampleFormNode.style.display = "";
        },
        forwardButton: function(){ 
            // and if they hit "forward" before making another request, this
            // happens:
            sampleFormNode.style.display = "none"; // we don't re-submit
        },
        formNode: sampleFormNode
    });

Note that forward button triggers are *only* fired when the user is linearly
progressing between the forward and back buttons. If the user takes an action
after going back-back-forward that would fire a new ``bind()`` request, the
next "forward" will have no callback fired from it since a new branch in the
history tree has been created and the old one is likely invalid.

Bookmarking
------------------------------------

Bookmarkability is a really big issue for web apps. Apps that don't have it are
at a huge dissadvantage to those that do. That's just how it is.

With that in mind, ``dojo.io.bind()`` gives you one last little bit of control
for making things bookmarkable. Simply pass in the value "true" to the flag
"changeURL".  Here's the obligitory example::

    dojo.io.bind({
        url: "http://foo.bar.com/sampleData.txt",
        load: function(type, data, evt){ /*do something w/ the data */ },
        changeURL: true,
        mimetype: "text/plain"
    });

Once the request is fired off, you will be able to read the new URL from
window.location.href (I usually do this in the load() method). A more elegant
way of infoming the server of the saved-as URL other than a new request is
still needed, but for now, this works and it's enough to be functional.

Unfortunantly, attempting to change the URL synchronously when the request is
fired isn't possible because of timing issues on Mozilla/Firefox. You are
advised to report your saved-as URL to the server (if that's necessaray) from
the load() or error() methods you provide.

Bookmarkability WILL interact with other inter-page navigation using named
anchors, but should NOT change the location of the user's scroll position in
the viewport. You are advised to test this functionality pretty thoroughly
before deploying.

Technical Discussion
------------------------------------

If you're not a DHTML hacker or don't want to know how sausage is made, you
might want to skip this.

There's a lot of black magic, browser-specific foo, and general hackery
rumbling around in this code. On IE, setting the hash of the URL doesn't affect
the back-button history, and so an iframe request is required along with a
bookmarkable request. On Mozilla, a back-button request is created, but no
events fire when back and forward are pressed, so a timer is required to watch
the value of location.href. On both browsers, detecting iframe loading requires
two queues to differentiate forward from back buttons, and the iframe MUST be
part of the intial document (in this case, created w/ document.write) since
dynamically created iframes *don't affect the history*. Likewise, it was
somewhat painful to determine what kind of anchor setting would work for
creating back-button entries but not change the scroll position in the
top-level viewport. It's almost painful to think of how many hours were burned
in determining exactly what does and doesn't work. There are, in fact, several
areas of the described APIs in which there might be nagging bugs, so please
report them if things don't behave as expected.

In short, this is exactly the kind of "don't try this at home"
cross-browser hell that turned people off from DHTML in the first place.

Remainders
----------

Usability != Accessability
##########################

The techniques discussed in this article are NOT intended to provide you with a
solution for accessaiblity concerns for your web apps. You still need to hammer
those out for yourself (although Dojo will soon be providing help in that area
too). If you want to flame the author for discussing usability without
discussing the negative accessabitliy impact of these tools, go right ahead,
but please consider that the author already has a good idea of what you're
going to say and he's already working on tools to make the situation better.
Flaming won't get those tools done any faster, though.

What's In the Package
#########################

This article is part of a "profile build" of Dojo that includes a single-file
distribution of the Dojo core (for HTML environments), the required
"blank.html" file used for generating back-button entries, a test page that
demonstrates usage of the API, and this article. Dojo does a LOT more than this
package might lead you to suspect, but don't worry, we'll be releasing more
soon.

What's Not
#########################

Dojo consists of much more functionality than this package exposes (in fact,
this package includes much more than is being discussed. No widget classes, xml
parsing, or generic event system code are included in this build, although all
of those things are functional in Dojo subversion.

About Dojo
#########################

Dojo: take two, they're small.

Getting Involved with Dojo
##########################

Comitters to Dojo are currently an invite-only group, but that doesn't mean it
can't include you. If you'd like to contribute to the future of Dojo and
responsive web applications, do something that impreses us (either with Dojo,
or with JS/DHTML/DSVG in general). Our license is intentionally non-political
(Academic Free License 2.1) and we support your use of Dojo in software that's
licensed in other ways, but will not accept differently-licensed patches. We're
not trying to be exclusive, just productive.

About The Author
#########################

Alex Russell is just a guy. You can flame him on various topics at
<alex@dojotoolkit.org>.

.. vim:ts=4:et:tw=0:shiftwidth=4:
