Fast Widget Authoring With Dojo
===============================

:Author: Alex Russell
:Version: 0.3
:Copyright: Dojo Foundation, 2005
:Date: 2005/05/02

.. contents::
	
Example
-------
	
.. start with a widget example

Intro
----------------------------------

A key feature of the Dojo widget system is the ability to prototype, test, and 
tweak the component's UI and interactions.  Dojo provides "templates" that you 
can use to rapidly prototype your UI in HTML and CSS and expose your widgets as 
markup on the pages you include them on.  Dojo also ensures that your prototype
isn't throw-away code by providing simple strategies for moving from development
to deployment that improve performance incrementally.


Prototype 
---------

Templates in Dojo place HTML and CSS fragments into files which are consulted
when a widget is constructed. The setup of event handlers and the creation of
references to DOM nodes is handled through some extra attributes on your HTML
markup.

Here's the minimum code to define a Dojo widget that uses a template::

    dojo.hostenv.startPackage("dojo.webui.widgets.HTMLTestWidget");
    dojo.hostenv.loadModule("dojo.webui.DomWidget");

    dojo.webui.widgets.HTMLTestWidget = function(){
        // mix-in inheritance. Order matters.
        dojo.webui.Widget.call(this);
        dojo.webui.DomWidget.call(this, true);
        dojo.webui.HTMLWidget.call(this);

        // templates
        this.templatePath = "src/webui/widgets/templates/HTMLTestWidget.html";
        this.templateCSSPath = "src/webui/widgets/templates/HTMLTestWidget.css";

        this.widgetType = "TestWidget";
    }

    // prototype inheritance
    dj_inherits(dojo.webui.widgets.HTMLTestWidget, dojo.webui.DomWidget);

Almost everything about this file is boilerplate code, and only the properties
that are absolutely necessary are set on the class
`dojo.webui.widgets.HTMLTestWidget`. Every Dojo widget you'll create comes from 
a constructor function like the one outlined here.

The non-stock bits of the above example are the  `template*` properties.
Template locations are specified relative to the root of the Dojo Subversion 
checkout, and these are made absolute (if necessary) when the widget is created.
Meaning that you don't have to specify an un-portable absolute URL for your
template files and you can move your widget file around without adverse 
consequences.

Dojo currently requires that templates have a single root node which gets 
assigned to the `domNode` property of the widget.  This property is defined in 
the `DomWidget` class, so every widget that inherits from it will have this 
property implicitly. So the most minimal template files possible might look
like this:

HTMLTestWidget.html::

    <span class="testWidget">a test widget!</span>

HTMLTestWidget.css::

    .testWidget {
        border: 1px solid black;
    }

That's it. A test page that includes the widget could now instantiate this UI
at any point in the page by adding extra attributes to any tag::

    ...
    <p dojoType="TestWidget">
        this is going to get replaced with the test widget
    </p>
    ...

Dojo allows you to (optionally) use markup *on both sides* of the widget
creation and use process. Thus you can quickly prototype your widget with markup
and declare it in your page with markup or with JavaScript.

Connect 
-------

The example above isn't very functional. A couple of key components are missing:

    1. the widget doesn't respond to user interaction
    2. the widget isn't populated with data

In HTML widgets, a user's actions are sent to the script as DOM events. As a 
programmer, you can receive notification of low-level UI changes, such as when
the user clicks on an element, but these events don't tell you anything 
high-level. To do that, we need to catch low-level DOM event(s) and connect 
them to functions or object methods that will actually handle a higher level 
interaction. It's not uncommon to see example code like::

    someNode.innerHTML = "<span onclick='calculate(); show();'>foo</span>";

There's a lot wrong with this code. A Dojo template might accomplish the same 
thing with some improvements. Firstly, we'd probably make `calculate()` and
`show()` methods of our widget class and not global functions, like this::

    dojo.webui.widgets.HTMLTestWidget = function(){
        // ... see previous examples for the code that goes here

        this.calcDisplayNode = null;

        this.result = 0;
        
        this.calculate = function(){
            this.result++;
        }

        this.showResult  = function(){
            this.calcDisplayNode.value = this.result;
        }

        this.calculateAndShow = function(){
            this.calculate();
            this.showResult();
        }
    }

Then, to connect it to our template, Dojo provides a shorthand attribute syntax.
The modified template code from HTMLTestWidget.html::

    <span class="testWidget">
        <p>a test widget!</p>
        <p dojoAttachEvent="onClick: calculateAndShow;">
            click here to perform calculation
        </p>
        <input type="text" value="not set" 
            dojoAttachPoint="calcDisplayNode" />
    </span>

Note the `dojoAttach*` attributes. The widget and the template do not explicitly
say anything like::
    
    widgetObj.calcDisplayNode = document.getElementById("...");

Instead, Dojo's `dojoAttachPoint` attribute accomplishes the same result. If the
value of this property is the name of a property on the widget  then the value
of that property is set to be a reference to that DOM Node.  So withing 
dojo.webui.widgets.HTMLTestWidget, we can simply refer to the following to get 
a handle to the calcDisplayNode::

    this.calcDisplayNode

The remaining issue is connecting event handlers through the `dojoAttachEvent` 
property.  Analogous to `dojoAttachPoint`, `dojoAttachEvent` provides a 
straightforward way to separate the DOM structure of a widget from
its programmatic behavior. In our example, we want the widget method
`calculateAndShow` to be called when the second paragraph is clicked. If you 
want to change the node or event that causes the recalculation, just change the 
location or value of `dojoAttachEvent`. For instance, exchange the above 
template with the following::

    <span class="testWidget">
        <img src="foo.gif" dojoAttachEvent="onMouseOver: calculateAndShow;" />
        <input type="text" value="not set" 
            dojoAttachPoint="calcDisplayNode" />
    </span>

Now the mouseover handler of the image tag quickly increments the value. No 
changes to the widget code were required except perhaps to point to a different 
template file.

Benefits of this style of event handler attachment:

- widget authors get to focus on what their widget is supposed to *do*
- de-emphasize on (re)wiring event handlers.
- widget functionality and template layout to be changed pretty independently
- cleaner, easier to maintain, and faster to write
- quickly prototype new templates for your widget by changing the value of the 
  `templatePath` property and have it be functional without any widget code 
  changes.

Making It A Tag
---------------

The last hurdle to making this widget something we'd consider working with is
to make it easy to instantiate. The easiest way to do this with Dojo is to make
your widget a tag . To do this in `HTMLTestWidget.js`, we'd add the following 
line at the very end of the file::

    dojo.webui.widgets.tags.addParseTreeHandler("dojo:testWidget");

We saw a brief example of this at the beginning of the article, but here's a refresher example of a Dojo inline constructor::
    
    <span dojoType="testWidget">this will get replaced</span>

Adding these extra attributes to elements in the page allows you to
instantiate as many separate widgets as you like. So you don't have to worry 
about problems like unique naming or hard-coding the number and type of widgets
you want to use.

Inline constructors also provide for us a way of setting data for a widget
instance.  For example, to set the initial value of our counter to be
something other than 0::

    <span dojoType="testWidget" result="15">
        this will get replaced
    </span>

The `result` property of our widget will now be initialized to 15. An obvious
improvement is to display our default (or over-ridden) value when the widget is
created. Here's the full source code for `HTMLTestWidget.js` so far, including
the `fillInTemplate` method to handle this improvement::

    dojo.hostenv.startPackage("dojo.webui.widgets.HTMLTestWidget");
    dojo.hostenv.loadModule("dojo.webui.DomWidget");

    dojo.webui.widgets.HTMLTestWidget = function(){
        // mix-in inheritance. Order matters.
        dojo.webui.Widget.call(this);
        dojo.webui.DomWidget.call(this, true);
        dojo.webui.HTMLWidget.call(this);

        // templates
        this.templatePath = "src/webui/widgets/templates/HTMLTestWidget.html";
        this.templateCSSPath = "src/webui/widgets/templates/HTMLTestWidget.css";

        this.widgetType = "TestWidget";

        this.calcDisplayNode = null;

        this.result = 0;
        
        this.calculate = function(){
            this.result++;
        }

        this.showResult  = function(){
            this.calcDisplayNode.value = this.result;
        }

        this.calculateAndShow = function(){
            this.calculate();
            this.showResult();
        }

        this.fillInTemplate = function(){
            // show the initial value after we first get built
            this.showResult();
        }
    }

    // prototype inheritance
    dj_inherits(dojo.webui.widgets.HTMLTestWidget, dojo.webui.DomWidget);
    dojo.webui.widgets.tags.addParseTreeHandler("dojo:testWidget");

So Dojo allows you to set arbitrary properties via your inline constructor 
within some limits:
	
- the property must be a member of the widget in order for it to be settable via   
  the inline constructor
- there are some limits for type-conversion

For instance, properties that have a numerical initial value cause the value  
passed by the constructor to be converted to a number before being assigned.  
Array values are converted by splitting on the semi-colon character and  
assigning an array of resulting strings. If we had given the `HTMLTestWidget` 
class an array property named `foo` initialized to an empty array it would be 
settable like this::

    <span dojoType="testWidget" foo="foo;bar;baz"></span>

And the resulting value would be::

    ["foo", "bar", "baz"]

If you want integers instead, you would have to convert them before using the 
values from this array.

Assigning to functions is subtly different, but no harder. Dojo includes an
abstract event system that should be familiar to those who have used Aspect
Oriented Programming (AOP). In a nutshell, this event system allows a developer
to "register" some code to be called when another function is called without
affecting the behavior of the initial function that is being used as the
trigger. Assigning to a function property in an inline constructor allows us to
likewise register a listener, but not to over-ride the default behavior of the
widget method. For instance, if we had the following method as a part of the
`HTMLTestWidget` class::

    // ...
    this.increment = function(){
        this.result++;
    }
    // ...

We could then add code that would nullify the behavior of the function like
this::

    <span dojoType="testWidget" increment="this.result--;">
    </span>

Note that the `this` keyword refers to the *widget object* and not the DOM
Node. Given these declarations, the result of calling `increment()` would
*NOT* be a decrement, but rather `this.result` would have the *SAME* value as
before `increment()` was called. Our handler code fires after the base function,
but before any other code that might be looking to act on the result.

Armed with this information, authors can create widgets that receive data from
widget users and easily change the look and feel of their widget!

More Information
----------------

`Dojo Status`_
`Problems tackled by the Dojo widget system`_

About The Author
#########################

Alex Russell is a core contributor to Dojo.  can be reached at
<alex@dojotoolkit.org>. His blog is at: http://alex.nWidgets.com

.. _`Dojo Status`: http://www.dojotoolkit.org/projectStatus.html
.. _`Problems tackled by the Dojo widget system`: http://www.dojotoolkit.org/widget_motivation.html

.. vim:ts=4:et:tw=0:shiftwidth=4:
