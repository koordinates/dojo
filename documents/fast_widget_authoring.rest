Fast Widget Authoring With Dojo
===============================

:Author: Alex Russell
:Version: 0.1
:Copyright: Dojo Foundation, 2005
:Date: 2005/04/18

.. contents::

Intro
----------------------------------

The Dojo project is working to build a modern, capable, "webish", and easy to
use DHTML toolkit. But what does "easy to use" mean? And easy to use for who?
That's a big question, and one which the project is attempting to answer by
introducing multiple points of entry into the code. What that means is that it
shouldn't matter whether you just want to use a widget or an API, build widgets
and APIs with Dojo, or hack on the core of Dojo itself: you should be able to
do all of those if you want to. This article is targeted at the group of people
who want to build and use widgets or "AJAX components" in their applications.

In order to make it simpler for the "average IT developer" to build better UIs,
Dojo first has to make easier for the people that build the tools they use to
construct better components faster. Given the time constraints and volititility
of specs in the average web app project, simplifying the creation and
maintenance of these components is of paramount importance. Until now,
developers building DHTML UI components have either had to rely on
hard-to-maintain innerHTML techniques or verbosely construct UI components one
node at a time with document.createElement() calls. Given these unappealing
options, most developers punt and scramble back to the relative sanity of the
server-side.

This article takes a deeper look at the status quo, proposes a hybrid way of
constructing UI components, and discuss the APIs and tools that Dojo provides
today to implement this new approach.

The Workflow Problem
----------------------------------

So it's hard, fine, but that's an invitation for a clever solution not a reason
to give up. Cross-browser issues aside, there are practical considerations of
usage and construction of components. Those who go the innerHTML route soon
find themselves building huge string variables and dealing with all manner of
string encoding issues. Worse, they quickly find out how sub-optimal it is to
attach programmatic logic to the newly built elements. What good is getting a
reference to a DOM node that could be blown away the next time your need to
repaint the UI in response to user input? Things go downhill from there.

The other side of the fence is the "clean" method of programmatically
constructing the UI with pure DOM manipulation in JavaScript. This is the
approach that toolkits like DomAPI and nWidgets take (for the most part). While
functional and avoiding most escaping issues, this approach carries with it
reduced productivity on the part of the widget author. It's so verbose and time
consuming to build UIs this way that once your widget or component works, the
last thing you ever want to do is change it's DOM structure. Didn't we move to
the web to get *away* from building UIs this way?

The DOM-only approach also doesn't fit well into the basic workflow of UI
development for web applications. Regardless of what system winds up building
the markup/DOM that the user interacts with, the procedure for developing
look, feel, and interaction design of an application almost never happens in
code. More likely, creative professionals will design the system they'd like to
see, and if the developer is lucky, will hand over (machine generated) HTML
with the final design (and when was the last time that a "final" design was
actually final, anyway?). Whether the deliverable from the interaction design
process is markup or slide-ware, the job of turning that design into a
functioning system falls to a web development professional. Regardless of
whether or not they've been handed slide-ware, the first step for this person is
almost always to prototype the UI is good markup and CSS.

This is a tremendously important point. Markup, it turns out, is perhaps the
fastest way to build a static representation of a UI for programmers and
designers alike. Classic desktop GUI toolkits are starting to adapt (GTK+ and
QT) or die (MFC will some day be replaced by XAML, Mozilla uses XUL now, etc.).
Said another way, markup has, for better and for worse, democratized the GUI
construction process.

Today, UI designers don't generate sequences of DOM commands for building a UI,
they build HTML or Photoshop mock-ups, and then hand it off to a developer to
"make it real". At this point, it's the component author's job to translate
that into a functioning, reusable, degradable component. Doing it the DOM way
is admirable, but given the costs, often misguided. The design process demands
flexibility, re-usability, and a hundred and one special cases in order to match
the user's mental model to the actual behavior of the system.

With Dojo, we are adopting a technique for the fast prototyping and development
of GUI components in HTML environments that was first introduced in the
netWindows toolkit but has never been given much discussion or attention. The
method we outline allows component authors to continue to realize the
advantages of HTML and CSS markup for creating the initial state of widgets
while maintaining the advantages of direct DOM manipulation for
post-initialization changes a component's look and feel.

Prototype 
---------

So you've been handed an image or HTML and CSS from a designer. Wouldn't it be
great if you could prototype, test, and tweak the component's UI and
interactions without sinking a ton of time into the project? Wouldn't it also
be nice if you could easily change the location of and arguments to your widgets
without tons of JavaScript in your prototype pages? Dojo can help by providing
"templates" that you can use to rapidly prototype your UI in HTML and CSS and
by exposing your widgets as markup on the pages you include them on. And when
your boss says "great, lets ship it!", Dojo also ensures that your prototype
isn't throw-away code by providing simple strategies for moving from
development to deployment that improve performance incrementally.

Templates in Dojo place HTML and CSS fragments into files which are consulted
when a widget is constructed. The setup of event handlers and the creation of
references to DOM nodes is handled through some extra attributes on your HTML
markup.

Lets looks the most minimal code for a stock HTML-only widget in Dojo::

    dojo.hostenv.startPackage("dojo.webui.widgets.HTMLTestWidget");
    dojo.hostenv.loadModule("dojo.webui.DomWidget");

    dojo.webui.widgets.HTMLTestWidget = function(){
        // mix-in inheritance. Order matters.
        dojo.webui.Widget.call(this);
        dojo.webui.DomWidget.call(this, true);
        dojo.webui.HTMLWidget.call(this);

        // templates
        this.templatePath = "src/webui/widgets/templates/HTMLTestWidget.html";
        this.templateCSSPath = "src/webui/widgets/templates/HTMLTestWidget.css";

        this.widgetType = "TestWidget";
    }

    // prototype inheritance
    dj_inherits(dojo.webui.widgets.HTMLTestWidget, dojo.webui.DomWidget);

Almost everything about this file is boilerplate code, and only the properties
that are absolutely necessary are set on the class
`dojo.webui.widgets.HTMLTestWidget`. You read that right: JavaScript has
classes and inheritance, and Dojo makes extensive use of them. Every Dojo
widget you'll create comes from a constructor function like the one outlined
here.

The non-stock bits of the above example are the  `template*` properties. Lets
look at those for a second. The properties that specify template locations are
relative to the root of the Dojo Subversion checkout, and these are made
absolute (if necessary) when the widget is created. This way, you don't have
to specify an un-portable absolute URL for your template files and you can move
your widget file around without adverse consequences. Handy, that.

So what could be in our template files? Currently, Dojo requires that templates
have a single single root node which gets assigned to the `domNode` property of
the widget.  This property is defined in the `DomWidget` class, so every widget
that inherits from it will have this property implicitly. So lets see what the
most minimal template files possible might look like.

HTMLTestWidget.html::

    <span class="testWidget">a test widget!</span>

HTMLTestWidget.css::

    .testWidget {
        border: 1px solid black;
    }

That's it. A test page that includes the widget could now instantiate this UI
at any point in the page by adding extra attributes to any tag, like this::

    ...
    <p dojoType="TestWidget">
        this is going to get replaced with the test widget
    </p>
    ...

Dojo allows you to (optionally) use markup *on both sides* of the widget
creation and use process. What good would it do to allow you to quickly
prototype your widget with markup and then force you into using JavaScript to
declare it in your page?

Connect 
-------

The example above isn't very functional. A couple of key components are missing:

    1. the widget doesn't respond to user actions in any way
    2. the widget isn't being populated with developer-provided data

The first problem is the easiest to solve when using Dojo. In HTML widgets, a
user's actions are sent to the script as DOM events. As a programmer, you can
receive notification of low-level UI changes, such as when the user clicks on
an element, but these event's don't tell you anything more high-level like "the
user wants you to calculate a complex result and show it to him". To do that,
we need to catch the low-level DOM event we are concerned with and connect it
to a function or object method that will actually handle the calculation. And
this assumes you're using good style, which most DHTML programmers don't. In
fact, it's not uncommon to see lots of example code that's littered with thing
like::

    someNode.innerHTML = "<span onclick='calculate(); show();'>foo</span>";

Now, there's a lot wrong with this code, but lets just look at how a Dojo
template might accomplish the same thing. First, lets assume that calculate()
and show() are methods on our widget object, like this::

    dojo.webui.widgets.HTMLTestWidget = function(){
        // ... see previous examples for the code that goes here

        this.calcDisplayNode = null;

        this.result = 0;
        
        this.calculate = function(){
            this.result++;
        }

        this.showResult  = function(){
            this.calcDisplayNode.value = this.result;
        }

        this.calculateAndShow = function(){
            this.calculate();
            this.showResult();
        }
    }

Ok, that's pretty easy, but how to connect it to our template? Dojo gives us a
shorthand to do this. Here's the modified template code from HTMLTestWidget.html::

    <span class="testWidget">
        <p>a test widget!</p>
        <p dojoAttachEvent="onClick: calculateAndShow;">
            click here to perform calculation
        </p>
        <input type="text" value="not set" 
            dojoAttachPoint="calcDisplayNode" />
    </span>

Looks straightforward, but note the magical extra attributes. Nowhere in the
widget or in the template do we explicitly say anything like::
    
    widgeObj.calcDisplayNode = document.getElementById("...");

Instead, Dojo takes care of this for us through the `dojoAttachPoint`
attribute. If the value of this property is the name of a property on the
widget (can be null, but must exist), then the value of that property is set to
be a reference to that DOM Node. The exception to this rule is the
implicitly-set `domNode` property of all HTML widgets. This value is set to be
a reference to the root node of the template, and should always be available,
regardless of whether or not you've explicitly linked it (or other nodes) to
widget properties.

The last piece of this puzzle is the event handling property,
`dojoAttachEvent`. Like `dojoAttachPoint`, `dojoAttachEvent` provides a simple
way for widget authors to separate the DOM structure of their widget from it's
programmatic behavior by allowing you to tie higher level actions to lower-level
DOM events with attributes on the markup, not code in the widget. In our
example, we want the widget method `calculateAndShow` to be called when the
second paragraph is clicked. But if it turns out that this isn't the right
action or node to trigger that event, all that's required to re-wire the event
handler is simply moving the location of the event handler or changing the DOM
event from which it's triggered. For instance, we could transparently exchange
the above template with the following::

    <span class="testWidget">
        <img src="foo.gif" dojoAttachEvent="onMouseOver: calculateAndShow;" />
        <input type="text" value="not set" 
            dojoAttachPoint="calcDisplayNode" />
    </span>

Now the mouseover handler of the image tag will increment the value (and
quickly!). No changes to the widget code were required at all.

This style of event handler attachment allows widget authors to focus on what
their widget is supposed to *do* and less on (re)wiring its event handlers.
Additionally, it allows widget functionality and template layout to be changed
(mostly) independently. It's cleaner, easier to maintain, and faster to
write. Better yet, you can quickly prototype new templates for your widget by
just changing the value of the `templatePath` property and have it be
functional without any widget code changes.

Making It A Tag
---------------

The last hurdle to making this widget something we'd consider working with is
to make it easy to instantiate. The easiest was to do this with Dojo is to make
your widget a tag. To do this in `HTMLTestWidget.js`, we'd add the following
line at the very end of the file::

    dojo.webui.widgets.tags.addParseTreeHandler("dojo:testWidget");

What does that buy us? First of all, it makes it tremendously simple to
instantiate the widget. In a page that includes all of the appropriate script
tags and resource files, you can instantiate a test widget by adding a
`dojoType` attribute to any tag. Here's a simple example::
    
    <span dojoType="testWidget">this will get replaced</span>

That's it. This syntax is called an "inline constructor" in Dojo-speak. You
just add an extra attribute to an element in the page at the location where you
want the widget to appear and it shows up there, and you can have as many of
them as you like. You don't have to add a special identifier (you can if you
like) to keep track of them or otherwise hard-code the number and type of
widgets you want to use. Since we built the widget class using the Dojo
framework, all of the accounting, housekeeping, building, destroying, and
connecting for widgets is taken care of.

But back to the problem of setting data for initial use. What if we wanted to
set the initial value of our counter to be something other than 0? Here's how::

    <span dojoType="testWidget" result="15">
        this will get replaced
    </span>

The `result` property of our widget will now be initialized to 15 when it's
created. But we should probably be display that value when the widget is
created too. Here's the full source code for `HTMLTestWidget.js` as it stands
so far with the addition of a `postInitialize` magic method::

    dojo.hostenv.startPackage("dojo.webui.widgets.HTMLTestWidget");
    dojo.hostenv.loadModule("dojo.webui.DomWidget");

    dojo.webui.widgets.HTMLTestWidget = function(){
        // mix-in inheritance. Order matters.
        dojo.webui.Widget.call(this);
        dojo.webui.DomWidget.call(this, true);
        dojo.webui.HTMLWidget.call(this);

        // templates
        this.templatePath = "src/webui/widgets/templates/HTMLTestWidget.html";
        this.templateCSSPath = "src/webui/widgets/templates/HTMLTestWidget.css";

        this.widgetType = "TestWidget";

        this.calcDisplayNode = null;

        this.result = 0;
        
        this.calculate = function(){
            this.result++;
        }

        this.showResult  = function(){
            this.calcDisplayNode.value = this.result;
        }

        this.calculateAndShow = function(){
            this.calculate();
            this.showResult();
        }

        this.postInitialize = function(){
            // show the initial value after we first get built
            this.showResult();
        }
    }

    // prototype inheritance
    dj_inherits(dojo.webui.widgets.HTMLTestWidget, dojo.webui.DomWidget);
    dojo.webui.widgets.tags.addParseTreeHandler("dojo:testWidget");

At this point, you might be wondering what's going on under the covers here.
Dojo really *does* allow you to set arbitrary properties as attributes on a
constructor, but within some narrow type limitations. For instance, those
properties that have initial integer or float value cause the value passed by
the constructor to be converted to a number before being assigned. Array values
are converted by splitting on the semi-colon character and assigning an array
of resulting strings. If, for instance, we had given the `HTMLTestWidget` class
an array property named `foo` initialized to an empty array, we could set it on
the inline constructor like this::

    <span dojoType="testWidget" foo="foo;bar;baz"></span>

Once initialized, the value of the `foo` property would be::

    ["foo", "bar", "baz"]

In this case, if the widget author wanted integers instead, he/she would have
to convert them before the first use.

So what about functions? Can we assign them the same way?

Sort of. Dojo sports an abstract event system that should be familiar to those
who have used Aspect Oriented Programming (AOP) in the past, but is likely to
be alien to web app developers. In a nutshell, this event system allows a
developer to "register" some code to be called when another function is called
without affecting the behavior of the initial function that is being used as
the trigger. Assigning to a function property in an inline constructor allows
us to likewise register a listener, but not to over-ride the default behavior
of the widget method. For instance, if we had the following method as a part of
the `HTMLTestWidget` class::

    // ...
    this.increment = function(){
        this.result++;
    }
    // ...

We could then add code that would nullify the behavior of the function in the
constructor, like this::

    <span dojoType="testWidget" increment="this.result--;">
    </span>

Note that the `this` keyword refers to the *widget object* and not the DOM
Node here. Given these declarations, the result of calling `increment` would
*NOT* be a decrement, but rather `this.result` would have the *SAME* value as
before `increment` was called. Our handler code fires after the base function,
but before any other code that might be looking to act on the result.

Armed with this information, we can now create widgets that receive data from
the end developer. Combined with the lightweight template syntax that makes it
simple to prototype a widget, the job of the web application programmer just
got a lot easier.

In our brief experience using this system, developers who have a firm grasp of
the system can prototype, iterate, and deploy robust degradable widget-based
UIs more quickly than ever before. Better yet, once the basics of the template
system are explained to designers and other UI-focused web professionals, the
work of maintaining the look and feel through CSS and HTML can often be
distributed to the best person on the team for the job.

Remainders
---------------

Getting Involved with Dojo
##########################

Comitters to Dojo are currently an invite-only group, but that doesn't mean it
can't include you. If you'd like to contribute to the future of Dojo and
responsive web applications, do something that impress us (either with Dojo, or
with JS/DHTML/DSVG in general). Our license is intentionally non-political
(Academic Free License 2.1) and we support your use of Dojo in software that's
licensed in other ways, but will not accept differently-licensed patches. We're
not trying to be exclusive, just productive.

About The Author
#########################

Alex Russell is a geek. He can be reached at <alex@dojotoolkit.org>. His blog
is at: http://alex.nWidgets.com

.. vim:ts=4:et:tw=0:shiftwidth=4:
