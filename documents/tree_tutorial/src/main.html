<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dojo Tree</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1a"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1"></a>Dojo Tree</h2></div></div><hr></div><div class="toc"><ul><li><span class="section"><a href="#d0e4">Introduction</a></span></li><li><span class="section"><a href="#d0e23">What's new in TreeV3</a></span><ul><li><span class="section"><a href="#d0e26">New HTML/CSS structure</a></span></li><li><span class="section"><a href="#d0e49">Event system modified</a></span></li><li><span class="section"><a href="#d0e68">Lazy widget creation</a></span></li><li><span class="section"><a href="#d0e87">Tree extensions</a></span></li><li><span class="section"><a href="#d0e102">Implicit helpers  removed</a></span></li><li><span class="section"><a href="#d0e107">RPC has both sync/async modes</a></span></li><li><span class="section"><a href="#d0e112">Drag'n'drop changes</a></span></li><li><span class="section"><a href="#d0e142">Inline node editing</a></span></li></ul></li><li><span class="section"><a href="#d0e147">Features</a></span></li><li><span class="section"><a href="#d0e201">Todo for TreeV3</a></span><ul><li><span class="section"><a href="#d0e204">A must, easy to implement</a></span></li><li><span class="section"><a href="#d0e211">Optional enhancements</a></span></li><li><span class="section"><a href="#d0e227">Problems to solve</a></span></li></ul></li><li><span class="section"><a href="#d0e245">Tree events</a></span><ul><li><span class="section"><a href="#d0e258">afterTreeCreate</a></span></li><li><span class="section"><a href="#d0e273">beforeTreeDestroy</a></span></li><li><span class="section"><a href="#d0e285">beforeNodeDestroy</a></span></li><li><span class="section"><a href="#d0e297">afterChangeTree</a></span></li><li><span class="section"><a href="#d0e329">afterSetFolder</a></span></li><li><span class="section"><a href="#d0e341">afterUnsetFolder</a></span></li><li><span class="section"><a href="#d0e359">(before|after)Move(From|To)</a></span></li><li><span class="section"><a href="#d0e407">afterAddChild</a></span></li><li><span class="section"><a href="#d0e440">afterDetach</a></span></li><li><span class="section"><a href="#d0e464">after(Expand|Collapse)</a></span></li><li><span class="section"><a href="#d0e476">afterSetTitle</a></span></li></ul></li><li><span class="section"><a href="#d0e494">Performance</a></span><ul><li><span class="section"><a href="#d0e513">Comparison</a></span></li></ul></li><li><span class="section"><a href="#d0e520">Performance tricks</a></span><ul><li><span class="section"><a href="#d0e534">Lazy loading</a></span></li><li><span class="section"><a href="#d0e549">Lazy creation</a></span></li><li><span class="section"><a href="#d0e589">IE image-reloading fixup (!!!)</a></span></li></ul></li><li><span class="section"><a href="#d0e603">Components</a></span></li><li><span class="section"><a href="#d0e657">Lazy loading</a></span><ul><li><span class="section"><a href="#d0e660">How to load *not* TreeNodes ?</a></span></li></ul></li><li><span class="section"><a href="#d0e678">Extensions</a></span></li><li><span class="section"><a href="#d0e720">Node creation</a></span><ul><li><span class="section"><a href="#d0e725">Markup creation</a></span></li><li><span class="section"><a href="#d0e767">Manual creation</a></span></li><li><span class="section"><a href="#d0e781">Input parameters</a></span></li></ul></li><li><span class="section"><a href="#d0e800">Faq</a></span><ul><li><span class="section"><a href="#d0e803">How to make tree unselectable?</a></span></li><li><span class="section"><a href="#d0e808">How to bind an object to tree node?</a></span></li><li><span class="section"><a href="#d0e813">How to walk all node descendants ?</a></span></li><li><span class="section"><a href="#d0e838">How to evade a situation where all nodes are (re)moved and tree is empty without a way to add new child (no nodes) ?             
        </a></span></li><li><span class="section"><a href="#d0e843">How to make pages open when a user clicks on node?</a></span></li><li><span class="section"><a href="#d0e850">I open very large tree. But navigation away to another page from the tree takes time. What's up?</a></span></li><li><span class="section"><a href="#d0e855">How to add icons to nodes ?</a></span></li></ul></li><li><span class="section"><a href="#d0e866">Contributors</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4"></a>Introduction</h3></div></div></div><p>
        This documentation refers to new TreeV3, not to stable Tree widget. Many classes have V3 on the end for TreeV3, 
        but that suffix can be omitted, because it will be removed in dojo 0.5.
    </p><p>
        Basic things are shown in tests (dojo/tests/widget/treeV3), so you might want to check them first and copy-paste
        exactly the things you need. The tutorial is meant to provide deeper understanding for those
        who want to extend/modify tree behavior.
     </p><p>This is just a draft, quite incomplete, but I'd be grateful for your replies.</p><p>The contacts are
       </p><div class="itemizedlist"><ul type="disc"><li>IRC: Freenode, #dojo by nick [algo]</li><li>ICQ: 820317</li><li>Dojo mailing lists: "Ilia Kantor" ilia @ dojotoolkit.org</li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e23"></a>What's new in TreeV3</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e26">New HTML/CSS structure</a></span></li><li><span class="section"><a href="#d0e49">Event system modified</a></span></li><li><span class="section"><a href="#d0e68">Lazy widget creation</a></span></li><li><span class="section"><a href="#d0e87">Tree extensions</a></span></li><li><span class="section"><a href="#d0e102">Implicit helpers  removed</a></span></li><li><span class="section"><a href="#d0e107">RPC has both sync/async modes</a></span></li><li><span class="section"><a href="#d0e112">Drag'n'drop changes</a></span></li><li><span class="section"><a href="#d0e142">Inline node editing</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e26"></a>New HTML/CSS structure</h4></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e29">Nested divs</a></span></li><li><span class="section"><a href="#d0e34">All design in CSS through classes and class combinations</a></span></li><li><span class="section"><a href="#d0e39">Different trees be styled with different CSS class families</a></span></li><li><span class="section"><a href="#d0e44">Multiline content support</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e29"></a>Nested divs</h5></div></div></div><p>Previous tree used a list of divs, each of them was indented  with grid and spacers to right level. The new tree uses
                natural nested divs structure (children' divs inside parent's div). Grid is contigous and structure is displayed correctly for any
                node/font size</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e34"></a>All design in CSS through classes and class combinations</h5></div></div></div><p>All image and size information was removed from JS code. There is a bunch of classes applied to nodes, that may denote
                node folder state, node type, show if there are children, etc. CSS moves this logical classes into style</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e39"></a>Different trees be styled with different CSS class families</h5></div></div></div><p>Want to put 2 differently styled trees on a page? Give them different classPrefix.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e44"></a>Multiline content support</h5></div></div></div><p>Rich content support was incomplete, because list-of-divs model could not handle arbitrary-sized nodes. Now
                you may have &lt;br&gt;, &lt;p&gt; and any other width/height modifiers.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e49"></a>Event system modified</h4></div></div></div><p><code class="methodname">nodeDOMCreated</code> event was removed. That's because listeners are bound to tree and may want to modify the new node,
            but that's only possible when the node is being bound to the tree, not when it was created and hanging around. 
            <code class="methodname">afterTreeChange</code> was introduced to help listeners to (un)bind nodes the right moment
        </p><p>All events were renamed to better reflect the moment of their publishing</p><p><code class="methodname">afterExpand</code>, <code class="methodname">afterCollapse</code> events now fire
            when the animation (e.g fading in or out) finishes, not when the actual expand/collapse is called.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e68"></a>Lazy widget creation</h4></div></div></div><p>Before TreeV3, all nodes must be widgets. A node is added  - hence graphical widget is created. For performance reasons
            that behavior was altered. Now when you add a node, you may actually add a "data object", containing node data, e.g
            {title:"new node"}. You may want to add a large nested branch of such data objects, like {title:"new", children:[...data objects..]}.
        </p><p>Data objects will become real members of children array (you may recursively search them, modify etc), but graphical widgets
            will be created only when visitor expands them.</p><p>The compatibility drawback of such behavior is that old code may erroneously call *widget* methods on *data objects* 
            while recursively traversing a tree, e.g with Widget#getDescendants. You should change such code to use TreeCommon#processDescendants,
            or handle data objects in special way.            
        </p><p> There are no special mechanisms to add laziliy instantiated "data objects". 
            You may manipulate them simply modifying <code class="methodname">children</code> array, but no events are thrown until a
            real widget appears on the scene. In most cases that is fine, but you are free to "disable" lazy widget creation - do not modify
            <code class="methodname">children</code> directly and enable <code class="methodname">tree.eagerWidgetInstantiation</code></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e87"></a>Tree extensions</h4></div></div></div><p>Many features were moved from core into extensions</p><div class="itemizedlist"><ul type="disc"><li>Added TreeDocIconExtension instead of builtin childIcon support</li><li>Selector now only throws events, not doing anything with nodes</li><li>Out-of-the box extensions introduced to be examples and handle well-known requirements</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e102"></a>Implicit helpers  removed</h4></div></div></div><p>The Tree is actually a pack of loosely coupled components, connected through events. To keep things simple and also
            for compatibility reasons, such components(controller,selector...) were created implicitly, if not declared. But actually this proved to be a source of 
            questions and misunderstandings. So now nothing is created implicitly, read how-to and declare things.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e107"></a>RPC has both sync/async modes</h4></div></div></div><p>Old callbacks code was removed in favor to dojo.Deferred. Now all operations may be async and run your callbacks at the end.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e112"></a>Drag'n'drop changes</h4></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e115">Multiple selection and multiple drag'n'drop (incomplete)</a></span></li><li><span class="section"><a href="#d0e128">Drop of any source, not just tree node</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e115"></a>Multiple selection and multiple drag'n'drop (incomplete)</h5></div></div></div><p>Sounds simple enough.. Select multiple nodes with ctrl and get them with <code class="methodname">selector.selectedNodes</code>.
                instead of removed <code class="methodname">selectorNode</code> call.</p><p>Currently, multiple drag'n'drop does not work with multiple selection because of dojo bugs. Hopefully will be fixed.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e128"></a>Drop of any source, not just tree node</h5></div></div></div><p>If <code class="methodname">treeNode</code> property is empty, tree will create a new node from the data returned by
                <code class="methodname">source.getTreeNode</code>, then <code class="methodname">source.onDrop</code> will be called to remove old node.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e142"></a>Inline node editing</h4></div></div></div><p>It became possible to edit nodes inline, using TreeEditor. Base variant uses RichText widget, you can make another wrapper though.
                Remote calls can be made on save only, or on start/cancel too e.g for locking purposes.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e147"></a>Features</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li>Flexible styling            
            <div class="itemizedlist"><ul type="circle"><li>All design in CSS through classes and class combinations</li><li>Different trees be styled with different CSS class families</li><li>Multiline and rich content support</li></ul></div></li><li>Full set of node operations
            <div class="itemizedlist"><ul type="circle"><li>expand/collapse</li><li>create with JS or markup</li><li>destroy/move/clone</li><li>addChild/detach/(de)folderize</li><li>inline editing</li><li>multiple selection and drag'n'drop</li></ul></div></li><li>Performance
            <div class="itemizedlist"><ul type="circle"><li>batch operations</li><li>special features</li></ul></div></li><li>Lazy loading &amp; RPC features
            <div class="itemizedlist"><ul type="circle"><li>ready to be in-sync with your data</li></ul></div></li><li>Rich event system
            <div class="itemizedlist"><ul type="circle"><li>fluently integrates with your app</li></ul></div></li><li>Customization
            <div class="itemizedlist"><ul type="circle"><li>change everything through inheritance, events and css</li><li>out-of-the box extensions</li></ul></div></li><li>Tests and demos</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e201"></a>Todo for TreeV3</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e204">A must, easy to implement</a></span></li><li><span class="section"><a href="#d0e211">Optional enhancements</a></span></li><li><span class="section"><a href="#d0e227">Problems to solve</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e204"></a>A must, easy to implement</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>doClone in RPC should get cloned nodes from server, like createChild</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e211"></a>Optional enhancements</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>Automated unit-testing system based on Selenium </li><li>Optimize all gifs with AGO (advanced gif optimizer) carefully. AGO spoils transparent gifs. It may make single layer LESS than 
                reported image size, that'd lead to background-repeat effect under OS X or Opera.
            </li><li>Make SortChildren extension to keep nodes sorted</li><li>Make DisableSelection extension to keep node selection</li><li>On Drag'n'drop tree 'wobbles', because node size increases/decreases when it is
                bordered.  Could be nice to evade it, either placing another transparent div with border onto
                the node or decreasing their size, or using padding divs, or..</li><li>Add checkbox extension. Every node will have checkbox, can save/restore checked state. When parent is checked,
      all children are marked "grey-checked", user may uncheck grey-checked nodes. grey-checked dependant nodes removed if parent is unchecked.
      This will require rewrite TreeDocIconExtension ( docIcon -&gt; checkbox ) to allow arbitrary new "thing" left from node.</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e227"></a>Problems to solve</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>Multiple dnd of nodes selected by multiple select work incorrectly. Although all is fine if dragManager
                uses shift for multiple dnd and TreeSelector uses ctrl. No idea what the reason is.</li><li>Drag'n'drop onDrop errors can't be handled. Need a way to hook on e.g permission denied errors.</li><li>When I expand a large tree and try to move its top (dnd), node starts to move after a pause - a gap in time between
                I start moving node with my mouse and dragClone appears. Lots of calculations?</li><li>wipe and fade togglers are broken</li><li>can't add subwidgets in title. Seems I need to put them to children, and children property will contain
            not only subnodes, but also title widgets.. Will need to fix a lot.</li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e245"></a>Tree events</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e258">afterTreeCreate</a></span></li><li><span class="section"><a href="#d0e273">beforeTreeDestroy</a></span></li><li><span class="section"><a href="#d0e285">beforeNodeDestroy</a></span></li><li><span class="section"><a href="#d0e297">afterChangeTree</a></span></li><li><span class="section"><a href="#d0e329">afterSetFolder</a></span></li><li><span class="section"><a href="#d0e341">afterUnsetFolder</a></span></li><li><span class="section"><a href="#d0e359">(before|after)Move(From|To)</a></span></li><li><span class="section"><a href="#d0e407">afterAddChild</a></span></li><li><span class="section"><a href="#d0e440">afterDetach</a></span></li><li><span class="section"><a href="#d0e464">after(Expand|Collapse)</a></span></li><li><span class="section"><a href="#d0e476">afterSetTitle</a></span></li></ul></div><p>There are many classes of events, published with dojo.event.publish mechanism. Every event has a name and message object,
        containing more precise information about what happened. You may use events to update your data while tree changes, and
        to perform additional processing of involved objects.</p><p>There is a default naming scheme for an event class. E.g for a tree with widgetId='mytree', event of class <span class="property">afterTreeCreate</span>
        will be named "mytree/afterTreeCreate". You may provide other names in <span class="property">eventNames</span> property of the tree.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e258"></a>afterTreeCreate</h4></div></div></div><p>Event occurs after tree creation is complete. There is an alternative to hook on this action by putting your objects in
            "listeners" property of the tree. The difference is that listeners are guaranteed to hook before nodes get added, and <span class="property">afterTreeCreate</span>
            is published after Tree widget is created.</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>references to tree</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e273"></a>beforeTreeDestroy</h4></div></div></div><p>Published right before actual Tree#destroy method is called. Useful for cleanups</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>references to tree</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e285"></a>beforeNodeDestroy</h4></div></div></div><p>Right before TreeNode#destroy is called. Node is detached after this event fired.</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>references to node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e297"></a>afterChangeTree</h4></div></div></div><p>This event is tightly created with node creation process. It is fired when
            
            </p><div class="itemizedlist"><ul type="disc"><li>a node is created</li><li>a node moves to another tree widget</li></ul></div><p>                
                
            </p><div class="variablelist"><dl><dt><span class="term">oldTree</span></dt><dd>references previous tree, null if node has been just created</dd><dt><span class="term">newTree</span></dt><dd>new(current) tree</dd><dt><span class="term">node</span></dt><dd>target node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e329"></a>afterSetFolder</h4></div></div></div><p>Fires when a node obtains "folder" state. That may happen when a first child is added to a leaf, or if a node was initially
            created with isFolder=true</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>references to node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e341"></a>afterUnsetFolder</h4></div></div></div><p>Fires when a node obtains looses "folder" state. That may happen when a last child leaves the node, and <span class="property">
            Tree.unsetFolderOnEmpty</span>is set, or when <span class="property">unsetFolder</span> is called explicitly.</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>references to node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e359"></a>(before|after)Move(From|To)</h4></div></div></div><p>These events share same arguments and fire when a node is moved. Move process is considered something special.
        When you move a node, no detach/addChild events get thrown. That allows to tell situations when a node leaves a tree for some time
            (detached then attached) from situations when a node is simply moved to another location</p><div class="variablelist"><dl><dt><span class="term">oldParent</span></dt><dd>previous parent</dd><dt><span class="term">oldTree</span></dt><dd>previous tree</dd><dt><span class="term">oldIndex</span></dt><dd>previous index among siblings</dd><dt><span class="term">newParent</span></dt><dd>new parent</dd><dt><span class="term">newTree</span></dt><dd>new tree</dd><dt><span class="term">newIndex</span></dt><dd>new index among siblings</dd><dt><span class="term">child</span></dt><dd>target node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e407"></a>afterAddChild</h4></div></div></div><p>Published when a node is attached to parent. This may happen at the end of creation process, or when a node is 
            lazily instantiated from data object.
        </p><div class="variablelist"><dl><dt><span class="term">child</span></dt><dd>references to node</dd><dt><span class="term">index</span></dt><dd>index among siblings</dd><dt><span class="term">parent</span></dt><dd>current parent who adopted a child</dd><dt><span class="term">childWidgetCreated</span></dt><dd>flag is set if child was laziliy instantiated. That is: it resided as data object in <span class="property">children</span>
                    array, but user expanded its parent, so node widget came to life.</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e440"></a>afterDetach</h4></div></div></div><p>Occurs when a node is detached. This may happen in the process of node destruction.</p><div class="variablelist"><dl><dt><span class="term">child</span></dt><dd>references to node</dd><dt><span class="term">parent</span></dt><dd>references to old parent</dd><dt><span class="term">index</span></dt><dd>references to index among children of old parent</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e464"></a>after(Expand|Collapse)</h4></div></div></div><p>Fire when a node is expanded/collapsed. Some togglers do nice animation hiding/showing node.
        This event fires when animation finishes.</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>target node</dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e476"></a>afterSetTitle</h4></div></div></div><p>When a node is edited, or explicit setTitle method is called, this event helps to inform interested parts about changes.</p><div class="variablelist"><dl><dt><span class="term">source</span></dt><dd>target node</dd><dt><span class="term">title</span></dt><dd>new node title</dd></dl></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e494"></a>Performance</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e513">Comparison</a></span></li></ul></div><p>Tree was coded with performance in mind. Although, JavaScript itself is a slow language.
        Flexible model requires some code that slows it down. It's not DOM manipulations, but actually
        javascript that I couldn't make lighter. Being a part of dojo/widget structure also implies some overhead, but also power.
    </p><p>        
        Almost all operations require small constant time when single node is involved. Depending on your
        application you may notice slowdown when (most common) creating lots of nodes or
        performing other batch operations.
    </p><p>
        In my tests 1000 nodes required 0.7-0.8 sec, growth is linear, depth does not matter, children
        are created with  <code class="code">createSimple</code> and added to parent all at once with <code class="code">setChildren</code>.                
    </p><p>Creation from markup or with standard create/addChild routines is  2-3 times slower,
        because these routines are generic.</p><p>Memory footprint (IE,FF) is about 1M per 100 nodes</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e513"></a>Comparison</h4></div></div></div><p>Fast node creation with dojo tree is 2-3 times slower than xtree 1.7, another tree widget, not
            so featured, but nicely optimized for performance.
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>The results described here refer to operations without any lazy features involved.
        Most of time you will use lazy creation or lazy loading, or both, and operate with 10000 "virtual" nodes with ease.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e520"></a>Performance tricks</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e534">Lazy loading</a></span></li><li><span class="section"><a href="#d0e549">Lazy creation</a></span></li><li><span class="section"><a href="#d0e589">IE image-reloading fixup (!!!)</a></span></li></ul></div><p>
    When talking about performance, one should understand, that there are <span class="type">single-node operations</span>
        
    that operate on single node... These ones are fast. The examples are: create a node, delete a node,
     move a node along the tree.
    </p><p>... And there are batch operations that touch a lot of nodes. The examples are: 
        initial tree creation,  moving a node from one tree to another which has different listeners, etc.</p><p>That performance issues become noticeable at 100-300 tree nodes depending on your trees.
        All algorithms are linear in worst case, but JS is slow language, DOM is also not that fast. 
      </p><p>There is a number of features one could use to get a speedup.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e534"></a>Lazy loading</h4></div></div></div><p>A node can be created with <code class="code">isFolder=true</code> flag, but without children.
            Any node has a <code class="code">state</code>, initially UNCHECKED for empty folder, and used
            by  TreeLoadingController.</p><p>When a user presses expand, tree controller (supporting lazy loading) will send a request to server asking for nodes,
            and parse the answer creating children.</p><p>The benefit is obvious: you don't have to load/process whole tree at once.
            You can only load a single node and user will load the rest clicking "expand"</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e549"></a>Lazy creation</h4></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e569">Comparison between lazy creation and lazy loading</a></span></li></ul></div><p>
            Node/tree keeps array of its children in <code class="code">children</code> property. 
            Lazy creation is somewhat a half-way approach to lazy loading. It allows you to put data objects 
            into this array and tree will create widgets of them later, when they are expanded.
        </p><p>For instance, one can call <code class="code">node.children = [{title:'node1'},{title:'node2'}]</code>.
            The objects will be set, but no widgets are created. You can also set children to nested array:
            <code class="code">node.children = [{title:'node1', children:[{title:'node2'}] }]</code>.    
            
        </p><p>You can create tree on server, JSON-serialize it and put to HTML, that is gzip-compressed.
            Compression will be 6 times or more, so it is not that space hungry. 
        </p><p>The benefit comes from postponing almost all real job: widget creation and attaching it to tree will
        happen in expansion-time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e569"></a>Comparison between lazy creation and lazy loading</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li>You need web-service for lazy loading, not for lazy creation</li><li>No network waits for lazy creation</li><li>Lazy creation gives you the tree right here. You can search data objects and modify them
                    without spending time and memory on graphical widgets</li></ul></div><p>Sometimes, lazy creation and loading may work together nicely, providing seamless increase
                in speed and decrease in memory footprint. For instance, server may pass a whole tree branch in JSON
            to lazy loading controller. Top nodes will be created right along, because user needs them, but the rest
            of the branch will be postponed relying on lazy creation feature.</p></div><p>
            There are operations, like "expandAll" where such lazy tricks don't help, because all graphical widgets must be processed. That is why
            widget creation process is well-optimized itself. <code class="code">createSimple</code> is a hacky program-only way
            to create TreeNodes fast. <code class="code">setChildren</code> is a method to assign (and create if needed)
            all children at once. It helps to evade some extra work happening when children are added one by one.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e589"></a>IE image-reloading fixup (!!!)</h4></div></div></div><p>IE has a well-known bug. If an image was loaded dynamically - with a <code class="code">new Image()</code>, or <code class="code">img.src=</code>
            assignment, or even as a background of a new node, it will not be cached. So every time when you create a node, all needed icons get loaded
            from server (or requested at least). A possible solution is to put a special div into HTML (adjust src to your path):
        </p><div class="literallayout"><p>&lt;div&nbsp;style="display:none"&gt;<br>
&nbsp;&nbsp;&lt;!--&nbsp;IE&nbsp;has&nbsp;a&nbsp;bug:&nbsp;it&nbsp;reloads&nbsp;all&nbsp;dynamically&nbsp;resolved&nbsp;images,&nbsp;no&nbsp;matter,&nbsp;is&nbsp;it&nbsp;<br>
&nbsp;&nbsp;new&nbsp;Image()&nbsp;or&nbsp;CSS&nbsp;background.&nbsp;If&nbsp;you&nbsp;don't&nbsp;specify&nbsp;images&nbsp;like&nbsp;that,<br>
&nbsp;&nbsp;it&nbsp;will&nbsp;reload&nbsp;them&nbsp;every&nbsp;time&nbsp;a&nbsp;new&nbsp;node&nbsp;is&nbsp;created&nbsp;--&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i_half.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_minus.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_plus.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_leaf.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i_long.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/document.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/open.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/closed.gif"/&gt;<br>
&lt;/div&gt;</p></div><p>
        
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e603"></a>Components</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Tree</span></dt><dd>Tree and TreeNode classes handle both data and view</dd><dt><span class="term">Controllers</span></dt><dd><div class="variablelist"><dl><dt><span class="term">TreeBasicController</span></dt><dd>Controller that provides all capabilities but no server calls</dd><dt><span class="term">TreeLoadingController</span></dt><dd>Added dynamic node loading from server</dd><dt><span class="term">TreeRPCController</span></dt><dd>All actions call server</dd></dl></div></dd><dt><span class="term">Selector</span></dt><dd>TreeSelector handles node selection. Currently, only single node can be selected</dd><dt><span class="term">Drag'n'Drop</span></dt><dd>TreeDragSource, TreeDropTarget and TreeDNDController are classes that
                allow nodes to be dragged, to be dropped on and mechanism binding that together.
                Sources are located under src/dnd folder, not among widgets. </dd><dt><span class="term">Context menu</span></dt><dd>TreeContextMenu inherits dojo context menu to provide a lightweight right-click
                menu. There is a single menu object for all nodes, although it always knows its target</dd><dt><span class="term">Style &amp; icons</span></dt><dd>Tree.css and icons are located under src/widget/templates and provide basic style
                used by default. 
                </dd><dt><span class="term">Extensions</span></dt><dd>TreeControllerExtension contains additional functions for controller that you might need
            </dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e657"></a>Lazy loading</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e660">How to load *not* TreeNodes ?</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e660"></a>How to load *not* TreeNodes ?</h4></div></div></div><p>Every data object you send is created with <span class="property">Tree#createNode</span> call.</p><p>You want to pass a special object, specify widgetName in <span class="property">widgetName</span> property of your object.
        </p><p>Another option is to change <code class="methodname">defaultChildWidget</code> property of the tree.
            Helpful in case when you have your own widgets and use them elsewhere instead of TreeNode</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e678"></a>Extensions</h3></div></div></div><p>Extensions are also called plugins, they can be hooked onto widgets in various combinations and provide wanted options.</p><p>Currently there is a couple of extensions
        
        </p><div class="variablelist"><dl><dt><span class="term">TreeDisableWrapExtension</span></dt><dd>Tree extension, disables wrapping for tree nodes. Also it fixes IE bug when an 'unwrappable' node (e.g single word) will move 
                to next line if no space left.</dd><dt><span class="term">TreeDocIconExtension</span></dt><dd>Tree extension, places icon to the left of a node, depening on <span class="property">nodeType</span> property</dd><dt><span class="term">TreeEmphasizeOnSelect</span></dt><dd>Selector extension, highlights currently selected nodes</dd><dt><span class="term">TreeDeselectOnDblselect</span></dt><dd>Selector extension, deselects a selected node when it is clicked. Usually, one should ctrl-click, or click another node.</dd><dt><span class="term">TreeLinkExtension</span></dt><dd>Tree extension, turns labels into links, merges object property into &lt;a&gt; tag</dd></dl></div><p>
        
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e720"></a>Node creation</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e725">Markup creation</a></span></li><li><span class="section"><a href="#d0e767">Manual creation</a></span></li><li><span class="section"><a href="#d0e781">Input parameters</a></span></li></ul></div><p>There are few code paths that lead to same purpose: to create a tree node.
        They differ in effeciency and use patterns</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e725"></a>Markup creation</h4></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e732">widget.create</a></span></li></ul></div><p>You specity a tree and its nodes in HTML, relying upon dojo to parse it and turn into widgets.
            That is a slowest way, but nice for small trees or if only tree top is specified and the rest is created
            later.
        </p><p>dojo widget parser walks DOM and creates a special structure. The next pass creates
            widgets from the structure.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e732"></a>widget.create</h5></div></div></div><p>The generic widget creation routine. It basically runs the operations in order:
            
            </p><div class="orderedlist"><ol type="1"><li>Mix in widget properties from parameters/markup</li><li>Register widget in widget.Manager</li><li>Call <code class="code">buildRendering</code> to make fill template and create domNode</li><li>Call <code class="code">initialize</code></li><li>Call <code class="code">postInitialize</code>. registers widget as a child of its parent
                    and after it creates all subwidgets</li><li>Call <code class="code">postCreate</code></li></ol></div><p>
               
                Note that <code class="code">initialize</code> is called in pre-order: parent is initialized before children, <code class="code">postInitialize</code> is called
                in post-order: a child is postCreated before its parent.
                
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e767"></a>Manual creation</h4></div></div></div><p>If you create nodes with javascript, then you run create calls manyally. So parents are naturally created (and
            postCreated) before children</p><p>There seem to be no good way to distinguish betwen markup creation and manual creation.
            From the one hand its seems good, because allows reuse of generic creation code.
            From the other hand code paths going through this code are subtly different.
        </p><p>The reliable thing is that <code class="code">initialize</code> will process widget after
            its domNode is built, BUT it should not assume anything about children.</p><p>nodeCreate event is fired on initialization also. If you want to know anything about children
       and do something at this point - check addChild, but not node creation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e781"></a>Input parameters</h4></div></div></div><p><code class="code">children</code> array may be
        </p><div class="itemizedlist"><ul type="disc"><li>empty</li><li>contain widgets, e.g if created from markup, or someone created them before parent and
                pushed in</li><li>contain data objects, that will be turned into widgets when parent expands.</li></ul></div><p>
            
        </p><p><code class="code">isFolder</code> comes into play only when there are no children. It allows creation
        of empty folders, with UNCHECKED state that can be filled later.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e800"></a>Faq</h3></div></div></div><div class="toc"><ul><li><span class="section"><a href="#d0e803">How to make tree unselectable?</a></span></li><li><span class="section"><a href="#d0e808">How to bind an object to tree node?</a></span></li><li><span class="section"><a href="#d0e813">How to walk all node descendants ?</a></span></li><li><span class="section"><a href="#d0e838">How to evade a situation where all nodes are (re)moved and tree is empty without a way to add new child (no nodes) ?             
        </a></span></li><li><span class="section"><a href="#d0e843">How to make pages open when a user clicks on node?</a></span></li><li><span class="section"><a href="#d0e850">I open very large tree. But navigation away to another page from the tree takes time. What's up?</a></span></li><li><span class="section"><a href="#d0e855">How to add icons to nodes ?</a></span></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e803"></a>How to make tree unselectable?</h4></div></div></div><p>To make tree (or its elements) unselectable use dojo.html.disableSelection in nodeCreate and treeCreate hooks.
            Apply disableSelection to every node you want to make unselectable.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e808"></a>How to bind an object to tree node?</h4></div></div></div><p>There is an "objectId" property and "object" property ready to be filled in from markup or program-way.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e813"></a>How to walk all node descendants ?</h4></div></div></div><p>You may use <code class="code">dojo.lang.forEach(nodeOrTree.getDescendants(),function(elem) { ... })</code> to process all descendants,
            it will walk <code class="methodname">children</code> property recursively.        
            
        </p><p>The safer way would be to call <code class="code">TreeCommon.prototype.processDescendants(nodeOrTree, filter, func)</code>, it will process all children
        with <code class="code">func</code>, but will not descend into nodes if <code class="code">filter(node)</code> returns false. E.g see <code class="methodname">collapseAll</code>
            controller method uses it to collapse all widgets, but skip non-folders and data objects. 
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e838"></a>How to evade a situation where all nodes are (re)moved and tree is empty without a way to add new child (no nodes) ?             
        </h4></div></div></div><p>Make a single root node with actionsDisabled="DETACH;MOVE". User will be unable to remove it, so interface will stay sane.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e843"></a>How to make pages open when a user clicks on node?</h4></div></div></div><p>There are 2 ways. The first one is to attach TreeSelector and hook on "select" event. So when a user clicks,
            event handler will change url to node.object.href. Of course, you should fill hrefs.
        </p><p>A probably more convinient path would be to employ TreeLinkExtension, which will turn your labelNodes into real links,
            and apply attrbutes from node object to them.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e850"></a>I open very large tree. But navigation away to another page from the tree takes time. What's up?</h4></div></div></div><p>Dojo performs actions not only when a node is created, but also cleanup when a node is destroyed.
        Lazy features allow node creation be distributed in time, but when you navigate away from a large tree, cleanup need some time.
        I don't know a way to evade that.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e855"></a>How to add icons to nodes ?</h4></div></div></div><p>TreeDocIconExtension handles that. You should declare <span class="property">nodeType</span> for your nodes, so they'll get
            <span class="property">nodeIcon[Your type]</span> CSS class. Default type is Document for leaves and Folder for folders.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e866"></a>Contributors</h3></div></div></div><p>Thanks to all dojo contributors, Tree widgets wouldn't be possible without such a nice background.</p><p>Also, there are people who contributed their skills to make Tree widget better.</p><div class="itemizedlist"><ul type="disc"><li>Ilia Kantor</li><li>Slava Ivanyuk</li><li>Nachoman</li></ul></div><p>In case if someone is left out, message me, please.</p></div></div></body></html>