.. raw:: html
   :file: website/rest_template/header.html


Intro
-----

Unlike the DOM events that web programmers normally associate with the word
"event", Dojo takes a broad view of eventing. The tools in `dojo.event.*`
allow developers to treat any function call (DOM event or otherwise) as an
event that can be listened to. Using Dojo, code can register to "hear" about
any action through a uniform API.

In this article we'll show you how to use these tools, what makes them
completely different from other JavaScript event systems you may have used, and
why you'll never start writing JavaScript without `dojo.event.connect()` again.

Examples
--------

The current trend toward unobtrusive JavaScript requires that the setting of
event handlers on DOM Nodes happen without explicit `on*` attributes in markup.
`dojo.event.connect()` can help::

    var handlerNode = document.getElementById("handler");

    function handleOnClick(evt){
        // ...
    }

    dojo.event.connect(handlerNode, "onclick", "handleOnClick");

In this example, `connect()` is already spotting us a bug fix. Without it, IE
fails to pass the DOM Event object as the first argument to our handler
function.  Instead, IE forces us to grab the event object from `window.event`.
Dojo makes sure it's passed into the handler and that it's properties are
normalized to be more standards-compliant. The normalized event has the
standard methods for canceling event bubbling and default behavior, which means
you can stop writing branching statements in handler functions.

But what if we don't want to set up an named fuction for the event handler? No
problem::

    var handlerNode = document.getElementById("handler");

    dojo.event.connect(handlerNode, "onclick", function(evt){
        // ...
    });

So far, though, we're  not doing anything that can't be done by setting the
`onclick` property of the DOM Node. But what about attaching a method of an
object to a DOM Node's event handler? Normally, you'd have to do something
like::

    var handlerNode = document.getElementById("handler");

    handlerNode.onclick = function(evt){
        object.handler(evt);
    };

Dojo simplifies it to::

    var handlerNode = document.getElementById("handler");

    dojo.event.connect(handlerNode, "onclick", object, "handler");

This `connect()` call ensures that when `handlerNode.onclick()` is called,
`object.handler()` will be called with the same arguments. Unfortunantly a
language limitation of JavaScript makes it impossible to pass in the object and
function name together, but separating them into an object reference and
function name isn't difficult.

Connect also transparently handles multiple listeners. They are called in the
order they are registered. This would kick off two separate actions from a
single onclick event::

    var handlerNode = document.getElementById("handler");

    dojo.event.connect(handlerNode, "onclick", object, "handler");
    dojo.event.connect(handlerNode, "onclick", object, "handler2");

We didn't have to change the API we were using, rewire anything for multiple
events, etc. It all just works. Now every time you click the node, and
`object.handler()` gets called and then `object.handler2()` gets called.

We've also inadevertantly demonstrated that `connect()` takes variable forms of
arguments. So far, it's correctly handled:

- object, name, name
- object, name, function pointer
- object, name, object, name

This is par for the course when using `connect()`. Since it is used in so many
places, for so many things, and in so many ways, `connect()` does a lot of
checking and normalization of it's arguments.

So we've seen that `connect()` can handle DOM events, but what about that more
expansive view of events that was mentioned earlier? To demonstrate, lets
define a simple object with a couple of methods::

    var exampleObj = {
        counter: 0,
        foo: function(){ 
            alert("foo");
            counter++;
        },
        bar: function(){
            alert("bar");
            counter++;
        }
    };

So lets say that I want `exampleObj.bar()` to get called whenever
`exampleObj.foo()` is called. We can set this up the same way that we do with
DOM events::

    dojo.event.connect(exmapleObj, "foo", exampleObj, "bar");

Now calling `foo()` will also call `bar()`, thereby incrementing the counter
twice and alerting "foo" and then "bar". Any caller that was counting on
getting the return value from `foo()` won't be dissapointed. The source method
should behave just as it always has. On the other hand, since there's no
explicit caller for `bar()`, it's return value will be lost since there's no
obvious place to put it.

Gotchas, Disconnection, Connecting Once, and Delaying Execution, and Using Keywords
-----------------------------------------------------------------------------------

Connecting is one thing, but what about when you want to stop listening?
`dojo.event.disconnect()` will stop the listening arrangement between
functions, but must be pass *exactly the same* arguments as were passed to
connect in order to ensure successful disconnection.

If there's anything that can trip up new users of `dojo.event.connect()`, it's
multi-connection. Very often, a peice of code will get called multiple times,
and it will contain a `dojo.event.connect()` call. The developer is then
suprised when their listener function is called multiple times for every time
the source function fires. What to do?

One option is to move your `connect()` call to a location that will get invoked
only once, but sometimes that's just not feasible. An optional argument to
`connect()` ensures that the same arguments to connect passed multiple times
will result in only one connection between functions. Unfortunantly, it's the
8th paramater. Ugg. The last thing we want to do is remember 8 different
paramaters to our handy little utility method and even moreso since it tries so
hard to figure out the right thing to do the rest of the time. The best answer
in this scenario is to use the keyword-argument version of connect, aptly named
`kwConnect()`. To use it, we have to give the paramaters we've been using so
far names. Here's our object connection example using `kwConnect()` and the
`once` paramater::

    dojo.event.kwConnect({
        srcObj:     exmapleObj, 
        srcFunc:    "foo", 
        targetObj:  exampleObj, 
        targetFunc: "bar",
        once:       true
    });

As I'm sure you've already guessed, there's an alagous `kwDisconnect` method.
Just pass it what you pass `kwConnect`, naturally.

There's one more modifier up the sleeve of `connect()`/`kwConnect()`; delayed
calling. The `delay` property in `kwConnect` (the 9th positional paramater for
`connect`) is a delay in milliseconds for those platforms that support it (all
browsers do).

The last problem worth mentioning is circular connections. Circular connections
can occur when (perhaps even indirectly) a listener also calls the fucntion
it's listening too. The good news is that in a JavaScript interpreter, this
will pretty quickly yeild an exception of some sort "Too much recursion" is a
popular error message for this kind of problem. Debugging circualr connections
can be opaque, but tools like `Venkman`_ help.

Advanced Usage: Seeking Advice
------------------------------

`connect()` is clearly powerful, but we've only scratched the surface.  In
addition to being able to call any function or method after any other function
or method call, `connect()` can be used to call listeners *before* the source
function is called. In `Aspect Oriented Programming`_ terminology, this is called
"before advice" while the previous examples have all be "after advice". Here's
how we'd ensure that "bar" gets alerted *before* "foo" when `exampleObj.foo()`
is called::

    dojo.event.connect("before", exampleObj, "foo", exampleObj, "bar");

As you can see, we just prepended our prevous call to `connect()` with the word
"before". In the other cases, the word "after" was the implied first argument,
which we could have added if we wanted, but typing more isn't something any of
us want, and most of the time "after" is what you want anyway.

The same connection using `kwConnect()` looks like::

    dojo.event.connect({
        type:       "before", 
        srcObj:     exampleObj, 
        srcFunc:    "foo", 
        targetObj:  exampleObj,
        targetFunc: "bar"
    });

Before and after advice give us tools to handle a huge range of problems, but
what about when the listener and the source functions don't have the same call
signatures? Or what about when you want to change the behavior of a function
from someone else's code but don't want to change their code? If we take the
view that any function call in our environment is an event, then shouldn't we
also have an "event object" for each of them? When using
`dojo.event.connect()`, this is exactly what happens under the covers, and we
can get access to it via "around advice". Long story short, around advice
allows you to wrap any function and manipulate both it's inputs and outputs.
This'll let us change both the calling signatures of functions and change
arguments for listeners (among other things).

Unlike the other advice types, around adivce requires a little bit more
cooperation from the author of the around advice function, but since you'll
probably only be using it in situations where you know that you want to
explicitly change a behavior, this is isn't really a problem. This example take
a function `foo()` which takes 2 arguments and provides a default value for the
second argument if one isn't passed::

    function foo(arg1, arg2){
        // ...
    }

    function aroundFoo(invocation){
        if(invocation.args.length > 2){
            // note that it's a real array, not a pseudo-arr
            invocation.args.push("default for arg2");
        }

        var result = invocation.proceed();
        // we could change the result here
        return result;
    }

    dojo.event.connect("around", "foo", "aroundFoo");

The `aroundFoo()` function must take only a single argument. This argument is
the method-invocation object. This object has some useful properties (like
`args`) and one method, `proceed()`. `proceed()` calls the wrapped function
with the arguments packed in the `args` array and returns the result. At this
point, you can further manipulate the result before returning it. If you don't
return the result of `proceed()`, it will appear to the caller as though the
wrapped function didn't return a value. At any point you could call another
function to do things like log timing information.

Once this connection is made, every time `foo()` is called `aroundFoo()` will
check it's argument and insert a default value for `arg2`. Around advice is
kind of like goto in C and C++: if you don't know better you can make huge
messes, but when you really need it, you *really* need it.

Despite the power of around advice, it's not very often that globally changing
a function signature or return value is the best plan. More often, you'll just
want to smooth over the differences in calling signatures between two functions
that are being connected. As you might have come to expect by now, Dojo
provides a solution for this type of impedence matching problem too.

The solution is *before-around* and *after-around* advice. These advice types
apply a supplied around advice function to the listener in a connection. They
only apply the around advice when the listener function is being called from
the connected-to source. Put another way, it's connection-specific argument and
return value manipulation.

To access before-around and after-around advice, just pass in another
object/name pair to a normal "before" or "after" connection, like this::

    var obj1 = {
        twoArgFunc: function(arg1, arg2){
            // function expects two arguments
        }
    };

    var obj2 = {
        oneArgFunc: function(arg1){
            // this function expects a two-element array 
            // as its only paramater
        }
    };

    // we'd probably connect the functions somewhere else. Perhaps in a
    // different file entirely.

    function aroundFunc(invocation){
        var tmpArgs = [ 
                        invocation.args[0], 
                        invocation.args[1]
                      ];
        invocation.args = tmpArgs;
        return invocation.proceed();
    }
    
    // after-around advice
    dojo.event.connect( obj1, "twoArgFunc", 
                        obj2, "oneArgFunc"
                        "aroundFunc");

Each function now gets what it expects, and the code calling
`obj1.twoArgFunc()` never need be the wiser that any of this is happening.

Using Topics For Truly Anonymous Communication
----------------------------------------------

The `connect()` function does a *lot* of work for you, but there are still some
cases where hacking together a solution for communicating between modules and
object is difficult. These include cases where your code might not be able to
"see" both objects or might need to to create components asynchornously and
therefore might not know when it's "safe" to try to `connect()` methods
together.

Topics to the rescue!

We can do truly anonymous communication between components if they agree ahead
of time on a unique name for the event that they are going to send and/or
listen for. The `dojo.event.topic` object builds on `dojo.event.connect()` to
make this happen. Here's one of our early `connect()` examples modified to use
topics::

    var exampleObj = {
        counter: 0,
        foo: function(){ 
            alert("foo");
            counter++;
        },
        bar: function(){
            alert("bar");
            counter++;
        }
    };

    // previously we used this connect syntax
    //
    //  dojo.event.connect(exmapleObj, "foo", exampleObj, "bar");
    //
    // which we now replace with:
    
    // set up our publisher
    dojo.event.topic.registerPublisher("/example", exampleObj, "foo");

    // and at some point later, register our listener
    dojo.event.topic.subscribe("/example", exampleObj, "bar");

Note that our publisher and subscriber are now joined by the topic `/example`
and not any code that can "see" both of them. Our example is obviously
contrived, but it's possible to see how publish and subscribe over topics can
make your code even less tightly tied, freeing you to structure it as you like,
without having to build registry objects for callback functions when doing
asynchronous programming.

A Note on Lineage
-----------------

Like much of the rest of Dojo, the event system is the work of many people over
time. The contributions both in code and concept have been incredibly valuable.

The event system was developed after an extensive review of the available
code-bases and aproaches. `f(m)`'s system, while equally flexible, was more
cumbersome to use in the common case. `netWindow`'s system, while directly
analagous to after advice, wouldn't have been easy to retrofit for the other
event types, but  it's easy-to-use API interface was borrowed. `Burst`'s
advice system eventually became the root of the Dojo event system after it
became clear that initial work on a new system was turning into an
almost-verbatim re-write of what was already available there. Subsequent
modifications have been made for ease of use, `before-advice` and
`after-advice` event types, and delayed events.

Event normalization for browser was inspired from much good and similar work in
`f(m)`.

Topic-based events build on the basic capabilities provided by `connect()`. It
was was donated to Dojo by the WebWork team after discussions about how it
might be accomplished and how a similar system based on `netWindows` sigslot
systems was developed for the `repubusb` client.

About The Author
#########################

Alex Russell is the project lead for Dojo and  can be reached at
<alex@dojotoolkit.org>. His blog is at: http://alex.dojotoolkit.org

.. _`Aspect Oriented Programming`: http://www-128.ibm.com/developerworks/rational/library/2782.html
.. _`The Dojo Wiki`: http://dojo.jot.com/
.. _`Venkman`: http://www.hacksrus.com/~ginda/venkman/

.. raw:: html
   :file: website/rest_template/sidebar.html

The Dojo Event System
=====================

:Author: Alex Russell
:Version: 0.1
:Copyright: Dojo Foundation, 2005
:Date: 2005/08/18

.. contents::
	
.. raw:: html
   :file: website/rest_template/footer.html

.. vim:ts=4:et:tw=0:shiftwidth=4:
