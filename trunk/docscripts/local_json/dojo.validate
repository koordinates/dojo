{"dojo.validate._":{"meta":{"requires":{"common":["dojo.validate.check","dojo.validate.datetime","dojo.validate.de","dojo.validate.jp","dojo.validate.us","dojo.validate.web"]}}},"dojo.validate.check":{"meta":{"requires":{"common":["dojo.validate.common","dojo.lang.common"]},"methods":{"dojo.validate.check":{"_":{"meta":{"summary":"","parameters":{"form":{"type":""},"profile":{"type":""}},"src":"\tvar invalid = [];\n\n\t\/\/ results object summarizes the validation\n\tvar results = {\n\t\tisSuccessful: function() {return ( !this.hasInvalid() && !this.hasMissing() );},\n\t\thasMissing: function() {return ( missing.length > 0 );},\n\t\tgetMissing: function() {return missing;},\n\t\tisMissing: function(elemname) {\n\t\t\tfor (var i = 0; i < missing.length; i++) {\n\t\t\t\tif ( elemname == missing[i] ) { return true; }\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\thasInvalid: function() {return ( invalid.length > 0 );},\n\t\tgetInvalid: function() {return invalid;},\n\t\tisInvalid: function(elemname) {\n\t\t\tfor (var i = 0; i < invalid.length; i++) {\n\t\t\t\tif ( elemname == invalid[i] ) { return true; }\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t\/\/ Filters are applied before fields are validated.\n\t\/\/ Trim removes white space at the front and end of the fields.\n\tif ( profile.trim instanceof Array ) {\n\t\tfor (var i = 0; i < profile.trim.length; i++) {\n\t\t\tvar elem = form[profile.trim[i]];\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; }\n\t\t\telem.value = elem.value.replace(\/(^\\s*|\\s*$)\/g, \"\");\n\t\t}\n\t}\n\t\/\/ Convert to uppercase\n\tif ( profile.uppercase instanceof Array ) {\n\t\tfor (var i = 0; i < profile.uppercase.length; i++) {\n\t\t\tvar elem = form[profile.uppercase[i]];\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; }\n\t\t\telem.value = elem.value.toUpperCase();\n\t\t}\n\t}\n\t\/\/ Convert to lowercase\n\tif ( profile.lowercase instanceof Array ) {\n\t\tfor (var i = 0; i < profile.lowercase.length; i++) {\n\t\t\tvar elem = form[profile.lowercase[i]];\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; }\n\t\t\telem.value = elem.value.toLowerCase();\n\t\t}\n\t}\n\t\/\/ Uppercase first letter\n\tif ( profile.ucfirst instanceof Array ) {\n\t\tfor (var i = 0; i < profile.ucfirst.length; i++) {\n\t\t\tvar elem = form[profile.ucfirst[i]];\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; }\n\t\t\telem.value = elem.value.replace(\/\\b\\w+\\b\/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });\n\t\t}\n\t}\n\t\/\/ Remove non digits characters from the input.\n\tif ( profile.digit instanceof Array ) {\n\t\tfor (var i = 0; i < profile.digit.length; i++) {\n\t\t\tvar elem = form[profile.digit[i]];\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; }\n\t\t\telem.value = elem.value.replace(\/\\D\/g, \"\");\n\t\t}\n\t}\n\n\t\/\/ See if required input fields have values missing.\n\tif ( profile.required instanceof Array ) {\n\t\tfor (var i = 0; i < profile.required.length; i++) { \n\t\t\tif(!dojo.lang.isString(profile.required[i])){ continue; }\n\t\t\tvar elem = form[profile.required[i]];\n\t\t\t\/\/ Are textbox, textarea, or password fields blank.\n\t\t\tif ( (elem.type == \"text\" || elem.type == \"textarea\" || elem.type == \"password\") && \/^\\s*$\/.test(elem.value) ) {\t\n\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t}\n\t\t\t\/\/ Does drop-down box have option selected.\n\t\t\telse if ( (elem.type == \"select-one\" || elem.type == \"select-multiple\") && elem.selectedIndex == -1 ) {\n\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t}\n\t\t\t\/\/ Does radio button group (or check box group) have option checked.\n\t\t\telse if ( elem instanceof Array )  {\n\t\t\t\tvar checked = false;\n\t\t\t\tfor (var j = 0; j < elem.length; j++) {\n\t\t\t\t\tif (elem[j].checked) { checked = true; }\n\t\t\t\t}\n\t\t\t\tif ( !checked ) {\t\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/ See if checkbox groups and select boxes have x number of required values.\n\tif ( profile.required instanceof Array ) {\n\t\tfor (var i = 0; i < profile.required.length; i++) { \n\t\t\tif(!dojo.lang.isObject(profile.required[i])){ continue; }\n\t\t\tvar elem, numRequired;\n\t\t\tfor (var name in profile.required[i]) { \n\t\t\t\telem = form[name]; \n\t\t\t\tnumRequired = profile.required[i][name];\n\t\t\t}\n\t\t\t\/\/ case 1: elem is a check box group\n\t\t\tif ( elem instanceof Array )  {\n\t\t\t\tvar checked = 0;\n\t\t\t\tfor (var j = 0; j < elem.length; j++) {\n\t\t\t\t\tif (elem[j].checked) { checked++; }\n\t\t\t\t}\n\t\t\t\tif ( checked < numRequired ) {\t\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ case 2: elem is a select box\n\t\t\telse if ( elem.type == \"select-multiple\" ) {\n\t\t\t\tvar selected = 0;\n\t\t\t\tfor (var j = 0; j < elem.options.length; j++) {\n\t\t\t\t\tif (elem.options[j].selected) { selected++; }\n\t\t\t\t}\n\t\t\t\tif ( selected < numRequired ) {\t\n\t\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/ Dependant fields are required when the target field is present (not blank).\n\t\/\/ Todo: Support dependant and target fields that are radio button groups, or select drop-down lists.\n\t\/\/ Todo: Make the dependancy based on a specific value of the target field.\n\t\/\/ Todo: allow dependant fields to have several required values, like {checkboxgroup: 3}.\n\tif(dojo.lang.isObject(profile.dependancies)){\n\t\t\/\/ properties of dependancies object are the names of dependant fields to be checked\n\t\tfor (name in profile.dependancies) {\n\t\t\tvar elem = form[name];\t\/\/ the dependant element\n\t\t\tif ( elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\" ) { continue; } \/\/ limited support\n\t\t\tif ( \/\\S+\/.test(elem.value) ) { continue; }\t\/\/ has a value already\n\t\t\tif ( results.isMissing(elem.name) ) { continue; }\t\/\/ already listed as missing\n\t\t\tvar target = form[profile.dependancies[name]];\n\t\t\tif ( target.type != \"text\" && target.type != \"textarea\" && target.type != \"password\" ) { continue; }\t\/\/ limited support\n\t\t\tif ( \/^\\s*$\/.test(target.value) ) { continue; }\t\/\/ skip if blank\n\t\t\tmissing[missing.length] = elem.name;\t\/\/ ok the dependant field is missing\n\t\t}\n\t}\n\n\t\/\/ Find invalid input fields.\n\tif(dojo.lang.isObject(profile.constraints)){\n\t\t\/\/ constraint properties are the names of fields to be validated\n\t\tfor(name in profile.constraints){\n\t\t\tvar elem = form[name];\n\t\t\tif(\t(elem.type != \"text\")&&\n\t\t\t\t(elem.type != \"textarea\")&&\n\t\t\t\t(elem.type != \"password\")){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\/\/ skip if blank - its optional unless required, in which case it\n\t\t\t\/\/ is already listed as missing.\n\t\t\tif( \/^\\s*$\/.test(elem.value)){ continue; }\n\n\t\t\tvar isValid = true;\n\t\t\t\/\/ case 1: constraint value is validation function\n\t\t\tif(dojo.lang.isFunction(profile.constraints[name])){\n\t\t\t\tisValid = profile.constraints[name](elem.value);\n\t\t\t} else if(dojo.lang.isArray(profile.constraints[name])){\n\t\t\t\t\/\/ handle nested arrays for multiple constraints\n\t\t\t\tif (dojo.lang.isArray(profile.constraints[name][0])) {\n\t\t\t\t\tfor (var i=0; i<profile.constraints[name].length; i++) {\n\t\t\t\t\t\tisValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name][i], name, elem);\n\t\t\t\t\t\tif (!isValid) { break; }\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t\/\/ case 2: constraint value is array, first elem is function,\n\t\t\t\t\t\/\/ tail is parameters\n\t\t\t\t\tisValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name], name, elem);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!isValid){\t\n\t\t\t\tinvalid[invalid.length] = elem.name;\n\t\t\t}\n\t\t}\n\t}\n\n\t\/\/ Find unequal confirm fields and report them as Invalid.\n\tif(dojo.lang.isObject(profile.confirm)){\n\t\tfor(name in profile.confirm){\n\t\t\tvar elem = form[name];\t\/\/ the confirm element\n\t\t\tvar target = form[profile.confirm[name]];\n\t\t\tif ( (elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\") \n\t\t\t\t||(target.type != elem.type)\n\t\t\t\t||(target.value == elem.value)\t\/\/ it's valid\n\t\t\t\t||(results.isInvalid(elem.name))\/\/ already listed as invalid\n\t\t\t\t||(\/^\\s*$\/.test(target.value))\t)\t\/\/ skip if blank - only confirm if target has a value\n\t\t\t{\n\t\t\t\tcontinue; \n\t\t\t}\t\n\t\t\tinvalid[invalid.length] = elem.name;\n\t\t}\n\t}\n\n\treturn results;"}}},"dojo.validate.evaluateConstraint":{"_":{"meta":{"summary":"","parameters":{"profile":{"type":""},"constraint":{"type":""},"fieldName":{"type":""},"elem":{"type":""}},"src":"\tvar isValidSomething = constraint[0];\n\tvar params = constraint.slice(1);\n\tparams.unshift(elem.value);\n\tif(typeof isValidSomething != \"undefined\"){\n\t\treturn isValidSomething.apply(null, params);\n\t}\n\treturn false;"}}}}}},"dojo.validate.common":{"meta":{"requires":{"common":["dojo.regexp"]},"methods":{"dojo.validate.isText":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tflags = (typeof flags == \"object\") ? flags : {};\n\n\t\/\/ test for text\n\tif ( \/^\\s*$\/.test(value) ) { return false; }\n\n\t\/\/ length tests\n\tif ( typeof flags.length == \"number\" && flags.length != value.length ) { return false; }\n\tif ( typeof flags.minlength == \"number\" && flags.minlength > value.length ) { return false; }\n\tif ( typeof flags.maxlength == \"number\" && flags.maxlength < value.length ) { return false; }\n\n\treturn true;"}}},"dojo.validate.isInteger":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.integer(flags) + \"$\");\n\treturn re.test(value);"}}},"dojo.validate.isRealNumber":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.realNumber(flags) + \"$\");\n\treturn re.test(value);"}}},"dojo.validate.isCurrency":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.currency(flags) + \"$\");\n\treturn re.test(value);"}}},"dojo.validate.isInRange":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar max = (typeof flags.max == \"number\") ? flags.max : Infinity;\n\tvar min = (typeof flags.min == \"number\") ? flags.min : -Infinity;\n\tvar dec = (typeof flags.decimal == \"string\") ? flags.decimal : \".\";\n\t\n\t\/\/ splice out anything not part of a number\n\tvar pattern = \"[^\" + dec + \"\\\\deE+-]\";\n\tvalue = value.replace(RegExp(pattern, \"g\"), \"\");\n\n\t\/\/ trim ends of things like e, E, or the decimal character\n\tvalue = value.replace(\/^([+-]?)(\\D*)\/, \"$1\");\n\tvalue = value.replace(\/(\\D*)$\/, \"\");\n\n\t\/\/ replace decimal with \".\". The minus sign '-' could be the decimal!\n\tpattern = \"(\\\\d)[\" + dec + \"](\\\\d)\";\n\tvalue = value.replace(RegExp(pattern, \"g\"), \"$1.$2\");\n\n\tvalue = Number(value);\n\tif ( value < min || value > max ) { return false; }\n\n\treturn true;"}}},"dojo.validate.isNumberFormat":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.numberFormat(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}}}}},"dojo.validate.datetime":{"meta":{"requires":{"common":["dojo.validate.common"]},"methods":{"dojo.validate.isValidTime":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.time(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.is12HourTime":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\treturn dojo.validate.isValidTime(value, {format: [\"h:mm:ss t\", \"h:mm t\"]});"}}},"dojo.validate.is24HourTime":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\treturn dojo.validate.isValidTime(value, {format: [\"HH:mm:ss\", \"HH:mm\"]} );"}}},"dojo.validate.isValidDate":{"_":{"meta":{"summary":"","parameters":{"dateValue":{"type":""},"format":{"type":""}},"src":"\tif (typeof format != \"string\") { format = \"MM\/DD\/YYYY\"; }\n\n\t\/\/ Create a literal regular expression based on format\n\tvar reLiteral = format.replace(\/([$^.*+?=!:|\\\/\\\\\\(\\)\\[\\]\\{\\}])\/g, \"\\\\$1\");\n\n\t\/\/ Convert all the tokens to RE elements\n\treLiteral = reLiteral.replace( \"YYYY\", \"([0-9]{4})\" );\n\treLiteral = reLiteral.replace( \"MM\", \"(0[1-9]|10|11|12)\" );\n\treLiteral = reLiteral.replace( \"M\", \"([1-9]|10|11|12)\" );\n\treLiteral = reLiteral.replace( \"DDD\", \"(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])\" );\n\treLiteral = reLiteral.replace( \"DD\", \"(0[1-9]|[12][0-9]|30|31)\" );\n\treLiteral = reLiteral.replace( \"D\", \"([1-9]|[12][0-9]|30|31)\" );\n\treLiteral = reLiteral.replace( \"ww\", \"(0[1-9]|[1-4][0-9]|5[0-3])\" );\n\treLiteral = reLiteral.replace( \"d\", \"([1-7])\" );\n\n\t\/\/ Anchor pattern to begining and end of string\n\treLiteral = \"^\" + reLiteral + \"$\";\n\n\t\/\/ Dynamic RE that parses the original format given\n\tvar re = new RegExp(reLiteral);\n\t\n\t\/\/ Test if date is in a valid format\n\tif (!re.test(dateValue))  return false;\n\n\t\/\/ Parse date to get elements and check if date is valid\n\t\/\/ Assume valid values for date elements not given.\n\tvar year = 0, month = 1, date = 1, dayofyear = 1, week = 1, day = 1;\n\n\t\/\/ Capture tokens\n\tvar tokens = format.match( \/(YYYY|MM|M|DDD|DD|D|ww|d)\/g );\n\n\t\/\/ Capture date values\n\tvar values = re.exec(dateValue);\n\n\t\/\/ Match up tokens with date values\n\tfor (var i = 0; i < tokens.length; i++) {\n\t\tswitch (tokens[i]) {\n\t\tcase \"YYYY\":\n\t\t\tyear = Number(values[i+1]); break;\n\t\tcase \"M\":\n\t\tcase \"MM\":\n\t\t\tmonth = Number(values[i+1]); break;\n\t\tcase \"D\":\n\t\tcase \"DD\":\n\t\t\tdate = Number(values[i+1]); break;\n\t\tcase \"DDD\":\n\t\t\tdayofyear = Number(values[i+1]); break;\n\t\tcase \"ww\":\n\t\t\tweek = Number(values[i+1]); break;\n\t\tcase \"d\":\n\t\t\tday = Number(values[i+1]); break;\n\t\t}\n\t}\n\n\t\/\/ Leap years are divisible by 4, but not by 100, unless by 400\n\tvar leapyear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n\n\t\/\/ 31st of a month with 30 days\n\tif (date == 31 && (month == 4 || month == 6 || month == 9 || month == 11)) return false; \n\n\t\/\/ February 30th or 31st\n\tif (date >= 30 && month == 2) return false; \n\n\t\/\/ February 29th outside a leap year\n\tif (date == 29 && month == 2 && !leapyear) return false; \n\tif (dayofyear == 366 && !leapyear)  return false;\n\n\treturn true;"}}}}}},"dojo.validate.de":{"meta":{"requires":{"common":["dojo.validate.common"]},"methods":{"dojo.validate.isGermanCurrency":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tvar flags = {\n\t\tsymbol: \"\ufffd\",\n\t\tplacement: \"after\",\n\t\tdecimal: \",\",\n\t\tseparator: \".\"\n\t};\n\treturn dojo.validate.isCurrency(value, flags);"}}}}}},"dojo.validate.jp":{"meta":{"requires":{"common":["dojo.validate.common"]},"methods":{"dojo.validate.isJapaneseCurrency":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tvar flags = {\n\t\tsymbol: \"\ufffd\",\n\t\tcents: false\n\t};\n\treturn dojo.validate.isCurrency(value, flags);"}}}}}},"dojo.validate.us":{"meta":{"requires":{"common":["dojo.validate.common"]},"methods":{"dojo.validate.us.isCurrency":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\treturn dojo.validate.isCurrency(value, flags);"}}},"dojo.validate.us.isState":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.us.state(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.us.isPhoneNumber":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tvar flags = {\n\t\tformat: [\n\t\t\t\"###-###-####\",\n\t\t\t\"(###) ###-####\",\n\t\t\t\"(###) ### ####\",\n\t\t\t\"###.###.####\",\n\t\t\t\"###\/###-####\",\n\t\t\t\"### ### ####\",\n\t\t\t\"###-###-#### x#???\",\n\t\t\t\"(###) ###-#### x#???\",\n\t\t\t\"(###) ### #### x#???\",\n\t\t\t\"###.###.#### x#???\",\n\t\t\t\"###\/###-#### x#???\",\n\t\t\t\"### ### #### x#???\",\n\t\t\t\"##########\"\n\t\t]\n\t};\n\n\treturn dojo.validate.isNumberFormat(value, flags);"}}},"dojo.validate.us.isSocialSecurityNumber":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tvar flags = {\n\t\tformat: [\n\t\t\t\"###-##-####\",\n\t\t\t\"### ## ####\",\n\t\t\t\"#########\"\n\t\t]\n\t};\n\n\treturn dojo.validate.isNumberFormat(value, flags);"}}},"dojo.validate.us.isZipCode":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tvar flags = {\n\t\tformat: [\n\t\t\t\"#####-####\",\n\t\t\t\"##### ####\",\n\t\t\t\"#########\",\n\t\t\t\"#####\"\n\t\t]\n\t};\n\n\treturn dojo.validate.isNumberFormat(value, flags);"}}}}}},"dojo.validate.web":{"meta":{"requires":{"common":["dojo.validate.common"]},"methods":{"dojo.validate.isIpAddress":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.ipAddress(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.isUrl":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.url(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.isEmailAddress":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.emailAddress(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.isEmailAddressList":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.emailAddressList(flags) + \"$\", \"i\");\n\treturn re.test(value);"}}},"dojo.validate.getEmailAddressList":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":"\tif(!flags) { flags = {}; }\n\tif(!flags.listSeparator) { flags.listSeparator = \"\\\\s;,\"; }\n\n\tif ( dojo.validate.isEmailAddressList(value, flags) ) {\n\t\treturn value.split(new RegExp(\"\\\\s*[\" + flags.listSeparator + \"]\\\\s*\"));\n\t}\n\treturn [];"}}}}}},"dojo.validate":{"meta":{"requires":{"common":["dojo.validate.common"]}}}}