{"dojo.lang._":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.assert","dojo.lang.array","dojo.lang.type","dojo.lang.func","dojo.lang.extras","dojo.lang.repr","dojo.lang.declare"]}}},"dojo.lang.array":{"meta":{"requires":{"common":["dojo.lang.common"]},"methods":{"dojo.lang.has":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""},"name":{"type":""}},"src":"\ttry{\n\t\treturn (typeof obj[name] != \"undefined\");\n\t}catch(e){ return false; }"}}},"dojo.lang.isEmpty":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""}},"src":"\tif(dojo.lang.isObject(obj)) {\n\t\tvar tmp = {};\n\t\tvar count = 0;\n\t\tfor(var x in obj){\n\t\t\tif(obj[x] && (!tmp[x])){\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t} \n\t\t}\n\t\treturn (count == 0);\n\t} else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)) {\n\t\treturn obj.length == 0;\n\t}"}}},"dojo.lang.map":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""},"obj":{"type":""},"unary_func":{"type":""}},"src":"\tvar isString = dojo.lang.isString(arr);\n\tif(isString){\n\t\tarr = arr.split(\"\");\n\t}\n\tif(dojo.lang.isFunction(obj)&&(!unary_func)){\n\t\tunary_func = obj;\n\t\tobj = dj_global;\n\t}else if(dojo.lang.isFunction(obj) && unary_func){\n\t\t\/\/ ff 1.5 compat\n\t\tvar tmpObj = obj;\n\t\tobj = unary_func;\n\t\tunary_func = tmpObj;\n\t}\n\tif(Array.map){\n\t \tvar outArr = Array.map(arr, unary_func, obj);\n\t}else{\n\t\tvar outArr = [];\n\t\tfor(var i=0;i<arr.length;++i){\n\t\t\toutArr.push(unary_func.call(obj, arr[i]));\n\t\t}\n\t}\n\tif(isString) {\n\t\treturn outArr.join(\"\");\n\t} else {\n\t\treturn outArr;\n\t}"}}},"dojo.lang.reduce":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""},"initialValue":{"type":""},"obj":{"type":""},"binary_func":{"type":""}},"src":"\tvar reducedValue = initialValue;\n\tvar ob = obj ? obj : dj_global;\n\tdojo.lang.map(arr, \n\t\tfunction(val){\n\t\t\treducedValue = binary_func.call(ob, reducedValue, val);\n\t\t}\n\t);\n\treturn reducedValue;"}}},"dojo.lang.forEach":{"_":{"meta":{"summary":"","parameters":{"anArray":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object"}},"src":"\tif(dojo.lang.isString(anArray)){ \n\t\tanArray = anArray.split(\"\"); \n\t}\n\tif(Array.forEach){\n\t\tArray.forEach(anArray, callback, thisObject);\n\t}else{\n\t\t\/\/ FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?\n\t\tif(!thisObject){\n\t\t\tthisObject=dj_global;\n\t\t}\n\t\tfor(var i=0,l=anArray.length; i<l; i++){ \n\t\t\tcallback.call(thisObject, anArray[i], i, anArray);\n\t\t}\n\t}"}}},"dojo.lang._everyOrSome":{"_":{"meta":{"summary":"","parameters":{"every":{"type":""},"arr":{"type":""},"callback":{"type":""},"thisObject":{"type":""}},"src":"\tif(dojo.lang.isString(arr)){ \n\t\tarr = arr.split(\"\"); \n\t}\n\tif(Array.every){\n\t\treturn Array[ (every) ? \"every\" : \"some\" ](arr, callback, thisObject);\n\t}else{\n\t\tif(!thisObject){\n\t\t\tthisObject = dj_global;\n\t\t}\n\t\tfor(var i=0,l=arr.length; i<l; i++){\n\t\t\tvar result = callback.call(thisObject, arr[i], i, arr);\n\t\t\tif((every)&&(!result)){\n\t\t\t\treturn false;\n\t\t\t}else if((!every)&&(result)){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn (every) ? true : false;\n\t}"}}},"dojo.lang.every":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""},"callback":{"type":""},"thisObject":{"type":""}},"src":"\treturn this._everyOrSome(true, arr, callback, thisObject);"}}},"dojo.lang.some":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""},"callback":{"type":""},"thisObject":{"type":""}},"src":"\treturn this._everyOrSome(false, arr, callback, thisObject);"}}},"dojo.lang.filter":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""},"callback":{"type":""},"thisObject":{"type":""}},"src":"\tvar isString = dojo.lang.isString(arr);\n\tif(isString) { arr = arr.split(\"\"); }\n\tif(Array.filter) {\n\t\tvar outArr = Array.filter(arr, callback, thisObject);\n\t} else {\n\t\tif(!thisObject) {\n\t\t\tif(arguments.length >= 3) { dojo.raise(\"thisObject doesn't exist!\"); }\n\t\t\tthisObject = dj_global;\n\t\t}\n\n\t\tvar outArr = [];\n\t\tfor(var i = 0; i < arr.length; i++) {\n\t\t\tif(callback.call(thisObject, arr[i], i, arr)) {\n\t\t\t\toutArr.push(arr[i]);\n\t\t\t}\n\t\t}\n\t}\n\tif(isString) {\n\t\treturn outArr.join(\"\");\n\t} else {\n\t\treturn outArr;\n\t}"}}},"dojo.lang.unnest":{"_":{"meta":{"summary":"","src":"\tvar out = [];\n\tfor(var i = 0; i < arguments.length; i++) {\n\t\tif(dojo.lang.isArrayLike(arguments[i])) {\n\t\t\tvar add = dojo.lang.unnest.apply(this, arguments[i]);\n\t\t\tout = out.concat(add);\n\t\t} else {\n\t\t\tout.push(arguments[i]);\n\t\t}\n\t}\n\treturn out;"}}},"dojo.lang.toArray":{"_":{"meta":{"summary":"","parameters":{"arrayLike":{"type":""},"startOffset":{"type":""}},"src":"\tvar array = [];\n\tfor(var i = startOffset||0; i < arrayLike.length; i++) {\n\t\tarray.push(arrayLike[i]);\n\t}\n\treturn array;"}}}}}},"dojo.lang.assert":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.array","dojo.lang.type"]},"methods":{"dojo.lang.assert":{"_":{"meta":{"summary":"","parameters":{"booleanValue":{"type":""},"message":{"type":""}},"src":"\tif(!booleanValue){\n\t\tvar errorMessage = \"An assert statement failed.\\n\" +\n\t\t\t\"The method dojo.lang.assert() was called with a 'false' value.\\n\";\n\t\tif(message){\n\t\t\terrorMessage += \"Here's the assert message:\\n\" + message + \"\\n\";\n\t\t}\n\t\t\/\/ Use throw instead of dojo.raise, until bug #264 is fixed:\n\t\t\/\/ dojo.raise(errorMessage);\n\t\tthrow new Error(errorMessage);\n\t}"}}},"dojo.lang.assertType":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"type":{"type":""},"keywordParameters":{"type":""}},"src":"\tif (dojo.lang.isString(keywordParameters)) {\n\t\tdojo.deprecated('dojo.lang.assertType(value, type, \"message\")', 'use dojo.lang.assertType(value, type) instead', \"0.5\");\n\t}\n\tif(!dojo.lang.isOfType(value, type, keywordParameters)){\n\t\tif(!dojo.lang.assertType._errorMessage){\n\t\t\tdojo.lang.assertType._errorMessage = \"Type mismatch: dojo.lang.assertType() failed.\";\n\t\t}\n\t\tdojo.lang.assert(false, dojo.lang.assertType._errorMessage);\n\t}"}}},"dojo.lang.assertValidKeywords":{"_":{"meta":{"summary":"","parameters":{"object":{"type":""},"expectedProperties":{"type":""},"message":{"type":""}},"src":"\tvar key;\n\tif(!message){\n\t\tif(!dojo.lang.assertValidKeywords._errorMessage){\n\t\t\tdojo.lang.assertValidKeywords._errorMessage = \"In dojo.lang.assertValidKeywords(), found invalid keyword:\";\n\t\t}\n\t\tmessage = dojo.lang.assertValidKeywords._errorMessage;\n\t}\n\tif(dojo.lang.isArray(expectedProperties)){\n\t\tfor(key in object){\n\t\t\tif(!dojo.lang.inArray(expectedProperties, key)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(key in object){\n\t\t\tif(!(key in expectedProperties)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}"}}}}}},"dojo.lang.common":{"meta":{"methods":{"dojo.lang.inherits":{"_":{"meta":{"summary":"Set up inheritance between two classes.","parameters":{"subclass":{"type":"Function"},"superclass":{"type":"Function"}},"src":"\t\tdojo.raise(\"dojo.inherits: superclass argument [\"+superclass+\"] must be a function (subclass: [\"+subclass+\"']\");\n\t}\n\tsubclass.prototype = new superclass();\n\tsubclass.prototype.constructor = subclass;\n\tsubclass.superclass = superclass.prototype;\n\t\/\/ DEPRICATED: super is a reserved word, use 'superclass'\n\tsubclass['super'] = superclass.prototype;"}}},"dojo.lang._mixin":{"_":{"meta":{"summary":"Adds all properties and methods of props to obj.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object"}},"src":"\tfor(var x in props){\n\t\t\/\/ the \"tobj\" condition avoid copying properties in \"props\"\n\t\t\/\/ inherited from Object.prototype.  For example, if obj has a custom\n\t\t\/\/ toString() method, don't overwrite it with the toString() method\n\t\t\/\/ that props inherited from Object.protoype\n\t\tif((typeof tobj[x] == \"undefined\") || (tobj[x] != props[x])){\n\t\t\tobj[x] = props[x];\n\t\t}\n\t}\n\t\/\/ IE doesn't recognize custom toStrings in for..in\n\tif(dojo.render.html.ie \n\t\t&& (typeof(props[\"toString\"]) == \"function\")\n\t\t&& (props[\"toString\"] != obj[\"toString\"])\n\t\t&& (props[\"toString\"] != tobj[\"toString\"]))\n\t{\n\t\tobj.toString = props.toString;\n\t}\n\treturn obj;"}}},"dojo.lang.mixin":{"_":{"meta":{"summary":"Adds all properties and methods of props to obj.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object..."}},"src":"\t\tdojo.lang._mixin(obj, arguments[i]);\n\t}\n\treturn obj; \/\/ Object","returns":"Object"}}},"dojo.lang.extend":{"_":{"meta":{"summary":"Adds all properties and methods of props to constructor's prototype, making them available to all instances created with constructor.","parameters":{"constructor":{"type":"Object"},"props":{"type":"Object..."}},"src":"\t\tdojo.lang._mixin(constructor.prototype, arguments[i]);\n\t}\n\treturn constructor;"}}},"dojo.lang.find":{"_":{"meta":{"summary":"Return the index of value in array, returning -1 if not found. param: identity:  If true, matches with identity comparison (===). If false, uses normal comparison (==). param: findLast:  If true, returns index of last instance of value. usage: find(array, value[, identity [findLast]]) \/\/ recommended usage: find(value, array[, identity [findLast]]) \/\/ deprecated support both (array, value) and (value, array)","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"Boolean?"},"findLast":{"type":"Boolean?"}},"src":"\t\tdojo.deprecated('dojo.lang.find(value, array)', 'use dojo.lang.find(array, value) instead', \"0.5\");\n\t\tvar temp = array;\n\t\tarray = value;\n\t\tvalue = temp;\n\t}\n\tvar isString = dojo.lang.isString(array);\n\tif(isString) { array = array.split(\"\"); }\n\n\tif(findLast) {\n\t\tvar step = -1;\n\t\tvar i = array.length - 1;\n\t\tvar end = -1;\n\t} else {\n\t\tvar step = 1;\n\t\tvar i = 0;\n\t\tvar end = array.length;\n\t}\n\tif(identity){\n\t\twhile(i != end) {\n\t\t\tif(array[i] === value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}else{\n\t\twhile(i != end) {\n\t\t\tif(array[i] == value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}\n\treturn -1;\t\/\/ number","returns":"number"}}},"dojo.lang.findLast":{"_":{"meta":{"summary":"Return index of last occurance of value in array, returning -1 if not found. param: identity:  If true, matches with identity comparison (===). If false, uses normal comparison (==).","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"boolean?"}},"src":""}}},"dojo.lang.inArray":{"_":{"meta":{"summary":"Return true if value is present in array. return: boolean","parameters":{"array":{"type":"Array"},"value":{"type":"Object"}},"src":"","returns":"return: boolean"}}},"dojo.lang.isObject":{"_":{"meta":{"summary":"Return true if it is an Object, Array or Function.","parameters":{"it":{"type":""}},"src":"\treturn (typeof it == \"object\" || it === null || dojo.lang.isArray(it) || dojo.lang.isFunction(it));"}}},"dojo.lang.isArray":{"_":{"meta":{"summary":"Return true if it is an Array.","parameters":{"it":{"type":""}},"src":""}}},"dojo.lang.isArrayLike":{"_":{"meta":{"summary":"Return true if it can be used as an array (i.e. is an object with an integer length property).","parameters":{"it":{"type":""}},"src":"\tif(dojo.lang.isString(it)){ return false; }\n\tif(dojo.lang.isFunction(it)){ return false; } \/\/ keeps out built-in constructors (Number, String, ...) which have length properties\n\tif(dojo.lang.isArray(it)){ return true; }\n\t\/\/ form node itself is ArrayLike, but not always iterable. Use form.elements instead.\n\tif((it.tagName)&&(it.tagName.toLowerCase()=='form')){ return false; }\n\tif(dojo.lang.isNumber(it.length) && isFinite(it.length)){ return true; }\n\treturn false;","returns":"keeps out built-in constructors (Number, String, ...) which have length properties"}}},"dojo.lang.isFunction":{"_":{"meta":{"summary":"Return true if it is a Function.","parameters":{"it":{"type":""}},"src":"\treturn (it instanceof Function || typeof it == \"function\");"}}},"dojo.lang.isString":{"_":{"meta":{"summary":"Return true if it is a String.","parameters":{"it":{"type":""}},"src":""}}},"dojo.lang.isAlien":{"_":{"meta":{"summary":"Return true if it is not a built-in function.","parameters":{"it":{"type":""}},"src":"\treturn !dojo.lang.isFunction() && \/\\{\\s*\\[native code\\]\\s*\\}\/.test(String(it));"}}},"dojo.lang.isBoolean":{"_":{"meta":{"summary":"Return true if it is a Boolean.","parameters":{"it":{"type":""}},"src":""}}},"dojo.lang.isNumber":{"_":{"meta":{"summary":"Return true if it is a number. warning: In most cases, isNaN(it) is sufficient to determine whether or not something is a number or can be used as such. For example, a number or string can be used interchangably when accessing array items (array[\"1\"] is the same as array[1]) and isNaN will return false for both values (\"1\" and 1). However, isNumber(\"1\")  will return false, which is generally not too useful. Also, isNumber(NaN) returns true, again, this isn't generally useful, but there are corner cases (like when you want to make sure that two things are really the same type of thing). That is really where isNumber \"shines\". recommendation: Use isNaN(it) when possible","parameters":{"it":{"type":""}},"src":""}}},"dojo.lang.isUndefined":{"_":{"meta":{"summary":"Return true if it is not defined. warning: In some cases, isUndefined will not behave as you might expect. If you do isUndefined(foo) and there is no earlier reference to foo, an error will be thrown before isUndefined is called. It behaves correctly if you scope yor object first, i.e. isUndefined(foo.bar) where foo is an object and bar isn't a property of the object. recommendation: Use typeof foo == \"undefined\" when possible","parameters":{"it":{"type":""}},"src":""}}}}}},"dojo.lang.declare":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.extras"]},"methods":{"dojo.lang.declare":{"_":{"meta":{"summary":"","parameters":{"className":{"type":"string"},"superclass":{"type":"function || array"},"init":{"type":"function"},"props":{"type":"object"}},"src":"\t\tvar temp = props;\n\t\tprops = init;\n\t\tinit = temp;\n\t}\t\n\tvar mixins = [ ];\n\tif (dojo.lang.isArray(superclass)) {\n\t\tmixins = superclass;\n\t\tsuperclass = mixins.shift();\n\t}\n\tif(!init){\n\t\tinit = dojo.evalObjPath(className, false);\n\t\tif ((init)&&(!dojo.lang.isFunction(init))){ init = null };\n\t}\n\tvar ctor = dojo.lang.declare._makeConstructor();\n\tvar scp = (superclass ? superclass.prototype : null);\n\tif(scp){\n\t\tscp.prototyping = true;\n\t\tctor.prototype = new superclass();\n\t\tscp.prototyping = false; \n\t}\n\tctor.superclass = scp;\n\tctor.mixins = mixins;\n\tfor(var i=0,l=mixins.length; i<l; i++){\n\t\tdojo.lang.extend(ctor, mixins[i].prototype);\n\t}\n\tctor.prototype.initializer = null;\n\tctor.prototype.declaredClass = className;\n\tif(dojo.lang.isArray(props)){\n\t\tdojo.lang.extend.apply(dojo.lang, [ctor].concat(props));\n\t}else{\n\t\tdojo.lang.extend(ctor, (props)||{});\n\t}\n\tdojo.lang.extend(ctor, dojo.lang.declare.base);\n\tctor.prototype.constructor = ctor;\n\tctor.prototype.initializer=(ctor.prototype.initializer)||(init)||(function(){});\n\tdojo.lang.setObjPathValue(className, ctor, null, true);\n\treturn ctor;"}}},"dojo.lang.declare._makeConstructor":{"_":{"meta":{"summary":"","src":"\treturn function(){ \n\t\t\/\/ get the generational context (which object [or prototype] should be constructed)\n\t\tvar self = this._getPropContext();\n\t\tvar s = self.constructor.superclass;\n\t\tif((s)&&(s.constructor)){\n\t\t\tif(s.constructor==arguments.callee){\n\t\t\t\t\/\/ if this constructor is invoked directly (my.ancestor.call(this))\n\t\t\t\tthis.inherited(\"constructor\", arguments);\n\t\t\t}else{\n\t\t\t\tthis._inherited(s, \"constructor\", arguments);\n\t\t\t}\n\t\t}\n\t\tvar m = (self.constructor.mixins)||([]);\n\t\tfor(var i=0,l=m.length; i<l; i++) {\n\t\t\t(((m[i].prototype)&&(m[i].prototype.initializer))||(m[i])).apply(this, arguments);\n\t\t}\n\t\tif((!this.prototyping)&&(self.initializer)){\n\t\t\tself.initializer.apply(this, arguments);\n\t\t}\n\t}"}}}}}},"dojo.lang.extras":{"meta":{"requires":{"common":["dojo.lang.common"]},"methods":{"dojo.lang.setTimeout":{"_":{"meta":{"summary":"","parameters":{"func":{"type":""},"delay":{"type":""}},"src":"\tvar context = window, argsStart = 2;\n\tif(!dojo.lang.isFunction(func)){\n\t\tcontext = func;\n\t\tfunc = delay;\n\t\tdelay = arguments[2];\n\t\targsStart++;\n\t}\n\n\tif(dojo.lang.isString(func)){\n\t\tfunc = context[func];\n\t}\n\t\n\tvar args = [];\n\tfor (var i = argsStart; i < arguments.length; i++) {\n\t\targs.push(arguments[i]);\n\t}\n\treturn dojo.global().setTimeout(function () { func.apply(context, args); }, delay);"}}},"dojo.lang.clearTimeout":{"_":{"meta":{"summary":"","parameters":{"timer":{"type":""}},"src":"\tdojo.global().clearTimeout(timer);"}}},"dojo.lang.getNameInObj":{"_":{"meta":{"summary":"","parameters":{"ns":{"type":""},"item":{"type":""}},"src":"\tif(!ns){ ns = dj_global; }\n\n\tfor(var x in ns){\n\t\tif(ns[x] === item){\n\t\t\treturn new String(x);\n\t\t}\n\t}\n\treturn null;"}}},"dojo.lang.shallowCopy":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""},"deep":{"type":""}},"src":"\tvar i, ret;\t\n\t\n\tif (obj === null) return null;\n\t\n\tif (dojo.lang.isObject(obj)) {\t\t\n\t\tret = new obj.constructor();\n\t\tfor (i in obj) {\n\t\t\tif(dojo.lang.isUndefined(ret[i])) {\n\t\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t\t}\n\t\t}\n\t} else if (dojo.lang.isArray(obj)) {\n\t\tret = [];\n\t\tfor(i=0; i<obj.length; i++) {\n\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t}\n\t} else {\n\t\tret = obj;\n\t}\n\t\t\t\n\treturn ret;"}}},"dojo.lang.firstValued":{"_":{"meta":{"summary":"","src":"\tfor(var i = 0; i < arguments.length; i++) {\n\t\tif(typeof arguments[i] != \"undefined\") {\n\t\t\treturn arguments[i];\n\t\t}\n\t}\n\treturn undefined;"}}},"dojo.lang.getObjPathValue":{"_":{"meta":{"summary":"","parameters":{"objpath":{"type":""},"context":{"type":""},"create":{"type":""}},"src":"\twith(dojo.parseObjPath(objpath, context, create)){\n\t\treturn dojo.evalProp(prop, obj, create);\n\t}"}}},"dojo.lang.setObjPathValue":{"_":{"meta":{"summary":"","parameters":{"objpath":{"type":""},"value":{"type":""},"context":{"type":""},"create":{"type":""}},"src":"\tif(arguments.length < 4){\n\t\tcreate = true;\n\t}\n\twith(dojo.parseObjPath(objpath, context, create)){\n\t\tif(obj && (create || (prop in obj))){\n\t\t\tobj[prop] = value;\n\t\t}\n\t}"}}}}}},"dojo.lang.func":{"meta":{"requires":{"common":["dojo.lang.common"]},"methods":{"dojo.lang.hitch":{"_":{"meta":{"summary":"","parameters":{"thisObject":{"type":""},"method":{"type":""}},"src":"\tvar fcn = (dojo.lang.isString(method) ? thisObject[method] : method) || function(){};\n\n\treturn function() {\n\t\treturn fcn.apply(thisObject, arguments);\n\t};"}}},"dojo.lang.nameAnonFunc":{"_":{"meta":{"summary":"","parameters":{"anonFuncPtr":{"type":""},"namespaceObj":{"type":""},"searchForNames":{"type":""}},"src":"\tvar nso = (namespaceObj || dojo.lang.anon);\n\tif( (searchForNames) ||\n\t\t((dj_global[\"djConfig\"])&&(djConfig[\"slowAnonFuncLookups\"] == true)) ){\n\t\tfor(var x in nso){\n\t\t\ttry{\n\t\t\t\tif(nso[x] === anonFuncPtr){\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}catch(e){} \/\/ window.external fails in IE embedded in Eclipse (Eclipse bug #151165)\n\t\t}\n\t}\n\tvar ret = \"__\"+dojo.lang.anonCtr++;\n\twhile(typeof nso[ret] != \"undefined\"){\n\t\tret = \"__\"+dojo.lang.anonCtr++;\n\t}\n\tnso[ret] = anonFuncPtr;\n\treturn ret;"}}},"dojo.lang.forward":{"_":{"meta":{"summary":"","parameters":{"funcName":{"type":""}},"src":"\t\treturn this[funcName].apply(this, arguments);\n\t};"}}},"dojo.lang.curry":{"_":{"meta":{"summary":"","parameters":{"ns":{"type":""},"func":{"type":"args ..."}},"src":"\tvar outerArgs = [];\n\tns = ns||dj_global;\n\tif(dojo.lang.isString(func)){\n\t\tfunc = ns[func];\n\t}\n\tfor(var x=2; x<arguments.length; x++){\n\t\touterArgs.push(arguments[x]);\n\t}\n\t\/\/ since the event system replaces the original function with a new\n\t\/\/ join-point runner with an arity of 0, we check to see if it's left us\n\t\/\/ any clues about the original arity in lieu of the function's actual\n\t\/\/ length property\n\tvar ecount = (func[\"__preJoinArity\"]||func.length) - outerArgs.length;\n\t\/\/ borrowed from svend tofte\n\tfunction gather(nextArgs, innerArgs, expected){\n\t\tvar texpected = expected;\n\t\tvar totalArgs = innerArgs.slice(0); \/\/ copy\n\t\tfor(var x=0; x<nextArgs.length; x++){\n\t\t\ttotalArgs.push(nextArgs[x]);\n\t\t}\n\t\t\/\/ check the list of provided nextArgs to see if it, plus the\n\t\t\/\/ number of innerArgs already supplied, meets the total\n\t\t\/\/ expected.\n\t\texpected = expected-nextArgs.length;\n\t\tif(expected<=0){\n\t\t\tvar res = func.apply(ns, totalArgs);\n\t\t\texpected = texpected;\n\t\t\treturn res;\n\t\t}else{\n\t\t\treturn function(){\n\t\t\t\treturn gather(arguments,\/\/ check to see if we've been run\n\t\t\t\t\t\t\t\t\t\t\/\/ with enough args\n\t\t\t\t\t\t\ttotalArgs,\t\/\/ a copy\n\t\t\t\t\t\t\texpected);\t\/\/ how many more do we need to run?;\n\t\t\t};\n\t\t}\n\t}\n\treturn gather([], outerArgs, ecount);","returns":"check to see if we've been run"}}},"dojo.lang.curryArguments":{"_":{"meta":{"summary":"","parameters":{"ns":{"type":""},"func":{"type":""},"args":{"type":""},"offset":{"type":""}},"src":"\tvar targs = [];\n\tvar x = offset||0;\n\tfor(x=offset; x<args.length; x++){\n\t\ttargs.push(args[x]); \/\/ ensure that it's an arr\n\t}\n\treturn dojo.lang.curry.apply(dojo.lang, [ns, func].concat(targs));"}}},"dojo.lang.tryThese":{"_":{"meta":{"summary":"","src":"\tfor(var x=0; x<arguments.length; x++){\n\t\ttry{\n\t\t\tif(typeof arguments[x] == \"function\"){\n\t\t\t\tvar ret = (arguments[x]());\n\t\t\t\tif(ret){\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tdojo.debug(e);\n\t\t}\n\t}"}}},"dojo.lang.delayThese":{"_":{"meta":{"summary":"","parameters":{"farr":{"type":""},"cb":{"type":""},"delay":{"type":""},"onend":{"type":""}},"src":"\t\tif(typeof onend == \"function\"){\n\t\t\tonend();\n\t\t}\n\t\treturn;\n\t}\n\tif((typeof delay == \"undefined\")&&(typeof cb == \"number\")){\n\t\tdelay = cb;\n\t\tcb = function(){};\n\t}else if(!cb){\n\t\tcb = function(){};\n\t\tif(!delay){ delay = 0; }\n\t}\n\tsetTimeout(function(){\n\t\t(farr.shift())();\n\t\tcb();\n\t\tdojo.lang.delayThese(farr, cb, delay, onend);\n\t}, delay);"}}}}}},"dojo.lang.repr":{"meta":{"requires":{"common":["dojo.lang.common","dojo.AdapterRegistry","dojo.string.extras"]},"methods":{"dojo.lang.registerRepr":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""},"check":{"type":""},"wrap":{"type":""},"override":{"type":"optional"}},"src":""}}},"dojo.lang.repr":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":""}},"src":"\t\treturn \"undefined\";\n\t}else if(obj === null){\n\t\treturn \"null\";\n\t}\n\n\ttry{\n\t\tif(typeof(obj[\"__repr__\"]) == 'function'){\n\t\t\treturn obj[\"__repr__\"]();\n\t\t}else if((typeof(obj[\"repr\"]) == 'function')&&(obj.repr != arguments.callee)){\n\t\t\treturn obj[\"repr\"]();\n\t\t}\n\t\treturn dojo.lang.reprRegistry.match(obj);\n\t}catch(e){\n\t\tif(typeof(obj.NAME) == 'string' && (\n\t\t\t\tobj.toString == Function.prototype.toString ||\n\t\t\t\tobj.toString == Object.prototype.toString\n\t\t\t)){\n\t\t\treturn o.NAME;\n\t\t}\n\t}\n\n\tif(typeof(obj) == \"function\"){\n\t\tobj = (obj + \"\").replace(\/^\\s+\/, \"\");\n\t\tvar idx = obj.indexOf(\"{\");\n\t\tif(idx != -1){\n\t\t\tobj = obj.substr(0, idx) + \"{...}\";\n\t\t}\n\t}\n\treturn obj + \"\";"}}},"dojo.lang.reprArrayLike":{"_":{"meta":{"summary":"","parameters":{"arr":{"type":""}},"src":"\ttry{\n\t\tvar na = dojo.lang.map(arr, dojo.lang.repr);\n\t\treturn \"[\" + na.join(\", \") + \"]\";\n\t}catch(e){ }"}}}}}},"dojo.lang.timing.Streamer":{"meta":{"requires":{"common":["dojo.lang.timing.Timer"]},"methods":{"dojo.lang.timing.Streamer":{"_":{"meta":{"summary":" Streamer will take an input function that pushes N datapoints into a queue, and will pass the next point in that queue out to an","parameters":{"input":{"type":"function"},"output":{"type":"function"},"interval":{"type":"int"},"minimum":{"type":"int"},"initialData":{"type":"array"}},"src":"\tvar queue = [];\r\n\r\n\t\/\/\tpublic properties\r\n\tthis.interval = interval || 1000;\r\n\tthis.minimumSize = minimum || 10;\t\/\/\tlatency usually == interval * minimumSize\r\n\tthis.inputFunction = input || function(q){ };\r\n\tthis.outputFunction = output || function(point){ };\r\n\r\n\t\/\/\tmore setup\r\n\tvar timer = new dojo.lang.timing.Timer(this.interval);\r\n\tvar tick = function(){\r\n\t\tself.onTick(self);\r\n\r\n\t\tif(queue.length < self.minimumSize){\r\n\t\t\tself.inputFunction(queue);\r\n\t\t}\r\n\r\n\t\tvar obj = queue.shift();\r\n\t\twhile(typeof(obj) == \"undefined\" && queue.length > 0){\r\n\t\t\tobj = queue.shift();\r\n\t\t}\r\n\t\t\r\n\t\t\/\/\tcheck to see if the input function needs to be fired\r\n\t\t\/\/\tstop before firing the output function\r\n\t\t\/\/\tTODO: relegate this to the output function?\r\n\t\tif(typeof(obj) == \"undefined\"){\r\n\t\t\tself.stop();\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t\/\/\tcall the output function.\r\n\t\tself.outputFunction(obj);\r\n\t};\r\n\r\n\tthis.setInterval = function(\/* int *\/ms){\r\n\t\t\/\/\tsummary\r\n\t\t\/\/\tsets the interval in milliseconds of the internal timer\r\n\t\tthis.interval = ms;\r\n\t\ttimer.setInterval(ms);\r\n\t};\r\n\r\n\tthis.onTick = function(\/* dojo.lang.timing.Streamer *\/obj){ };\r\n\t\/\/ wrap the timer functions so that we can connect to them if needed.\r\n\tthis.start = function(){\r\n\t\t\/\/\tsummary\r\n\t\t\/\/\tstarts the Streamer\r\n\t\tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\r\n\t\t\ttimer.start();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");\r\n\t};\r\n\tthis.onStart = function(){ };\r\n\tthis.stop = function(){\r\n\t\t\/\/\tsummary\r\n\t\t\/\/\tstops the Streamer\r\n\t\ttimer.stop();\r\n\t};\r\n\tthis.onStop = function(){ };\r\n\r\n\t\/\/\tfinish initialization\r\n\ttimer.onTick = this.tick;\r\n\ttimer.onStart = this.onStart;\r\n\ttimer.onStop = this.onStop;\r\n\tif(initialData){\r\n\t\tqueue.concat(initialData);\r\n\t}\r","this_variables":["interval","minimumSize","inputFunction","outputFunction","setInterval","onTick","start","onStart","stop","onStop"]}}},"dojo.lang.timing.Streamer.setInterval":{"_":{"meta":{"summary":" sets the interval in milliseconds of the internal timer","parameters":{"ms":{"type":"int"}},"src":"\t\ttimer.setInterval(ms);\r","this_variables":["interval"]}}},"dojo.lang.timing.Streamer.onTick":{"_":{"meta":{"summary":"","parameters":{"obj":{"type":"dojo.lang.timing.Streamer"}},"src":""}}},"dojo.lang.timing.Streamer.start":{"_":{"meta":{"summary":" starts the Streamer","src":"\t\t\ttimer.start();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");\r"}}},"dojo.lang.timing.Streamer.onStart":{"_":{"meta":{"summary":"","src":""}}},"dojo.lang.timing.Streamer.stop":{"_":{"meta":{"summary":" stops the Streamer","src":""}}},"dojo.lang.timing.Streamer.onStop":{"_":{"meta":{"summary":"","src":""}}}}}},"dojo.lang.timing.Timer":{"meta":{"requires":{"common":["dojo.lang.func"]},"methods":{"dojo.lang.timing.Timer":{"_":{"meta":{"summary":"Timer object executes an \"onTick()\" method repeatedly at a specified interval. repeatedly at a given interval.","parameters":{"interval":{"type":"int"}},"src":"\tthis.isRunning = false;\r\n\tthis.interval = interval;\r\n\r\n\tthis.onStart = null;\r\n\tthis.onStop = null;\r","this_variables":["timer","isRunning","interval","onStart","onStop"]}}}}}},"dojo.lang.type":{"meta":{"requires":{"common":["dojo.lang.common"]},"methods":{"dojo.lang.whatAmI":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\tdojo.deprecated(\"dojo.lang.whatAmI\", \"use dojo.lang.getType instead\", \"0.5\");\n\treturn dojo.lang.getType(value);"}}},"dojo.lang.getType":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\ttry {\n\t\tif(dojo.lang.isArray(value)) { return \"array\"; }\n\t\tif(dojo.lang.isFunction(value)) { return \"function\"; }\n\t\tif(dojo.lang.isString(value)) { return \"string\"; }\n\t\tif(dojo.lang.isNumber(value)) { return \"number\"; }\n\t\tif(dojo.lang.isBoolean(value)) { return \"boolean\"; }\n\t\tif(dojo.lang.isAlien(value)) { return \"alien\"; }\n\t\tif(dojo.lang.isUndefined(value)) { return \"undefined\"; }\n\t\t\/\/ FIXME: should this go first?\n\t\tfor(var name in dojo.lang.whatAmI.custom) {\n\t\t\tif(dojo.lang.whatAmI.custom[name](value)) {\n\t\t\t\treturn name;\n\t\t\t}\n\t\t}\n\t\tif(dojo.lang.isObject(value)) { return \"object\"; }\n\t} catch(E) {}\n\treturn \"unknown\";"}}},"dojo.lang.isNumeric":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\treturn (!isNaN(value) && isFinite(value) && (value != null) &&\n\t\t\t!dojo.lang.isBoolean(value) && !dojo.lang.isArray(value) &&\n\t\t\t!\/^\\s*$\/.test(value));"}}},"dojo.lang.isBuiltIn":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\treturn (dojo.lang.isArray(value)\t\t|| \n\t\t\tdojo.lang.isFunction(value)\t|| \n\t\t\tdojo.lang.isString(value)\t\t|| \n\t\t\tdojo.lang.isNumber(value)\t\t|| \n\t\t\tdojo.lang.isBoolean(value)\t\t|| \n\t\t\t(value == null)\t\t\t\t|| \n\t\t\t(value instanceof Error)\t\t|| \n\t\t\t(typeof value == \"error\") );"}}},"dojo.lang.isPureObject":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":"\treturn ((value != null) && dojo.lang.isObject(value) && value.constructor == Object);"}}},"dojo.lang.isOfType":{"_":{"meta":{"summary":"","parameters":{"value":{"type":""},"type":{"type":""},"keywordParameters":{"type":""}},"src":"\tvar optional = false;\n\tif (keywordParameters) {\n\t\toptional = keywordParameters[\"optional\"];\n\t}\n\tif (optional && ((value === null) || dojo.lang.isUndefined(value))) {\n\t\treturn true;\n\t}\n\tif(dojo.lang.isArray(type)){\n\t\tvar arrayOfTypes = type;\n\t\tfor(var i in arrayOfTypes){\n\t\t\tvar aType = arrayOfTypes[i];\n\t\t\tif(dojo.lang.isOfType(value, aType)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}else{\n\t\tif(dojo.lang.isString(type)){\n\t\t\ttype = type.toLowerCase();\n\t\t}\n\t\tswitch (type) {\n\t\t\tcase Array:\n\t\t\tcase \"array\":\n\t\t\t\treturn dojo.lang.isArray(value);\n\t\t\t\tbreak;\n\t\t\tcase Function:\n\t\t\tcase \"function\":\n\t\t\t\treturn dojo.lang.isFunction(value);\n\t\t\t\tbreak;\n\t\t\tcase String:\n\t\t\tcase \"string\":\n\t\t\t\treturn dojo.lang.isString(value);\n\t\t\t\tbreak;\n\t\t\tcase Number:\n\t\t\tcase \"number\":\n\t\t\t\treturn dojo.lang.isNumber(value);\n\t\t\t\tbreak;\n\t\t\tcase \"numeric\":\n\t\t\t\treturn dojo.lang.isNumeric(value);\n\t\t\t\tbreak;\n\t\t\tcase Boolean:\n\t\t\tcase \"boolean\":\n\t\t\t\treturn dojo.lang.isBoolean(value);\n\t\t\t\tbreak;\n\t\t\tcase Object:\n\t\t\tcase \"object\":\n\t\t\t\treturn dojo.lang.isObject(value);\n\t\t\t\tbreak;\n\t\t\tcase \"pureobject\":\n\t\t\t\treturn dojo.lang.isPureObject(value);\n\t\t\t\tbreak;\n\t\t\tcase \"builtin\":\n\t\t\t\treturn dojo.lang.isBuiltIn(value);\n\t\t\t\tbreak;\n\t\t\tcase \"alien\":\n\t\t\t\treturn dojo.lang.isAlien(value);\n\t\t\t\tbreak;\n\t\t\tcase \"undefined\":\n\t\t\t\treturn dojo.lang.isUndefined(value);\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\tcase \"null\":\n\t\t\t\treturn (value === null);\n\t\t\t\tbreak;\n\t\t\tcase \"optional\":\n\t\t\t\tdojo.deprecated('dojo.lang.isOfType(value, [type, \"optional\"])', 'use dojo.lang.isOfType(value, type, {optional: true} ) instead', \"0.5\");\n\t\t\t\treturn ((value === null) || dojo.lang.isUndefined(value));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (dojo.lang.isFunction(type)) {\n\t\t\t\t\treturn (value instanceof type);\n\t\t\t\t} else {\n\t\t\t\t\tdojo.raise(\"dojo.lang.isOfType() was passed an invalid type\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tdojo.raise(\"If we get here, it means a bug was introduced above.\");"}}},"dojo.lang.getObject":{"_":{"meta":{"summary":" Will return an object, if it exists, based on the name in the passed string.","parameters":{"str":{"type":"String"}},"src":"\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj!=dj_global)?obj:null;\t\/\/\tObject","returns":"Object"}}},"dojo.lang.doesObjectExist":{"_":{"meta":{"summary":" Check to see if object [str] exists, based on the passed string.","parameters":{"str":{"type":"String"}},"src":"\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj&&obj!=dj_global);\t\/\/\tboolean","returns":"boolean"}}}}}},"dojo.lang":{"meta":{"requires":{"common":["dojo.lang.common"]}}}}