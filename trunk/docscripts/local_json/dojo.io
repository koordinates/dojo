{"dojo.io.BrowserIO":{"meta":{"requires":{"common":["dojo.io","dojo.lang.array","dojo.lang.func","dojo.string.extras","dojo.dom","dojo.undo.browser"]},"methods":{"dojo.io.checkChildrenForFile":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\tvar hasFile = false;\n\tvar inputs = node.getElementsByTagName(\"input\");\n\tdojo.lang.forEach(inputs, function(input){\n\t\tif(hasFile){ return; }\n\t\tif(input.getAttribute(\"type\")==\"file\"){\n\t\t\thasFile = true;\n\t\t}\n\t});\n\treturn hasFile;"}}},"dojo.io.formHasFile":{"_":{"meta":{"summary":"","parameters":{"formNode":{"type":""}},"src":"\treturn dojo.io.checkChildrenForFile(formNode);"}}},"dojo.io.updateNode":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"urlOrArgs":{"type":""}},"src":"\tnode = dojo.byId(node);\n\tvar args = urlOrArgs;\n\tif(dojo.lang.isString(urlOrArgs)){\n\t\targs = { url: urlOrArgs };\n\t}\n\targs.mimetype = \"text\/html\";\n\targs.load = function(t, d, e){\n\t\twhile(node.firstChild){\n\t\t\tif(dojo[\"event\"]){\n\t\t\t\ttry{\n\t\t\t\t\tdojo.event.browser.clean(node.firstChild);\n\t\t\t\t}catch(e){}\n\t\t\t}\n\t\t\tnode.removeChild(node.firstChild);\n\t\t}\n\t\tnode.innerHTML = d;\n\t};\n\tdojo.io.bind(args);"}}},"dojo.io.formFilter":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\tvar type = (node.type||\"\").toLowerCase();\n\treturn !node.disabled && node.name\n\t\t&& !dojo.lang.inArray([\"file\", \"submit\", \"image\", \"reset\", \"button\"], type);"}}},"dojo.io.encodeForm":{"_":{"meta":{"summary":"","parameters":{"formNode":{"type":""},"encoding":{"type":""},"formFilter":{"type":""}},"src":"\tif((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == \"form\")){\n\t\tdojo.raise(\"Attempted to encode a non-form element.\");\n\t}\n\tif(!formFilter) { formFilter = dojo.io.formFilter; }\n\tvar enc = \/utf\/i.test(encoding||\"\") ? encodeURIComponent : dojo.string.encodeAscii;\n\tvar values = [];\n\n\tfor(var i = 0; i < formNode.elements.length; i++){\n\t\tvar elm = formNode.elements[i];\n\t\tif(!elm || elm.tagName.toLowerCase() == \"fieldset\" || !formFilter(elm)) { continue; }\n\t\tvar name = enc(elm.name);\n\t\tvar type = elm.type.toLowerCase();\n\n\t\tif(type == \"select-multiple\"){\n\t\t\tfor(var j = 0; j < elm.options.length; j++){\n\t\t\t\tif(elm.options[j].selected) {\n\t\t\t\t\tvalues.push(name + \"=\" + enc(elm.options[j].value));\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(dojo.lang.inArray([\"radio\", \"checkbox\"], type)){\n\t\t\tif(elm.checked){\n\t\t\t\tvalues.push(name + \"=\" + enc(elm.value));\n\t\t\t}\n\t\t}else{\n\t\t\tvalues.push(name + \"=\" + enc(elm.value));\n\t\t}\n\t}\n\n\t\/\/ now collect input type=\"image\", which doesn't show up in the elements array\n\tvar inputs = formNode.getElementsByTagName(\"input\");\n\tfor(var i = 0; i < inputs.length; i++) {\n\t\tvar input = inputs[i];\n\t\tif(input.type.toLowerCase() == \"image\" && input.form == formNode\n\t\t\t&& formFilter(input)) {\n\t\t\tvar name = enc(input.name);\n\t\t\tvalues.push(name + \"=\" + enc(input.value));\n\t\t\tvalues.push(name + \".x=0\");\n\t\t\tvalues.push(name + \".y=0\");\n\t\t}\n\t}\n\treturn values.join(\"&\") + \"&\";"}}},"dojo.io.FormBind":{"_":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":"\tthis.bindArgs = {};\n\n\tif(args && args.formNode) {\n\t\tthis.init(args);\n\t} else if(args) {\n\t\tthis.init({formNode: args});\n\t}","this_variables":["bindArgs","form","clickedButton","clickedButton"],"protovariables":{"form":"","bindArgs":"","clickedButton":""}}}},"e.preventDefault":{"_":{"meta":{"summary":"","parameters":{"!e.preventDefault":{"type":""}},"src":"                            e.preventDefault = function() { window.event.returnValue = false; }   "}}},"dojo.io.XMLHTTPTransport.clearCache":{"_":{"meta":{"summary":"","src":"\t\t_cache = {};"}}},"dojo.io.XMLHTTPTransport.startWatchingInFlight":{"_":{"meta":{"summary":"","src":"\t\tif(!this.inFlightTimer){\n\t\t\t\/\/ setInterval broken in mozilla x86_64 in some circumstances, see\n\t\t\t\/\/ https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=344439\n\t\t\t\/\/ using setTimeout instead\n\t\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);\n\t\t}","this_variables":["inFlightTimer"]}}},"dojo.io.XMLHTTPTransport.watchInFlight":{"_":{"meta":{"summary":"","src":"\t\tvar now = null;\n\t\t\/\/ make sure sync calls stay thread safe, if this callback is called during a sync call\n\t\t\/\/ and this results in another sync call before the first sync call ends the browser hangs\n\t\tif(!dojo.hostenv._blockAsync && !_this._blockAsync){\n\t\t\tfor(var x=this.inFlight.length-1; x>=0; x--){\n\t\t\t\tvar tif = this.inFlight[x];\n\t\t\t\tif(!tif || tif.http._aborted || !tif.http.readyState){\n\t\t\t\t\tthis.inFlight.splice(x, 1); continue; \n\t\t\t\t}\n\t\t\t\tif(4==tif.http.readyState){\n\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\tdoLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);\n\t\t\t\t}else if (tif.startTime){\n\t\t\t\t\t\/\/See if this is a timeout case.\n\t\t\t\t\tif(!now){\n\t\t\t\t\t\tnow = (new Date()).getTime();\n\t\t\t\t\t}\n\t\t\t\t\tif(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){\n\t\t\t\t\t\t\/\/Stop the request.\n\t\t\t\t\t\tif(typeof tif.http.abort == \"function\"){\n\t\t\t\t\t\t\ttif.http.abort();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\/\/ remove it so we can clean refs\n\t\t\t\t\t\tthis.inFlight.splice(x, 1);\n\t\t\t\t\t\ttif.req[(typeof tif.req.timeout == \"function\") ? \"timeout\" : \"handle\"](\"timeout\", null, tif.http, tif.req);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tclearTimeout(this.inFlightTimer);\n\t\tif(this.inFlight.length == 0){\n\t\t\tthis.inFlightTimer = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.inFlightTimer = setTimeout(\"dojo.io.XMLHTTPTransport.watchInFlight();\", 10);","this_variables":["inFlightTimer"]}}},"dojo.io.XMLHTTPTransport.canHandle":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\t\t&& dojo.lang.inArray([\"text\/plain\", \"text\/html\", \"application\/xml\", \"text\/xml\", \"text\/javascript\", \"text\/json\"], (kwArgs[\"mimetype\"].toLowerCase()||\"\"))\n\t\t\t&& !( kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]) );"}}},"dojo.io.XMLHTTPTransport.bind":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tif(!kwArgs[\"url\"]){\n\t\t\t\/\/ are we performing a history action?\n\t\t\tif( !kwArgs[\"formNode\"]\n\t\t\t\t&& (kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"] || kwArgs[\"watchForURL\"])\n\t\t\t\t&& (!djConfig.preventBackButtonFix)) {\n        dojo.deprecated(\"Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request\",\n        \t\t\t\t\"Use dojo.undo.browser.addToHistory() instead.\", \"0.4\");\n\t\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ build this first for cache purposes\n\t\tvar url = kwArgs.url;\n\t\tvar query = \"\";\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\n\t\tif(kwArgs[\"file\"]){\n\t\t\t\/\/ force post for file transfer\n\t\t\tkwArgs.method = \"post\";\n\t\t}\n\n\t\tif(!kwArgs[\"method\"]){\n\t\t\tkwArgs.method = \"get\";\n\t\t}\n\n\t\t\/\/ guess the multipart value\n\t\tif(kwArgs.method.toLowerCase() == \"get\"){\n\t\t\t\/\/ GET cannot use multipart\n\t\t\tkwArgs.multipart = false;\n\t\t}else{\n\t\t\tif(kwArgs[\"file\"]){\n\t\t\t\t\/\/ enforce multipart when sending files\n\t\t\t\tkwArgs.multipart = true;\n\t\t\t}else if(!kwArgs[\"multipart\"]){\n\t\t\t\t\/\/ default \n\t\t\t\tkwArgs.multipart = false;\n\t\t\t}\n\t\t}\n\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\n\t\tvar content = kwArgs[\"content\"] || {};\n\n\t\tif(kwArgs.sendTransport) {\n\t\t\tcontent[\"dojo.transport\"] = \"xmlhttp\";\n\t\t}\n\n\t\tdo { \/\/ break-block\n\t\t\tif(kwArgs.postContent){\n\t\t\t\tquery = kwArgs.postContent;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(content) {\n\t\t\t\tquery += dojo.io.argsFromMap(content, kwArgs.encoding);\n\t\t\t}\n\t\t\t\n\t\t\tif(kwArgs.method.toLowerCase() == \"get\" || !kwArgs.multipart){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar\tt = [];\n\t\t\tif(query.length){\n\t\t\t\tvar q = query.split(\"&\");\n\t\t\t\tfor(var i = 0; i < q.length; ++i){\n\t\t\t\t\tif(q[i].length){\n\t\t\t\t\t\tvar p = q[i].split(\"=\");\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + p[0] + \"\\\"\", \n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\tp[1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(kwArgs.file){\n\t\t\t\tif(dojo.lang.isArray(kwArgs.file)){\n\t\t\t\t\tfor(var i = 0; i < kwArgs.file.length; ++i){\n\t\t\t\t\t\tvar o = kwArgs.file[i];\n\t\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\t\to.content);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvar o = kwArgs.file;\n\t\t\t\t\tt.push(\t\"--\" + this.multipartBoundary,\n\t\t\t\t\t\t\t\"Content-Disposition: form-data; name=\\\"\" + o.name + \"\\\"; filename=\\\"\" + (\"fileName\" in o ? o.fileName : o.name) + \"\\\"\",\n\t\t\t\t\t\t\t\"Content-Type: \" + (\"contentType\" in o ? o.contentType : \"application\/octet-stream\"),\n\t\t\t\t\t\t\t\"\",\n\t\t\t\t\t\t\to.content);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(t.length){\n\t\t\t\tt.push(\"--\"+this.multipartBoundary+\"--\", \"\");\n\t\t\t\tquery = t.join(\"\\r\\n\");\n\t\t\t}\n\t\t}while(false);\n\n\t\t\/\/ kwArgs.Connection = \"close\";\n\n\t\tvar async = kwArgs[\"sync\"] ? false : true;\n\n\t\tvar preventCache = kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false);\n\t\tvar useCache = kwArgs[\"useCache\"] == true ||\n\t\t\t(this.useCache == true && kwArgs[\"useCache\"] != false );\n\n\t\t\/\/ preventCache is browser-level (add query string junk), useCache\n\t\t\/\/ is for the local cache. If we say preventCache, then don't attempt\n\t\t\/\/ to look in the cache, but if useCache is true, we still want to cache\n\t\t\/\/ the response\n\t\tif(!preventCache && useCache){\n\t\t\tvar cachedHttp = getFromCache(url, query, kwArgs.method);\n\t\t\tif(cachedHttp){\n\t\t\t\tdoLoad(kwArgs, cachedHttp, url, query, false);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ much of this is from getText, but reproduced here because we need\n\t\t\/\/ more flexibility\n\t\tvar http = dojo.hostenv.getXmlhttpObject(kwArgs);\t\n\t\tvar received = false;\n\n\t\t\/\/ build a handler function that calls back to the handler obj\n\t\tif(async){\n\t\t\tvar startTime = \n\t\t\t\/\/ FIXME: setting up this callback handler leaks on IE!!!\n\t\t\tthis.inFlight.push({\n\t\t\t\t\"req\":\t\tkwArgs,\n\t\t\t\t\"http\":\t\thttp,\n\t\t\t\t\"url\":\t \turl,\n\t\t\t\t\"query\":\tquery,\n\t\t\t\t\"useCache\":\tuseCache,\n\t\t\t\t\"startTime\": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0\n\t\t\t});\n\t\t\tthis.startWatchingInFlight();\n\t\t}else{\n\t\t\t\/\/ block async callbacks until sync is in, needed in khtml, others?\n\t\t\t_this._blockAsync = true;\n\t\t}\n\n\t\tif(kwArgs.method.toLowerCase() == \"post\"){\n\t\t\t\/\/ FIXME: need to hack in more flexible Content-Type setting here!\n\t\t\thttp.open(\"POST\", url, async);\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\thttp.setRequestHeader(\"Content-Type\", kwArgs.multipart ? (\"multipart\/form-data; boundary=\" + this.multipartBoundary) : \n\t\t\t\t(kwArgs.contentType || \"application\/x-www-form-urlencoded\"));\n\t\t\ttry{\n\t\t\t\thttp.send(query);\n\t\t\t}catch(e){\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}else{\n\t\t\tvar tmpUrl = url;\n\t\t\tif(query != \"\") {\n\t\t\t\ttmpUrl += (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\t}\n\t\t\tif(preventCache) {\n\t\t\t\ttmpUrl += (dojo.string.endsWithAny(tmpUrl, \"?\", \"&\")\n\t\t\t\t\t? \"\" : (tmpUrl.indexOf(\"?\") > -1 ? \"&\" : \"?\")) + \"dojo.preventCache=\" + new Date().valueOf();\n\t\t\t}\n\t\t\thttp.open(kwArgs.method.toUpperCase(), tmpUrl, async);\n\t\t\tsetHeaders(http, kwArgs);\n\t\t\ttry {\n\t\t\t\thttp.send(null);\n\t\t\t}catch(e)\t{\n\t\t\t\tif(typeof http.abort == \"function\"){\n\t\t\t\t\thttp.abort();\n\t\t\t\t}\n\t\t\t\tdoLoad(kwArgs, {status: 404}, url, query, useCache);\n\t\t\t}\n\t\t}\n\n\t\tif( !async ) {\n\t\t\tdoLoad(kwArgs, http, url, query, useCache);\n\t\t\t_this._blockAsync = false;\n\t\t}\n\n\t\tkwArgs.abort = function(){\n\t\t\ttry{\/\/ khtml doesent reset readyState on abort, need this workaround\n\t\t\t\thttp._aborted = true; \n\t\t\t}catch(e){\/*squelsh*\/}\n\t\t\treturn http.abort();\n\t\t}\n\n\t\treturn;"}}},"dojo.io.FormBind.init":{"_":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":"\t\tvar form = dojo.byId(args.formNode);\n\n\t\tif(!form || !form.tagName || form.tagName.toLowerCase() != \"form\") {\n\t\t\tthrow new Error(\"FormBind: Couldn't apply, invalid form\");\n\t\t} else if(this.form == form) {\n\t\t\treturn;\n\t\t} else if(this.form) {\n\t\t\tthrow new Error(\"FormBind: Already applied to a form\");\n\t\t}\n\n\t\tdojo.lang.mixin(this.bindArgs, args);\n\t\tthis.form = form;\n\n\t\tthis.connect(form, \"onsubmit\", \"submit\");\n\n\t\tfor(var i = 0; i < form.elements.length; i++) {\n\t\t\tvar node = form.elements[i];\n\t\t\tif(node && node.type && dojo.lang.inArray([\"submit\", \"button\"], node.type.toLowerCase())) {\n\t\t\t\tthis.connect(node, \"onclick\", \"click\");\n\t\t\t}\n\t\t}\n\n\t\tvar inputs = form.getElementsByTagName(\"input\");\n\t\tfor(var i = 0; i < inputs.length; i++) {\n\t\t\tvar input = inputs[i];\n\t\t\tif(input.type.toLowerCase() == \"image\" && input.form == form) {\n\t\t\t\tthis.connect(input, \"onclick\", \"click\");\n\t\t\t}\n\t\t}","this":"dojo.io.FormBind"}}},"dojo.io.FormBind.onSubmit":{"_":{"meta":{"summary":"","parameters":{"form":{"type":""}},"src":"\t\treturn true;","this":"dojo.io.FormBind"}}},"dojo.io.FormBind.submit":{"_":{"meta":{"summary":"","parameters":{"e":{"type":""}},"src":"\t\te.preventDefault();\n\t\tif(this.onSubmit(this.form)) {\n\t\t\tdojo.io.bind(dojo.lang.mixin(this.bindArgs, {\n\t\t\t\tformFilter: dojo.lang.hitch(this, \"formFilter\")\n\t\t\t}));\n\t\t}","this":"dojo.io.FormBind"}}},"dojo.io.FormBind.click":{"_":{"meta":{"summary":"","parameters":{"e":{"type":""}},"src":"\t\tvar node = e.currentTarget;\n\t\tif(node.disabled) { return; }\n\t\tthis.clickedButton = node;","this":"dojo.io.FormBind"}}},"dojo.io.FormBind.formFilter":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\tvar type = (node.type||\"\").toLowerCase();\n\t\tvar accept = false;\n\t\tif(node.disabled || !node.name) {\n\t\t\taccept = false;\n\t\t} else if(dojo.lang.inArray([\"submit\", \"button\", \"image\"], type)) {\n\t\t\tif(!this.clickedButton) { this.clickedButton = node; }\n\t\t\taccept = node == this.clickedButton;\n\t\t} else {\n\t\t\taccept = !dojo.lang.inArray([\"file\", \"submit\", \"reset\", \"button\"], type);\n\t\t}\n\t\treturn accept;","this":"dojo.io.FormBind"}}},"dojo.io.FormBind.connect":{"_":{"meta":{"summary":"","parameters":{"srcObj":{"type":""},"srcFcn":{"type":""},"targetFcn":{"type":""}},"src":"\t\tif(dojo.evalObjPath(\"dojo.event.connect\")) {\n\t\t\tdojo.event.connect(srcObj, srcFcn, this, targetFcn);\n\t\t} else {\n\t\t\tvar fcn = dojo.lang.hitch(this, targetFcn);\n\t\t\tsrcObj[srcFcn] = function(e) {\n\t\t\t\tif(!e) { e = window.event; }\n\t\t\t\tif(!e.currentTarget) { e.currentTarget = e.srcElement; }\n\t\t\t\tif(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }\n\t\t\t\tfcn(e);\n\t\t\t}\n\t\t}","this":"dojo.io.FormBind"}}}}}},"dojo.io.IframeIO":{"meta":{"requires":{"common":["dojo.io.BrowserIO","dojo.uri.*"]},"methods":{"dojo.io.createIFrame":{"_":{"meta":{"summary":"","parameters":{"fname":{"type":""},"onloadstr":{"type":""},"uri":{"type":""}},"src":"\tif(window[fname]){ return window[fname]; }\n\tif(window.frames[fname]){ return window.frames[fname]; }\n\tvar r = dojo.render.html;\n\tvar cframe = null;\n\tvar turi = uri||dojo.uri.dojoUri(\"iframe_history.html?noInit=true\");\n\tvar ifrstr = ((r.ie)&&(dojo.render.os.win)) ? '<iframe name=\"'+fname+'\" src=\"'+turi+'\" onload=\"'+onloadstr+'\">' : 'iframe';\n\tcframe = document.createElement(ifrstr);\n\twith(cframe){\n\t\tname = fname;\n\t\tsetAttribute(\"name\", fname);\n\t\tid = fname;\n\t}\n\tdojo.body().appendChild(cframe);\n\twindow[fname] = cframe;\n\n\twith(cframe.style){\n\t\tif(!r.safari){\n\t\t\t\/\/We can't change the src in Safari 2.0.3 if absolute position. Bizarro.\n\t\t\tposition = \"absolute\";\n\t\t}\n\t\tleft = top = \"0px\";\n\t\theight = width = \"1px\";\n\t\tvisibility = \"hidden\";\n\t\t\/*\n\t\tif(djConfig.isDebug){\n\t\t\tposition = \"relative\";\n\t\t\theight = \"300px\";\n\t\t\twidth = \"600px\";\n\t\t\tvisibility = \"visible\";\n\t\t}\n\t\t*\/\n\t}\n\n\tif(!r.ie){\n\t\tdojo.io.setIFrameSrc(cframe, turi, true);\n\t\tcframe.onload = new Function(onloadstr);\n\t}\n\t\n\treturn cframe;"}}},"dojo.io.IframeTransport.fireNextRequest":{"_":{"meta":{"summary":"","src":"\t\tif((this.currentRequest)||(this.requestQueue.length == 0)){ return; }\n\t\t\/\/ dojo.debug(\"fireNextRequest\");\n\t\tvar cr = this.currentRequest = this.requestQueue.shift();\n\t\tcr._contentToClean = [];\n\t\tvar fn = cr[\"formNode\"];\n\t\tvar content = cr[\"content\"] || {};\n\t\tif(cr.sendTransport) {\n\t\t\tcontent[\"dojo.transport\"] = \"iframe\";\n\t\t}\n\t\tif(fn){\n\t\t\tif(content){\n\t\t\t\t\/\/ if we have things in content, we need to add them to the form\n\t\t\t\t\/\/ before submission\n\t\t\t\tfor(var x in content){\n\t\t\t\t\tif(!fn[x]){\n\t\t\t\t\t\tvar tn;\n\t\t\t\t\t\tif(dojo.render.html.ie){\n\t\t\t\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\t\t\t\tfn.appendChild(tn);\n\t\t\t\t\t\t\ttn.type = \"hidden\";\n\t\t\t\t\t\t\ttn.name = x;\n\t\t\t\t\t\t\ttn.value = content[x];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcr._contentToClean.push(x);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfn[x].value = content[x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cr[\"url\"]){\n\t\t\t\tcr._originalAction = fn.getAttribute(\"action\");\n\t\t\t\tfn.setAttribute(\"action\", cr.url);\n\t\t\t}\n\t\t\tif(!fn.getAttribute(\"method\")){\n\t\t\t\tfn.setAttribute(\"method\", (cr[\"method\"]) ? cr[\"method\"] : \"post\");\n\t\t\t}\n\t\t\tcr._originalTarget = fn.getAttribute(\"target\");\n\t\t\tfn.setAttribute(\"target\", this.iframeName);\n\t\t\tfn.target = this.iframeName;\n\t\t\tfn.submit();\n\t\t}else{\n\t\t\t\/\/ otherwise we post a GET string by changing URL location for the\n\t\t\t\/\/ iframe\n\t\t\tvar query = dojo.io.argsFromMap(this.currentRequest.content);\n\t\t\tvar tmpUrl = (cr.url.indexOf(\"?\") > -1 ? \"&\" : \"?\") + query;\n\t\t\tdojo.io.setIFrameSrc(this.iframe, tmpUrl, true);\n\t\t}","this_variables":["currentRequest"]}}},"dojo.io.IframeTransport.canHandle":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\treturn (\n\t\t\t(\n\t\t\t\t\/\/ FIXME: can we really handle text\/plain and\n\t\t\t\t\/\/ text\/javascript requests?\n\t\t\t\tdojo.lang.inArray([\t\"text\/plain\", \"text\/html\", \"text\/javascript\", \"text\/json\"], kwArgs[\"mimetype\"])\n\t\t\t)&&(\n\t\t\t\t\/\/ make sur we really only get used in file upload cases\t\n\t\t\t\t(kwArgs[\"formNode\"])&&(dojo.io.checkChildrenForFile(kwArgs[\"formNode\"]))\n\t\t\t)&&(\n\t\t\t\tdojo.lang.inArray([\"post\", \"get\"], kwArgs[\"method\"].toLowerCase())\n\t\t\t)&&(\n\t\t\t\t\/\/ never handle a sync request\n\t\t\t\t!  ((kwArgs[\"sync\"])&&(kwArgs[\"sync\"] == true))\n\t\t\t)\n\t\t);"}}},"dojo.io.IframeTransport.bind":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tif(!this[\"iframe\"]){ this.setUpIframe(); }\n\t\tthis.requestQueue.push(kwArgs);\n\t\tthis.fireNextRequest();\n\t\treturn;"}}},"dojo.io.IframeTransport.setUpIframe":{"_":{"meta":{"summary":"","src":"","this_variables":["iframe"]}}},"dojo.io.IframeTransport.iframeOnload":{"_":{"meta":{"summary":"","src":"\t\tif(!_this.currentRequest){\n\t\t\t_this.fireNextRequest();\n\t\t\treturn;\n\t\t}\n\n\t\tvar req = _this.currentRequest;\n\n\t\t\/\/ remove all the hidden content inputs\n\t\tvar toClean = req._contentToClean;\n\t\tfor(var i = 0; i < toClean.length; i++) {\n\t\t\tvar key = toClean[i];\n\t\t\tif(dojo.render.html.safari){\n\t\t\t\t\/\/In Safari (at least 2.0.3), can't use formNode[key] syntax to find the node,\n\t\t\t\t\/\/for nodes that were dynamically added.\n\t\t\t\tvar fNode = req.formNode;\n\t\t\t\tfor(var j = 0; j < fNode.childNodes.length; j++){\n\t\t\t\t\tvar chNode = fNode.childNodes[j];\n\t\t\t\t\tif(chNode.name == key){\n\t\t\t\t\t\tvar pNode = chNode.parentNode;\n\t\t\t\t\t\tpNode.removeChild(chNode);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else if(req.formNode){\n\t\t\t\tvar input = req.formNode[key];\n\t\t\t\treq.formNode.removeChild(input);\n\t\t\t\treq.formNode[key] = null;\n\t\t\t}\n\t\t}\n\n\t\t\/\/ restore original action + target\n\t\tif(req[\"_originalAction\"]){\n\t\t\treq.formNode.setAttribute(\"action\", req._originalAction);\n\t\t}\n\t\treq.formNode.setAttribute(\"target\", req._originalTarget);\n\t\treq.formNode.target = req._originalTarget;\n\n\t\tvar contentDoc = function(iframe_el){\n\t\t\tvar doc = iframe_el.contentDocument || \/\/ W3\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.contentWindow)&&(iframe_el.contentWindow.document)\n\t\t\t\t) ||  \/\/ IE\n\t\t\t\t(\n\t\t\t\t\t(iframe_el.name)&&(document.frames[iframe_el.name])&&\n\t\t\t\t\t(document.frames[iframe_el.name].document)\n\t\t\t\t) || null;\n\t\t\treturn doc;\n\t\t};\n\n\t\tvar ifd = contentDoc(_this.iframe);\n\t\t\/\/ handle successful returns\n\t\t\/\/ FIXME: how do we determine success for iframes? Is there an equiv of\n\t\t\/\/ the \"status\" property?\n\t\tvar value;\n\t\tvar success = false;\n\n\t\ttry{\n\t\t\tvar cmt = req.mimetype;\n\t\t\tif((cmt == \"text\/javascript\")||(cmt == \"text\/json\")){\n\t\t\t\t\/\/ FIXME: not sure what to do here? try to pull some evalulable\n\t\t\t\t\/\/ text from a textarea or cdata section? \n\t\t\t\t\/\/ how should we set up the contract for that?\n\t\t\t\tvar js = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t\tif(cmt == \"text\/json\") { js = \"(\" + js + \")\"; }\n\t\t\t\tvalue = dj_eval(js);\n\t\t\t}else if(cmt == \"text\/html\"){\n\t\t\t\tvalue = ifd;\n\t\t\t}else{ \/\/ text\/plain\n\t\t\t\tvalue = ifd.getElementsByTagName(\"textarea\")[0].value;\n\t\t\t}\n\t\t\tsuccess = true;\n\t\t}catch(e){ \n\t\t\t\/\/ looks like we didn't get what we wanted!\n\t\t\tvar errObj = new dojo.io.Error(\"IframeTransport Error\");\n\t\t\tif(dojo.lang.isFunction(req[\"error\"])){\n\t\t\t\treq.error(\"error\", errObj, req);\n\t\t\t}\n\t\t}\n\n\t\t\/\/ don't want to mix load function errors with processing errors, thus\n\t\t\/\/ a separate try..catch\n\t\ttry {\n\t\t\tif(success && dojo.lang.isFunction(req[\"load\"])){\n\t\t\t\treq.load(\"load\", value, req);\n\t\t\t}\n\t\t} catch(e) {\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t_this.currentRequest = null;\n\t\t\t_this.fireNextRequest();\n\t\t}"}}}}}},"dojo.io.RepubsubIO":{"meta":{"requires":{"common":["dojo.event.*","dojo.io.BrowserIO"]},"methods":{"dojo.io.repubsubTranport.canHandle":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tif((kwArgs[\"mimetype\"] == \"text\/javascript\")&&(kwArgs[\"method\"] == \"repubsub\")){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;"}}},"dojo.io.repubsubTranport.bind":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tif(!rps.isInitialized){\n\t\t\t\/\/ open up our tunnel, queue up requests anyway\n\t\t\trps.init();\n\t\t}\n\t\t\/\/ FIXME: we need to turn this into a topic subscription\n\t\t\/\/ var tgtURL = kwArgs.url+\"?\"+dojo.io.argsFromMap(kwArgs.content);\n\t\t\/\/ sampleTransport.sendRequest(tgtURL, hdlrFunc);\n\n\t\t\/\/ a normal \"bind()\" call in a request-response transport layer is\n\t\t\/\/ something that (usually) encodes most of it's payload with the\n\t\t\/\/ request. Multi-event systems like repubsub are a bit more complex,\n\t\t\/\/ and repubsub in particular distinguishes the publish and subscribe\n\t\t\/\/ portions of thep rocess with different method calls to handle each.\n\t\t\/\/ Therefore, a \"bind\" in the sense of repubsub must first determine if\n\t\t\/\/ we have an open subscription to a channel provided by the server,\n\t\t\/\/ and then \"publish\" the request payload if there is any. We therefore\n\t\t\/\/ must take care not to incorrectly or too agressively register or\n\t\t\/\/ file event handlers which are provided with the kwArgs method.\n\n\t\t\/\/ NOTE: we ONLY pay attention to those event handlers that are\n\t\t\/\/ registered with the bind request that subscribes to the channel. If\n\t\t\/\/ event handlers are provided with subsequent requests, we might in\n\t\t\/\/ the future support some additive or replacement syntax, but for now\n\t\t\/\/ they get dropped on the floor.\n\n\t\t\/\/ NOTE: in this case, url MUST be the \"topic\" to which we\n\t\t\/\/ subscribe\/publish for this channel\n\t\tif(!rps.topics[kwArgs.url]){\n\t\t\tkwArgs.rpsLoad = function(evt){\n\t\t\t\tkwArgs.load(\"load\", evt);\n\t\t\t}\n\t\t\trps.subscribe(kwArgs.url, kwArgs, \"rpsLoad\");\n\t\t}\n\n\t\tif(kwArgs[\"content\"]){\n\t\t\t\/\/ what we wanted to send\n\t\t\tvar cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);\n\t\t\trps.publish(kwArgs.url, cEvt);\n\t\t}"}}},"dojo.io.repubsub.getRandStr":{"_":{"meta":{"summary":"","src":"\t\treturn Math.random().toString().substring(2, 10);"}}},"dojo.io.repubsub.parseGetStr":{"_":{"meta":{"summary":"","src":"\t\tvar baseUrl = document.location.toString();\n\t\tvar params = baseUrl.split(\"?\", 2);\n\t\tif(params.length > 1){\n\t\t\tvar paramStr = params[1];\n\t\t\tvar pairs = paramStr.split(\"&\");\n\t\t\tvar opts = [];\n\t\t\tfor(var x in pairs){\n\t\t\t\tvar sp = pairs[x].split(\"=\");\n\t\t\t\t\/\/ FIXME: is this eval dangerous?\n\t\t\t\ttry{\n\t\t\t\t\topts[sp[0]]=eval(sp[1]);\n\t\t\t\t}catch(e){\n\t\t\t\t\topts[sp[0]]=sp[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn opts;\n\t\t}else{\n\t\t\treturn [];\n\t\t}"}}},"dojo.io.repubsub.tunnelCloseCallback":{"_":{"meta":{"summary":"","src":""}}},"dojo.io.repubsub.receiveEventFromTunnel":{"_":{"meta":{"summary":"","parameters":{"evt":{"type":""},"srcWindow":{"type":""}},"src":"\t\t\tthis.log(\"bailing! event received without elements!\", \"error\");\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/ if the event passes some minimal sanity tests, we need to attempt to\n\t\t\/\/ dispatch it!\n\n\t\t\/\/ first, it seems we have to munge the event object a bit\n\t\tvar e = {};\n\t\tfor(var i=0; i<evt.elements.length; i++){\n\t\t\tvar ee = evt.elements[i];\n\t\t\te[ee.name||ee.nameU] = (ee.value||ee.valueU);\n\t\t\t\/\/ FIXME: need to enable this only in some extreme debugging mode!\n\t\t\tthis.log(\"[event]: \"+(ee.name||ee.nameU)+\": \"+e[ee.name||ee.nameU]);\n\t\t}\n\n\t\t\/\/ NOTE: the previous version of this library put a bunch of code here\n\t\t\/\/ to manage state that tried to make sure that we never, ever, lost\n\t\t\/\/ any info about an event. If we unload RIGHT HERE, I don't think it's\n\t\t\/\/ going to make a huge difference one way or another. Time will tell.\n\n\t\t\/\/ and with THAT out of the way, dispatch it!\n\t\tthis.dispatch(e);\n\n\t\t\/\/ TODO: remove the script block that created the event obj to save\n\t\t\/\/ memory, etc."}}},"dojo.io.repubsub.widenDomain":{"_":{"meta":{"summary":"","parameters":{"domainStr":{"type":""}},"src":"\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");","returns":"probably file:"}}},"dojo.io.repubsub.parseCookie":{"_":{"meta":{"summary":"","src":"\t\tvar cs = document.cookie;\n\t\tvar keypairs = cs.split(\";\");\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tkeypairs[x] = keypairs[x].split(\"=\");\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\treturn keypairs;"}}},"dojo.io.repubsub.setCookie":{"_":{"meta":{"summary":"","parameters":{"keypairs":{"type":""},"clobber":{"type":""}},"src":"\t\tvar cs = \"\";\n\t\tfor(var x=0; x<keypairs.length; x++){\n\t\t\tcs += keypairs[x][0]+\"=\"+keypairs[x][1];\n\t\t\tif(x!=keypairs.length-1){ cs+=\";\"; }\n\t\t}\n\t\tdocument.cookie = cs;"}}},"dojo.io.repubsub.log":{"_":{"meta":{"summary":"","parameters":{"str":{"type":""},"lvl":{"type":""}},"src":"\t\tif(!this.debug){ return; }                                                 \n\t\twhile(this.logBacklog.length>0){\n\t\t\tif(!this.canLog){ break; }\n\t\t\tvar blo = this.logBacklog.shift();\n\t\t\tthis.writeLog(\"[\"+blo[0]+\"]: \"+blo[1], blo[2]);\n\t\t}\n\t\tthis.writeLog(str, lvl);","returns":"we of course only care if we're in debug mode"}}},"dojo.io.repubsub.writeLog":{"_":{"meta":{"summary":"","parameters":{"str":{"type":""},"lvl":{"type":""}},"src":"\t\tdojo.debug(((new Date()).toLocaleTimeString())+\": \"+str);"}}},"dojo.io.repubsub.init":{"_":{"meta":{"summary":"","src":"\t\tthis.widenDomain();\n\t\t\/\/ this.findPeers();\n\t\tthis.openTunnel();\n\t\tthis.isInitialized = true;\n\t\t\/\/ FIXME: this seems like entirely the wrong place to replay the backlog\n\t\twhile(this.subscriptionBacklog.length){\n\t\t\tthis.subscribe.apply(this, this.subscriptionBacklog.shift());\n\t\t}","this_variables":["isInitialized"]}}},"dojo.io.repubsub.clobber":{"_":{"meta":{"summary":"","src":"\t\tif(this.rcvNode){\n\t\t\tthis.setCookie( [\n\t\t\t\t\t[this.tunnelFrameKey,\"closed\"],\n\t\t\t\t\t[\"path\",\"\/\"]\n\t\t\t\t], false \n\t\t\t);\n\t\t}"}}},"dojo.io.repubsub.openTunnel":{"_":{"meta":{"summary":"","src":"\t\t\/\/ set cookie that can be used to find the receiving iframe\n\t\tthis.setCookie( [\n\t\t\t\t[this.tunnelFrameKey,this.rcvNodeName],\n\t\t\t\t[\"path\",\"\/\"]\n\t\t\t], false\n\t\t);\n\n\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.rcvNode, this.initDoc+\"?callback=repubsub.rcvNodeReady&domain=\"+document.domain);\n\n\t\t\/\/ the other for posting data in reply\n\n\t\tthis.sndNodeName = \"sndIFrame_\"+this.getRandStr();\n\t\tthis.sndNode = dojo.io.createIFrame(this.sndNodeName);\n\t\t\/\/ FIXME: set the src attribute here to the initialization URL\n\t\tdojo.io.setIFrameSrc(this.sndNode, this.initDoc+\"?callback=repubsub.sndNodeReady&domain=\"+document.domain);","this_variables":["rcvNodeName","rcvNode","sndNodeName","sndNode"]}}},"dojo.io.repubsub.rcvNodeReady":{"_":{"meta":{"summary":"","src":"\t\t\t\t\t\t String(this.tunnelInitCount++)].join(\"\"); \n            \/\/ (kn._seqNum++); \/\/ FIXME: !!!!\n\t\t\/\/ this.canRcv = true;\n\t\tthis.log(\"rcvNodeReady\");\n\t\t\/\/ FIXME: initialize receiver and request the base topic\n\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+\"\/kn?do_method=blank\");\n\t\tvar initURIArr = [\tthis.serverBaseURL, \"\/kn?kn_from=\", escape(this.tunnelURI),\n\t\t\t\t\t\t\t\"&kn_id=\", escape(this.tunnelID), \"&kn_status_from=\", \n\t\t\t\t\t\t\tescape(statusURI)];\n\t\t\/\/ FIXME: does the above really need a kn_response_flush? won't the\n\t\t\/\/ \t\t  server already know? If not, what good is it anyway?\n\t\tdojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(\"\"));\n\n\t\t\/\/ setup a status path listener, but don't tell the server about it,\n\t\t\/\/ since it already knows we're itnerested in our own tunnel status\n\t\tthis.subscribe(statusURI, this, \"statusListener\", true);\n\n\t\tthis.log(initURIArr.join(\"\"));"}}},"dojo.io.repubsub.sndNodeReady":{"_":{"meta":{"summary":"","src":"\t\tthis.canSnd = true;\n\t\tthis.log(\"sndNodeReady\");\n\t\tthis.log(this.backlog.length);\n\t\t\/\/ FIXME: handle any pent-up send commands\n\t\tif(this.backlog.length > 0){\n\t\t\tthis.dequeueEvent();\n\t\t}","this_variables":["canSnd"]}}},"dojo.io.repubsub.statusListener":{"_":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":"\t\tthis.log(\"status listener called\");\n\t\tthis.log(evt.status, \"info\");"}}},"dojo.io.repubsub.dispatch":{"_":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":"\t\t\tvar rf = evt[\"to\"]||evt[\"kn_routed_from\"];\n\t\t\t\/\/ split off the base server URL\n\t\t\tvar topic = rf.split(this.serverBaseURL, 2)[1];\n\t\t\tif(!topic){\n\t\t\t\t\/\/ FIXME: how do we recover when we don't get a sane \"from\"? Do\n\t\t\t\t\/\/ we try to route to it anyway?\n\t\t\t\ttopic = rf;\n\t\t\t}\n\t\t\tthis.log(\"[topic] \"+topic);\n\t\t\tif(topic.length>3){\n\t\t\t\tif(topic.slice(0, 3)==\"\/kn\"){\n\t\t\t\t\ttopic = topic.slice(3);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(this.attachPathList[topic]){\n\t\t\t\tthis.attachPathList[topic](evt);\n\t\t\t}\n\t\t}"}}},"dojo.io.repubsub.subscribe":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":"kn_from in the old terminilogy"},"toObj":{"type":""},"toFunc":{"type":""},"dontTellServer":{"type":""}},"src":"\t\tif(!this.isInitialized){\n\t\t\tthis.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);\n\t\t\treturn;\n\t\t}\n\t\tif(!this.attachPathList[topic]){\n\t\t\tthis.attachPathList[topic] = function(){ return true; }\n\t\t\tthis.log(\"subscribing to: \"+topic);\n\t\t\tthis.topics.push(topic);\n\t\t}\n\t\tvar revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, \"route\");\n\t\tvar rstr = [this.serverBaseURL+\"\/kn\", revt.toGetString()].join(\"\");\n\t\tdojo.event.kwConnect({\n\t\t\tonce: true,\n\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\/\/ NOTE: the above is a local mapping, if we're not the leader, we\n\t\t\/\/ \t\t should connect our mapping to the topic handler of the peer\n\t\t\/\/ \t\t leader, this ensures that not matter what happens to the\n\t\t\/\/ \t\t leader, we don't really loose our heads if\/when the leader\n\t\t\/\/ \t\t goes away.\n\t\tif(!this.rcvNode){ \/* this should be an error! *\/ }\n\t\tif(dontTellServer){\n\t\t\treturn;\n\t\t}\n\t\tthis.log(\"sending subscription to: \"+topic);\n\t\t\/\/ create a subscription event object and give it all the props we need\n\t\t\/\/ to updates on the specified topic\n\n\t\t\/\/ FIXME: we should only enqueue if this is our first subscription!\n\t\tthis.sendTopicSubToServer(topic, rstr);"}}},"dojo.io.repubsub.sendTopicSubToServer":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"str":{"type":""}},"src":"\t\tif(!this.attachPathList[topic][\"subscriptions\"]){\n\t\t\tthis.enqueueEventStr(str);\n\t\t\tthis.attachPathList[topic].subscriptions = 0;\n\t\t}\n\t\tthis.attachPathList[topic].subscriptions++;"}}},"dojo.io.repubsub.unSubscribe":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"toObj":{"type":""},"toFunc":{"type":""}},"src":"\t\t\tsrcObj: this.attachPathList, \n\t\t\tsrcFunc: topic, \n\t\t\tadviceObj: toObj, \n\t\t\tadviceFunc: toFunc\n\t\t});\n\t\t\n\t\t\/\/ FIXME: figure out if there are any remaining listeners to the topic,\n\t\t\/\/ \t\t  and if not, inform the server of our desire not to be\n\t\t\/\/ \t\t  notified of updates to the topic"}}},"dojo.io.repubsub.publish":{"_":{"meta":{"summary":"","parameters":{"topic":{"type":""},"event":{"type":""}},"src":"\t\tvar evt = dojo.io.repubsubEvent.initFromProperties(event);\n\t\t\/\/ FIXME: need to make sure we have from and to set correctly\n\t\t\/\/ \t\t  before we serialize and send off to the great blue\n\t\t\/\/ \t\t  younder.\n\t\tevt.to = topic;\n\t\t\/\/ evt.from = this.tunnelURI;\n\n\t\tvar evtURLParts = [];\n\t\tevtURLParts.push(this.serverBaseURL+\"\/kn\");\n\n\t\t\/\/ serialize the event to a string and then post it to the correct\n\t\t\/\/ topic\n\t\tevtURLParts.push(evt.toGetString());\n\t\tthis.enqueueEventStr(evtURLParts.join(\"\"));"}}},"dojo.io.repubsub.enqueueEventStr":{"_":{"meta":{"summary":"","parameters":{"evtStr":{"type":""}},"src":"\t\tthis.log(\"enqueueEventStr\");\n\t\tthis.backlog.push(evtStr);\n\t\tthis.dequeueEvent();"}}},"dojo.io.repubsub.dequeueEvent":{"_":{"meta":{"summary":"","parameters":{"force":{"type":""}},"src":"\t\tthis.log(\"dequeueEvent\");\n\t\tif(this.backlog.length <= 0){ return; }\n\t\tif((this.canSnd)||(force)){\n\t\t\tdojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+\"&callback=repubsub.sndNodeReady\");\n\t\t\tthis.canSnd = false;\n\t\t}else{\n\t\t\tthis.log(\"sndNode not available yet!\", \"debug\");\n\t\t}","this_variables":["canSnd"]}}},"dojo.io.repubsubEvent.initFromProperties":{"_":{"meta":{"summary":"","parameters":{"evt":{"type":""}},"src":"\t\tif(evt.constructor = dojo.io.repubsubEvent){ \n\t\t\tfor(var x in evt){\n\t\t\t\tthis[x] = evt[x];\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/ we want to copy all the properties of the evt object, and transform\n\t\t\t\/\/ those that are \"stock\" properties of dojo.io.repubsubEvent. All others should\n\t\t\t\/\/ be copied as-is\n\t\t\tfor(var x in evt){\n\t\t\t\tif(typeof this.forwardPropertiesMap[x] == \"string\"){\n\t\t\t\t\tthis[this.forwardPropertiesMap[x]] = evt[x];\n\t\t\t\t}else{\n\t\t\t\t\tthis[x] = evt[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}"}}},"dojo.io.repubsubEvent.toGetString":{"_":{"meta":{"summary":"","parameters":{"noQmark":{"type":""}},"src":"\t\tvar qs = [ ((noQmark) ? \"\" : \"?\") ];\n\t\tfor(var x=0; x<this.properties.length; x++){\n\t\t\tvar tp = this.properties[x];\n\t\t\tif(this[tp[0]]){\n\t\t\t\tqs.push(tp[1]+\"=\"+encodeURIComponent(String(this[tp[0]])));\n\t\t\t}\n\t\t\t\/\/ FIXME: we need to be able to serialize non-stock properties!!!\n\t\t}\n\t\treturn qs.join(\"&\");"}}}}}},"dojo.io.RhinoIO":{"meta":{"requires":{"common":["dojo.io","dojo.lang.func","dojo.lang.array","dojo.string.extras"]},"methods":{"dojo.io.RhinoHTTPTransport.canHandle":{"_":{"meta":{"summary":"","parameters":{"req":{"type":""}},"src":"\t\t\t\t[\"text\/plain\", \"text\/html\", \"text\/javascript\", \"text\/json\"])){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\t\/\/ We only handle http requests!  Unfortunately, because the method is \n\t\t\t\/\/ protected, I can't directly create a java.net.HttpURLConnection, so\n\t\t\t\/\/ this is the only way to test.\n\t\t\tif(req.url.substr(0, 7) != \"http:\/\/\"){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;"}}},"dojo.io.RhinoHTTPTransport.bind":{"_":{"meta":{"summary":"","parameters":{"req":{"type":""}},"src":"\t\t\tvar async = req[\"sync\"] ? false : true;\n\t\t\tif (async){\n\t\t\t\tsetTimeout(dojo.lang.hitch(this, function(){\n\t\t\t\t\tconnect(req);\n\t\t\t\t}), 1);\n\t\t\t} else {\n\t\t\t\tconnect(req);\n\t\t\t}"}}}}}},"dojo.io.ScriptSrcIO":{"meta":{"requires":{"common":["dojo.io.BrowserIO","dojo.undo.browser"]},"methods":{"dojo.io.ScriptSrcTransport.startWatchingInFlight":{"_":{"meta":{"summary":"","src":"\t\tif(!this.inFlightTimer){\n\t\t\tthis.inFlightTimer = setInterval(\"dojo.io.ScriptSrcTransport.watchInFlight();\", 100);\n\t\t}","this_variables":["inFlightTimer"]}}},"dojo.io.ScriptSrcTransport.watchInFlight":{"_":{"meta":{"summary":"","src":"\t\tvar totalCount = 0;\n\t\tvar doneCount = 0;\n\t\tfor(var param in this._state){\n\t\t\ttotalCount++;\n\t\t\tvar currentState = this._state[param];\n\t\t\tif(currentState.isDone){\n\t\t\t\tdoneCount++;\n\t\t\t\tdelete this._state[param];\n\t\t\t}else{\n\t\t\t\tvar listener = currentState.kwArgs;\n\t\t\t\ttry{\n\t\t\t\t\tif(currentState.checkString && eval(\"typeof(\" + currentState.checkString + \") != 'undefined'\")){\n\t\t\t\t\t\tthis._finish(currentState, \"load\");\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t}else if(listener.timeoutSeconds && listener.timeout){\n\t\t\t\t\t\tif(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){\n\t\t\t\t\t\t\tthis._finish(currentState, \"timeout\");\n\t\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t\t\tdelete this._state[param];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else if(!listener.timeoutSeconds){\n\t\t\t\t\t\t\/\/Increment the done count if no timeout is specified, so\n\t\t\t\t\t\t\/\/that we turn off the timer if all that is left in the state\n\t\t\t\t\t\t\/\/list are things we can't clean up because they fail without\n\t\t\t\t\t\t\/\/getting a callback.\n\t\t\t\t\t\tdoneCount++;\n\t\t\t\t\t}\n\t\t\t\t}catch(e){\n\t\t\t\t\tthis._finish(currentState, \"error\", {status: this.DsrStatusCodes.Error, response: e});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tif(doneCount == totalCount){\n\t\t\tclearInterval(this.inFlightTimer);\n\t\t\tthis.inFlightTimer = null;\n\t\t}","this_variables":["inFlightTimer"]}}},"dojo.io.ScriptSrcTransport.canHandle":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\treturn dojo.lang.inArray([\"text\/javascript\", \"text\/json\"], (kwArgs[\"mimetype\"].toLowerCase()))\n\t\t\t&& (kwArgs[\"method\"].toLowerCase() == \"get\")\n\t\t\t&& !(kwArgs[\"formNode\"] && dojo.io.formHasFile(kwArgs[\"formNode\"]))\n\t\t\t&& (!kwArgs[\"sync\"] || kwArgs[\"sync\"] == false)\n\t\t\t&& !kwArgs[\"file\"]\n\t\t\t&& !kwArgs[\"multipart\"];"}}},"dojo.io.ScriptSrcTransport.removeScripts":{"_":{"meta":{"summary":"","src":"\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; scripts && i < scripts.length; i++){\n\t\t\tvar scriptTag = scripts[i];\n\t\t\tif(scriptTag.className == \"ScriptSrcTransport\"){\n\t\t\t\tvar parent = scriptTag.parentNode;\n\t\t\t\tparent.removeChild(scriptTag);\n\t\t\t\ti--; \/\/Set the index back one since we removed an item.\n\t\t\t}\n\t\t}"}}},"dojo.io.ScriptSrcTransport.bind":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tvar query = \"\";\n\t\t\n\t\tif(kwArgs[\"formNode\"]){\n\t\t\tvar ta = kwArgs.formNode.getAttribute(\"action\");\n\t\t\tif((ta)&&(!kwArgs[\"url\"])){ url = ta; }\n\t\t\tvar tp = kwArgs.formNode.getAttribute(\"method\");\n\t\t\tif((tp)&&(!kwArgs[\"method\"])){ kwArgs.method = tp; }\n\t\t\tquery += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[\"formFilter\"]);\n\t\t}\n\n\t\tif(url.indexOf(\"#\") > -1) {\n\t\t\tdojo.debug(\"Warning: dojo.io.bind: stripping hash values from url:\", url);\n\t\t\turl = url.split(\"#\")[0];\n\t\t}\n\n\t\t\/\/Break off the domain\/path of the URL.\n\t\tvar urlParts = url.split(\"?\");\n\t\tif(urlParts && urlParts.length == 2){\n\t\t\turl = urlParts[0];\n\t\t\tquery += (query ? \"&\" : \"\") + urlParts[1];\n\t\t}\n\n\t\tif(kwArgs[\"backButton\"] || kwArgs[\"back\"] || kwArgs[\"changeUrl\"]){\n\t\t\tdojo.undo.browser.addToHistory(kwArgs);\n\t\t}\n\n\t\t\/\/Create an ID for the request.\n\t\tvar id = kwArgs[\"apiId\"] ? kwArgs[\"apiId\"] : \"id\" + this._counter++;\n\n\t\t\/\/Fill out any other content pieces.\n\t\tvar content = kwArgs[\"content\"];\n\t\tvar jsonpName = kwArgs.jsonParamName;\n\t\tif(kwArgs.sendTransport || jsonpName) {\n\t\t\tif (!content){\n\t\t\t\tcontent = {};\n\t\t\t}\n\t\t\tif(kwArgs.sendTransport){\n\t\t\t\tcontent[\"dojo.transport\"] = \"scriptsrc\";\n\t\t\t}\n\n\t\t\tif(jsonpName){\n\t\t\t\tcontent[jsonpName] = \"dojo.io.ScriptSrcTransport._state.\" + id + \".jsonpCall\";\n\t\t\t}\n\t\t}\n\n\t\tif(kwArgs.postContent){\n\t\t\tquery = kwArgs.postContent;\n\t\t}else if(content){\n\t\t\tquery += ((query) ? \"&\" : \"\") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);\n\t\t}\n\t\t\/\/END duplication from BrowserIO.js\n\n\t\t\/\/START DSR\n\n\t\t\/\/If an apiId is specified, then we want to make sure useRequestId is true.\n\t\tif(kwArgs[\"apiId\"]){\n\t\t\tkwArgs[\"useRequestId\"] = true;\n\t\t}\n\n\t\t\/\/Set up the state for this request.\n\t\tvar state = {\n\t\t\t\"id\": id,\n\t\t\t\"idParam\": \"_dsrid=\" + id,\n\t\t\t\"url\": url,\n\t\t\t\"query\": query,\n\t\t\t\"kwArgs\": kwArgs,\n\t\t\t\"startTime\": (new Date()).getTime()\n\t\t};\n\n\t\tif(!url){\n\t\t\t\/\/Error. An URL is needed.\n\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.none\"});\n\t\t\treturn;\n\t\t}\n\n\t\t\/\/If this is a jsonp request, intercept the jsonp callback\n\t\tif(content && content[jsonpName]){\n\t\t\tstate.jsonp = content[jsonpName];\n\t\t\tstate.jsonpCall = function(data){\n\t\t\t\tif(data[\"Error\"]||data[\"error\"]){\n\t\t\t\t\tif(dojo[\"json\"] && dojo[\"json\"][\"serialize\"]){\n\t\t\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\t\t}\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"error\", data);\n\t\t\t\t}else{\n\t\t\t\t\tdojo.io.ScriptSrcTransport._finish(this, \"load\", data);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t\/\/Only store the request state on the state tracking object if a callback\n\t\t\/\/is expected or if polling on a checkString will be done.\n\t\tif(kwArgs[\"useRequestId\"] || kwArgs[\"checkString\"] || state[\"jsonp\"]){\n\t\t\tthis._state[id] = state;\n\t\t}\n\n\t\t\/\/A checkstring is a string that if evaled will not be undefined once the\n\t\t\/\/script src loads. Used as an alternative to depending on a callback from\n\t\t\/\/the script file. If this is set, then multipart is not assumed to be used,\n\t\t\/\/since multipart requires a specific callback. With checkString we will be doing\n\t\t\/\/polling.\n\t\tif(kwArgs[\"checkString\"]){\n\t\t\tstate.checkString = kwArgs[\"checkString\"];\n\t\t}\n\n\t\t\/\/Constant params are parameters that should always be sent with each\n\t\t\/\/part of a multipart URL.\n\t\tstate.constantParams = (kwArgs[\"constantParams\"] == null ? \"\" : kwArgs[\"constantParams\"]);\n\t\n\t\tif(kwArgs[\"preventCache\"] ||\n\t\t\t(this.preventCache == true && kwArgs[\"preventCache\"] != false)){\n\t\t\tstate.nocacheParam = \"dojo.preventCache=\" + new Date().valueOf();\n\t\t}else{\n\t\t\tstate.nocacheParam = \"\";\n\t\t}\n\n\t\t\/\/Get total length URL, if we were to do it as one URL.\n\t\t\/\/Add some padding, extra & separators.\n\t\tvar urlLength = state.url.length + state.query.length + state.constantParams.length \n\t\t\t\t+ state.nocacheParam.length + this._extraPaddingLength;\n\n\t\tif(kwArgs[\"useRequestId\"]){\n\t\t\turlLength += state.idParam.length;\n\t\t}\n\t\t\n\t\tif(!kwArgs[\"checkString\"] && kwArgs[\"useRequestId\"] \n\t\t\t&& !state[\"jsonp\"] && !kwArgs[\"forceSingleRequest\"]\n\t\t\t&& urlLength > this.maxUrlLength){\n\t\t\tif(url > this.maxUrlLength){\n\t\t\t\t\/\/Error. The URL domain and path are too long. We can't\n\t\t\t\t\/\/segment that, so return an error.\n\t\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"url.tooBig\"});\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\t\/\/Start the multiple requests.\n\t\t\t\tthis._multiAttach(state, 1);\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/Send one URL.\n\t\t\tvar queryParams = [state.constantParams, state.nocacheParam, state.query];\n\t\t\tif(kwArgs[\"useRequestId\"] && !state[\"jsonp\"]){\n\t\t\t\tqueryParams.unshift(state.idParam);\n\t\t\t}\n\t\t\tvar finalUrl = this._buildUrl(state.url, queryParams);\n\n\t\t\t\/\/Track the final URL in case we need to use that instead of api ID when receiving\n\t\t\t\/\/the load callback.\n\t\t\tstate.finalUrl = finalUrl;\n\t\t\t\n\t\t\tthis._attach(state.id, finalUrl);\n\t\t}\n\t\t\/\/END DSR\n\n\t\tthis.startWatchingInFlight();"}}},"dojo.io.ScriptSrcTransport._buildUrl":{"_":{"meta":{"summary":"","parameters":{"url":{"type":""},"nameValueArray":{"type":""}},"src":"\t\tvar finalUrl = url;\n\t\tvar joiner = \"?\";\n\t\tfor(var i = 0; i < nameValueArray.length; i++){\n\t\t\tif(nameValueArray[i]){\n\t\t\t\tfinalUrl += joiner + nameValueArray[i];\n\t\t\t\tjoiner = \"&\";\n\t\t\t}\n\t\t}\n\n\t\treturn finalUrl;"}}},"dojo.io.ScriptSrcTransport._attach":{"_":{"meta":{"summary":"","parameters":{"id":{"type":""},"url":{"type":""}},"src":"\t\telement.type = \"text\/javascript\";\n\t\telement.src = url;\n\t\telement.id = id;\n\t\telement.className = \"ScriptSrcTransport\";\n\t\tdocument.getElementsByTagName(\"head\")[0].appendChild(element);"}}},"dojo.io.ScriptSrcTransport._multiAttach":{"_":{"meta":{"summary":"","parameters":{"state":{"type":""},"part":{"type":""}},"src":"\t\t\tthis._finish(state, \"error\", {status: this.DsrStatusCodes.Error, statusText: \"query.null\"});\n\t\t\treturn;\n\t\t}\n\n\t\tif(!state.constantParams){\n\t\t\tstate.constantParams = \"\";\n\t\t}\n\n\t\t\/\/How much of the query can we take?\n\t\t\/\/Add a padding constant to account for _part and a couple extra amperstands.\n\t\t\/\/Also add space for id since we'll need it now.\n\t\tvar queryMax = this.maxUrlLength - state.idParam.length\n\t\t\t\t\t - state.constantParams.length - state.url.length\n\t\t\t\t\t - state.nocacheParam.length - this._extraPaddingLength;\n\t\t\n\t\t\/\/Figure out if this is the last part.\n\t\tvar isDone = state.query.length < queryMax;\n\t\n\t\t\/\/Break up the query string if necessary.\n\t\tvar currentQuery;\n\t\tif(isDone){\n\t\t\tcurrentQuery = state.query;\n\t\t\tstate.query = null;\n\t\t}else{\n\t\t\t\/\/Find the & or = nearest the max url length.\n\t\t\tvar ampEnd = state.query.lastIndexOf(\"&\", queryMax - 1);\n\t\t\tvar eqEnd = state.query.lastIndexOf(\"=\", queryMax - 1);\n\n\t\t\t\/\/See if & is closer, or if = is right at the edge,\n\t\t\t\/\/which means we should put it on the next URL.\n\t\t\tif(ampEnd > eqEnd || eqEnd == queryMax - 1){\n\t\t\t\t\/\/& is nearer the end. So just chop off from there.\n\t\t\t\tcurrentQuery = state.query.substring(0, ampEnd);\n\t\t\t\tstate.query = state.query.substring(ampEnd + 1, state.query.length) \/\/strip off amperstand with the + 1.\n\t\t\t}else{\n\t\t\t\t\/\/= is nearer the end. Take the max amount possible. \n\t\t\t\tcurrentQuery = state.query.substring(0, queryMax);\n\t\t\t \n\t\t\t\t\/\/Find the last query name in the currentQuery so we can prepend it to\n\t\t\t\t\/\/ampEnd. Could be -1 (not there), so account for that.\n\t\t\t\tvar queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);\n\t\t\t\tstate.query = queryName + \"=\" + state.query.substring(queryMax, state.query.length);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\/\/Now send a part of the script\n\t\tvar queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];\n\t\tif(!isDone){\n\t\t\tqueryParams.push(\"_part=\" + part);\n\t\t}\n\n\t\tvar url = this._buildUrl(state.url, queryParams);\n\n\t\tthis._attach(state.id + \"_\" + part, url);"}}},"dojo.io.ScriptSrcTransport._finish":{"_":{"meta":{"summary":"","parameters":{"state":{"type":""},"callback":{"type":""},"event":{"type":""}},"src":"\t\tif(callback != \"partOk\" && !state.kwArgs[callback] && !state.kwArgs[\"handle\"]){\n\t\t\t\/\/Ignore \"partOk\" because that is an internal callback.\n\t\t\tif(callback == \"error\"){\n\t\t\t\tstate.isDone = true;\n\t\t\t\tthrow event;\n\t\t\t}\n\t\t}else{\n\t\t\tswitch(callback){\n\t\t\t\tcase \"load\":\n\t\t\t\t\tvar response = event ? event.response : null;\n\t\t\t\t\tif(!response){\n\t\t\t\t\t\tresponse = event;\n\t\t\t\t\t}\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.load == \"function\") ? \"load\" : \"handle\"](\"load\", response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"partOk\":\n\t\t\t\t\tvar part = parseInt(event.response.part, 10) + 1;\n\t\t\t\t\t\/\/Update the constant params, if any.\n\t\t\t\t\tif(event.response.constantParams){\n\t\t\t\t\t\tstate.constantParams = event.response.constantParams;\n\t\t\t\t\t}\n\t\t\t\t\tthis._multiAttach(state, part);\n\t\t\t\t\tstate.isDone = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs.error == \"function\") ? \"error\" : \"handle\"](\"error\", event.response, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstate.kwArgs[(typeof state.kwArgs[callback] == \"function\") ? callback : \"handle\"](callback, event, event, state.kwArgs);\n\t\t\t\t\tstate.isDone = true;\n\t\t\t}\n\t\t}"}}}}}},"dojo.io.XhrIframeProxy":{"meta":{"requires":{"common":["dojo.experimental","dojo.io.IframeIO","dojo.html.iframe","dojo.dom","dojo.uri.Uri"]},"methods":{"dojo.io.XhrIframeProxy.send":{"_":{"meta":{"summary":"","parameters":{"facade":{"type":""}},"src":"\t\tvar stateId = \"XhrIframeProxy\" + (this._stateIdCounter++);\n\t\tfacade._stateId = stateId;\n\n\t\tthis._state[stateId] = {\n\t\t\tfacade: facade,\n\t\t\tstateId: stateId,\n\t\t\tclientFrame: dojo.io.createIFrame(stateId,\n\t\t\t\t\"dojo.io.XhrIframeProxy.clientFrameLoaded('\" + stateId + \"');\",\n\t\t\t\tthis.xipClientUrl)\n\t\t};"}}},"dojo.io.XhrIframeProxy.receive":{"_":{"meta":{"summary":"","parameters":{"stateId":{"type":""},"urlEncodedData":{"type":""}},"src":"\t\tvar nvPairs = urlEncodedData.split(\"&\");\n\t\tfor(var i = 0; i < nvPairs.length; i++){\n\t\t\tif(nvPairs[i]){\n\t\t\t\tvar nameValue = nvPairs[i].split(\"=\");\n\t\t\t\tresponse[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);\n\t\t\t}\n\t\t}\n\n\t\t\/\/Set data on facade object.\n\t\tvar state = this._state[stateId];\n\t\tvar facade = state.facade;\n\n\t\tfacade._setResponseHeaders(response.responseHeaders);\n\t\tif(response.status == 0 || response.status){\n\t\t\tfacade.status = parseInt(response.status, 10);\n\t\t}\n\t\tif(response.statusText){\n\t\t\tfacade.statusText = response.statusText;\n\t\t}\n\t\tif(response.responseText){\n\t\t\tfacade.responseText = response.responseText;\n\t\t\t\n\t\t\t\/\/Fix responseXML.\n\t\t\tvar contentType = facade.getResponseHeader(\"Content-Type\");\n\t\t\tif(contentType && (contentType == \"application\/xml\" || contentType == \"text\/xml\")){\n\t\t\t\tfacade.responseXML = dojo.dom.createDocumentFromText(response.responseText, contentType);\n\t\t\t}\n\t\t}\n\t\tfacade.readyState = 4;\n\t\t\n\t\tthis.destroyState(stateId);"}}},"dojo.io.XhrIframeProxy.clientFrameLoaded":{"_":{"meta":{"summary":"","parameters":{"stateId":{"type":""}},"src":"\t\tvar state = this._state[stateId];\n\t\tvar facade = state.facade;\n\t\tvar clientWindow = dojo.html.iframeContentWindow(state.clientFrame);\n\t\t\n\t\tvar reqHeaders = [];\n\t\tfor(var param in facade._requestHeaders){\n\t\t\treqHeaders.push(param + \": \" + facade._requestHeaders[param]);\n\t\t}\n\t\t\n\t\tvar requestData = {\n\t\t\turi: facade._uri\n\t\t};\n\t\tif(reqHeaders.length > 0){\n\t\t\trequestData.requestHeaders = reqHeaders.join(\"\\r\\n\");\t\t\n\t\t}\n\t\tif(facade._method){\n\t\t\trequestData.method = facade._method;\n\t\t}\n\t\tif(facade._bodyData){\n\t\t\trequestData.data = facade._bodyData;\n\t\t}\n\n\t\tclientWindow.send(stateId, facade._ifpServerUrl, dojo.io.argsFromMap(requestData, \"utf8\"));"}}},"dojo.io.XhrIframeProxy.destroyState":{"_":{"meta":{"summary":"","parameters":{"stateId":{"type":""}},"src":"\t\tvar state = this._state[stateId];\n\t\tif(state){\n\t\t\tdelete this._state[stateId];\n\t\t\tvar parentNode = state.clientFrame.parentNode;\n\t\t\tparentNode.removeChild(state.clientFrame);\n\t\t\tstate.clientFrame = null;\n\t\t\tstate = null;\n\t\t}"}}},"dojo.io.XhrIframeProxy.createFacade":{"_":{"meta":{"summary":"","src":"\t\tif(arguments && arguments[0] && arguments[0][\"iframeProxyUrl\"]){\n\t\t\treturn new dojo.io.XhrIframeFacade(arguments[0][\"iframeProxyUrl\"]);\n\t\t}else{\n\t\t\treturn dojo.io.XhrIframeProxy.oldGetXmlhttpObject.apply(dojo.hostenv, arguments);\n\t\t}"}}},"dojo.io.XhrIframeFacade.open":{"_":{"meta":{"summary":"","parameters":{"method":{"type":""},"uri":{"type":""}},"src":"\t\tthis._method = method;\n\t\tthis._uri = uri;\n\n\t\tthis.readyState = 1;","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade":{"_":{"meta":{"this_variables":["_method","_uri","readyState","_bodyData","readyState","_allResponseHeaders"]}}},"dojo.io.XhrIframeFacade.setRequestHeader":{"_":{"meta":{"summary":"","parameters":{"header":{"type":""},"value":{"type":""}},"src":"\t\tthis._requestHeaders[header] = value;","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade.send":{"_":{"meta":{"summary":"","parameters":{"stringData":{"type":""}},"src":"\t\tthis._bodyData = stringData;\n\t\t\n\t\tdojo.io.XhrIframeProxy.send(this);\n\t\t\n\t\tthis.readyState = 2;","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade.abort":{"_":{"meta":{"summary":"","src":"\t\tdojo.io.XhrIframeProxy.destroyState(this._stateId);","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade.getAllResponseHeaders":{"_":{"meta":{"summary":"","src":"\t\treturn this._allResponseHeaders;","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade.getResponseHeader":{"_":{"meta":{"summary":"","parameters":{"header":{"type":""}},"src":"\t\treturn this._responseHeaders[header];","this":"dojo.io.XhrIframeFacade"}}},"dojo.io.XhrIframeFacade._setResponseHeaders":{"_":{"meta":{"summary":"","parameters":{"allHeaders":{"type":""}},"src":"\t\tif(allHeaders){\n\t\t\tthis._allResponseHeaders = allHeaders;\n\t\t\t\n\t\t\t\/\/Make sure ther are now CR characters in the headers.\n\t\t\tallHeaders = allHeaders.replace(\/\\r\/g, \"\");\n\t\t\tvar nvPairs = allHeaders.split(\"\\n\");\n\t\t\tfor(var i = 0; i < nvPairs.length; i++){\n\t\t\t\tif(nvPairs[i]){\n\t\t\t\t\tvar nameValue = nvPairs[i].split(\": \");\n\t\t\t\t\tthis._responseHeaders[nameValue[0]] = nameValue[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}","this":"dojo.io.XhrIframeFacade"}}}}}},"dojo.io._":{"meta":{"requires":{"common":["dojo.io"],"rhino":["dojo.io.RhinoIO"],"browser":["dojo.io.BrowserIO","dojo.io.cookie"],"dashboard":["dojo.io.BrowserIO","dojo.io.cookie"]}}},"dojo.io.cometd":{"meta":{"requires":{"common":["dojo.io","dojo.AdapterRegistry","dojo.json","dojo.io.BrowserIO","dojo.io.IframeIO","dojo.io.ScriptSrcIO","dojo.io.cookie","dojo.event.*","dojo.lang.common","dojo.lang.func"]},"methods":{"cometd.tunnelInit":{"_":{"meta":{"summary":"","parameters":{"childLocation":{"type":""},"childDomain":{"type":""}},"src":"\t\t\/\/ placeholder"}}},"cometd.tunnelCollapse":{"_":{"meta":{"summary":"","src":"\t\tdojo.debug(\"tunnel collapsed!\");\n\t\t\/\/ placeholder"}}},"cometd.init":{"_":{"meta":{"summary":"","parameters":{"props":{"type":""},"root":{"type":""},"bargs":{"type":""}},"src":"\t\t\/\/ go ask the short bus server what we can support\n\t\tprops.version = this.version;\n\t\tprops.minimumVersion = this.minimumVersion;\n\t\tprops.channel = \"\/meta\/handshake\";\n\t\t\/\/ FIXME: do we just assume that the props knows\n\t\t\/\/ everything we care about WRT to auth? Should we be trying to\n\t\t\/\/ call back into it for subsequent auth actions? Should we fire\n\t\t\/\/ local auth functions to ask for\/get auth data?\n\n\t\t\/\/ FIXME: what about ScriptSrcIO for x-domain comet?\n\t\tthis.url = root||djConfig[\"cometdRoot\"];\n\t\tif(!this.url){\n\t\t\tdojo.debug(\"no cometd root specified in djConfig and no root passed\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\/\/ FIXME: we need to select a way to handle JSONP-style stuff\n\t\t\/\/ generically here. We already know if the server is gonna be on\n\t\t\/\/ another domain (or can know it), so we should select appropriate\n\t\t\/\/ negotiation methods here as well as in final transport type\n\t\t\/\/ selection.\n\t\tvar bindArgs = {\n\t\t\turl: this.url,\n\t\t\tmethod: \"POST\",\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, \"finishInit\"),\n\t\t\tcontent: { \"message\": dojo.json.serialize([props]) }\n\t\t};\n\n\t\t\/\/ borrowed from dojo.uri.Uri in lieu of fixed host and port properties\n        var regexp = \"^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\\\\?([^#]*))?(#(.*))?$\";\n\t\tvar r = (\"\"+window.location).match(new RegExp(regexp));\n\t\tif(r[4]){\n\t\t\tvar tmp = r[4].split(\":\");\n\t\t\tvar thisHost = tmp[0];\n\t\t\tvar thisPort = tmp[1]||\"80\"; \/\/ FIXME: match 443\n\n\t\t\tr = this.url.match(new RegExp(regexp));\n\t\t\tif(r[4]){\n\t\t\t\ttmp = r[4].split(\":\");\n\t\t\t\tvar urlHost = tmp[0];\n\t\t\t\tvar urlPort = tmp[1]||\"80\";\n\t\t\t\tif(\t(urlHost != thisHost)||\n\t\t\t\t\t(urlPort != thisPort) ){\n\t\t\t\t\tdojo.debug(thisHost, urlHost);\n\t\t\t\t\tdojo.debug(thisPort, urlPort);\n\n\t\t\t\t\tthis.isXD = true;\n\t\t\t\t\tbindArgs.transport = \"ScriptSrcTransport\";\n\t\t\t\t\tbindArgs.jsonParamName = \"jsonp\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(bargs){\n\t\t\tdojo.lang.mixin(bindArgs, bargs);\n\t\t}\n\t\treturn dojo.io.bind(bindArgs);","this_variables":["url","isXD"]}}},"cometd.finishInit":{"_":{"meta":{"summary":"","parameters":{"type":{"type":""},"data":{"type":""},"evt":{"type":""},"request":{"type":""}},"src":"\t\tthis.handshakeReturn = data;\n\t\t\/\/ pick a transport\n\t\tif(data[\"authSuccessful\"] == false){\n\t\t\tdojo.debug(\"cometd authentication failed\");\n\t\t\treturn;\n\t\t}\n\t\tif(data.version < this.minimumVersion){\n\t\t\tdojo.debug(\"cometd protocol version mismatch. We wanted\", this.minimumVersion, \"but got\", data.version);\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport = this.connectionTypes.match(\n\t\t\tdata.supportedConnectionTypes,\n\t\t\tdata.version,\n\t\t\tthis.isXD\n\t\t);\n\t\tthis.currentTransport.version = data.version;\n\t\tthis.clientId = data.clientId;\n\t\tthis.tunnelInit = dojo.lang.hitch(this.currentTransport, \"tunnelInit\");\n\t\tthis.tunnelCollapse = dojo.lang.hitch(this.currentTransport, \"tunnelCollapse\");\n\t\tthis.initialized = true;\n\t\tthis.currentTransport.startup(data);\n\t\twhile(this.backlog.length != 0){\n\t\t\tvar cur = this.backlog.shift();\n\t\t\tvar fn = cur.shift();\n\t\t\tthis[fn].apply(this, cur);\n\t\t}","this_variables":["handshakeReturn","currentTransport","currentTransport.version","clientId","initialized"]}}},"cometd.getRandStr":{"_":{"meta":{"summary":"","src":"\t\treturn Math.random().toString().substring(2, 10);"}}},"cometd.deliver":{"_":{"meta":{"summary":"","parameters":{"messages":{"type":""}},"src":"\t\tdojo.lang.forEach(messages, this._deliver, this);"}}},"cometd._deliver":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""}},"src":"\t\t\tdojo.debug(\"cometd error: no channel for message!\");\n\t\t\treturn;\n\t\t}\n\t\tif(!this.currentTransport){\n\t\t\tthis.backlog.push([\"deliver\", message]);\n\t\t\treturn;\n\t\t}\n\t\tthis.lastMessage = message;\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.subscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/unsubscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd unsubscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.unsubscribed(message.subscription, message);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\/\/ send the message down for processing by the transport\n\t\tthis.currentTransport.deliver(message);\n\n\t\t\/\/ dispatch the message to any locally subscribed listeners\n\t\tvar tname = (this.globalTopicChannels[message.channel]) ? message.channel : \"\/cometd\"+message.channel;\n\t\tdojo.event.topic.publish(tname, message);","this_variables":["lastMessage"]}}},"cometd.disconnect":{"_":{"meta":{"summary":"","src":"\t\tif(!this.currentTransport){\n\t\t\tdojo.debug(\"no current transport to disconnect from\");\n\t\t\treturn;\n\t\t}\n\t\tthis.currentTransport.disconnect();"}}},"cometd.publish":{"_":{"meta":{"summary":" publishes the passed message to the cometd server for delivery on the specified topic","parameters":{"channel":{"type":"string"},"data":{"type":"object"},"properties":{"type":"object"}},"src":"\t\t\tthis.backlog.push([\"publish\", channel, data, properties]);\n\t\t\treturn;\n\t\t}\n\t\tvar message = {\n\t\t\tdata: data,\n\t\t\tchannel: channel\n\t\t};\n\t\tif(properties){\n\t\t\tdojo.lang.mixin(message, properties);\n\t\t}\n\t\treturn this.currentTransport.sendMessage(message);"}}},"cometd.subscribe":{"_":{"meta":{"summary":" inform the server of this client's interest in channel","parameters":{"channel":{"type":"string"},"useLocalTopics":{"type":"boolean, optional"},"objOrFunc":{"type":"object, optional"},"funcName":{"type":"string, optional"}},"src":"\t\t\tthis.backlog.push([\"subscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\tif(objOrFunc){\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tif(useLocalTopics){\n\t\t\t\tthis.globalTopicChannels[channel] = true;\n\t\t\t}\n\t\t\tdojo.event.topic.subscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\t\/\/ FIXME: would we handle queuing of the subscription if not connected?\n\t\t\/\/ Or should the transport object?\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/subscribe\",\n\t\t\tsubscription: channel\n\t\t});"}}},"cometd.subscribed":{"_":{"meta":{"summary":"","parameters":{"channel":{"type":"string"},"message":{"type":"obj"}},"src":"\t\tdojo.debug(channel);\n\t\tdojo.debugShallow(message);"}}},"cometd.unsubscribe":{"_":{"meta":{"summary":" inform the server of this client's disinterest in channel","parameters":{"channel":{"type":"string"},"useLocalTopics":{"type":"boolean, optional"},"objOrFunc":{"type":"object, optional"},"funcName":{"type":"string, optional"}},"src":"\t\t\tthis.backlog.push([\"unsubscribe\", channel, useLocalTopics, objOrFunc, funcName]);\n\t\t\treturn;\n\t\t}\n\t\t\/\/\t\ta callback function to notifiy upon channel message delivery\n\t\tif(objOrFunc){\n\t\t\t\/\/ FIXME: should actual local topic unsubscription be delayed for\n\t\t\t\/\/ successful unsubcribe notices from the other end? (guessing \"no\")\n\t\t\t\/\/ FIXME: if useLocalTopics is false, should we go ahead and\n\t\t\t\/\/ destroy the local topic?\n\t\t\tvar tname = (useLocalTopics) ? channel : \"\/cometd\"+channel;\n\t\t\tdojo.event.topic.unsubscribe(tname, objOrFunc, funcName);\n\t\t}\n\t\treturn this.currentTransport.sendMessage({\n\t\t\tchannel: \"\/meta\/unsubscribe\",\n\t\t\tsubscription: channel\n\t\t});"}}},"cometd.unsubscribed":{"_":{"meta":{"summary":"","parameters":{"channel":{"type":"string"},"message":{"type":"obj"}},"src":"\t\tdojo.debug(channel);\n\t\tdojo.debugShallow(message);"}}},"cometd.iframeTransport.check":{"_":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":"\t\treturn ((!xdomain)&&\n\t\t\t\t(!dojo.render.html.safari)&&\n\t\t\t\t(dojo.lang.inArray(types, \"iframe\")));"}}},"cometd.iframeTransport.tunnelInit":{"_":{"meta":{"summary":"","src":"\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"iframe\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});"}}},"cometd.iframeTransport.tunnelCollapse":{"_":{"meta":{"summary":"","src":"\t\tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\n\t\t\tthis.postToIframe({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","this_variables":["connected"]}}},"cometd.iframeTransport.deliver":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""}},"src":"\t\t\tthis.lastTimestamp = message.timestamp;\n\t\t}\n\t\tif(message[\"id\"]){\n\t\t\tthis.lastId = message.id;\n\t\t}\n\t\t\/\/ check to see if we got a \/meta channel message that we care about\n\t\tif(\t(message.channel.length > 5)&&\n\t\t\t(message.channel.substr(0, 5) == \"\/meta\")){\n\t\t\t\/\/ check for various meta topic actions that we need to respond to\n\t\t\tswitch(message.channel){\n\t\t\t\tcase \"\/meta\/connect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd connection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connectionId = message.connectionId;\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tthis.processBacklog();\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/reconnect\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd reconnection error:\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.connected = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"\/meta\/subscribe\":\n\t\t\t\t\tif(!message.successful){\n\t\t\t\t\t\tdojo.debug(\"cometd subscription error for channel\", message.channel, \":\", message.error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\/\/ this.subscribed(message.channel);\n\t\t\t\t\tdojo.debug(message.channel);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}","this_variables":["lastTimestamp","lastId","connectionId","connected"]}}},"cometd.iframeTransport.widenDomain":{"_":{"meta":{"summary":"","parameters":{"domainStr":{"type":""}},"src":"\t\tif(cd.indexOf(\".\")==-1){ return; } \/\/ probably file:\/\/\/ or localhost\n\t\tvar dps = cd.split(\".\");\n\t\tif(dps.length<=2){ return; } \/\/ probably file:\/\/\/ or an RFC 1918 address\n\t\tdps = dps.slice(dps.length-2);\n\t\tdocument.domain = dps.join(\".\");\n\t\treturn document.domain;","returns":"probably file:"}}},"cometd.iframeTransport.postToIframe":{"_":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":"\t\tif(!this.phonyForm){\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\tthis.phonyForm = document.createElement(\"<form enctype='application\/x-www-form-urlencoded' method='POST' style='display: none;'>\");\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t}else{\n\t\t\t\tthis.phonyForm = document.createElement(\"form\");\n\t\t\t\tthis.phonyForm.style.display = \"none\"; \/\/ FIXME: will this still work?\n\t\t\t\tdojo.body().appendChild(this.phonyForm);\n\t\t\t\tthis.phonyForm.enctype = \"application\/x-www-form-urlencoded\";\n\t\t\t\tthis.phonyForm.method = \"POST\";\n\t\t\t}\n\t\t}\n\n\t\tthis.phonyForm.action = url||cometd.url;\n\t\tthis.phonyForm.target = this.rcvNodeName;\n\t\tthis.phonyForm.setAttribute(\"target\", this.rcvNodeName);\n\n\t\twhile(this.phonyForm.firstChild){\n\t\t\tthis.phonyForm.removeChild(this.phonyForm.firstChild);\n\t\t}\n\n\t\tfor(var x in content){\n\t\t\tvar tn;\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\ttn = document.createElement(\"<input type='hidden' name='\"+x+\"' value='\"+content[x]+\"'>\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t}else{\n\t\t\t\ttn = document.createElement(\"input\");\n\t\t\t\tthis.phonyForm.appendChild(tn);\n\t\t\t\ttn.type = \"hidden\";\n\t\t\t\ttn.name = x;\n\t\t\t\ttn.value = content[x];\n\t\t\t}\n\t\t}\n\t\tthis.phonyForm.submit();","this_variables":["phonyForm","phonyForm.style.display","phonyForm.enctype","phonyForm.method","phonyForm.action","phonyForm.target"]}}},"cometd.iframeTransport.processBacklog":{"_":{"meta":{"summary":"","src":"\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}"}}},"cometd.iframeTransport.sendMessage":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":"\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\t\/\/ FIXME: we should be able to do better than this given that we're sending an array!\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}"}}},"cometd.iframeTransport.startup":{"_":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":"\t\tdojo.debug(\"startup!\");\n\t\tdojo.debug(dojo.json.serialize(handshakeData));\n\n\t\tif(this.connected){ return; }\n\n\t\t\/\/ this.widenDomain();\n\n\t\t\/\/ NOTE: we require the server to cooperate by hosting\n\t\t\/\/ cometdInit.html at the designated endpoint\n\t\tthis.rcvNodeName = \"cometdRcv_\"+cometd.getRandStr();\n\t\t\/\/ the \"forever frame\" approach\n\n\t\tvar initUrl = cometd.url+\"\/?tunnelInit=iframe\"; \/\/ &domain=\"+document.domain;\n\t\tif(false && dojo.render.html.ie){ \/\/ FIXME: DISALBED FOR NOW\n\t\t\t\/\/ use the \"htmlfile hack\" to prevent the background click junk\n\t\t\tthis.rcvNode = new ActiveXObject(\"htmlfile\");\n\t\t\tthis.rcvNode.open();\n\t\t\tthis.rcvNode.write(\"<html>\");\n\t\t\tthis.rcvNode.write(\"<script>document.domain = '\"+document.domain+\"'\");\n\t\t\tthis.rcvNode.write(\"<\/html>\");\n\t\t\tthis.rcvNode.close();\n\n\t\t\tvar ifrDiv = this.rcvNode.createElement(\"div\");\n\t\t\tthis.rcvNode.appendChild(ifrDiv);\n\t\t\tthis.rcvNode.parentWindow.dojo = dojo;\n\t\t\tifrDiv.innerHTML = \"<iframe src='\"+initUrl+\"'><\/iframe>\"\n\t\t}else{\n\t\t\tthis.rcvNode = dojo.io.createIFrame(this.rcvNodeName, \"\", initUrl);\n\t\t\t\/\/ dojo.io.setIFrameSrc(this.rcvNode, initUrl);\n\t\t\t\/\/ we're still waiting on the iframe to call back up to use and\n\t\t\t\/\/ advertise that it's been initialized via tunnelInit\n\t\t}","this_variables":["rcvNodeName","rcvNode","rcvNode.parentWindow.dojo"]}}},"cometd.mimeReplaceTransport.check":{"_":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":"\t\treturn ((!xdomain)&&\n\t\t\t\t(dojo.render.html.mozilla)&& \/\/ seems only Moz really supports this right now = (\n\t\t\t\t(dojo.lang.inArray(types, \"mime-message-block\")));"}}},"cometd.mimeReplaceTransport.tunnelInit":{"_":{"meta":{"summary":"","src":"\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"mime-message-block\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","this_variables":["connected"]}}},"cometd.mimeReplaceTransport.tunnelCollapse":{"_":{"meta":{"summary":"","src":"\t\tif(this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","this_variables":["connected"]}}},"cometd.mimeReplaceTransport.handleOnLoad":{"_":{"meta":{"summary":"","parameters":{"resp":{"type":""}},"src":"\t\tcometd.deliver(dojo.json.evalJson(this.xhr.responseText));"}}},"cometd.mimeReplaceTransport.openTunnelWith":{"_":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":"\t\tthis.xhr.multipart = true; \/\/ FIXME: do Opera and Safari support this flag?\n\t\tif(dojo.render.html.mozilla){\n\t\t\tthis.xhr.addEventListener(\"load\", dojo.lang.hitch(this, \"handleOnLoad\"), false);\n\t\t}else if(dojo.render.html.safari){\n\t\t\t\/\/ Blah. WebKit doesn't actually populate responseText and\/or responseXML. Useless.\n\t\t\tdojo.debug(\"Webkit is broken with multipart responses over XHR = (\");\n\t\t\tthis.xhr.onreadystatechange = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}else{\n\t\t\tthis.xhr.onload = dojo.lang.hitch(this, \"handleOnLoad\");\n\t\t}\n\t\tthis.xhr.open(\"POST\", (url||cometd.url), true); \/\/ async post\n\t\tthis.xhr.setRequestHeader(\"Content-Type\", \"application\/x-www-form-urlencoded\");\n\t\tdojo.debug(dojo.json.serialize(content));\n\t\tthis.xhr.send(dojo.io.argsFromMap(content, \"utf8\"));","this_variables":["xhr","xhr.multipart","xhr.onreadystatechange","xhr.onload"]}}},"cometd.mimeReplaceTransport.processBacklog":{"_":{"meta":{"summary":"","src":"\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}"}}},"cometd.mimeReplaceTransport.sendMessage":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":"\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"POST\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}"}}},"cometd.mimeReplaceTransport.startup":{"_":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":"\t\tdojo.debugShallow(handshakeData);\n\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();"}}},"cometd.longPollTransport.check":{"_":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":"\t\treturn ((!xdomain)&&(dojo.lang.inArray(types, \"long-polling\")));"}}},"cometd.longPollTransport.tunnelInit":{"_":{"meta":{"summary":"","src":"\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"long-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","this_variables":["connected"]}}},"cometd.longPollTransport.tunnelCollapse":{"_":{"meta":{"summary":"","src":"\t\tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tdojo.debug(\"clientId:\", cometd.clientId);\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","this_variables":["connected"]}}},"cometd.longPollTransport.openTunnelWith":{"_":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":"\t\tdojo.io.bind({\n\t\t\turl: (url||cometd.url),\n\t\t\tmethod: \"post\",\n\t\t\tcontent: content,\n\t\t\tmimetype: \"text\/json\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\t\/\/ dojo.debug(evt.responseText);\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;","this_variables":["connected"]}}},"cometd.longPollTransport.processBacklog":{"_":{"meta":{"summary":"","src":"\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}"}}},"cometd.longPollTransport.sendMessage":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":"\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\tmethod: \"post\",\n\t\t\t\tmimetype: \"text\/json\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}"}}},"cometd.longPollTransport.startup":{"_":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":"\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();"}}},"cometd.callbackPollTransport.check":{"_":{"meta":{"summary":"","parameters":{"types":{"type":""},"version":{"type":""},"xdomain":{"type":""}},"src":""}}},"cometd.callbackPollTransport.tunnelInit":{"_":{"meta":{"summary":"","src":"\t\tif(this.connected){ return; }\n\t\t\/\/ FIXME: open up the connection here\n\t\tthis.openTunnelWith({\n\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t{\n\t\t\t\t\tchannel:\t\"\/meta\/connect\",\n\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\tconnectionType: \"callback-polling\"\n\t\t\t\t\t\/\/ FIXME: auth not passed here!\n\t\t\t\t\t\/\/ \"authToken\": this.authToken\n\t\t\t\t}\n\t\t\t])\n\t\t});\n\t\tthis.connected = true;","this_variables":["connected"]}}},"cometd.callbackPollTransport.tunnelCollapse":{"_":{"meta":{"summary":"","src":"\t\tif(!this.connected){\n\t\t\t\/\/ try to restart the tunnel\n\t\t\tthis.connected = false;\n\t\t\tthis.openTunnelWith({\n\t\t\t\tmessage: dojo.json.serialize([\n\t\t\t\t\t{\n\t\t\t\t\t\tchannel:\t\"\/meta\/reconnect\",\n\t\t\t\t\t\tconnectionType: \"long-polling\",\n\t\t\t\t\t\tclientId:\tcometd.clientId,\n\t\t\t\t\t\tconnectionId:\tthis.connectionId,\n\t\t\t\t\t\ttimestamp:\tthis.lastTimestamp,\n\t\t\t\t\t\tid:\t\t\tthis.lastId\n\t\t\t\t\t\t\/\/ FIXME: no authToken provision!\n\t\t\t\t\t}\n\t\t\t\t])\n\t\t\t});\n\t\t}","this_variables":["connected"]}}},"cometd.callbackPollTransport.openTunnelWith":{"_":{"meta":{"summary":"","parameters":{"content":{"type":""},"url":{"type":""}},"src":"\t\t\turl: (url||cometd.url),\n\t\t\tcontent: content,\n\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\tjsonParamName: \"jsonp\",\n\t\t\tload: dojo.lang.hitch(this, function(type, data, evt, args){\n\t\t\t\tdojo.debug(dojo.json.serialize(data));\n\t\t\t\tcometd.deliver(data);\n\t\t\t\tthis.connected = false;\n\t\t\t\tthis.tunnelCollapse();\n\t\t\t}),\n\t\t\terror: function(){ dojo.debug(\"tunnel opening failed\"); }\n\t\t});\n\t\tthis.connected = true;","this_variables":["connected"]}}},"cometd.callbackPollTransport.processBacklog":{"_":{"meta":{"summary":"","src":"\t\twhile(this.backlog.length > 0){\n\t\t\tthis.sendMessage(this.backlog.shift(), true);\n\t\t}"}}},"cometd.callbackPollTransport.sendMessage":{"_":{"meta":{"summary":"","parameters":{"message":{"type":""},"bypassBacklog":{"type":""}},"src":"\t\t\tmessage.connectionId = this.connectionId;\n\t\t\tmessage.clientId = cometd.clientId;\n\t\t\tvar bindArgs = {\n\t\t\t\turl: cometd.url||djConfig[\"cometdRoot\"],\n\t\t\t\ttransport: \"ScriptSrcTransport\",\n\t\t\t\tjsonParamName: \"jsonp\",\n\t\t\t\tcontent: { message: dojo.json.serialize([ message ]) }\n\t\t\t};\n\t\t\treturn dojo.io.bind(bindArgs);\n\t\t}else{\n\t\t\tthis.backlog.push(message);\n\t\t}"}}},"cometd.callbackPollTransport.startup":{"_":{"meta":{"summary":"","parameters":{"handshakeData":{"type":""}},"src":"\t\tif(this.connected){ return; }\n\t\tthis.tunnelInit();"}}}}}},"dojo.io.cookie":{"meta":{"methods":{"dojo.io.cookie.setCookie":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""},"value":{"type":""},"days":{"type":""},"path":{"type":""},"domain":{"type":""},"secure":{"type":""}},"src":"\tvar expires = -1;\n\tif(typeof days == \"number\" && days >= 0) {\n\t\tvar d = new Date();\n\t\td.setTime(d.getTime()+(days*24*60*60*1000));\n\t\texpires = d.toGMTString();\n\t}\n\tvalue = escape(value);\n\tdocument.cookie = name + \"=\" + value + \";\"\n\t\t+ (expires != -1 ? \" expires=\" + expires + \";\" : \"\")\n\t\t+ (path ? \"path=\" + path : \"\")\n\t\t+ (domain ? \"; domain=\" + domain : \"\")\n\t\t+ (secure ? \"; secure\" : \"\");"}}},"dojo.io.cookie.getCookie":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""}},"src":"\tif(idx == -1) { return null; }\n\tvar value = document.cookie.substring(idx+name.length+1);\n\tvar end = value.indexOf(';');\n\tif(end == -1) { end = value.length; }\n\tvalue = value.substring(0, end);\n\tvalue = unescape(value);\n\treturn value;"}}},"dojo.io.cookie.deleteCookie":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""}},"src":"\tdojo.io.cookie.setCookie(name, \"-\", 0);"}}},"dojo.io.cookie.setObjectCookie":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""},"obj":{"type":""},"days":{"type":""},"path":{"type":""},"domain":{"type":""},"secure":{"type":""},"clearCurrent":{"type":""}},"src":"\tif(arguments.length == 5) {                        \n\t\tclearCurrent = domain;\n\t\tdomain = null;\n\t\tsecure = null;\n\t}\n\tvar pairs = [], cookie, value = \"\";\n\tif(!clearCurrent) { cookie = dojo.io.cookie.getObjectCookie(name); }\n\tif(days >= 0) {\n\t\tif(!cookie) { cookie = {}; }\n\t\tfor(var prop in obj) {\n\t\t\tif(prop == null) {\n\t\t\t\tdelete cookie[prop];\n\t\t\t} else if(typeof obj[prop] == \"string\" || typeof obj[prop] == \"number\") {\n\t\t\t\tcookie[prop] = obj[prop];\n\t\t\t}\n\t\t}\n\t\tprop = null;\n\t\tfor(var prop in cookie) {\n\t\t\tpairs.push(escape(prop) + \"=\" + escape(cookie[prop]));\n\t\t}\n\t\tvalue = pairs.join(\"&\");\n\t}\n\tdojo.io.cookie.setCookie(name, value, days, path, domain, secure);"}}},"dojo.io.cookie.getObjectCookie":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""}},"src":"\tvar values = null, cookie = dojo.io.cookie.getCookie(name);\n\tif(cookie) {\n\t\tvalues = {};\n\t\tvar pairs = cookie.split(\"&\");\n\t\tfor(var i = 0; i < pairs.length; i++) {\n\t\t\tvar pair = pairs[i].split(\"=\");\n\t\t\tvar value = pair[1];\n\t\t\tif( isNaN(value) ) { value = unescape(pair[1]); }\n\t\t\tvalues[ unescape(pair[0]) ] = value;\n\t\t}\n\t}\n\treturn values;"}}},"dojo.io.cookie.isSupported":{"_":{"meta":{"summary":"","src":"\tif(typeof navigator.cookieEnabled != \"boolean\") {\n\t\tdojo.io.cookie.setCookie(\"__TestingYourBrowserForCookieSupport__\",\n\t\t\t\"CookiesAllowed\", 90, null);\n\t\tvar cookieVal = dojo.io.cookie.getCookie(\"__TestingYourBrowserForCookieSupport__\");\n\t\tnavigator.cookieEnabled = (cookieVal == \"CookiesAllowed\");\n\t\tif(navigator.cookieEnabled) {\n\t\t\t\/\/ FIXME: should we leave this around?\n\t\t\tthis.deleteCookie(\"__TestingYourBrowserForCookieSupport__\");\n\t\t}\n\t}\n\treturn navigator.cookieEnabled;"}}}}}},"dojo.io":{"meta":{"requires":{"common":["dojo.string","dojo.lang.extras"]},"methods":{"dojo.io.Request":{"_":{"meta":{"summary":"","parameters":{"url":{"type":""},"mimetype":{"type":""},"transport":{"type":""},"changeUrl":{"type":""}},"src":"\tif((arguments.length == 1)&&(arguments[0].constructor == Object)){\n\t\tthis.fromKwArgs(arguments[0]);\n\t}else{\n\t\tthis.url = url;\n\t\tif(mimetype){ this.mimetype = mimetype; }\n\t\tif(transport){ this.transport = transport; }\n\t\tif(arguments.length >= 4){ this.changeUrl = changeUrl; }\n\t}","this_variables":["url","mimetype","transport","changeUrl"],"protovariables":{"url":"","mimetype":"","method":"","content":"","transport":"","changeUrl":"","formNode":"","sync":"","bindSuccess":"","useCache":"","preventCache":"","timeoutSeconds":""}}}},"dojo.io.Error":{"_":{"meta":{"summary":"","parameters":{"msg":{"type":""},"type":{"type":""},"num":{"type":""}},"src":"\tthis.message = msg;\n\tthis.type =  type || \"unknown\"; \/\/ must be one of \"io\", \"parse\", \"unknown\"\n\tthis.number = num || 0; \/\/ per-substrate error number, not normalized","this_variables":["message","type","number"]}}},"dojo.io.transports.addTransport":{"_":{"meta":{"summary":"","parameters":{"name":{"type":""}},"src":"\tthis.push(name);\n\t\/\/ FIXME: do we need to handle things that aren't direct children of the\n\t\/\/ dojo.io namespace? (say, dojo.io.foo.fooTransport?)\n\tthis[name] = dojo.io[name];"}}},"dojo.io.bind":{"_":{"meta":{"summary":"","parameters":{"request":{"type":""}},"src":"\t\ttry{\n\t\t\trequest = new dojo.io.Request(request);\n\t\t}catch(e){ dojo.debug(e); }\n\t}\n\tvar tsName = \"\";\n\tif(request[\"transport\"]){\n\t\ttsName = request[\"transport\"];\n\t\t\/\/ FIXME: it would be good to call the error handler, although we'd\n\t\t\/\/ need to use setTimeout or similar to accomplish this and we can't\n\t\t\/\/ garuntee that this facility is available.\n\t\tif(!this[tsName]){ return request; }\n\t}else{\n\t\t\/\/ otherwise we do our best to auto-detect what available transports\n\t\t\/\/ will handle \n\t\tfor(var x=0; x<dojo.io.transports.length; x++){\n\t\t\tvar tmp = dojo.io.transports[x];\n\t\t\tif((this[tmp])&&(this[tmp].canHandle(request))){\n\t\t\t\ttsName = tmp;\n\t\t\t}\n\t\t}\n\t\tif(tsName == \"\"){ return request; }\n\t}\n\tthis[tsName].bind(request);\n\trequest.bindSuccess = true;\n\treturn request;"}}},"dojo.io.queueBind":{"_":{"meta":{"summary":"","parameters":{"request":{"type":""}},"src":"\tif(!(request instanceof dojo.io.Request)){\n\t\ttry{\n\t\t\trequest = new dojo.io.Request(request);\n\t\t}catch(e){ dojo.debug(e); }\n\t}\n\n\t\/\/ make sure we get called if\/when we get a response\n\tvar oldLoad = request.load;\n\trequest.load = function(){\n\t\tdojo.io._queueBindInFlight = false;\n\t\tvar ret = oldLoad.apply(this, arguments);\n\t\tdojo.io._dispatchNextQueueBind();\n\t\treturn ret;\n\t}\n\n\tvar oldErr = request.error;\n\trequest.error = function(){\n\t\tdojo.io._queueBindInFlight = false;\n\t\tvar ret = oldErr.apply(this, arguments);\n\t\tdojo.io._dispatchNextQueueBind();\n\t\treturn ret;\n\t}\n\n\tdojo.io._bindQueue.push(request);\n\tdojo.io._dispatchNextQueueBind();\n\treturn request;"}}},"dojo.io._dispatchNextQueueBind":{"_":{"meta":{"summary":"","src":"\tif(!dojo.io._queueBindInFlight){\n\t\tdojo.io._queueBindInFlight = true;\n\t\tif(dojo.io._bindQueue.length > 0){\n\t\t\tdojo.io.bind(dojo.io._bindQueue.shift());\n\t\t}else{\n\t\t\tdojo.io._queueBindInFlight = false;\n\t\t}\n\t}"}}},"dojo.io.argsFromMap":{"_":{"meta":{"summary":"","parameters":{"map":{"type":""},"encoding":{"type":""},"last":{"type":""}},"src":"\tvar enc = \/utf\/i.test(encoding||\"\") ? encodeURIComponent : dojo.string.encodeAscii;\n\tvar mapped = [];\n\tvar control = new Object();\n\tfor(var name in map){\n\t\tvar domap = function(elt){\n\t\t\tvar val = enc(name)+\"=\"+enc(elt);\n\t\t\tmapped[(last == name) ? \"push\" : \"unshift\"](val);\n\t\t}\n\t\tif(!control[name]){\n\t\t\tvar value = map[name];\n\t\t\t\/\/ FIXME: should be isArrayLike?\n\t\t\tif (dojo.lang.isArray(value)){\n\t\t\t\tdojo.lang.forEach(value, domap);\n\t\t\t}else{\n\t\t\t\tdomap(value);\n\t\t\t}\n\t\t}\n\t}\n\treturn mapped.join(\"&\");"}}},"dojo.io.setIFrameSrc":{"_":{"meta":{"summary":"","parameters":{"iframe":{"type":""},"src":{"type":""},"replace":{"type":""}},"src":"\ttry{\n\t\tvar r = dojo.render.html;\n\t\t\/\/ dojo.debug(iframe);\n\t\tif(!replace){\n\t\t\tif(r.safari){\n\t\t\t\tiframe.location = src;\n\t\t\t}else{\n\t\t\t\tframes[iframe.name].location = src;\n\t\t\t}\n\t\t}else{\n\t\t\t\/\/ Fun with DOM 0 incompatibilities!\n\t\t\tvar idoc;\n\t\t\tif(r.ie){\n\t\t\t\tidoc = iframe.contentWindow.document;\n\t\t\t}else if(r.safari){\n\t\t\t\tidoc = iframe.document;\n\t\t\t}else{ \/\/  if(r.moz){\n\t\t\t\tidoc = iframe.contentWindow;\n\t\t\t}\n\n\t\t\t\/\/For Safari (at least 2.0.3) and Opera, if the iframe\n\t\t\t\/\/has just been created but it doesn't have content\n\t\t\t\/\/yet, then iframe.document may be null. In that case,\n\t\t\t\/\/use iframe.location and return.\n\t\t\tif(!idoc){\n\t\t\t\tiframe.location = src;\n\t\t\t\treturn;\n\t\t\t}else{\n\t\t\t\tidoc.location.replace(src);\n\t\t\t}\n\t\t}\n\t}catch(e){ \n\t\tdojo.debug(e); \n\t\tdojo.debug(\"setIFrameSrc: \"+e); \n\t}"}}},"dojo.io.Request.load":{"_":{"meta":{"summary":"","parameters":{"type":{"type":""},"data":{"type":""},"evt":{"type":""}},"src":"","this":"dojo.io.Request"}}},"dojo.io.Request.error":{"_":{"meta":{"summary":"","parameters":{"type":{"type":""},"error":{"type":""}},"src":"","this":"dojo.io.Request"}}},"dojo.io.Request.timeout":{"_":{"meta":{"summary":"","parameters":{"type":{"type":""}},"src":"","this":"dojo.io.Request"}}},"dojo.io.Request.handle":{"_":{"meta":{"summary":"","src":"","this":"dojo.io.Request"}}},"dojo.io.Request.abort":{"_":{"meta":{"summary":"","src":"","this":"dojo.io.Request"}}},"dojo.io.Request.fromKwArgs":{"_":{"meta":{"summary":"","parameters":{"kwArgs":{"type":""}},"src":"\t\tif(kwArgs[\"formNode\"]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }\n\t\tif(!kwArgs[\"method\"] && kwArgs[\"formNode\"] && kwArgs[\"formNode\"].method) {\n\t\t\tkwArgs.method = kwArgs[\"formNode\"].method;\n\t\t}\n\t\t\n\t\t\/\/ backwards compatibility\n\t\tif(!kwArgs[\"handle\"] && kwArgs[\"handler\"]){ kwArgs.handle = kwArgs.handler; }\n\t\tif(!kwArgs[\"load\"] && kwArgs[\"loaded\"]){ kwArgs.load = kwArgs.loaded; }\n\t\tif(!kwArgs[\"changeUrl\"] && kwArgs[\"changeURL\"]) { kwArgs.changeUrl = kwArgs.changeURL; }\n\n\t\t\/\/ encoding fun!\n\t\tkwArgs.encoding = dojo.lang.firstValued(kwArgs[\"encoding\"], djConfig[\"bindEncoding\"], \"\");\n\n\t\tkwArgs.sendTransport = dojo.lang.firstValued(kwArgs[\"sendTransport\"], djConfig[\"ioSendTransport\"], false);\n\n\t\tvar isFunction = dojo.lang.isFunction;\n\t\tfor(var x=0; x<dojo.io.hdlrFuncNames.length; x++){\n\t\t\tvar fn = dojo.io.hdlrFuncNames[x];\n\t\t\tif(kwArgs[fn] && isFunction(kwArgs[fn])){ continue; }\n\t\t\tif(kwArgs[\"handle\"] && isFunction(kwArgs[\"handle\"])){\n\t\t\t\tkwArgs[fn] = kwArgs.handle;\n\t\t\t}\n\t\t\t\/\/ handler is aliased above, shouldn't need this check\n\t\t\t\/* else if(dojo.lang.isObject(kwArgs.handler)){\n\t\t\t\tif(isFunction(kwArgs.handler[fn])){\n\t\t\t\t\tkwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler[\"handle\"]||function(){};\n\t\t\t\t}\n\t\t\t}*\/\n\t\t}\n\t\tdojo.lang.mixin(this, kwArgs);","this":"dojo.io.Request"}}}}}}}