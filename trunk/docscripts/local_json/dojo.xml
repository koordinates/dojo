{"dojo.xml.Parse":{"meta":{"requires":{"common":["dojo.dom"]},"methods":{"dojo.xml.Parse":{"_":{"meta":{"summary":"","src":"\tfunction getDojoTagName(node){\n\t\tvar tagName = node.tagName;\n\t\tif(dojo.render.html.capable && dojo.render.html.ie && node.scopeName != 'HTML'){\n\t\t\ttagName = node.scopeName + ':' + tagName;\n\t\t}\n\t\tif(tagName.substr(0,5).toLowerCase() == \"dojo:\"){\n\t\t\treturn tagName.toLowerCase();\n\t\t}\n\n\t\tif(tagName.substr(0,4).toLowerCase() == \"dojo\"){\n\t\t\t\/\/ FIXME: this assumes tag names are always lower case\n\t\t\treturn \"dojo:\" + tagName.substring(4).toLowerCase();\n\t\t}\n\n\t\t\/\/ allow lower-casing\n\t\tvar djt = node.getAttribute(\"dojoType\") || node.getAttribute(\"dojotype\");\n\t\tif(djt){\n\t\t\tif(djt.indexOf(\":\")<0){\n\t\t\t\tdjt = \"dojo:\"+djt;\n\t\t\t}\n\t\t\treturn djt.toLowerCase();\n\t\t}\n\t\t\n\t\tif(node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,\"type\")){\n\t\t\treturn \"dojo:\" + node.getAttributeNS(dojo.dom.dojoml,\"type\").toLowerCase();\n\t\t}\n\t\ttry{\n\t\t\t\/\/ FIXME: IE really really doesn't like this, so we squelch errors for it\n\t\t\tdjt = node.getAttribute(\"dojo:type\");\n\t\t}catch(e){ \/* FIXME: log? *\/ }\n\n\t\tif(djt){ return \"dojo:\"+djt.toLowerCase(); }\n\t\n\t\tif(!dj_global[\"djConfig\"] || !djConfig[\"ignoreClassNames\"]){ \n\t\t\t\/\/ FIXME: should we make this optionally enabled via djConfig?\n\t\t\tvar classes = node.className||node.getAttribute(\"class\");\n\t\t\t\/\/ FIXME: following line, without check for existence of classes.indexOf\n\t\t\t\/\/ breaks firefox 1.5's svg widgets\n\t\t\tif(classes && classes.indexOf && classes.indexOf(\"dojo-\") != -1){\n\t\t\t    var aclasses = classes.split (\" \");\n\t\t\t    for(var x=0; x<aclasses.length; x++){\n\t\t\t        if(aclasses[x].length > 5 && aclasses[x].indexOf(\"dojo-\") >= 0){\n\t\t\t            return \"dojo:\"+aclasses[x].substr(5).toLowerCase(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tagName.toLowerCase();\n\t}\n\n\tthis.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){\n\n\t\tvar parsedNodeSet = {};\n\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(node.tagName && node.tagName.indexOf(\"\/\") == 0){\n\t\t\treturn null;\n\t\t}\n\n\t\tvar tagName = getDojoTagName(node);\n\t\tparsedNodeSet[tagName] = [];\n\t\tif(tagName.substr(0,4).toLowerCase()==\"dojo\"){\n\t\t\tparsedNodeSet.namespace = \"dojo\";\n\t\t}else{\n\t\t\tvar pos = tagName.indexOf(\":\");\n\t\t\tif(pos > 0){\n\t\t\t    parsedNodeSet.namespace = tagName.substring(0,pos);\n\t\t\t}\n\t\t}\n\n\t\tvar process = false;\n\t\tif(!optimizeForDojoML){process=true;}\n\t\telse if(parsedNodeSet.namespace&&dojo.getNamespace(parsedNodeSet.namespace)){process=true;}\n\t\telse if(dojo.widget.tags[tagName]){\n\t\t\tdojo.deprecated('dojo.xml.Parse.parseElement', 'Widgets should be placed in a defined namespace', \"0.5\");\n\t\t\tprocess = true;\t\n\t\t}\n\t\t\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t\t\/\/    dojo.debug(\"parseElement: set the element tagName = \"+parsedNodeSet.tagName+\" and namespace to \"+parsedNodeSet.namespace);\n\t\t}\n\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;\n\t};\n\n\t\/* parses a set of attributes on a node into an object tree *\/\n\tthis.parseAttributes = function(node){\n\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif((dojo.render.html.capable)&&(dojo.render.html.ie)){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif(\t(typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\t\t\t\t\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;\n\t};","this_variables":["parseElement","parseAttributes"]}}},"dojo.xml.Parse.parseElement":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"hasParentNodeSet":{"type":""},"optimizeForDojoML":{"type":""},"thisIdx":{"type":""}},"src":"\t\tvar parsedNodeSet = {};\n\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(node.tagName && node.tagName.indexOf(\"\/\") == 0){\n\t\t\treturn null;\n\t\t}\n\n\t\tvar tagName = getDojoTagName(node);\n\t\tparsedNodeSet[tagName] = [];\n\t\tif(tagName.substr(0,4).toLowerCase()==\"dojo\"){\n\t\t\tparsedNodeSet.namespace = \"dojo\";\n\t\t}else{\n\t\t\tvar pos = tagName.indexOf(\":\");\n\t\t\tif(pos > 0){\n\t\t\t    parsedNodeSet.namespace = tagName.substring(0,pos);\n\t\t\t}\n\t\t}\n\n\t\tvar process = false;\n\t\tif(!optimizeForDojoML){process=true;}\n\t\telse if(parsedNodeSet.namespace&&dojo.getNamespace(parsedNodeSet.namespace)){process=true;}\n\t\telse if(dojo.widget.tags[tagName]){\n\t\t\tdojo.deprecated('dojo.xml.Parse.parseElement', 'Widgets should be placed in a defined namespace', \"0.5\");\n\t\t\tprocess = true;\t\n\t\t}\n\t\t\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t\t\/\/    dojo.debug(\"parseElement: set the element tagName = \"+parsedNodeSet.tagName+\" and namespace to \"+parsedNodeSet.namespace);\n\t\t}\n\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;"}}},"dojo.xml.Parse.parseAttributes":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif((dojo.render.html.capable)&&(dojo.render.html.ie)){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif(\t(typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\t\t\t\t\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;"}}}}}},"dojo.xml._":{"meta":{"requires":{"common":["dojo.dom"],"browser":["dojo.html.*"],"dashboard":["dojo.html.*"],"svg":["dojo.xml.svgUtil"]}}},"dojo.xml.svgUtil":{"meta":{"methods":{"dojo.xml.svgUtil.getInnerWidth":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\t\/\/ FIXME: need to find out from dylan how to "}}},"dojo.xml.svgUtil.getOuterWidth":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}},"dojo.xml.svgUtil.getInnerHeight":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}},"dojo.xml.svgUtil.getOuterHeight":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}}}}}}