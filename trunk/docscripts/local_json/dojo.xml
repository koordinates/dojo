{"dojo.xml.Parse":{"meta":{"requires":{"common":["dojo.dom"]},"functions":{"dojo.xml.Parse":{"_":{"meta":{"summary":"","src":"\t\treturn ((node)&&(node.tagName) ? node.tagName.toLowerCase() : '');\n\t}\n\n\t\/\/ locate dojo qualified tag name\n\t\/\/ FIXME: add rejection test against namespace filters declared in djConfig\n\tfunction getDojoTagName(node){\n\t\tvar tagName = getTagName(node);\n\t\tif (!tagName){\n\t\t\t\treturn '';\n\t\t}\n\t\t\/\/ any registered tag\n\t\tif((dojo.widget)&&(dojo.widget.tags[tagName])){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <prefix:tag> => prefix:tag\n\t\tvar p = tagName.indexOf(\":\");\n\t\tif(p>=0){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <dojo:tag> => dojo:tag\n\t\tif(tagName.substr(0,5) == \"dojo:\"){\n\t\t\treturn tagName;\n\t\t}\n\t\tif(dojo.render.html.capable && dojo.render.html.ie && node.scopeName != 'HTML'){\n\t\t\treturn node.scopeName.toLowerCase() + ':' + tagName;\n\t\t}\n\t\t\/\/ <dojoTag> => dojo:tag\n\t\tif(tagName.substr(0,4) == \"dojo\"){\n\t\t\t\/\/ FIXME: this assumes tag names are always lower case\n\t\t\treturn \"dojo:\" + tagName.substring(4);\n\t\t}\n\t\t\/\/ <tag dojoType=\"prefix:type\"> => prefix:type\n\t\t\/\/ <tag dojoType=\"type\"> => dojo:type\n\t\tvar djt = node.getAttribute(\"dojoType\") || node.getAttribute(\"dojotype\");\n\t\tif(djt){\n\t\t\tif (djt.indexOf(\":\")<0){\n\t\t\t\tdjt = \"dojo:\"+djt;\n\t\t\t}\n\t\t\treturn djt.toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\tif((node.getAttributeNS)&&(node.getAttributeNS(dojo.dom.dojoml,\"type\"))){\n\t\t\treturn \"dojo:\" + node.getAttributeNS(dojo.dom.dojoml,\"type\").toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\ttry{\n\t\t\t\/\/ FIXME: IE really really doesn't like this, so we squelch errors for it\n\t\t\tdjt = node.getAttribute(\"dojo:type\").toLowerCase();\n\t\t}catch(e){ \n\t\t\t\/\/ FIXME: log?  \n\t\t}\n\t\tif(djt){ return \"dojo:\"+djt; }\n\t\t\/\/ <tag class=\"classa dojo-type classb\"> => dojo:type\t\n\t\tif(!dj_global[\"djConfig\"] || !djConfig[\"ignoreClassNames\"]){ \n\t\t\t\/\/ FIXME: should we make this optionally enabled via djConfig?\n\t\t\tvar classes = node.className||node.getAttribute(\"class\");\n\t\t\t\/\/ FIXME: following line, without check for existence of classes.indexOf\n\t\t\t\/\/ breaks firefox 1.5's svg widgets\n\t\t\tif(classes && classes.indexOf && classes.indexOf(\"dojo-\") != -1){\n\t\t    var aclasses = classes.split(\" \");\n\t\t    for(var x=0, c; x<aclasses.length; x++){\n\t        if (aclasses[x].slice(0, 5) == \"dojo-\") {\n            return \"dojo:\"+aclasses[x].substr(5).toLowerCase(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ no dojo-qualified name\n\t\treturn '';\n\t}\n\n\tthis.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){\n\n\t\tvar parsedNodeSet = {};\n\t\t\n\t\tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif((tagName)&&(tagName.indexOf(\"\/\")==0)){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"namespace\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo[\"namespace\"])&&(!dojo[\"namespace\"].allow(ns))){process=false;}\n\t\t}\n\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t\t\/\/dojo.debug(\"parseElement: set the element tagName = \"+parsedNodeSet.tagName+\" and namespace to \"+parsedNodeSet[\"namespace\"]);\n\t\t}\n\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;\n\t};\n\n\t\/* parses a set of attributes on a node into an object tree *\/\n\tthis.parseAttributes = function(node){\n\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif((dojo.render.html.capable)&&(dojo.render.html.ie)){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif(\t(typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\t\t\t\t\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;\n\t};","this_variables":["parseElement","parseAttributes"]}}},"dojo.xml.Parse.parseElement":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""},"hasParentNodeSet":{"type":""},"optimizeForDojoML":{"type":""},"thisIdx":{"type":""}},"src":"\t\tvar parsedNodeSet = {};\n\t\t\n\t\tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif((tagName)&&(tagName.indexOf(\"\/\")==0)){\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"namespace\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo[\"namespace\"])&&(!dojo[\"namespace\"].allow(ns))){process=false;}\n\t\t}\n\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t\t\/\/dojo.debug(\"parseElement: set the element tagName = \"+parsedNodeSet.tagName+\" and namespace to \"+parsedNodeSet[\"namespace\"]);\n\t\t}\n\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;"}}},"dojo.xml.Parse.parseAttributes":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif((dojo.render.html.capable)&&(dojo.render.html.ie)){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif(\t(typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\t\t\t\t\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;"}}}}}},"dojo.xml._":{"meta":{"requires":{"common":["dojo.dom"],"browser":["dojo.html.*"],"dashboard":["dojo.html.*"],"svg":["dojo.xml.svgUtil"]}}},"dojo.xml.svgUtil":{"meta":{"functions":{"dojo.xml.svgUtil.getInnerWidth":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\t\/\/ FIXME: need to find out from dylan how to "}}},"dojo.xml.svgUtil.getOuterWidth":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}},"dojo.xml.svgUtil.getInnerHeight":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}},"dojo.xml.svgUtil.getOuterHeight":{"_":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":""}}}}}}}