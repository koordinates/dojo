{"dojo.loader_xd":{"meta":{"functions":{"dojo.hostenv.resetXd":{"meta":{"summary":"","src":" this.isXDomain = djConfig.forceXDomain || false;\n\tthis.xdTimer = 0;\n\tthis.xdInFlight = {};\n\tthis.xdOrderedReqs = [];\n\tthis.xdDepMap = {};\n\tthis.xdContents = [];","instance_variables":["isXDomain","xdTimer","xdInFlight","xdOrderedReqs","xdDepMap","xdContents"]}},"dojo.hostenv.createXdPackage":{"meta":{"summary":"","parameters":{"contents":{"type":""}},"src":" var deps = [];\n    var depRegExp = \/dojo.(require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\\.conditionalLoadModule|.hostenv\\.loadModule|hostenv\\.moduleLoaded)\\(([\\w\\W]*?)\\)\/mg;\n    var match;\n\twhile((match = depRegExp.exec(contents)) != null){\n\t\tdeps.push(\"\\\"\" + match[1] + \"\\\", \" + match[2]);\n\t}\n\t\/\/Create package object and the call to packageLoaded.\n\tvar output = [];\n\toutput.push(\"dojo.hostenv.packageLoaded({\\n\");\n\t\/\/Add dependencies\n\tif(deps.length > 0){\n\t\toutput.push(\"depends: [\");\n\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\tif(i > 0){\n\t\t\t\toutput.push(\",\\n\");\n\t\t\t}\n\t\t\toutput.push(\"[\" + deps[i] + \"]\");\n\t\t}\n\t\toutput.push(\"],\");\n\t}\n\t\/\/Add the contents of the file inside a function.\n\t\/\/Pass in dojo as an argument to the function to help with\n\t\/\/allowing multiple versions of dojo in a page.\n\toutput.push(\"\\ndefinePackage: function(dojo){\");\n\toutput.push(contents);\n\toutput.push(\"\\n}});\");\n\treturn output.join(\"\");"}},"dojo.hostenv.loadPath":{"meta":{"summary":"","parameters":{"relpath":{"type":""},"module":{"type":"optional"},"cb":{"type":"optional"}},"src":" var colonIndex = relpath.indexOf(\":\");\n\tvar slashIndex = relpath.indexOf(\"\/\");\n\tvar uri;\n\tvar currentIsXDomain = false;\n\tif(colonIndex > 0 && colonIndex < slashIndex){\n\t\turi = relpath;\n\t\tthis.isXDomain = currentIsXDomain = true;\n\t}else{\n\t\turi = this.getBaseScriptUri() + relpath;\n\t\t\/\/Is ithe base script URI-based URL a cross domain URL?\n\t\tcolonIndex = uri.indexOf(\":\");\n\t\tslashIndex = uri.indexOf(\"\/\");\n\t\tif(colonIndex > 0 && colonIndex < slashIndex && (!location.host || uri.indexOf(\"http:\/\/\" + location.host) != 0)){\n\t\t\tthis.isXDomain = currentIsXDomain = true;\n\t\t}\n\t}\n\tif(djConfig.cacheBust && dojo.render.html.capable) { uri += \"?\" + String(djConfig.cacheBust).replace(\/\\W+\/g,\"\"); }\n\ttry{\n\t\treturn ((!module || this.isXDomain) ? this.loadUri(uri, cb, currentIsXDomain, module) : this.loadUriAndCheck(uri, module, cb));\n\t}catch(e){\n\t\tdojo.debug(e);\n\t\treturn false;\n\t}","instance_variables":["isXDomain"]}},"dojo.hostenv.loadUri":{"meta":{"summary":"","parameters":{"uri":{"type":""},"cb":{"type":""},"currentIsXDomain":{"type":""},"module":{"type":""}},"src":" if(this.loadedUris[uri]){\n\t\treturn 1;\n\t}\n\t\/\/Add the module (package) to the list of modules.\n\tif(this.isXDomain){\n\t\t\/\/Curious: is this array going to get whacked with multiple access since scripts\n\t\t\/\/load asynchronously and may be accessing the array at the same time?\n\t\t\/\/JS is single-threaded supposedly, so it should be ok. And we don't need\n\t\t\/\/a precise ordering.\n\t\tthis.xdOrderedReqs.push(module);\n\t\t\/\/Add to waiting packages.\n\t\t\/\/If this is a __package__.js file, then this must be\n\t\t\/\/a package.* request (since xdomain can only work with the first\n\t\t\/\/path in a package search list. However, .* module names are not\n\t\t\/\/passed to this function, so do an adjustment here.\n\t\tif(uri.indexOf(\"__package__\") != -1){\n\t\t\tmodule += \".*\";\n\t\t}\n\t\tthis.xdInFlight[module] = true;\n\t\t\/\/Increment inFlightCount\n\t\t\/\/This will stop the modulesLoaded from firing all the way.\n\t\tthis.inFlightCount++;\n\t\t\/\/Start timer\n\t\tif(!this.xdTimer){\n\t\t\tthis.xdTimer = setInterval(\"dojo.hostenv.watchInFlightXDomain();\", 100);\n\t\t}\n\t\tthis.xdStartTime = (new Date()).getTime();\n\t}\n\tif (currentIsXDomain){\n\t\t\/\/Fix name to be a .xd.fileextension name.\n\t\tvar lastIndex = uri.lastIndexOf('.');\n\t\tif(lastIndex <= 0){\n\t\t\tlastIndex = uri.length - 1;\n\t\t}\n\t\tvar xdUri = uri.substring(0, lastIndex) + \".xd\";\n\t\tif(lastIndex != uri.length - 1){\n\t\t\txdUri += uri.substring(lastIndex, uri.length);\n\t\t}\n\t\t\/\/Add to script src\n\t\tvar element = document.createElement(\"script\");\n\t\telement.type = \"text\/javascript\";\n\t\telement.src = xdUri;\n\t\tif(!this.headElement){\n\t\t\tthis.headElement = document.getElementsByTagName(\"head\")[0];\n\t\t}\n\t\tthis.headElement.appendChild(element);\n\t}else{\n\t\tvar contents = this.getText(uri, null, true);\n\t\tif(contents == null){ return 0; }\n\t\tif(this.isXDomain){\n\t\t\tvar pkg = this.createXdPackage(contents);\n\t\t\tdj_eval(pkg);\n\t\t}else{\n\t\t\tif(cb){ contents = '('+contents+')'; }\n\t\t\tvar value = dj_eval(contents);\n\t\t\tif(cb){\n\t\t\t\tcb(value);\n\t\t\t}\n\t\t}\n\t}\n\t\/\/These steps are done in the non-xd loader version of this function.\n\t\/\/Maintain these steps to fit in with the existing system.\n\tthis.loadedUris[uri] = true;\n\treturn 1;","instance_variables":["xdTimer","xdStartTime","headElement"]}},"dojo.hostenv.packageLoaded":{"meta":{"summary":"","parameters":{"pkg":{"type":""}},"src":" var deps = pkg.depends;\n\tvar requireList = null;\n\tvar requireAfterList = null;\n\tvar provideList = [];\n\tif(deps && deps.length > 0){\n\t\tvar dep = null;\n\t\tvar insertHint = 0;\n\t\tvar attachedPackage = false;\n\t\tfor(var i = 0; i < deps.length; i++){\n\t\t\tdep = deps[i];\n\t\t\t\/\/Look for specific dependency indicators.\n\t\t\tif (dep[0] == \"provide\" || dep[0] == \"hostenv.moduleLoaded\"){\n\t\t\t\tprovideList.push(dep[1]);\n\t\t\t}else{\n\t\t\t\tif(!requireList){\n\t\t\t\t\trequireList = [];\n\t\t\t\t}\n\t\t\t\tif(!requireAfterList){\n\t\t\t\t\trequireAfterList = [];\n\t\t\t\t}\n\t\t\t\tvar unpackedDeps = this.unpackXdDependency(dep);\n\t\t\t\tif(unpackedDeps.requires){\n\t\t\t\t\trequireList = requireList.concat(unpackedDeps.requires);\n\t\t\t\t}\n\t\t\t\tif(unpackedDeps.requiresAfter){\n\t\t\t\t\trequireAfterList = requireAfterList.concat(unpackedDeps.requiresAfter);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/Call the dependency indicator to allow for the normal dojo setup.\n\t\t\t\/\/Only allow for one dot reference, for the hostenv.* type calls.\n\t\t\tvar depType = dep[0];\n\t\t\tvar objPath = depType.split(\".\");\n\t\t\tif(objPath.length == 2){\n\t\t\t\tdojo[objPath[0]][objPath[1]].apply(dojo[objPath[0]], dep.slice(1));\n\t\t\t}else{\n\t\t\t\tdojo[depType].apply(dojo, dep.slice(1));\n\t\t\t}\n\t\t}\n\t\t\/\/Save off the package contents for definition later.\n\t\tvar contentIndex = this.xdContents.push({content: pkg.definePackage, isDefined: false}) - 1;\n\t\t\/\/Add provide\/requires to dependency map.\n\t\tfor(var i = 0; i < provideList.length; i++){\n\t\t\tthis.xdDepMap[provideList[i]] = { requires: requireList, requiresAfter: requireAfterList, contentIndex: contentIndex };\n\t\t}\n\t\t\/\/Now update the inflight status for any provided packages in this loaded package.\n\t\t\/\/Do this at the very end (in a *separate* for loop) to avoid shutting down the \n\t\t\/\/inflight timer check too soon.\n\t\tfor(var i = 0; i < provideList.length; i++){\n\t\t\tthis.xdInFlight[provideList[i]] = false;\n\t\t}\n\t}"}},"dojo.hostenv.xdLoadFlattenedBundle":{"meta":{"summary":"","parameters":{"moduleName":{"type":"String"},"bundleName":{"type":"String"},"locale":{"type":"String?"},"bundleData":{"type":"Object"}},"src":" locale = locale || \"root\";\n\tvar jsLoc = dojo.hostenv.normalizeLocale(locale).replace('-', '_');\n \tvar bundlePackage = [moduleName, \"nls\", bundleName].join(\".\");\n\tvar bundle = dojo.hostenv.startPackage(bundlePackage);\n\tbundle[jsLoc] = bundleData;\n\t\/\/Assign the bundle for the original locale(s) we wanted.\n\tvar mapName = [moduleName, jsLoc, bundleName].join(\".\");\n\tvar bundleMap = dojo.hostenv.xdBundleMap[mapName];\n\tif(bundleMap){\n\t\tfor(var param in bundleMap){\n\t\t\tbundle[param] = bundleData;\n\t\t}\n\t}"}},"dojo.xdRequireLocalization":{"meta":{"summary":"","parameters":{"moduleName":{"type":"String"},"bundleName":{"type":"String"},"locale":{"type":"String?"},"availableLocales":{"type":"String"}},"src":" var locales = availableLocales.split(\",\");\n\t\/\/Find the best-match locale to load.\n\tvar jsLoc = dojo.hostenv.normalizeLocale(locale);\n\tvar bestLocale = \"\";\n\tfor(var i = 0; i < locales.length; i++){\n\t\t\/\/Locale must match from start of string.\n\t\tif(jsLoc.indexOf(locales[i]) == 0){\n\t\t\tif(locales[i].length > bestLocale.length){\n\t\t\t\tbestLocale = locales[i];\n\t\t\t}\n\t\t}\n\t}\n\tvar fixedBestLocale = bestLocale.replace('-', '_');\n\t\/\/See if the bundle we are going to use is already loaded.\n \tvar bundlePackage = dojo.evalObjPath([moduleName, \"nls\", bundleName].join(\".\"));\n\tif(bundlePackage && bundlePackage[fixedBestLocale]){\n\t\tbundle[jsLoc.replace('-', '_')] = bundlePackage[fixedBestLocale];\n\t}else{\n\t\t\/\/Need to remember what locale we wanted and which one we actually use.\n\t\t\/\/Then when we load the one we are actually using, use that bundle for the one\n\t\t\/\/we originally wanted.\n\t\tvar mapName = [moduleName, (fixedBestLocale||\"root\"), bundleName].join(\".\");\n\t\tvar bundleMap = dojo.hostenv.xdBundleMap[mapName];\n\t\tif(!bundleMap){\n\t\t\tbundleMap = dojo.hostenv.xdBundleMap[mapName] = {};\n\t\t}\n\t\tbundleMap[jsLoc.replace('-', '_')] = true;\n\t\t\/\/Do just a normal dojo.require so the package tracking stuff works as usual.\n\t\tdojo.require(moduleName + \".nls\" + (bestLocale ? \".\" + bestLocale : \"\") + \".\" + bundleName);\n\t}"}},"dojo.hostenv.unpackXdDependency":{"meta":{"summary":"","parameters":{"dep":{"type":""}},"src":" var newDeps = null;\n\tvar newAfterDeps = null;\n\tswitch(dep[0]){\n\t\tcase \"requireIf\":\n\t\tcase \"requireAfterIf\":\n\t\tcase \"conditionalRequire\":\n\t\t\t\/\/First arg (dep[1]) is the test. Depedency is dep[2].\n\t\t\tif((dep[1] === true)||(dep[1]==\"common\")||(dep[1] && dojo.render[dep[1]].capable)){\n\t\t\t\tnewDeps = [{name: dep[2], content: null}];\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"requireAll\":\n\t\t\t\/\/the arguments are an array, each element a call to require.\n\t\t\t\/\/Get rid of first item, which is \"requireAll\".\n\t\t\tdep.shift();\n\t\t\tnewDeps = dep;\n\t\t\tdojo.hostenv.flattenRequireArray(newDeps);\n\t\t\tbreak;\n\t\tcase \"kwCompoundRequire\":\n\t\tcase \"hostenv.conditionalLoadModule\":\n\t\t\tvar modMap = dep[1];\n\t\t\tvar common = modMap[\"common\"]||[];\n\t\t\tvar newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[\"default\"]||[]);\t\n\t\t\tdojo.hostenv.flattenRequireArray(newDeps);\n\t\t\tbreak;\n\t\tcase \"require\":\n\t\tcase \"requireAfter\":\n\t\tcase \"hostenv.loadModule\":\n\t\t\t\/\/Just worry about dep[1]\n\t\t\tnewDeps = [{name: dep[1], content: null}];\n\t\t\tbreak;\n\t}\n\t\/\/The requireAfterIf or requireAfter needs to be evaluated after the current package is evaluated.\n\tif(dep[0] == \"requireAfterIf\"){\n\t\tnewAfterDeps = newDeps;\n\t\tnewDeps = null;\n\t}\n\treturn {requires: newDeps, requiresAfter: newAfterDeps};"}},"dojo.hostenv.xdWalkReqs":{"meta":{"summary":"","src":" var reqChain = null;\n\tvar req;\n\tfor(var i = 0; i < this.xdOrderedReqs.length; i++){\n\t\treq = this.xdOrderedReqs[i];\n\t\tif(this.xdDepMap[req]){\n\t\t\treqChain = [req];\n\t\t\treqChain[req] = true; \/\/Allow for fast lookup of the req in the array\n\t\t\tthis.xdEvalReqs(reqChain);\n\t\t}\n\t}"}},"dojo.hostenv.xdTraceReqs":{"meta":{"summary":"","parameters":{"reqs":{"type":""},"reqChain":{"type":""}},"src":" if(reqs && reqs.length > 0){\n\t\tvar nextReq;\n\t\tfor(var i = 0; i < reqs.length; i++){\n\t\t\tnextReq = reqs[i].name;\n\t\t\tif(nextReq && !reqChain[nextReq]){\n\t\t\t\t\/\/New req depedency. Follow it down.\n\t\t\t\treqChain.push(nextReq);\n\t\t\t\treqChain[nextReq] = true;\n\t\t\t\tthis.xdEvalReqs(reqChain);\n\t\t\t}\n\t\t}\n\t}"}},"dojo.hostenv.xdEvalReqs":{"meta":{"summary":"","parameters":{"reqChain":{"type":""}},"src":" if(reqChain.length > 0){\n\t\tvar req = reqChain[reqChain.length - 1];\n\t\tvar pkg = this.xdDepMap[req];\n\t\tif(pkg){\n\t\t\t\/\/Trace down any requires for this package.\n\t\t\tthis.xdTraceReqs(pkg.requires, reqChain);\n\t\t\t\/\/Evaluate the package.\n\t\t\tvar contents = this.xdContents[pkg.contentIndex];\n\t\t\tif(!contents.isDefined){\n\t\t\t\t\/\/Evaluate the package to bring it into being.\n\t\t\t\t\/\/Pass dojo in so that later, to support multiple versions of dojo\n\t\t\t\t\/\/in a page, we can pass which version of dojo to use.\n\t\t\t\tcontents.content(dojo);\n\t\t\t\tcontents.isDefined = true;\n\t\t\t}\n\t\t\tthis.xdDepMap[req] = null;\n\t\t\t\/\/Trace down any requireAfters for this package..\n\t\t\tthis.xdTraceReqs(pkg.requiresAfter, reqChain);\n\t\t}\n\t\t\/\/Done with that require. Remove it and go to the next one.\n\t\treqChain.pop();\n\t\tthis.xdEvalReqs(reqChain);\n\t}"}},"dojo.hostenv.clearXdInterval":{"meta":{"summary":"","src":" clearInterval(this.xdTimer);\n\tthis.xdTimer = 0;","instance_variables":["xdTimer"]}},"dojo.hostenv.watchInFlightXDomain":{"meta":{"summary":"","src":" var waitInterval = (djConfig.xdWaitSeconds || 30) * 1000;\n\tif(this.xdStartTime + waitInterval < (new Date()).getTime()){\n\t\tthis.clearXdInterval();\n\t\tvar noLoads = \"\";\n\t\tfor(var param in this.xdInFlight){\n\t\t\tif(this.xdInFlight[param]){\n\t\t\t\tnoLoads += param + \" \";\n\t\t\t}\n\t\t}\n\t\tdojo.raise(\"Could not load cross-domain packages: \" + noLoads);\n\t}\n\t\/\/If any are true, then still waiting.\n\t\/\/Come back later.\t\n\tfor(var param in this.xdInFlight){\n\t\tif(this.xdInFlight[param]){\n\t\t\treturn;\n\t\t}\n\t}\n\t\/\/All done loading. Clean up and notify that we are loaded.\n\tthis.clearXdInterval();\n\tthis.xdWalkReqs();\n\t\/\/Evaluate any packages that were not evaled before.\n\t\/\/This normally shouldn't happen with proper dojo.provide and dojo.require\n\t\/\/usage, but providing it just in case. Note that these may not be executed\n\t\/\/in the original order that the developer intended.\n\t\/\/Pass dojo in so that later, to support multiple versions of dojo\n\t\/\/in a page, we can pass which version of dojo to use.\n\tfor(var i = 0; i < this.xdContents.length; i++){\n\t\tvar current = this.xdContents[i];\n\t\tif(current.content && !current.isDefined){\n\t\t\tcurrent.content(dojo);\n\t\t}\n\t}\n\t\/\/Clean up for the next round of xd loading.\n\tthis.resetXd();\n\t\/\/Clear inflight count so we will finally do finish work.\n\tthis.inFlightCount = 0; \n\tthis.callLoaded();","instance_variables":["inFlightCount"]}},"dojo.hostenv.flattenRequireArray":{"meta":{"summary":"","parameters":{"target":{"type":""}},"src":" if(target){\n\t\tfor(var i = 0; i < target.length; i++){\n\t\t\tif(target[i] instanceof Array){\n\t\t\t\ttarget[i] = {name: target[i][0], content: null};\n\t\t\t}else{\n\t\t\t\ttarget[i] = {name: target[i], content: null};\n\t\t\t}\n\t\t}\n\t}"}},"dojo.hostenv.callLoaded":{"meta":{"summary":"","src":" if(this.xdHasCalledPreload || dojo.hostenv.getModulePrefix(\"dojo\") == \"src\" || !this.localesGenerated){\n\t\tthis.xdRealCallLoaded();\n\t\tthis.xdHasCalledPreload = true;\n\t}else{\n\t\tif(this.localesGenerated){\n\t\t\tthis.registerNlsPrefix = function(){\n\t\t\t\t\/\/Need to set the nls prefix to be the xd location.\n\t\t\t\tdojo.registerModulePath(\"nls\", dojo.hostenv.getModulePrefix(\"dojo\") + \"\/..\/nls\");\t\n\t\t\t};\n\t\t\tthis.preloadLocalizations();\n\t\t}\n\t\tthis.xdHasCalledPreload = true;\n\t}","instance_variables":["xdHasCalledPreload","registerNlsPrefix"]}},"dojo.hostenv.callLoaded.registerNlsPrefix":{"meta":{"summary":"","src":" \t\t\tdojo.registerModulePath(\"nls\", dojo.hostenv.getModulePrefix(\"dojo\") + \"\/..\/nls\");\t","instance":"dojo.hostenv.callLoaded"}}}}}}