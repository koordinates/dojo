{"dojo.xml.Parse":{"meta":{"requires":{"common":["dojo.dom"]},"functions":{"dojo.xml.Parse":{"meta":{"summary":"","src":"\t\/\/ get normalized (lowercase) tagName\n\t\/\/ some browsers report tagNames in lowercase no matter what\n\tfunction getTagName(node){\n\t\t\/*\n\t\treturn ((node)&&(node[\"tagName\"]) ? node.tagName.toLowerCase() : '');\n\t\t*\/\n\t\ttry{\n\t\t\treturn node.tagName.toLowerCase();\n\t\t}catch(e){\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\/\/ locate dojo qualified tag name\n\tfunction getDojoTagName(node){\n\t\tvar tagName = getTagName(node);\n\t\tif (!tagName){\n\t\t\t\treturn '';\n\t\t}\n\t\t\/\/ any registered tag\n\t\tif((dojo.widget)&&(dojo.widget.tags[tagName])){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <prefix:tag> => prefix:tag\n\t\tvar p = tagName.indexOf(\":\");\n\t\tif(p>=0){\n\t\t\treturn tagName;\n\t\t}\n\t\t\/\/ <dojo:tag> => dojo:tag\n\t\tif(tagName.substr(0,5) == \"dojo:\"){\n\t\t\treturn tagName;\n\t\t}\n\t\tif(dojo.render.html.capable && dojo.render.html.ie && node.scopeName != 'HTML'){\n\t\t\treturn node.scopeName.toLowerCase() + ':' + tagName;\n\t\t}\n\t\t\/\/ <dojoTag> => dojo:tag\n\t\tif(tagName.substr(0,4) == \"dojo\"){\n\t\t\t\/\/ FIXME: this assumes tag names are always lower case\n\t\t\treturn \"dojo:\" + tagName.substring(4);\n\t\t}\n\t\t\/\/ <tag dojoType=\"prefix:type\"> => prefix:type\n\t\t\/\/ <tag dojoType=\"type\"> => dojo:type\n\t\tvar djt = node.getAttribute(\"dojoType\") || node.getAttribute(\"dojotype\");\n\t\tif(djt){\n\t\t\tif (djt.indexOf(\":\")<0){\n\t\t\t\tdjt = \"dojo:\"+djt;\n\t\t\t}\n\t\t\treturn djt.toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\tdjt = node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,\"type\");\n\t\tif(djt){\n\t\t\treturn \"dojo:\" + djt.toLowerCase();\n\t\t}\n\t\t\/\/ <tag dojo:type=\"type\"> => dojo:type\n\t\ttry{\n\t\t\t\/\/ FIXME: IE really really doesn't like this, so we squelch errors for it\n\t\t\tdjt = node.getAttribute(\"dojo:type\");\n\t\t}catch(e){ \n\t\t\t\/\/ FIXME: log?  \n\t\t}\n\t\tif(djt){ return \"dojo:\"+djt.toLowerCase(); }\n\t\t\/\/ <tag class=\"classa dojo-type classb\"> => dojo:type\t\n\t\tif((dj_global[\"djConfig\"])&&(!djConfig[\"ignoreClassNames\"])){ \n\t\t\t\/\/ FIXME: should we make this optionally enabled via djConfig?\n\t\t\tvar classes = node.className||node.getAttribute(\"class\");\n\t\t\t\/\/ FIXME: following line, without check for existence of classes.indexOf\n\t\t\t\/\/ breaks firefox 1.5's svg widgets\n\t\t\tif((classes )&&(classes.indexOf)&&(classes.indexOf(\"dojo-\")!=-1)){\n\t\t\t\tvar aclasses = classes.split(\" \");\n\t\t\t\tfor(var x=0, c=aclasses.length; x<c; x++){\n\t\t\t\t\tif(aclasses[x].slice(0, 5) == \"dojo-\"){\n\t\t\t\t\t\treturn \"dojo:\"+aclasses[x].substr(5).toLowerCase(); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\/\/ no dojo-qualified name\n\t\treturn '';\n\t}\n\tthis.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){\n\t\t\/\/ run shortcuts to bail out of processing up front to save time and\n\t\t\/\/ object alloc if possible.\n\t\tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(tagName.indexOf(\"\/\")==0){ return null; }\n\t\ttry{\n\t\t\tif(node.getAttribute(\"parseWidgets\").toLowerCase() == \"false\"){\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}catch(e){\/*continue*\/}\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\t\tvar parsedNodeSet = {};\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"ns\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo.ns)&&(!dojo.ns.allow(ns))){process=false;}\n\t\t}\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t}\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;\n\t};\n\tvar isIE = ((dojo.render.html.capable)&&(dojo.render.html.ie));\n\t\/* parses a set of attributes on a node into an object tree *\/\n\tthis.parseAttributes = function(node){\n\t\tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif(isIE){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif((typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;\n\t};","instance_variables":["parseElement","parseAttributes"]}},"dojo.xml.Parse.parseElement":{"meta":{"summary":"","parameters":{"node":{"type":""},"hasParentNodeSet":{"type":""},"optimizeForDojoML":{"type":""},"thisIdx":{"type":""}},"src":" \tvar tagName = getTagName(node);\n\t\t\/\/There's a weird bug in IE where it counts end tags, e.g. <\/dojo:button> as nodes that should be parsed.  Ignore these\n\t\tif(tagName.indexOf(\"\/\")==0){ return null; }\n\t\ttry{\n\t\t\tif(node.getAttribute(\"parseWidgets\").toLowerCase() == \"false\"){\n\t\t\t\treturn {};\n\t\t\t}\n\t\t}catch(e){\/*continue*\/}\n\t\t\/\/ look for a dojoml qualified name\n\t\t\/\/ process dojoml only when optimizeForDojoML is true\n\t\tvar process = true;\n\t\tif(optimizeForDojoML){\n\t\t\tvar dojoTagName = getDojoTagName(node);\n\t\t\ttagName = dojoTagName || tagName;\n\t\t\tprocess = Boolean(dojoTagName);\n\t\t}\n\t\tvar parsedNodeSet = {};\n\t\tparsedNodeSet[tagName] = [];\n\t\tvar pos = tagName.indexOf(\":\");\n\t\tif(pos>0){\n\t\t\tvar ns = tagName.substring(0,pos);\n\t\t\tparsedNodeSet[\"ns\"] = ns;\n\t\t\t\/\/ honor user namespace filters\n\t\t\tif((dojo.ns)&&(!dojo.ns.allow(ns))){process=false;}\n\t\t}\n\t\tif(process){\n\t\t\tvar attributeSet = this.parseAttributes(node);\n\t\t\tfor(var attr in attributeSet){\n\t\t\t\tif((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != \"array\")){\n\t\t\t\t\tparsedNodeSet[tagName][attr] = [];\n\t\t\t\t}\n\t\t\t\tparsedNodeSet[tagName][attr].push(attributeSet[attr]);\n\t\t\t}\t\n\t\t\t\/\/ FIXME: we might want to make this optional or provide cloning instead of\n\t\t\t\/\/ referencing, but for now, we include a node reference to allow\n\t\t\t\/\/ instantiated components to figure out their \"roots\"\n\t\t\tparsedNodeSet[tagName].nodeRef = node;\n\t\t\tparsedNodeSet.tagName = tagName;\n\t\t\tparsedNodeSet.index = thisIdx||0;\n\t\t}\n\t\tvar count = 0;\n\t\tfor(var i = 0; i < node.childNodes.length; i++){\n\t\t\tvar tcn = node.childNodes.item(i);\n\t\t\tswitch(tcn.nodeType){\n\t\t\t\tcase  dojo.dom.ELEMENT_NODE: \/\/ element nodes, call this function recursively\n\t\t\t\t\tcount++;\n\t\t\t\t\tvar ctn = getDojoTagName(tcn) || getTagName(tcn);\n\t\t\t\t\tif(!parsedNodeSet[ctn]){\n\t\t\t\t\t\tparsedNodeSet[ctn] = [];\n\t\t\t\t\t}\n\t\t\t\t\tparsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));\n\t\t\t\t\tif(\t(tcn.childNodes.length == 1)&&\n\t\t\t\t\t\t(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){\n\t\t\t\t\t\tparsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.TEXT_NODE: \/\/ if a single text node is the child, treat it as an attribute\n\t\t\t\t\tif(node.childNodes.length == 1){\n\t\t\t\t\t\tparsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: break;\n\t\t\t\t\/*\n\t\t\t\tcase  dojo.dom.ATTRIBUTE_NODE: \/\/ attribute node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.CDATA_SECTION_NODE: \/\/ cdata section... not sure if this would ever be meaningful... might be...\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_REFERENCE_NODE: \/\/ entity reference node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.ENTITY_NODE: \/\/ entity node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.PROCESSING_INSTRUCTION_NODE: \/\/ processing instruction node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.COMMENT_NODE: \/\/ comment node... not not sure if this would ever be meaningful \n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_NODE: \/\/ document node... not sure if this would ever be meaningful\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_TYPE_NODE: \/\/ document type node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.DOCUMENT_FRAGMENT_NODE: \/\/ document fragment node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\tcase  dojo.dom.NOTATION_NODE:\/\/ notation node... not meaningful here\n\t\t\t\t\tbreak;\n\t\t\t\t*\/\n\t\t\t}\n\t\t}\n\t\t\/\/return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;\n\t\t\/\/if(parsedNodeSet.tagName)dojo.debug(\"parseElement: RETURNING NODE WITH TAGNAME \"+parsedNodeSet.tagName);\n\t\treturn parsedNodeSet;","instance":"dojo.xml.Parse"}},"dojo.xml.Parse.parseAttributes":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":" \tvar parsedAttributeSet = {};\n\t\tvar atts = node.attributes;\n\t\t\/\/ TODO: should we allow for duplicate attributes at this point...\n\t\t\/\/ would any of the relevant dom implementations even allow this?\n\t\tvar attnode, i=0;\n\t\twhile((attnode=atts[i++])){\n\t\t\tif(isIE){\n\t\t\t\tif(!attnode){ continue; }\n\t\t\t\tif((typeof attnode == \"object\")&&\n\t\t\t\t\t(typeof attnode.nodeValue == 'undefined')||\n\t\t\t\t\t(attnode.nodeValue == null)||\n\t\t\t\t\t(attnode.nodeValue == '')){ \n\t\t\t\t\tcontinue; \n\t\t\t\t}\n\t\t\t}\n\t\t\tvar nn = attnode.nodeName.split(\":\");\n\t\t\tnn = (nn.length == 2) ? nn[1] : attnode.nodeName;\n\t\t\tparsedAttributeSet[nn] = { \n\t\t\t\tvalue: attnode.nodeValue \n\t\t\t};\n\t\t}\n\t\treturn parsedAttributeSet;","instance":"dojo.xml.Parse"}}}}},"dojo.xml.XslTransform":{"meta":{"functions":{"dojo.xml.XslTransform":{"meta":{"summary":"dojo.xml.XslTransform is a convenience object that takes the URI String of an XSL file as a constructor argument. After each transformation all parameters will be cleared. Note this is supported by IE and Mozilla ONLY.","parameters":{"xsltUri":{"type":"String"}},"src":" dojo.debug(\"XslTransform is supported by Internet Explorer and Mozilla, with limited support in Opera 9 (no document function support).\");\r\n\tvar IS_IE = window.ActiveXObject ? true : false;\r\n\tvar ACTIVEX_DOMS = [\r\n\t\t\"Msxml2.DOMDocument.5.0\", \r\n\t\t\"Msxml2.DOMDocument.4.0\", \r\n\t\t\"Msxml2.DOMDocument.3.0\", \r\n\t\t\"MSXML2.DOMDocument\", \r\n\t\t\"MSXML.DOMDocument\", \r\n\t\t\"Microsoft.XMLDOM\"\r\n\t];\r\n\tvar ACTIVEX_FT_DOMS = [\r\n\t\t\"Msxml2.FreeThreadedDOMDocument.5.0\", \r\n\t\t\"MSXML2.FreeThreadedDOMDocument.4.0\", \r\n\t\t\"MSXML2.FreeThreadedDOMDocument.3.0\"\r\n\t];\r\n\tvar ACTIVEX_TEMPLATES = [\r\n\t\t\"Msxml2.XSLTemplate.5.0\", \r\n\t\t\"Msxml2.XSLTemplate.4.0\", \r\n\t\t\"MSXML2.XSLTemplate.3.0\"\r\n\t];\r\n\tfunction getActiveXImpl(activeXArray) {\r\n\t\tfor (var i=0; i < activeXArray.length; i++) {\r\n\t\t\ttry {\r\n\t\t\t\tvar testObj = new ActiveXObject(activeXArray[i]);\r\n\t\t\t\tif (testObj) {\r\n\t\t\t\t\treturn activeXArray[i];\r\n\t\t\t\t}\r\n\t\t\t} catch (e) {}\r\n\t\t}\r\n\t\tdojo.raise(\"Could not find an ActiveX implementation in:\\n\\n \" + activeXArray);\r\n\t}\r\n    if (xsltUri == null || xsltUri == undefined) {\r\n        dojo.raise(\"You must pass the URI String for the XSL file to be used!\");\r\n        return false;\r\n    }\r\n    var xsltDocument = null;\r\n    var xsltProcessor = null;\r\n    if (IS_IE) {\r\n        xsltDocument = new ActiveXObject(getActiveXImpl(ACTIVEX_FT_DOMS));\r\n        xsltDocument.async = false;\r\n    } else {\r\n        xsltProcessor = new XSLTProcessor();\r\n        xsltDocument = document.implementation.createDocument(\"\", \"\", null);\r\n        xsltDocument.addEventListener(\"load\", onXslLoad, false);\r\n    }\r\n    xsltDocument.load(xsltUri);\r\n    if (IS_IE) {\r\n        var xslt = new ActiveXObject(getActiveXImpl(ACTIVEX_TEMPLATES));\r\n        xslt.stylesheet = xsltDocument;  \r\n        xsltProcessor = xslt.createProcessor();\r\n    }\r\n    function onXslLoad() {\r\n        xsltProcessor.importStylesheet(xsltDocument); \r\n    }\r\n    function getResultDom(xmlDoc, params) {\r\n      if (IS_IE) {\r\n          addIeParams(params);\r\n          var result = getIeResultDom(xmlDoc);\r\n          removeIeParams(params);   \r\n          return result;\r\n      } else {\r\n          return getMozillaResultDom(xmlDoc, params);\r\n      }\r\n    }\r\n    function addIeParams(params) {\r\n        if (params != null) {\r\n          for (var i=0; i<params.length; i++) \r\n              xsltProcessor.addParameter(params[i][0], params[i][1]);\r\n        }\r\n    }\r\n    function removeIeParams(params) {\r\n        if (params != null) {\r\n            for (var i=0; i<params.length; i++) \r\n                xsltProcessor.addParameter(params[i][0], \"\");\r\n        }\r\n    }\r\n    function getIeResultDom(xmlDoc) {\r\n        xsltProcessor.input = xmlDoc;\r\n        var outDoc = new ActiveXObject(getActiveXImpl(ACTIVEX_DOMS));\r\n        outDoc.async = false;  \r\n        outDoc.validateOnParse = false;\r\n        xsltProcessor.output = outDoc;\r\n        xsltProcessor.transform();\r\n        if (outDoc.parseError.errorCode != 0) {\r\n            var err = outDoc.parseError;\r\n\t\t\tdojo.raise(\"err.errorCode: \" + err.errorCode + \"\\n\\nerr.reason: \" + err.reason + \"\\n\\nerr.url: \" + err.url + \"\\n\\nerr.srcText: \" + err.srcText);\r\n        }\r\n        return outDoc;\r\n    }\r\n    function getIeResultStr(xmlDoc, params) {\r\n        xsltProcessor.input = xmlDoc;\r\n        xsltProcessor.transform();    \r\n        return xsltProcessor.output;\r\n    }\r\n    function addMozillaParams(params) {\r\n        if (params != null) {\r\n            for (var i=0; i<params.length; i++) \r\n                xsltProcessor.setParameter(null, params[i][0], params[i][1]);\r\n        }\r\n    }\r\n    function getMozillaResultDom(xmlDoc, params) {\r\n        addMozillaParams(params);\r\n        var resultDoc = xsltProcessor.transformToDocument(xmlDoc);\r\n        xsltProcessor.clearParameters();\r\n        return resultDoc;\r\n    }\r\n    function getMozillaResultStr(xmlDoc, params, parentDoc) {\r\n        addMozillaParams(params);\r\n        var resultDoc = xsltProcessor.transformToFragment(xmlDoc, parentDoc);\r\n        var serializer = new XMLSerializer();\r\n        xsltProcessor.clearParameters();\r\n        return serializer.serializeToString(resultDoc);\r\n    }\r\n    this.getResultString = function(\/*XMLDocument*\/ xmlDoc, \/*2 Dimensional Array*\/params, \/*HTMLDocument*\/parentDoc) {\r\n        var content = null;\r\n        if (IS_IE) {\r\n            addIeParams(params);\r\n            content = getIeResultStr(xmlDoc, params);\r\n            removeIeParams(params);  \r\n        } else {\r\n            content = getMozillaResultStr(xmlDoc, params, parentDoc);\r\n        } \r\n        \/\/dojo.debug(content);\r\n        return content;\r\n    };\r\n    this.transformToContentPane = function(\/*XMLDocument*\/ xmlDoc, \/*2 Dimensional Array*\/params, \/*ContentPane*\/contentPane, \/*HTMLDocument*\/parentDoc) {\r\n        var content = this.getResultString(xmlDoc, params, parentDoc);\r\n        contentPane.setContent(content);\r\n    };\r\n    this.transformToRegion = function(\/*XMLDocument*\/ xmlDoc, \/*2 Dimensional Array*\/params, \/*HTMLElement*\/region, \/*HTMLDocument*\/parentDoc) {\r\n        try {\r\n            var content = this.getResultString(xmlDoc, params, parentDoc);\r\n            region.innerHTML = content;\r\n        } catch (e) {\r\n            dojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n        }\r\n    };\r\n    this.transformToDocument = function(\/*XMLDocument*\/ xmlDoc, \/*2 Dimensional Array*\/params) {\r\n        return getResultDom(xmlDoc, params);\r\n    }\r\n    this.transformToWindow = function(\/*XMLDocument*\/ xmlDoc, \/*2 Dimensional Array*\/params, \/*HTMLDocument*\/windowDoc, \/*HTMLDocument*\/parentDoc) {\r\n        try {\r\n            windowDoc.open();\r\n            windowDoc.write(this.getResultString(xmlDoc, params, parentDoc));\r\n            windowDoc.close();\r\n        } catch (e) {\r\n            dojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n        }\r\n    };\r","instance_variables":["getResultString","transformToContentPane","transformToRegion","transformToDocument","transformToWindow"]}},"dojo.xml.XslTransform.getResultString":{"meta":{"summary":"","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"parentDoc":{"type":"HTMLDocument"}},"src":"        var content = null;\r\n        if (IS_IE) {\r\n            addIeParams(params);\r\n            content = getIeResultStr(xmlDoc, params);\r\n            removeIeParams(params);  \r\n        } else {\r\n            content = getMozillaResultStr(xmlDoc, params, parentDoc);\r\n        } \r\n        \/\/dojo.debug(content);\r\n        return content;\r","instance":"dojo.xml.XslTransform"}},"dojo.xml.XslTransform.transformToContentPane":{"meta":{"summary":"","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"contentPane":{"type":"ContentPane"},"parentDoc":{"type":"HTMLDocument"}},"src":"        var content = this.getResultString(xmlDoc, params, parentDoc);\r\n        contentPane.setContent(content);\r","instance":"dojo.xml.XslTransform"}},"dojo.xml.XslTransform.transformToRegion":{"meta":{"summary":"","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"region":{"type":"HTMLElement"},"parentDoc":{"type":"HTMLDocument"}},"src":"        try {\r\n            var content = this.getResultString(xmlDoc, params, parentDoc);\r\n            region.innerHTML = content;\r\n        } catch (e) {\r\n            dojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n        }\r","instance":"dojo.xml.XslTransform"}},"dojo.xml.XslTransform.transformToDocument":{"meta":{"summary":"","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"}},"src":"        return getResultDom(xmlDoc, params);\r","instance":"dojo.xml.XslTransform"}},"dojo.xml.XslTransform.transformToWindow":{"meta":{"summary":"","parameters":{"xmlDoc":{"type":"XMLDocument"},"params":{"type":"2 Dimensional Array"},"windowDoc":{"type":"HTMLDocument"},"parentDoc":{"type":"HTMLDocument"}},"src":"        try {\r\n            windowDoc.open();\r\n            windowDoc.write(this.getResultString(xmlDoc, params, parentDoc));\r\n            windowDoc.close();\r\n        } catch (e) {\r\n            dojo.raise(e.message + \"\\n\\n xsltUri: \" + xsltUri)\r\n        }\r","instance":"dojo.xml.XslTransform"}}}}},"dojo.xml._":{"meta":{"requires":{"common":["dojo.dom","dojo.xml.Parse"],"browser":["dojo.html.*"],"dashboard":["dojo.html.*"],"svg":["dojo.xml.svgUtil"]}}},"dojo.xml.svgUtil":{"meta":{"functions":{"dojo.xml.svgUtil":{"meta":{"initialized":true,"summary":"","src":" this.getInnerWidth = function(node){\n\t\t\/\/ FIXME: need to find out from dylan how to \n\t}\n\tthis.getOuterWidth = function(node){\n\t}\n\tthis.getInnerHeight = function(node){\n\t}\n\tthis.getOuterHeight = function(node){\n\t}","instance_variables":["getInnerWidth","getOuterWidth","getInnerHeight","getOuterHeight"]}},"dojo.xml.svgUtil.getInnerWidth":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"\t\t\/\/ FIXME: need to find out from dylan how to ","instance":"dojo.xml.svgUtil"}},"dojo.xml.svgUtil.getOuterWidth":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"","instance":"dojo.xml.svgUtil"}},"dojo.xml.svgUtil.getInnerHeight":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"","instance":"dojo.xml.svgUtil"}},"dojo.xml.svgUtil.getOuterHeight":{"meta":{"summary":"","parameters":{"node":{"type":""}},"src":"","instance":"dojo.xml.svgUtil"}}}}}}