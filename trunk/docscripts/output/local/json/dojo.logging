{"dojo.logging.ConsoleLogger":{"meta":{"requires":{"common":["dojo.logging.Logger"]},"functions":{"dojo.logging.MemoryLogHandler":{"meta":{"prototype_variables":["debug","info","warn","error","critical","emit","debug","info","warn","error","critical"]}},"dojo.logging.Logger.exception":{"meta":{"summary":"","parameters":{"msg":{"type":""},"e":{"type":""},"squelch":{"type":""}},"src":" \t\tvar args=[msg];\n\t\t\tif(e){\n\t\t\t\tmsg+=\" : \"+ e.name + \" \" + (e.description||e.message);\n\t\t\t\targs.push(e);\n\t\t\t}\n\t\t\tthis.logType(\"ERROR\", args);\n\t\t\tif(!squelch){\n\t\t\t\tthrow e;\n\t\t\t}","prototype":"dojo.logging.Logger"}}}}},"dojo.logging.Logger":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.declare"]},"functions":{"dojo.logging.MemoryLogHandler":{"meta":{"prototype_chain":["dojo.logging.LogHandler"],"call_chain":["dojo.logging.LogHandler"]}},"dojo.logging.Record":{"meta":{"summary":"A simple data structure class that stores information for and about a logged event. Objects of this type are created automatically when an event is logged and are the internal format in which information about log events is kept.","parameters":{"logLevel":{"type":"Integer"},"message":{"type":"String||Array"}},"src":" this.level = logLevel;\n\tthis.message = \"\";\n\tthis.msgArgs = [];\n\tthis.time = new Date();\n\tif(dojo.lang.isArray(message)){\n\t\tif(message.length > 0 && dojo.lang.isString(message[0])){\n\t\t\tthis.message=message.shift();\n\t\t}\n\t\tthis.msgArgs = message;\n\t}else{\n\t\tthis.message = message;\n\t}\n\t\/\/ FIXME: what other information can we receive\/discover here?","instance_variables":["level","message","msgArgs","time"]},"extra":{"parameters":{"logLevel":{"type":"Integer","summary":"mapped via the dojo.logging.log.levels object from a string. This mapping also corresponds to an instance of dojo.logging.Logger"}},"variables":{"message":{"type":"The","summary":"contents of the message represented by this log record."}}}},"dojo.logging.LogFilter":{"meta":{"summary":"An empty parent (abstract) class which concrete filters should inherit from. Filters should have only a single method, filter(), which processes a record and returns true or false to denote whether or not it should be handled by the next step in a filter chain.","parameters":{"loggerChain":{"type":""}},"src":" this.passChain = loggerChain || \"\";\n\tthis.filter = function(record){\n\t\t\/\/ FIXME: need to figure out a way to enforce the loggerChain\n\t\t\/\/ restriction\n\t\treturn true; \/\/ pass all records\n\t}","instance_variables":["passChain","filter"],"returns":"pass all records"}},"dojo.logging.LogFilter.filter":{"meta":{"summary":"","parameters":{"record":{"type":""}},"src":" \treturn true; \/\/ pass all records","returns":"pass all records","instance":"dojo.logging.LogFilter"}},"dojo.logging.Logger":{"meta":{"summary":"","src":" this.cutOffLevel = 0;\n\tthis.propagate = true;\n\tthis.parent = null;\n\t\/\/ storage for dojo.logging.Record objects seen and accepted by this logger\n\tthis.data = [];\n\tthis.filters = [];\n\tthis.handlers = [];","instance_variables":["cutOffLevel","propagate","parent","data","filters","handlers"],"prototype_variables":["debug","warn","err","crit"]}},"dojo.logging.LogHandler":{"meta":{"summary":"","parameters":{"level":{"type":""}},"src":" this.cutOffLevel = (level) ? level : 0;\n\tthis.formatter = null; \/\/ FIXME: default formatter?\n\tthis.data = [];\n\tthis.filters = [];","instance_variables":["cutOffLevel","formatter","data","filters"],"prototype_variables":["setFormatter","flush","close","handleError","handle","emit"]}},"dojo.logging.log.getLogger":{"meta":{"summary":"","parameters":{"name":{"type":"string"}},"src":" if(!this.loggers[name]){\n\t\tthis.loggers[name] = new dojo.logging.Logger();\n\t\tthis.loggers[name].parent = this;\n\t}\n\treturn this.loggers[name]; \/\/ dojo.logging.Logger","returns":"dojo.logging.Logger"},"extra":{"returns":"a named dojo.logging.Logger instance. If one is not already available with that name in the global map, one is created and returne."}},"dojo.logging.log.getLevelName":{"meta":{"summary":"turns integer logging level into a human-friendly name","parameters":{"lvl":{"type":"integer"}},"src":" for(var x=0; x<this.levels.length; x++){\n\t\tif(this.levels[x].level == lvl){\n\t\t\treturn this.levels[x].name; \/\/ string\n\t\t}\n\t}\n\treturn null;","returns":"string"}},"dojo.logging.log.getLevel":{"meta":{"summary":"name->integer conversion for log levels","parameters":{"name":{"type":"string"}},"src":" for(var x=0; x<this.levels.length; x++){\n\t\tif(this.levels[x].name.toUpperCase() == name.toUpperCase()){\n\t\t\treturn this.levels[x].level; \/\/ integer\n\t\t}\n\t}\n\treturn null;","returns":"integer"}},"dojo.logging.Logger._argsToArr":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":" \tvar ret = [];\n\t\tfor(var x=0; x<args.length; x++){\n\t\t\tret.push(args[x]);\n\t\t}\n\t\treturn ret;"}},"dojo.logging.Logger.setLevel":{"meta":{"summary":"set the logging level for this logger.","parameters":{"lvl":{"type":"Integer"}},"src":" \tthis.cutOffLevel = parseInt(lvl);","instance_variables":["cutOffLevel"]},"extra":{"parameters":{"lvl":{"type":"the","summary":"logging level to set the cutoff for, as derived from the dojo.logging.log.levels object. Any messages below the specified level are dropped on the floor"}}}},"dojo.logging.Logger.isEnabledFor":{"meta":{"summary":"will a message at the specified level be emitted?","parameters":{"lvl":{"type":"Integer"}},"src":" \treturn parseInt(lvl) >= this.cutOffLevel; \/\/ boolean","returns":"boolean"}},"dojo.logging.Logger.getEffectiveLevel":{"meta":{"summary":"gets the effective cutoff level, including that of any potential parent loggers in the chain.","src":" \tif((this.cutOffLevel==0)&&(this.parent)){\n\t\t\treturn this.parent.getEffectiveLevel(); \/\/ Integer\n\t\t}\n\t\treturn this.cutOffLevel; \/\/ Integer","instance_variables":["cutOffLevel"],"returns":"Integer"}},"dojo.logging.Logger.addFilter":{"meta":{"summary":"registers a new LogFilter object. All records will be passed through this filter from now on.","parameters":{"flt":{"type":"dojo.logging.LogFilter"}},"src":" \tthis.filters.push(flt);\n\t\treturn this.filters.length-1; \/\/ Integer","returns":"Integer"}},"dojo.logging.Logger.removeFilterByIndex":{"meta":{"summary":"removes the filter at the specified index from the filter chain. Returns whether or not removal was successful.","parameters":{"fltIndex":{"type":"Integer"}},"src":" \tif(this.filters[fltIndex]){\n\t\t\tdelete this.filters[fltIndex];\n\t\t\treturn true; \/\/ boolean\n\t\t}\n\t\treturn false; \/\/ boolean","returns":"boolean"}},"dojo.logging.Logger.removeFilter":{"meta":{"summary":"removes the passed LogFilter. Returns whether or not removal was successful.","parameters":{"fltRef":{"type":"dojo.logging.LogFilter"}},"src":" \tfor(var x=0; x<this.filters.length; x++){\n\t\t\tif(this.filters[x]===fltRef){\n\t\t\t\tdelete this.filters[x];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;"}},"dojo.logging.Logger.removeAllFilters":{"meta":{"summary":"clobbers all the registered filters.","src":" \tthis.filters = []; \/\/ clobber all of them","instance_variables":["filters"]}},"dojo.logging.Logger.filter":{"meta":{"summary":"runs the passed Record through the chain of registered filters. Returns a boolean indicating whether or not the Record should be emitted.","parameters":{"rec":{"type":"dojo.logging.Record"}},"src":" \tfor(var x=0; x<this.filters.length; x++){\n\t\t\tif((this.filters[x][\"filter\"])&&\n\t\t\t   (!this.filters[x].filter(rec))||\n\t\t\t   (rec.level<this.cutOffLevel)){\n\t\t\t\treturn false; \/\/ boolean\n\t\t\t}\n\t\t}\n\t\treturn true; \/\/ boolean","returns":"boolean"}},"dojo.logging.Logger.addHandler":{"meta":{"summary":"adds as LogHandler to the chain","parameters":{"hdlr":{"type":"dojo.logging.LogHandler"}},"src":" \tthis.handlers.push(hdlr);\n\t\treturn this.handlers.length-1;"}},"dojo.logging.Logger.handle":{"meta":{"summary":"if the Record survives filtering, pass it down to the registered handlers. Returns a boolean indicating whether or not the record was successfully handled. If the message is culled for some reason, returns false.","parameters":{"rec":{"type":"dojo.logging.Record"}},"src":" \tif((!this.filter(rec))||(rec.level<this.cutOffLevel)){ return false; } \/\/ boolean\n\t\tfor(var x=0; x<this.handlers.length; x++){\n\t\t\tif(this.handlers[x][\"handle\"]){\n\t\t\t   this.handlers[x].handle(rec);\n\t\t\t}\n\t\t}\n\t\t\/\/ FIXME: not sure what to do about records to be propagated that may have\n\t\t\/\/ been modified by the handlers or the filters at this logger. Should\n\t\t\/\/ parents always have pristine copies? or is passing the modified record\n\t\t\/\/ OK?\n\t\t\/\/ if((this.propagate)&&(this.parent)){ this.parent.handle(rec); }\n\t\treturn true; \/\/ boolean","returns":"boolean"}},"dojo.logging.Logger.log":{"meta":{"summary":"log a message at the specified log level","parameters":{"lvl":{"type":"integer"},"msg":{"type":"string"}},"src":" \tif(\t(this.propagate)&&(this.parent)&&\n\t\t\t(this.parent.rec.level>=this.cutOffLevel)){\n\t\t\tthis.parent.log(lvl, msg);\n\t\t\treturn false;\n\t\t}\n\t\t\/\/ FIXME: need to call logging providers here!\n\t\tthis.handle(new dojo.logging.Record(lvl, msg));\n\t\treturn true;"}},"dojo.logging.Logger.info":{"meta":{"summary":"log the msg and any other arguments at the \"info\" logging level.","parameters":{"msg":{"type":""}},"src":" \treturn this.logType(\"INFO\", this._argsToArr(arguments));"}},"dojo.logging.Logger.warning":{"meta":{"summary":"log the msg and any other arguments at the \"warning\" logging level.","parameters":{"msg":{"type":""}},"src":" \treturn this.logType(\"WARNING\", this._argsToArr(arguments));"}},"dojo.logging.Logger.error":{"meta":{"summary":"log the msg and any other arguments at the \"error\" logging level.","parameters":{"msg":{"type":""}},"src":" \treturn this.logType(\"ERROR\", this._argsToArr(arguments));"}},"dojo.logging.Logger.critical":{"meta":{"summary":"log the msg and any other arguments at the \"critical\" logging level.","parameters":{"msg":{"type":""}},"src":" \treturn this.logType(\"CRITICAL\", this._argsToArr(arguments));"}},"dojo.logging.Logger.exception":{"meta":{"summary":"logs the error and the message at the \"exception\" logging level. If squelch is true, also prevent bubbling of the exception.","parameters":{"msg":{"type":"string"},"e":{"type":"Error"},"squelch":{"type":"boolean"}},"src":"\t\t\/\/ FIXME: this needs to be modified to put the exception in the msg\n\t\t\/\/ if we're on Moz, we can get the following from the exception object:\n\t\t\/\/\t\tlineNumber\n\t\t\/\/\t\tmessage\n\t\t\/\/\t\tfileName\n\t\t\/\/\t\tstack\n\t\t\/\/\t\tname\n\t\t\/\/ on IE, we get:\n\t\t\/\/\t\tname\n\t\t\/\/\t\tmessage (from MDA?)\n\t\t\/\/\t\tnumber\n\t\t\/\/\t\tdescription (same as message!)\n\t\tif(e){\n\t\t\tvar eparts = [e.name, (e.description||e.message)];\n\t\t\tif(e.fileName){\n\t\t\t\teparts.push(e.fileName);\n\t\t\t\teparts.push(\"line \"+e.lineNumber);\n\t\t\t\t\/\/ eparts.push(e.stack);\n\t\t\t}\n\t\t\tmsg += \" \"+eparts.join(\" : \");\n\t\t}\n\t\tthis.logType(\"ERROR\", msg);\n\t\tif(!squelch){\n\t\t\tthrow e;\n\t\t}"}},"dojo.logging.Logger.logType":{"meta":{"summary":"a more \"user friendly\" version of the log() function. Takes the named log level instead of the corresponding integer.","parameters":{"type":{"type":"string"},"args":{"type":"array"}},"src":" \treturn this.log.apply(this, [dojo.logging.log.getLevel(type), \n\t\t\targs]);","call_chain":["this.log"]}}}}},"dojo.logging._":{"meta":{"requires":{"rhino":["dojo.logging.RhinoLogger"]}}}}