{"dojo.undo.Manager":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.undo.Manager":{"meta":{"summary":"","parameters":{"parent":{"type":""}},"src":" this.clear();\n\tthis._parent = parent;","instance_variables":["_parent"],"prototype_variables":["_parent","_undoStack","_redoStack","_currentManager","canUndo","canRedo","isUndoing","isRedoing"]}},"dojo.undo.Manager.onUndo":{"meta":{"summary":"","parameters":{"manager":{"type":""},"item":{"type":""}},"src":""}},"dojo.undo.Manager.onRedo":{"meta":{"summary":"","parameters":{"manager":{"type":""},"item":{"type":""}},"src":""}},"dojo.undo.Manager.onUndoAny":{"meta":{"summary":"","parameters":{"manager":{"type":""},"item":{"type":""}},"src":""}},"dojo.undo.Manager.onRedoAny":{"meta":{"summary":"","parameters":{"manager":{"type":""},"item":{"type":""}},"src":""}},"dojo.undo.Manager._updateStatus":{"meta":{"summary":"","src":" \tthis.canUndo = this._undoStack.length > 0;\n\t\tthis.canRedo = this._redoStack.length > 0;","instance_variables":["canUndo","canRedo"]}},"dojo.undo.Manager.clear":{"meta":{"summary":"","src":" \tthis._undoStack = [];\n\t\tthis._redoStack = [];\n\t\tthis._currentManager = this;\n\t\tthis.isUndoing = false;\n\t\tthis.isRedoing = false;\n\t\tthis._updateStatus();","instance_variables":["_undoStack","_redoStack","_currentManager","isUndoing","isRedoing"]}},"dojo.undo.Manager.undo":{"meta":{"summary":"","src":" \tif(!this.canUndo) { return false; }\n\t\tthis.endAllTransactions();\n\t\tthis.isUndoing = true;\n\t\tvar top = this._undoStack.pop();\n\t\tif(top instanceof dojo.undo.Manager){\n\t\t\ttop.undoAll();\n\t\t}else{\n\t\t\ttop.undo();\n\t\t}\n\t\tif(top.redo){\n\t\t\tthis._redoStack.push(top);\n\t\t}\n\t\tthis.isUndoing = false;\n\t\tthis._updateStatus();\n\t\tthis.onUndo(this, top);\n\t\tif(!(top instanceof dojo.undo.Manager)) {\n\t\t\tthis.getTop().onUndoAny(this, top);\n\t\t}\n\t\treturn true;","instance_variables":["isUndoing"]}},"dojo.undo.Manager.redo":{"meta":{"summary":"","src":" \tif(!this.canRedo){ return false; }\n\t\tthis.isRedoing = true;\n\t\tvar top = this._redoStack.pop();\n\t\tif(top instanceof dojo.undo.Manager) {\n\t\t\ttop.redoAll();\n\t\t}else{\n\t\t\ttop.redo();\n\t\t}\n\t\tthis._undoStack.push(top);\n\t\tthis.isRedoing = false;\n\t\tthis._updateStatus();\n\t\tthis.onRedo(this, top);\n\t\tif(!(top instanceof dojo.undo.Manager)){\n\t\t\tthis.getTop().onRedoAny(this, top);\n\t\t}\n\t\treturn true;","instance_variables":["isRedoing"]}},"dojo.undo.Manager.undoAll":{"meta":{"summary":"","src":" \twhile(this._undoStack.length > 0) {\n\t\t\tthis.undo();\n\t\t}"}},"dojo.undo.Manager.redoAll":{"meta":{"summary":"","src":" \twhile(this._redoStack.length > 0) {\n\t\t\tthis.redo();\n\t\t}"}},"dojo.undo.Manager.push":{"meta":{"summary":"","parameters":{"undo":{"type":""},"redo":{"type":"optional"},"description":{"type":"optional"}},"src":" \tif(!undo) { return; }\n\t\tif(this._currentManager == this) {\n\t\t\tthis._undoStack.push({\n\t\t\t\tundo: undo,\n\t\t\t\tredo: redo,\n\t\t\t\tdescription: description\n\t\t\t});\n\t\t} else {\n\t\t\tthis._currentManager.push.apply(this._currentManager, arguments);\n\t\t}\n\t\t\/\/ adding a new undo-able item clears out the redo stack\n\t\tthis._redoStack = [];\n\t\tthis._updateStatus();","instance_variables":["_currentManager","_redoStack"],"call_chain":["this._currentManager.push"]}},"dojo.undo.Manager.concat":{"meta":{"summary":"","parameters":{"manager":{"type":""}},"src":" \tif ( !manager ) { return; }\n\t\tif (this._currentManager == this ) {\n\t\t\tfor(var x=0; x < manager._undoStack.length; x++) {\n\t\t\t\tthis._undoStack.push(manager._undoStack[x]);\n\t\t\t}\n\t\t\t\/\/ adding a new undo-able item clears out the redo stack\n\t\t\tif (manager._undoStack.length > 0) {\n\t\t\t\tthis._redoStack = [];\n\t\t\t}\n\t\t\tthis._updateStatus();\n\t\t} else {\n\t\t\tthis._currentManager.concat.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager","_redoStack"],"call_chain":["this._currentManager.concat"]}},"dojo.undo.Manager.beginTransaction":{"meta":{"summary":"","parameters":{"description":{"type":"optional"}},"src":" \tif(this._currentManager == this) {\n\t\t\tvar mgr = new dojo.undo.Manager(this);\n\t\t\tmgr.description = description ? description : \"\";\n\t\t\tthis._undoStack.push(mgr);\n\t\t\tthis._currentManager = mgr;\n\t\t\treturn mgr;\n\t\t} else {\n\t\t\t\/\/for nested transactions need to make sure the top level _currentManager is set\n\t\t\tthis._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager"],"call_chain":["this._currentManager.beginTransaction"]}},"dojo.undo.Manager.endTransaction":{"meta":{"summary":"","parameters":{"flatten":{"type":"optional"}},"src":" \tif(this._currentManager == this) {\n\t\t\tif(this._parent) {\n\t\t\t\tthis._parent._currentManager = this._parent;\n\t\t\t\t\/\/ don't leave empty transactions hangin' around\n\t\t\t\tif(this._undoStack.length == 0 || flatten) {\n\t\t\t\t\tvar idx = dojo.lang.find(this._parent._undoStack, this);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tthis._parent._undoStack.splice(idx, 1);\n\t\t\t\t\t\t\/\/add the current transaction to parents undo stack\n\t\t\t\t\t\tif (flatten) {\n\t\t\t\t\t\t\tfor(var x=0; x < this._undoStack.length; x++){\n\t\t\t\t\t\t\t\tthis._parent._undoStack.splice(idx++, 0, this._undoStack[x]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._updateStatus();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this._parent;\n\t\t\t}\n\t\t} else {\n\t\t\t\/\/for nested transactions need to make sure the top level _currentManager is set\n\t\t\tthis._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);\n\t\t}","instance_variables":["_currentManager","_parent._currentManager","_undoStack.length"],"call_chain":["this._currentManager.endTransaction"]}},"dojo.undo.Manager.endAllTransactions":{"meta":{"summary":"","src":" \twhile(this._currentManager != this) {\n\t\t\tthis.endTransaction();\n\t\t}"}},"dojo.undo.Manager.getTop":{"meta":{"summary":"","src":" \tif(this._parent) {\n\t\t\treturn this._parent.getTop();\n\t\t} else {\n\t\t\treturn this;\n\t\t}"}}}}},"dojo.undo._":{"meta":{"requires":{"common":["dojo.undo.Manager"]}}},"dojo.undo.browser":{"meta":{"requires":{"common":["dojo.io.common"]},"functions":{"tcb":{"meta":{"summary":"","parameters":{"handleName":{"type":""}},"src":" \t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"';\", 1);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\toldCB.apply(this, [handleName]);","call_chain":["oldCB"]}},"tfw":{"meta":{"summary":"","parameters":{"handleName":{"type":""}},"src":" \t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\twindow.location.href = hash;\n\t\t\t\t\t}\n\t\t\t\t\tif(oldFW){ \/\/ we might not actually have one\n\t\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\n\t\t\t\t\t}","call_chain":["oldFW"]}},"dojo.undo.browser.setInitialState":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":" \tthis.initialState = this._createState(this.initialHref, args, this.initialHash);","instance_variables":["initialState"]}},"dojo.undo.browser.addToHistory":{"meta":{"summary":"","parameters":{"args":{"type":""}},"src":" \tthis.forwardStack = []; \n\t\tvar hash = null;\n\t\tvar url = null;\n\t\tif(!this.historyIframe){\n\t\t\tthis.historyIframe = window.frames[\"djhistory\"];\n\t\t}\n\t\tif(!this.bookmarkAnchor){\n\t\t\tthis.bookmarkAnchor = document.createElement(\"a\");\n\t\t\tdojo.body().appendChild(this.bookmarkAnchor);\n\t\t\tthis.bookmarkAnchor.style.display = \"none\";\n\t\t}\n\t\tif(args[\"changeUrl\"]){\n\t\t\thash = \"#\"+ ((args[\"changeUrl\"]!==true) ? args[\"changeUrl\"] : (new Date()).getTime());\n\t\t\t\/\/If the current hash matches the new one, just replace the history object with\n\t\t\t\/\/this new one. It doesn't make sense to track different state objects for the same\n\t\t\t\/\/logical URL. This matches the browser behavior of only putting in one history\n\t\t\t\/\/item no matter how many times you click on the same #hash link, at least in Firefox\n\t\t\t\/\/and Safari, and there is no reliable way in those browsers to know if a #hash link\n\t\t\t\/\/has been clicked on multiple times. So making this the standard behavior in all browsers\n\t\t\t\/\/so that dojo.undo.browser's behavior is the same in all browsers.\n\t\t\tif(this.historyStack.length == 0 && this.initialState.urlHash == hash){\n\t\t\t\tthis.initialState = this._createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}else if(this.historyStack.length > 0 && this.historyStack[this.historyStack.length - 1].urlHash == hash){\n\t\t\t\tthis.historyStack[this.historyStack.length - 1] = this._createState(url, args, hash);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.changingUrl = true;\n\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"'; dojo.undo.browser.changingUrl = false;\", 1);\n\t\t\tthis.bookmarkAnchor.href = hash;\n\t\t\tif(dojo.render.html.ie){\n\t\t\t\turl = this._loadIframeHistory();\n\t\t\t\tvar oldCB = args[\"back\"]||args[\"backButton\"]||args[\"handle\"];\n\t\t\t\t\/\/The function takes handleName as a parameter, in case the\n\t\t\t\t\/\/callback we are overriding was \"handle\". In that case,\n\t\t\t\t\/\/we will need to pass the handle name to handle.\n\t\t\t\tvar tcb = function(handleName){\n\t\t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\tsetTimeout(\"window.location.href = '\"+hash+\"';\", 1);\n\t\t\t\t\t}\n\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\toldCB.apply(this, [handleName]);\n\t\t\t\t}\n\t\t\t\t\/\/Set interceptor function in the right place.\n\t\t\t\tif(args[\"back\"]){\n\t\t\t\t\targs.back = tcb;\n\t\t\t\t}else if(args[\"backButton\"]){\n\t\t\t\t\targs.backButton = tcb;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tcb;\n\t\t\t\t}\n\t\t\t\tvar oldFW = args[\"forward\"]||args[\"forwardButton\"]||args[\"handle\"];\n\t\t\t\t\/\/The function takes handleName as a parameter, in case the\n\t\t\t\t\/\/callback we are overriding was \"handle\". In that case,\n\t\t\t\t\/\/we will need to pass the handle name to handle.\n\t\t\t\tvar tfw = function(handleName){\n\t\t\t\t\tif(window.location.hash != \"\"){\n\t\t\t\t\t\twindow.location.href = hash;\n\t\t\t\t\t}\n\t\t\t\t\tif(oldFW){ \/\/ we might not actually have one\n\t\t\t\t\t\t\/\/Use apply to set \"this\" to args, and to try to avoid memory leaks.\n\t\t\t\t\t\toldFW.apply(this, [handleName]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\/\/Set interceptor function in the right place.\n\t\t\t\tif(args[\"forward\"]){\n\t\t\t\t\targs.forward = tfw;\n\t\t\t\t}else if(args[\"forwardButton\"]){\n\t\t\t\t\targs.forwardButton = tfw;\n\t\t\t\t}else if(args[\"handle\"]){\n\t\t\t\t\targs.handle = tfw;\n\t\t\t\t}\n\t\t\t}else if(dojo.render.html.moz){\n\t\t\t\t\/\/ start the timer\n\t\t\t\tif(!this.locationTimer){\n\t\t\t\t\tthis.locationTimer = setInterval(\"dojo.undo.browser.checkLocation();\", 200);\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\turl = this._loadIframeHistory();\n\t\t}\n\t\tthis.historyStack.push(this._createState(url, args, hash));","instance_variables":["forwardStack","historyIframe","bookmarkAnchor","bookmarkAnchor.style.display","historyStack.length","initialState","changingUrl","bookmarkAnchor.href","locationTimer"],"call_chain":["oldCB","oldFW"]}},"dojo.undo.browser.checkLocation":{"meta":{"summary":"","src":" \tif (!this.changingUrl){\n\t\t\tvar hsl = this.historyStack.length;\n\t\t\tif((window.location.hash == this.initialHash||window.location.href == this.initialHref)&&(hsl == 1)){\n\t\t\t\t\/\/ FIXME: could this ever be a forward button?\n\t\t\t\t\/\/ we can't clear it because we still need to check for forwards. Ugg.\n\t\t\t\t\/\/ clearInterval(this.locationTimer);\n\t\t\t\tthis.handleBackButton();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/ first check to see if we could have gone forward. We always halt on\n\t\t\t\/\/ a no-hash item.\n\t\t\tif(this.forwardStack.length > 0){\n\t\t\t\tif(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){\n\t\t\t\t\tthis.handleForwardButton();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ ok, that didn't work, try someplace back in the history stack\n\t\t\tif((hsl >= 2)&&(this.historyStack[hsl-2])){\n\t\t\t\tif(this.historyStack[hsl-2].urlHash==window.location.hash){\n\t\t\t\t\tthis.handleBackButton();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}"}},"dojo.undo.browser.iframeLoaded":{"meta":{"summary":"","parameters":{"evt":{"type":""},"ifrLoc":{"type":""}},"src":" \tif(!dojo.render.html.opera){\n\t\t\tvar query = this._getUrlQuery(ifrLoc.href);\n\t\t\tif(query == null){ \n\t\t\t\t\/\/ alert(\"iframeLoaded\");\n\t\t\t\t\/\/ we hit the end of the history, so we should go back\n\t\t\t\tif(this.historyStack.length == 1){\n\t\t\t\t\tthis.handleBackButton();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(this.moveForward){\n\t\t\t\t\/\/ we were expecting it, so it's not either a forward or backward movement\n\t\t\t\tthis.moveForward = false;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\/\/Check the back stack first, since it is more likely.\n\t\t\t\/\/Note that only one step back or forward is supported.\n\t\t\tif(this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){\n\t\t\t\tthis.handleBackButton();\n\t\t\t}\n\t\t\telse if(this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){\n\t\t\t\tthis.handleForwardButton();\n\t\t\t}\n\t\t}","instance_variables":["historyStack.length","moveForward"]}},"dojo.undo.browser.handleBackButton":{"meta":{"summary":"","src":" \tvar current = this.historyStack.pop();\n\t\tif(!current){ return; }\n\t\tvar last = this.historyStack[this.historyStack.length-1];\n\t\tif(!last && this.historyStack.length == 0){\n\t\t\tlast = this.initialState;\n\t\t}\n\t\tif (last){\n\t\t\tif(last.kwArgs[\"back\"]){\n\t\t\t\tlast.kwArgs[\"back\"]();\n\t\t\t}else if(last.kwArgs[\"backButton\"]){\n\t\t\t\tlast.kwArgs[\"backButton\"]();\n\t\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\t\tlast.kwArgs.handle(\"back\");\n\t\t\t}\n\t\t}\n\t\tthis.forwardStack.push(current);","instance_variables":["historyStack.length"]}},"dojo.undo.browser.handleForwardButton":{"meta":{"summary":"","src":" \tvar last = this.forwardStack.pop();\n\t\tif(!last){ return; }\n\t\tif(last.kwArgs[\"forward\"]){\n\t\t\tlast.kwArgs.forward();\n\t\t}else if(last.kwArgs[\"forwardButton\"]){\n\t\t\tlast.kwArgs.forwardButton();\n\t\t}else if(last.kwArgs[\"handle\"]){\n\t\t\tlast.kwArgs.handle(\"forward\");\n\t\t}\n\t\tthis.historyStack.push(last);"}},"dojo.undo.browser._createState":{"meta":{"summary":"","parameters":{"url":{"type":""},"args":{"type":""},"hash":{"type":""}},"src":" \treturn {\"url\": url, \"kwArgs\": args, \"urlHash\": hash};\t"}},"dojo.undo.browser._getUrlQuery":{"meta":{"summary":"","parameters":{"url":{"type":""}},"src":" \tvar segments = url.split(\"?\");\n\t\tif (segments.length < 2){\n\t\t\treturn null;\n\t\t}\n\t\telse{\n\t\t\treturn segments[1];\n\t\t}"}},"dojo.undo.browser._loadIframeHistory":{"meta":{"summary":"","src":" \tvar url = dojo.hostenv.getBaseScriptUri()+\"iframe_history.html?\"+(new Date()).getTime();\n\t\tthis.moveForward = true;\n\t\tdojo.io.setIFrameSrc(this.historyIframe, url, false);\t\n\t\treturn url;","instance_variables":["moveForward"]}}},"objects":{"dojo.undo.browser":{"meta":{"variables":["initialHref","initialHash","moveForward","historyStack","forwardStack","historyIframe","bookmarkAnchor","locationTimer"]}}}}}}