if((args["fastMixIn"])||(frag["fastMixIn"])){
	 dojo.profile.start("mixInProperties_fastMixIn");
	 fast mix in assumes case sensitivity, no type casting, etc...
	 dojo.lang.mixin(this, args);
	for(var x in args){
		this[x] = args[x];
	}
	 dojo.profile.end("mixInProperties_fastMixIn");
	return;
}
 dojo.profile.start("mixInProperties");
 * the actual mix-in code attempts to do some type-assignment based on
 * PRE-EXISTING properties of the "this" object. When a named property
 * of a propset is located, it is first tested to make sure that the
 * current object already "has one". Properties which are undefined in
 * the base widget are NOT settable here. The next step is to try to
 * determine type of the pre-existing property. If it's a string, the
 * property value is simply assigned. If a function, the property is
 * replaced with a "new Function()" declaration. If an Array, the
 * system attempts to split the string value on ";" chars, and no
 * further processing is attempted (conversion of array elements to a
 * integers, for instance). If the property value is an Object
 * (testObj.constructor === Object), the property is split first on ";"
 * chars, secondly on ":" chars, and the resulting key/value pairs are
 * assigned to an object in a map style. The onus is on the property
 * user to ensure that all property values are converted to the
 * expected type before usage.

var undef;

 NOTE: we cannot assume that the passed properties are case-correct
 (esp due to some browser bugs). Therefore, we attempt to locate
 properties for assignment regardless of case. This may cause
 problematic assignments and bugs in the future and will need to be
 documented with big bright neon lights.

 FIXME: fails miserably if a mixin property has a default value of null in 
 a widget

 NOTE: caching lower-cased args in the prototype is only 
 acceptable if the properties are invariant.
 if we have a name-cache, get it
var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
if ( lcArgs == null ){
	 build a lower-case property name cache if we don't have one
	lcArgs = {};
	for(var y in this){
		lcArgs[((new String(y)).toLowerCase())] = y;
	}
	dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
}
var visited = {};
for(var x in args){
	if(!this[x]){  check the cache for properties
		var y = lcArgs[(new String(x)).toLowerCase()];
		if(y){
			args[y] = args[x];
			x = y; 
		}
	}
	if(visited[x]){ continue; }
	visited[x] = true;
	if((typeof this[x]) != (typeof undef)){
		if(typeof args[x] != "string"){
			this[x] = args[x];
		}else{
			if(dojo.lang.isString(this[x])){
				this[x] = args[x];
			}else if(dojo.lang.isNumber(this[x])){
				this[x] = new Number(args[x]);  FIXME: what if NaN is the result?
			}else if(dojo.lang.isBoolean(this[x])){
				this[x] = (args[x].toLowerCase()=="false") ? false : true;
			}else if(dojo.lang.isFunction(this[x])){

				 FIXME: need to determine if always over-writing instead
				 of attaching here is appropriate. I suspect that we
				 might want to only allow attaching w/ action items.
				
				 RAR, 1/19/05: I'm going to attach instead of
				 over-write here. Perhaps function objects could have
				 some sort of flag set on them? Or mixed-into objects
				 could have some list of non-mutable properties
				 (although I'm not sure how that would alleviate this
				 particular problem)? 

				 this[x] = new Function(args[x]);

				 after an IRC discussion last week, it was decided
				 that these event handlers should execute in the
				 context of the widget, so that the "this" pointer
				 takes correctly.
				var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
				dojo.event.connect(this, x, this, tn);
			}else if(dojo.lang.isArray(this[x])){  typeof [] == "object"
				this[x] = args[x].split(";");
			} else if (this[x] instanceof Date) {
				this[x] = new Date(Number(args[x]));  assume timestamp
			}else if(typeof this[x] == "object"){ 
				 FIXME: should we be allowing extension here to handle
				 other object types intelligently?

				 FIXME: unlike all other types, we do not replace the
				 object with a new one here. Should we change that?
				var pairs = args[x].split(";");
				for(var y=0; y<pairs.length; y++){
					var si = pairs[y].indexOf(":");
					if((si != -1)&&(pairs[y].length>si)){
						this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, "")] = pairs[y].substr(si+1);
					}
				}
			}else{
				 the default is straight-up string assignment. When would
				 we ever hit this?
				this[x] = args[x];
			}
		}
	}else{
		 collect any extra 'non mixed in' args
		this.extraArgs[x] = args[x];
	}
}
 dojo.profile.end("mixInProperties");