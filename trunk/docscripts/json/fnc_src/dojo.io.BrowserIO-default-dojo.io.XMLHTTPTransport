var _this = this;

this.initialHref = window.location.href;
this.initialHash = window.location.hash;

this.moveForward = false;

var _cache = {};  FIXME: make this public? do we even need to?
this.useCache = false;  if this is true, we'll cache unless kwArgs.useCache = false
this.preventCache = false;  if this is true, we'll always force GET requests to cache
this.historyStack = [];
this.forwardStack = [];
this.historyIframe = null;
this.bookmarkAnchor = null;
this.locationTimer = null;

 NOTES:
 *	Safari 1.2: 
 *		back button "works" fine, however it's not possible to actually
 *		DETECT that you've moved backwards by inspecting window.location.
 *		Unless there is some other means of locating.
 *		FIXME: perhaps we can poll on history.length?
 *	IE 5.5 SP2:
 *		back button behavior is macro. It does not move back to the
 *		previous hash value, but to the last full page load. This suggests
 *		that the iframe is the correct way to capture the back button in
 *		these cases.
 *	IE 6.0:
 *		same behavior as IE 5.5 SP2
 * Firefox 1.0:
 *		the back button will return us to the previous hash on the same
 *		page, thereby not requiring an iframe hack, although we do then
 *		need to run a timer to detect inter-page movement.

 FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?
function getCacheKey(url, query, method) {
	return url + "|" + query + "|" + method.toLowerCase();
}

function addToCache(url, query, method, http) {
	_cache[getCacheKey(url, query, method)] = http;
}

function getFromCache(url, query, method) {
	return _cache[getCacheKey(url, query, method)];
}

 moved successful load stuff here
function doLoad(kwArgs, http, url, query, useCache) {
	if(	(http.status==200)||
		(http.status==304)||
		(location.protocol=="file:" && (http.status==0 || http.status==undefined))
	){
		var ret;
		if(kwArgs.method.toLowerCase() == "head"){
			var headers = http.getAllResponseHeaders();
			ret = {};
			ret.toString = function(){ return headers; }
			var values = headers.split(/[\r\n]+/g);
			for(var i = 0; i < values.length; i++) {
				var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
				if(pair) {
					ret[pair[1]] = pair[2];
				}
			}
		}else if(kwArgs.mimetype == "text/javascript"){
			try{
				ret = dj_eval(http.responseText);
			}catch(e){
				dojo.debug(e);
				dojo.debug(http.responseText);
				ret = null;
			}
		}else if(kwArgs.mimetype == "text/json"){
			try{
				ret = dj_eval("("+http.responseText+")");
			}catch(e){
				dojo.debug(e);
				dojo.debug(http.responseText);
				ret = false;
			}
		}else if((kwArgs.mimetype == "application/xml")||
					(kwArgs.mimetype == "text/xml")){
			ret = http.responseXML;
			if(!ret || typeof ret == "string") {
				ret = dojo.dom.createDocumentFromText(http.responseText);
			}
		}else{
			ret = http.responseText;
		}

		if(useCache){  only cache successful responses
			addToCache(url, query, kwArgs.method, http);
		}
		kwArgs[(typeof kwArgs.load == "function") ? "load" : "handle"]("load", ret, http);
	}else{
		var errObj = new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
		kwArgs[(typeof kwArgs.error == "function") ? "error" : "handle"]("error", errObj, http);
	}
}

 set headers (note: Content-Type will get overriden if kwArgs.contentType is set)
function setHeaders(http, kwArgs){
	if(kwArgs["headers"]) {
		for(var header in kwArgs["headers"]) {
			if(header.toLowerCase() == "content-type" && !kwArgs["contentType"]) {
				kwArgs["contentType"] = kwArgs["headers"][header];
			} else {
				http.setRequestHeader(header, kwArgs["headers"][header]);
			}
		}
	}
}

this.inFlight = [];
this.inFlightTimer = null;

var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;

this.multipartBoundary = "45309FFF-BD65-4d50-99C9-36986896A96F";	 unique guid as a boundary value for multipart posts

dojo.io.transports.addTransport("XMLHTTPTransport");