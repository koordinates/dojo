if(!kwArgs["url"]){
	 are we performing a history action?
	if( !kwArgs["formNode"]
		&& (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"] || kwArgs["watchForURL"])
		&& (!djConfig.preventBackButtonFix)) {
		this.addToHistory(kwArgs);
		return true;
	}
}

 build this first for cache purposes
var url = kwArgs.url;
var query = "";
if(kwArgs["formNode"]){
	var ta = kwArgs.formNode.getAttribute("action");
	if((ta)&&(!kwArgs["url"])){ url = ta; }
	var tp = kwArgs.formNode.getAttribute("method");
	if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
	query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
}

if(url.indexOf("#") > -1) {
	dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
	url = url.split("#")[0];
}

if(kwArgs["file"]){
	 force post for file transfer
	kwArgs.method = "post";
}

if(!kwArgs["method"]){
	kwArgs.method = "get";
}

 guess the multipart value		
if(kwArgs.method.toLowerCase() == "get"){
	 GET cannot use multipart
	kwArgs.multipart = false;
}else{
	if(kwArgs["file"]){
		 enforce multipart when sending files
		kwArgs.multipart = true;
	}else if(!kwArgs["multipart"]){
		 default 
		kwArgs.multipart = false;
	}
}

if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
	this.addToHistory(kwArgs);
}

var content = kwArgs["content"] || {};

if(kwArgs.sendTransport) {
	content["dojo.transport"] = "xmlhttp";
}

do {  break-block
	if(kwArgs.postContent){
		query = kwArgs.postContent;
		break;
	}

	if(content) {
		query += dojo.io.argsFromMap(content, kwArgs.encoding);
	}
	
	if(kwArgs.method.toLowerCase() == "get" || !kwArgs.multipart){
		break;
	}

	var	t = [];
	if(query.length){
		var q = query.split("&");
		for(var i = 0; i < q.length; ++i){
			if(q[i].length){
				var p = q[i].split("=");
				t.push(	"--" + this.multipartBoundary,
						"Content-Disposition: form-data; name=\"" + p[0] + "\"", 
						"",
						p[1]);
			}
		}
	}

	if(kwArgs.file){
		if(dojo.lang.isArray(kwArgs.file)){
			for(var i = 0; i < kwArgs.file.length; ++i){
				var o = kwArgs.file[i];
				t.push(	"--" + this.multipartBoundary,
						"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
						"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
						"",
						o.content);
			}
		}else{
			var o = kwArgs.file;
			t.push(	"--" + this.multipartBoundary,
					"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
					"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
					"",
					o.content);
		}
	}

	if(t.length){
		t.push("--"+this.multipartBoundary+"--", "");
		query = t.join("\r\n");
	}
}while(false);

 kwArgs.Connection = "close";

var async = kwArgs["sync"] ? false : true;

var preventCache = kwArgs["preventCache"] ||
	(this.preventCache == true && kwArgs["preventCache"] != false);
var useCache = kwArgs["useCache"] == true ||
	(this.useCache == true && kwArgs["useCache"] != false );

 preventCache is browser-level (add query string junk), useCache
 is for the local cache. If we say preventCache, then don't attempt
 to look in the cache, but if useCache is true, we still want to cache
 the response
if(!preventCache && useCache){
	var cachedHttp = getFromCache(url, query, kwArgs.method);
	if(cachedHttp){
		doLoad(kwArgs, cachedHttp, url, query, false);
		return;
	}
}

 much of this is from getText, but reproduced here because we need
 more flexibility
var http = dojo.hostenv.getXmlhttpObject(kwArgs);
var received = false;

 build a handler function that calls back to the handler obj
if(async){
	 FIXME: setting up this callback handler leaks on IE!!!
	this.inFlight.push({
		"req":		kwArgs,
		"http":		http,
		"url":		url,
		"query":	query,
		"useCache":	useCache
	});
	this.startWatchingInFlight();
}

if(kwArgs.method.toLowerCase() == "post"){
	 FIXME: need to hack in more flexible Content-Type setting here!
	http.open("POST", url, async);
	setHeaders(http, kwArgs);
	http.setRequestHeader("Content-Type", kwArgs.multipart ? ("multipart/form-data; boundary=" + this.multipartBoundary) : 
		(kwArgs.contentType || "application/x-www-form-urlencoded"));
	http.send(query);
}else{
	var tmpUrl = url;
	if(query != "") {
		tmpUrl += (tmpUrl.indexOf("?") > -1 ? "&" : "?") + query;
	}
	if(preventCache) {
		tmpUrl += (dojo.string.endsWithAny(tmpUrl, "?", "&")
			? "" : (tmpUrl.indexOf("?") > -1 ? "&" : "?")) + "dojo.preventCache=" + new Date().valueOf();
	}
	http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
	setHeaders(http, kwArgs);
	http.send(null);
}

if( !async ) {
	doLoad(kwArgs, http, url, query, useCache);
}

kwArgs.abort = function(){
	return http.abort();
}

return;