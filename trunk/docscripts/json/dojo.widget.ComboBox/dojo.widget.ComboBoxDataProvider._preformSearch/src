var st = type||this.searchType;
 FIXME: this is just an example search, which means that we implement
 only a linear search without any of the attendant (useful!) optimizations
var ret = [];
if(!this.caseSensitive){
	searchStr = searchStr.toLowerCase();
}
for(var x=0; x<this.data.length; x++){
	if((!ignoreLimit)&&(ret.length >= this.searchLimit)){
		break;
	}
	 FIXME: we should avoid copies if possible!
	var dataLabel = new String((!this.caseSensitive) ? this.data[x][0].toLowerCase() : this.data[x][0]);
	if(dataLabel.length < searchStr.length){
		 this won't ever be a good search, will it? What if we start
		 to support regex search?
		continue;
	}

	if(st == "STARTSTRING"){
		 jum.debug(dataLabel.substr(0, searchStr.length))
		 jum.debug(searchStr);
		if(searchStr == dataLabel.substr(0, searchStr.length)){
			ret.push(this.data[x]);
		}
	}else if(st == "SUBSTRING"){
		 this one is a gimmie
		if(dataLabel.indexOf(searchStr) >= 0){
			ret.push(this.data[x]);
		}
	}else if(st == "STARTWORD"){
		 do a substring search and then attempt to determine if the
		 preceeding char was the beginning of the string or a
		 whitespace char.
		var idx = dataLabel.indexOf(searchStr);
		if(idx == 0){
			 implicit match
			ret.push(this.data[x]);
		}
		if(idx <= 0){
			 if we didn't match or implicily matched, march onward
			continue;
		}
		 otherwise, we have to go figure out if the match was at the
		 start of a word...
		 this code is taken almost directy from nWidgets
		var matches = false;
		while(idx!=-1){
			 make sure the match either starts whole string, or
			 follows a space, or follows some punctuation
			if(" ,/(".indexOf(dataLabel.charAt(idx-1)) != -1){
				 FIXME: what about tab chars?
				matches = true; break;
			}
			idx = dataLabel.indexOf(searchStr, tti+1);
		}
		if(!matches){
			continue;
		}else{
			ret.push(this.data[x]);
		}
	}
}
this.provideSearchResults(ret);