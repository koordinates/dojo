var url = kwArgs.url;
var query = "";

if(kwArgs["formNode"]){
	var ta = kwArgs.formNode.getAttribute("action");
	if((ta)&&(!kwArgs["url"])){ url = ta; }
	var tp = kwArgs.formNode.getAttribute("method");
	if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
	query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
}

if(url.indexOf("#") > -1) {
	dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
	url = url.split("#")[0];
}

Break off the domain/path of the URL.
var urlParts = url.split("?");
if(urlParts && urlParts.length == 2){
	url = urlParts[0];
	query += (query ? "&" : "") + urlParts[1];
}

if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
	dojo.undo.browser.addToHistory(kwArgs);
}

var content = kwArgs["content"];

if(kwArgs.sendTransport || kwArgs.jsonp) {
	if (!content){
		content = {};
	}
	if(kwArgs.sendTransport){
		content["dojo.transport"] = "scriptsrc";
	}
	if(kwArgs.jsonp){
		content["jsonp"] = kwArgs.jsonp;
	}
}

if(kwArgs.postContent){
	query = kwArgs.postContent;
}else if(content){
	query += ((query) ? "&" : "") + dojo.io.argsFromMap(content, kwArgs.encoding);
}
END duplication from BrowserIO.js

START DSR

If an apiId is specified, then we want to make sure useRequestId is true.
if(kwArgs["apiId"]){
	kwArgs["useRequestId"] = true;
}

Set up the state for this request.
var id = kwArgs["apiId"] ? kwArgs["apiId"] : "id" + this._counter++;
var state = {
	"id": id,
	"idParam": "_dsrid=" + id,
	"url": url,
	"query": query,
	"kwArgs": kwArgs,
	"startTime": (new Date()).getTime()
};

if(!url){
	Error. An URL is needed.
	this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.none"});
	return;
}

If this is a jsonp request, intercept the jsonp callback
var jsonpMatch = query.match(/jsonp=([^\&]*)/);
if(jsonpMatch){
	state.jsonp = jsonpMatch[1];
	state.jsonpCall = function(data){
		dojo.io.ScriptSrcTransport._finish(this, "jsonp", data);
	};
	state.query = query.replace(/jsonp=([^\&]*)/, "jsonp=dojo.io.ScriptSrcTransport._state['" + id + "'].jsonpCall");
}

Only store the request state on the state tracking object if a callback
is expected or if polling on a checkString will be done.
if(kwArgs["useRequestId"] || kwArgs["checkString"] || state["jsonp"]){
	this._state[id] = state;
}

A checkstring is a string that if evaled will not be undefined once the
script src loads. Used as an alternative to depending on a callback from
the script file. If this is set, then multipart is not assumed to be used,
since multipart requires a specific callback. With checkString we will be doing
polling.
if(kwArgs["checkString"]){
	state.checkString = kwArgs["checkString"];
}

Constant params are parameters that should always be sent with each
part of a multipart URL.
state.constantParams = (kwArgs["constantParams"] == null ? "" : kwArgs["constantParams"]);
	
if(kwArgs["preventCache"] ||
	(this.preventCache == true && kwArgs["preventCache"] != false)){
	state.nocacheParam = "dojo.preventCache=" + new Date().valueOf();
}else{
	state.nocacheParam = "";
}

Get total length URL, if we were to do it as one URL.
Add some padding, extra & separators.
var urlLength = state.url.length + state.query.length + state.constantParams.length 
		+ state.nocacheParam.length + this._extraPaddingLength;

if(kwArgs["useRequestId"]){
	urlLength += state.idParam.length;
}

if(!kwArgs["checkString"] && kwArgs["useRequestId"] 
	&& !state["jsonp"] && !kwArgs["forceSingleRequest"]
	&& urlLength > this.maxUrlLength){
	if(url > this.maxUrlLength){
		Error. The URL domain and path are too long. We can't
		segment that, so return an error.
		this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.tooBig"});
		return;
	}else{
		Start the multiple requests.
		this._multiAttach(state, 1);
	}
}else{
	Send one URL.
	var queryParams = [state.query, state.constantParams, state.nocacheParam];
	if(kwArgs["useRequestId"] && !state["jsonp"]){
		queryParams.push(state.idParam);
	}
	var finalUrl = this._buildUrl(state.url, queryParams);

	Track the final URL in case we need to use that instead of api ID when receiving
	the load callback.
	state.finalUrl = finalUrl;
	
	this._attach(state.id, finalUrl);
}
END DSR

this.startWatchingInFlight();