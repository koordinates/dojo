var errorMessage = "Called getTimestamp() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.";
dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);

if (!returnType) {returnType = null};
switch (returnType) {
	case "string":
	case String:
		return this.getTimestamp(Date).toUTCString();
		break;
	case "hex":
		 Return a 15-character string of hex digits containing the 
		 timestamp for this UUID, with the high-order bits first.
		if (!this._timestampAsHexString) {
			var arrayOfStrings = this._uuidString.split('-');
			var hexTimeLow = arrayOfStrings[0];
			var hexTimeMid = arrayOfStrings[1];
			var hexTimeHigh = arrayOfStrings[2];
		
			 Chop off the leading "1" character, which is the UUID 
			 version number for time-based UUIDs.
			hexTimeHigh = hexTimeHigh.slice(1);
		
			this._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
			dojo.lang.assert(this._timestampAsHexString.length == 15);
		}
		return this._timestampAsHexString;
		break;
	case null:  no returnType was specified, so default to Date
	case "date":
	case Date:
		 Return a JavaScript Date object. 
		if (!this._timestampAsDate) {
			var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
		
			var arrayOfParts = this._uuidString.split('-');
			var timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);
			var timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);
			var timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);
			var hundredNanosecondIntervalsSince1582 = timeHigh & 0x0FFF;
			hundredNanosecondIntervalsSince1582 <<= 16;
			hundredNanosecondIntervalsSince1582 += timeMid;
			 What we really want to do next is shift left 32 bits, but the 
			 result will be too big to fit in an int, so we'll multiply by 2^32,
			 and the result will be a floating point approximation.
			hundredNanosecondIntervalsSince1582 *= 0x100000000;
			hundredNanosecondIntervalsSince1582 += timeLow;
			var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
		
			 Again, this will be a floating point approximation.
			 We can make things exact later if we need to.
			var secondsPerHour = 60 * 60;
			var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
			var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
			var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
			var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
		
			this._timestampAsDate = new Date(millisecondsSince1970);
		}
		return this._timestampAsDate;
		break;
	default:
		 we got passed something other than a valid returnType
		dojo.lang.assert(false, "The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: " + returnType);
		break;
}