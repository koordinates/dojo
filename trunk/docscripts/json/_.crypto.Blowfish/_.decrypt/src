var ip=dojo.crypto.outputTypes.Base64;
var mode=dojo.crypto.cipherModes.EBC;
if (ao){
	if (ao.outputType) ip=ao.outputType;
	if (ao.cipherMode) mode=ao.cipherMode;
}
var bx = init(key);
var pt=[];
	
var c=null;
switch(ip){
	case dojo.crypto.outputTypes.Hex:{
		c=[];
		var i=0;
		while (i+1<ciphertext.length){
			c.push(parseInt(ciphertext.substr(i,2),16));
			i+=2;
		}
		break;
	}
	case dojo.crypto.outputTypes.String:{
		c=[];
		for (var i=0; i<ciphertext.length; i++){
			c.push(ciphertext.charCodeAt(i));
		}
		break;
	}
	case dojo.crypto.outputTypes.Raw:{
		c=ciphertext;		should be a byte array
		break;
	}
	default:{
		c=fromBase64(ciphertext);
		break;
	}
}

var count=c.length >> 3;
var pos=0;
var o={};
var isCBC=(mode==dojo.crypto.cipherModes.CBC);
var vector={left:iv.left||null, right:iv.right||null};
for(var i=0; i<count; i++){
	o.left=c[pos]*POW24|c[pos+1]*POW16|c[pos+2]*POW8|c[pos+3];
	o.right=c[pos+4]*POW24|c[pos+5]*POW16|c[pos+6]*POW8|c[pos+7];

	if(isCBC){
		var left=o.left;
		var right=o.right;
	}

	db(o, bx);		decrypt the block

	if(isCBC){
		o.left=xor(o.left, vector.left);
		o.right=xor(o.right, vector.right);
		vector.left=left;
		vector.right=right;
	}

	pt.push((o.left>>24)&0xff);
	pt.push((o.left>>16)&0xff);
	pt.push((o.left>>8)&0xff);
	pt.push(o.left&0xff);
	pt.push((o.right>>24)&0xff);
	pt.push((o.right>>16)&0xff);
	pt.push((o.right>>8)&0xff);
	pt.push(o.right&0xff);
	pos+=8;
}

	check for padding, and remove.
if(pt[pt.length-1]==pt[pt.length-2]||pt[pt.length-1]==0x01){
	var n=pt[pt.length-1];
	pt.splice(pt.length-n, n);
}

	convert to string
for(var i=0; i<pt.length; i++)
	pt[i]=String.fromCharCode(pt[i]);
return pt.join("");