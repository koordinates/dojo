<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dojo Tree Tutorial</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1a"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1"></a>Dojo Tree Tutorial</h2></div></div><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4"></a>Introduction</h3></div></div></div><p>Tree is a generic thing, a "must have" of any widget collection. 
        Unfortunately, javacript toolkit should be lightweight, so I couldn't take a Swing
        tree component and simply copy it. Almost all components are optional and event-based,
        feel free to hook on whatever you'd like.
    </p><p>
        Basic things are shown in tests (dojo/tests/widget/treeV3), so you might want to check them first and copy-paste
        exactly the things you need. The tutorial is meant to provide deeper understanding for those
        who want to extend/modify tree behavior.
     </p><p>
        This documentation refers to new treeV3, not to stable and old dojo Tree widget.
        Feel free to suggest features and test/critisize existing solutions. 
    </p><p>This is just a draft, but I'd be grateful for your replies. The contacts are
       </p><div class="itemizedlist"><ul type="disc"><li>IRC: Freenode, #dojo by nick [algo]</li><li>ICQ: 820317</li><li>Dojo mailing lists: "Ilia Kantor" ilia @ dojotoolkit.org</li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e23"></a>What's new in TreeV3</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li>New HTML/CSS structure, lightweight and easier to style</li><li>Code rewritten completely, event system changed</li><li>Multiline content support</li><li>Add TreeDocIcon extension instead of builtin childIcon support</li><li>New extensions model with examples and out-of-the box ready extensions</li><li>classPrefix property allows different trees be styled with different CSS class families</li><li>Design is moved to CSS completely. A bunch of classes was introduced to reflect TreeNode state</li><li>Implicit helper widget creations were removed. Now you need to create/assigns them explicitly with JS or markup.</li><li>Many features were moved from core into extensions</li><li>Lazy creation feature allows to create graphical widgets from node data only when they need to be shown</li><li>Major speedup</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e49"></a>TODO for TreeV3</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li>Denote interface so any widget may become a treeNode</li><li>Add document.write() for all images to prevent IE dynamic loading on every expand. Maybe put this functionality into CSS parser?</li><li>Allow passing nested arrays from server for TreeLoadingController</li><li>Allow other objects be dropped onto treenodes (call getTreeNode)</li><li>Allow inline editing of node title via context-menu--edit or other bindings</li><li>Add refresh/reset method to loading controllers</li><li>Make unselectable extension (on treeChange bindings)</li><li>Automated unit-testing system on Selenium</li><li>Optimize all gifs with AGO carefully. AGO spoils transparent gifs sometimes</li><li>Need a way to inform user about finishing of expandToLevel or expansion from indices operations, that may involve async &amp; loading features</li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e73"></a>BUGS</h4></div></div></div><div class="itemizedlist"><ul type="disc"></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e77"></a>Possible TODO</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>On Drag'n'drop tree 'wobbles', because node size increases/decreases when it is
            bordered.  Could be nice to evade it, either placing another transparent div with border onto
            the node or decreasing their size, or using padding divs, or..</li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e83"></a>Performance</h3></div></div></div><p>Tree was coded with performance in mind. Although, JavaScript itself is a slow language.
        Flexible model requires some code that slows it down. It's not DOM manipulations, but actually
        javascript that I couldn't make lighter. Being a part of dojo/widget structure also implies some overhead, but also power.
    </p><p>        
        Almost all operations require small constant time when single node is involved. Depending on your
        application you may notice slowdown when (most common) creating lots of nodes or
        performing other batch operations.
    </p><p>
        In my tests 1000 nodes required 0.7-0.8 sec, growth is linear, depth does not matter, children
        are created with  <code class="code">createSimple</code> and added to parent all at once with <code class="code">setChildren</code>.                
    </p><p>Creation from markup or with standard create/addChild routines is  2-3 times slower,
        because these routines are generic.</p><p>Memory footprint (IE,FF) is about 1M per 100 nodes, that were not postponed by lazy creation feature</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e102"></a>Comparison</h4></div></div></div><p>Fast node creation with dojo tree is 2-3 times slower than xtree 1.7, another tree widget, not
            so featured, but nicely optimized for performance.
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>These tests are in-dev tests carried on early stages. The results may change, but not much.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e109"></a>Performance tricks</h3></div></div></div><p>
    When talking about performance, one should understand, that there are <span class="type">single-node operations</span>
        
    that operate on single node... These ones are fast. The examples are: create a node, delete a node,
     move a node along the tree.
    </p><p>... And there are batch operations that touch a lot of nodes. The examples are: 
        initial tree creation,  moving a node from one tree to another which has different listeners, etc.</p><p>That performance issues become noticeable at 100-300 tree nodes depending on your trees.
        All algorithms are linear in worst case, but JS is slow language, DOM is also not that fast. 
      </p><p>There is a number of features one could use to get a speedup.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e123"></a>Lazy loading</h4></div></div></div><p>A node can be created with <code class="code">isFolder=true</code> flag, but without children.
            Any node has a <code class="code">state</code>, initially UNCHECKED for empty folder, and used
            by  TreeLoadingController.</p><p>When a user presses expand, tree controller (supporting lazy loading) will send a request to server asking for nodes,
            and parse the answer creating children.</p><p>The benefit is obvious: you don't have to load/process whole tree at once.
            You can only load a single node and user will load the rest clicking "expand"</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e138"></a>Lazy creation</h4></div></div></div><p>
            Node/tree keeps array of its children in <code class="code">children</code> property. 
            Lazy creation is somewhat a half-way approach to lazy loading. It allows you to put data objects 
            into this array and tree will create widgets of them later, when they are expanded.
        </p><p>For instance, one can call <code class="code">node.children = [{title:'node1'},{title:'node2'}]</code>.
            The objects will be set, but no widgets are created. You can also set children to nested array:
            <code class="code">node.children = [{title:'node1', children:[{title:'node2'}] }]</code>.    
            
        </p><p>You can create tree on server, JSON-serialize it and put to HTML, that is gzip-compressed.
            Compression will be 10 times or more, so it is not that space hungry. 
        </p><p>The benefit comes from postponing almost all real job: widget creation and attaching it to tree will
        happen in expansion-time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e158"></a>Comparison between lazy creation and lazy loading</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li>You need web-service for lazy loading, not for lazy creation</li><li>No network waits for lazy creation</li><li>Lazy creation gives you the tree right here. You can search data objects and modify them
                    without spending time and memory on graphical widgets</li></ul></div><p>Sometimes, lazy creation and loading may work together nicely, providing seamless increase
                in speed and decrease in memory footprint. For instance, server may pass a whole tree branch in JSON
            to lazy loading controller. Top nodes will be created right along, because user needs them, but the rest
            of the branch will be postponed relying on lazy creation feature.</p></div><p>
            There are operations, like "expandAll" where such lazy tricks don't help. That is why
            widget creation process is well-optimized itself. <code class="code">createSimple</code> is a hacky program-only way
            to create TreeNodes fast. <code class="code">setChildren</code> is a method to assign (and create if needed)
            all children at once. It helps to evade some extra work happening when children are added one by one.
           </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e178"></a>Components</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Tree</span></dt><dd>Tree and TreeNode classes handle both data and view</dd><dt><span class="term">Controllers</span></dt><dd><div class="variablelist"><dl><dt><span class="term">TreeBasicController</span></dt><dd>Controller that provides all capabilities but no server calls</dd><dt><span class="term">TreeLoadingController</span></dt><dd>Added dynamic node loading from server</dd><dt><span class="term">TreeRPCController</span></dt><dd>All actions call server</dd></dl></div></dd><dt><span class="term">Selector</span></dt><dd>TreeSelector handles node selection. Currently, only single node can be selected</dd><dt><span class="term">Drag'n'Drop</span></dt><dd>TreeDragSource, TreeDropTarget and TreeDNDController are classes that
                allow nodes to be dragged, to be dropped on and mechanism binding that together.
                Sources are located under src/dnd folder, not among widgets. </dd><dt><span class="term">Context menu</span></dt><dd>TreeContextMenu inherits dojo context menu to provide a lightweight right-click
                menu. There is a single menu object for all nodes, although it always knows its target</dd><dt><span class="term">Style &amp; icons</span></dt><dd>Tree.css and icons are located under src/widget/templates and provide basic style
                used by default. 
                </dd><dt><span class="term">Extensions</span></dt><dd>TreeControllerExtension contains additional functions for controller that you might need
            </dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e232"></a>Tree model</h3></div></div></div><p>Two classes handle the model: <code class="classname">Tree</code> is root node and
    <code class="classname">TreeNode</code> is any  other node, linked by <code class="methodname">parent</code>
    and <code class="methodname">children[]</code> properties. Many functions implemented in <code class="classname">Tree</code>
        are mixed into TreeNode.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e252"></a>Extensions</h3></div></div></div><p>Extensions provide additional functionality by either adding new methods or hooking on events</p><p>Additional aim of writing them is to demonstrate how one can do certain things.</p><p>You can declare extensions in markup by listing them in <code class="code">extension</code> property.</p><p>An extension is declared just like any other widget and it has special <code class="code">loadExtension</code> method that applies it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e269"></a>How-to</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e272"></a>Make tree unselectable</h4></div></div></div><p>Sometimes people want tree nodes to be unselectable, sometimes selection is a good way to copy (part of) content from the node.</p><p>To make tree (or its elements) unselectable use dojo.html.disableSelection in nodeCreate and treeCreate hooks.
            Apply disableSelection to every node you want to make unselectable.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e279"></a>Add custom properties to tree</h4></div></div></div><p>There is an "objectId" property and "object" property ready to be filled in from markup or program-way.</p></div></div></div></body></html>