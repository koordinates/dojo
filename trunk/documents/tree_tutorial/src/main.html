<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Dojo Tree Tutorial</title><meta name="generator" content="DocBook XSL Stylesheets V1.69.1a"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1"></a>Dojo Tree Tutorial</h2></div></div><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e4"></a>Introduction</h3></div></div></div><p>Tree is a generic thing, a "must have" of any widget collection. 
        Unfortunately, javacript toolkit should be lightweight, so I couldn't take a Swing
        tree component and simply copy it. Almost all components are optional and event-based,
        feel free to hook on whatever you'd like.
    </p><p>
        Basic things are shown in tests (dojo/tests/widget/treeV3), so you might want to check them first and copy-paste
        exactly the things you need. The tutorial is meant to provide deeper understanding for those
        who want to extend/modify tree behavior.
     </p><p>
        This documentation refers to new treeV3, not to stable and old dojo Tree widget.
        Feel free to suggest features and test/critisize existing solutions. 
    </p><p>This is just a draft, but I'd be grateful for your replies. The contacts are
       </p><div class="itemizedlist"><ul type="disc"><li>IRC: Freenode, #dojo by nick [algo]</li><li>ICQ: 820317</li><li>Dojo mailing lists: "Ilia Kantor" ilia @ dojotoolkit.org</li></ul></div><p>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e23"></a>What's new in TreeV3</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li>New HTML/CSS structure
            
            <div class="itemizedlist"><ul type="circle"><li>Nested divs</li><li>All design in CSS through classes and class combinations</li><li>Different trees be styled with different CSS class families</li><li>Multiline content supported</li></ul></div></li><li>Core rewritten completely, event system modified</li><li>Lazy creation feature allows to create graphical widgets from node data only when they need to be shown.
           
            <div class="itemizedlist"><ul type="circle"><li> If it is enabled, old code may call widget methods on data objects while traversing a tree</li></ul></div></li><li>Many features were moved from core into extensions
        
            <div class="itemizedlist"><ul type="circle"><li>Add TreeDocIcon extension instead of builtin childIcon support</li></ul></div></li><li>Implicit helpers(controller,selector) were removed. Now you need to create/assigns them explicitly with JS or markup.</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e52"></a>TODO for TreeV3</h3></div></div></div><div class="itemizedlist"><ul type="disc"><li>Denote interface so any widget may become a treeNode</li><li>Add document.write() for all images to prevent IE dynamic loading on every expand. Maybe put this functionality into CSS parser?</li><li>Allow passing nested arrays from server for TreeLoadingController</li><li>Allow other objects be dropped onto treenodes (call getTreeNode)</li><li>Allow inline editing of node title via context-menu--edit or other bindings. Make RPCController work w/ it. (events?)</li><li>Add refresh/reset method to loading controllers</li><li>Make unselectable extension (on treeChange bindings)</li><li>make it possible: Is it possible right now to use lazy loading to get a full tree &#8220;branch&#8221; and then use lazy creation for all levels except the top level? I am thinking that you can&#8217;t right now and that the barrier is the TreeLoadingController not being able to decode nested arrays. Is this right?</li><li>Automated unit-testing system based on Selenium</li><li>Optimize all gifs with AGO carefully. AGO spoils transparent gifs sometimes</li><li>Need a way to inform user about finishing of expandToLevel or expansion from indices operations, that may involve async &amp; loading features</li><li>Make SortChildren extension to keep nodes sorted</li><li>Solve use case<div class="literallayout"><p><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;have&nbsp;a&nbsp;tree&nbsp;where&nbsp;each&nbsp;level&nbsp;has&nbsp;the&nbsp;same&nbsp;'type'.&nbsp;Example:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;typea<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----&nbsp;typeb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------&nbsp;typec<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------&nbsp;typec<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------&nbsp;typec<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----&nbsp;typeb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----&nbsp;typeb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------&nbsp;typec<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;----------&nbsp;typec<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-----&nbsp;typeb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;want&nbsp;to&nbsp;be&nbsp;able&nbsp;to&nbsp;dnd&nbsp;(between)&nbsp;only&nbsp;for&nbsp;the&nbsp;same&nbsp;type&nbsp;for&nbsp;subtrees.&nbsp;The&nbsp;examples&nbsp;I&nbsp;have&nbsp;(DnD&nbsp;nodes&nbsp;within&nbsp;a&nbsp;tree&nbsp;or&nbsp;between&nbsp;two&nbsp;trees)&nbsp;doesn't&nbsp;seem&nbsp;to&nbsp;help.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p></div></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e84"></a>BUGS</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>none reported</li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e90"></a>Possible TODO</h4></div></div></div><div class="itemizedlist"><ul type="disc"><li>On Drag'n'drop tree 'wobbles', because node size increases/decreases when it is
            bordered.  Could be nice to evade it, either placing another transparent div with border onto
            the node or decreasing their size, or using padding divs, or..</li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e96"></a>Features</h3></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>We will have that all, but not everything in place right now</div><div class="itemizedlist"><ul type="disc"><li>Flexible styling            
            <div class="itemizedlist"><ul type="circle"><li>All design in CSS through classes and class combinations</li><li>Different trees be styled with different CSS class families</li><li>Multiline content support</li></ul></div></li><li>Full set of node operations
            <div class="itemizedlist"><ul type="circle"><li>expand/collapse</li><li>create with JS or markup</li><li>destroy/move/clone/edit</li><li>addChild/detach/(de)folderize</li><li>batch operations</li><li>drag'n'drop</li></ul></div></li><li>Written with performance in mind</li><li>Integrated lazy loading &amp; RPC features</li><li>Rich event system</li><li>Extension system with out-of-the box working examples</li><li>Tests and documentation</li></ul></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>The rest of the document is draft and may be outdated. Lazy loading &amp; RPC stuff is not ready yet.</div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e138"></a>Performance</h3></div></div></div><p>Tree was coded with performance in mind. Although, JavaScript itself is a slow language.
        Flexible model requires some code that slows it down. It's not DOM manipulations, but actually
        javascript that I couldn't make lighter. Being a part of dojo/widget structure also implies some overhead, but also power.
    </p><p>        
        Almost all operations require small constant time when single node is involved. Depending on your
        application you may notice slowdown when (most common) creating lots of nodes or
        performing other batch operations.
    </p><p>
        In my tests 1000 nodes required 0.7-0.8 sec, growth is linear, depth does not matter, children
        are created with  <code class="code">createSimple</code> and added to parent all at once with <code class="code">setChildren</code>.                
    </p><p>Creation from markup or with standard create/addChild routines is  2-3 times slower,
        because these routines are generic.</p><p>Memory footprint (IE,FF) is about 1M per 100 nodes, that were not postponed by lazy creation feature</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e157"></a>Comparison</h4></div></div></div><p>Fast node creation with dojo tree is 2-3 times slower than xtree 1.7, another tree widget, not
            so featured, but nicely optimized for performance.
        </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3>These tests are in-dev tests carried on early stages. The results may change, but not much.</div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e164"></a>Performance tricks</h3></div></div></div><p>
    When talking about performance, one should understand, that there are <span class="type">single-node operations</span>
        
    that operate on single node... These ones are fast. The examples are: create a node, delete a node,
     move a node along the tree.
    </p><p>... And there are batch operations that touch a lot of nodes. The examples are: 
        initial tree creation,  moving a node from one tree to another which has different listeners, etc.</p><p>That performance issues become noticeable at 100-300 tree nodes depending on your trees.
        All algorithms are linear in worst case, but JS is slow language, DOM is also not that fast. 
      </p><p>There is a number of features one could use to get a speedup.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e178"></a>Lazy loading</h4></div></div></div><p>A node can be created with <code class="code">isFolder=true</code> flag, but without children.
            Any node has a <code class="code">state</code>, initially UNCHECKED for empty folder, and used
            by  TreeLoadingController.</p><p>When a user presses expand, tree controller (supporting lazy loading) will send a request to server asking for nodes,
            and parse the answer creating children.</p><p>The benefit is obvious: you don't have to load/process whole tree at once.
            You can only load a single node and user will load the rest clicking "expand"</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e193"></a>Lazy creation</h4></div></div></div><p>
            Node/tree keeps array of its children in <code class="code">children</code> property. 
            Lazy creation is somewhat a half-way approach to lazy loading. It allows you to put data objects 
            into this array and tree will create widgets of them later, when they are expanded.
        </p><p>For instance, one can call <code class="code">node.children = [{title:'node1'},{title:'node2'}]</code>.
            The objects will be set, but no widgets are created. You can also set children to nested array:
            <code class="code">node.children = [{title:'node1', children:[{title:'node2'}] }]</code>.    
            
        </p><p>You can create tree on server, JSON-serialize it and put to HTML, that is gzip-compressed.
            Compression will be 6 times or more, so it is not that space hungry. 
        </p><p>The benefit comes from postponing almost all real job: widget creation and attaching it to tree will
        happen in expansion-time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="d0e213"></a>Comparison between lazy creation and lazy loading</h5></div></div></div><div class="itemizedlist"><ul type="disc"><li>You need web-service for lazy loading, not for lazy creation</li><li>No network waits for lazy creation</li><li>Lazy creation gives you the tree right here. You can search data objects and modify them
                    without spending time and memory on graphical widgets</li></ul></div><p>Sometimes, lazy creation and loading may work together nicely, providing seamless increase
                in speed and decrease in memory footprint. For instance, server may pass a whole tree branch in JSON
            to lazy loading controller. Top nodes will be created right along, because user needs them, but the rest
            of the branch will be postponed relying on lazy creation feature.</p></div><p>
            There are operations, like "expandAll" where such lazy tricks don't help, because all graphical widgets must be processed. That is why
            widget creation process is well-optimized itself. <code class="code">createSimple</code> is a hacky program-only way
            to create TreeNodes fast. <code class="code">setChildren</code> is a method to assign (and create if needed)
            all children at once. It helps to evade some extra work happening when children are added one by one.
           </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e233"></a>IE image-reloading fixup</h4></div></div></div><p>IE has a well-known bug. If an image was loaded dynamically - with a <code class="code">new Image()</code>, or <code class="code">img.src=</code>
            assignment, or even as a background of a new node, it will not be cached. So every time when you create a node, all needed icons get loaded
            from server (or requested at least). A possible solution is to put a special div into HTML (adjust src to your path):
        </p><div class="literallayout"><p>&lt;div&nbsp;style="display:none"&gt;<br>
&nbsp;&nbsp;&lt;!--&nbsp;IE&nbsp;has&nbsp;a&nbsp;bug:&nbsp;it&nbsp;reloads&nbsp;all&nbsp;dynamically&nbsp;resolved&nbsp;images,&nbsp;no&nbsp;matter,&nbsp;is&nbsp;it&nbsp;<br>
&nbsp;&nbsp;new&nbsp;Image()&nbsp;or&nbsp;CSS&nbsp;background.&nbsp;If&nbsp;you&nbsp;don't&nbsp;specify&nbsp;images&nbsp;like&nbsp;that,<br>
&nbsp;&nbsp;it&nbsp;will&nbsp;reload&nbsp;them&nbsp;every&nbsp;time&nbsp;a&nbsp;new&nbsp;node&nbsp;is&nbsp;created&nbsp;--&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i_half.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_minus.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_plus.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/expand_leaf.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/i_long.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/document.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/open.gif"/&gt;<br>
&nbsp;&nbsp;&lt;img&nbsp;src="../../../src/widget/templates/images/TreeV3/closed.gif"/&gt;<br>
&lt;/div&gt;</p></div><p>
        
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e247"></a>Components</h3></div></div></div><div class="variablelist"><dl><dt><span class="term">Tree</span></dt><dd>Tree and TreeNode classes handle both data and view</dd><dt><span class="term">Controllers</span></dt><dd><div class="variablelist"><dl><dt><span class="term">TreeBasicController</span></dt><dd>Controller that provides all capabilities but no server calls</dd><dt><span class="term">TreeLoadingController</span></dt><dd>Added dynamic node loading from server</dd><dt><span class="term">TreeRPCController</span></dt><dd>All actions call server</dd></dl></div></dd><dt><span class="term">Selector</span></dt><dd>TreeSelector handles node selection. Currently, only single node can be selected</dd><dt><span class="term">Drag'n'Drop</span></dt><dd>TreeDragSource, TreeDropTarget and TreeDNDController are classes that
                allow nodes to be dragged, to be dropped on and mechanism binding that together.
                Sources are located under src/dnd folder, not among widgets. </dd><dt><span class="term">Context menu</span></dt><dd>TreeContextMenu inherits dojo context menu to provide a lightweight right-click
                menu. There is a single menu object for all nodes, although it always knows its target</dd><dt><span class="term">Style &amp; icons</span></dt><dd>Tree.css and icons are located under src/widget/templates and provide basic style
                used by default. 
                </dd><dt><span class="term">Extensions</span></dt><dd>TreeControllerExtension contains additional functions for controller that you might need
            </dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e301"></a>Tree model</h3></div></div></div><p>Two classes handle the model: <code class="classname">TreeV3</code> is "tree" itself and somewhat a root node, while
    <code class="classname">TreeNodeV3</code> is any  other node, linked by <code class="methodname">parent</code>
    and <code class="methodname">children[]</code> properties. There is a common mixin <code class="classname">TreeWithNode</code>.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e321"></a>Tree parameters</h4></div></div></div><p><code class="methodname">listeners</code> specifies a list of widgetIds.
            They will be called AFTER tree itself is initialized, but BEFORE any nodes get added. This allows them to hook on node creation events,
            mostly useful for markup creation.
          </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e328"></a>Extensions</h3></div></div></div><p>Extensions provide additional functionality by either adding new methods or hooking on events</p><p>Additional aim of writing them is to demonstrate how one can do certain things.</p><p>You can declare extensions in markup by listing them in <code class="code">extension</code> property.</p><p>An extension is declared just like any other widget and it has special <code class="code">loadExtension</code> method that applies it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="d0e345"></a>How-to</h3></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e348"></a>Make tree unselectable</h4></div></div></div><p>TODO: write extension
            Sometimes people want tree nodes to be unselectable, sometimes selection is a good way to copy (part of) content from the node.</p><p>To make tree (or its elements) unselectable use dojo.html.disableSelection in nodeCreate and treeCreate hooks.
            Apply disableSelection to every node you want to make unselectable.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e355"></a>Bind an object to tree node</h4></div></div></div><p>There is an "objectId" property and "object" property ready to be filled in from markup or program-way.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="d0e360"></a>Walk all node descendants</h4></div></div></div><p>You may use <code class="code">dojo.lang.forEach(nodeOrTree.getDescendants(),function(elem) { ... })</code> to process all descendants,
            it will walk <code class="methodname">children</code> property recursively.        
            
        </p><p>The safer way would be to call <code class="code">TreeCommon.prototype.processDescendants(nodeOrTree, filter, func)</code>, it will process all children
        with <code class="code">func</code>, but will not descend into nodes if <code class="code">filter(node)</code> returns false. E.g see <code class="methodname">collapseAll</code>
            controller method uses it to collapse all widgets, but skip non-folders and data objects. 
        </p></div></div></div></body></html>