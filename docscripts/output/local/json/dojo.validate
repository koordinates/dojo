{"dojo.validate._":{"meta":{"requires":{"common":["dojo.validate.check","dojo.validate.datetime","dojo.validate.de","dojo.validate.jp","dojo.validate.us","dojo.validate.web","dojo.validate"]}}},"dojo.validate.check":{"meta":{"requires":{"common":["dojo.validate.common","dojo.lang.common"]},"functions":{"dojo.validate.check":{"meta":{"summary":"validates user input of an HTML form based on input profile","parameters":{"form":{"type":"HTMLFormElement"},"profile":{"type":"Object"}},"src":"\t\/\/ Essentially private properties of results object\n\tvar missing = [];\n\tvar invalid = [];\n\t\/\/ results object summarizes the validation\n\tvar results = {\n\t\tisSuccessful: function() {return ( !this.hasInvalid() && !this.hasMissing() );},\n\t\thasMissing: function() {return ( missing.length > 0 );},\n\t\tgetMissing: function() {return missing;},\n\t\tisMissing: function(elemname) {\n\t\t\tfor(var i = 0; i < missing.length; i++){\n\t\t\t\tif(elemname == missing[i]){ return true; }\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\thasInvalid: function() {return ( invalid.length > 0 );},\n\t\tgetInvalid: function() {return invalid;},\n\t\tisInvalid: function(elemname){\n\t\t\tfor(var i = 0; i < invalid.length; i++){\n\t\t\t\tif(elemname == invalid[i]){ return true; }\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\t\/\/ Filters are applied before fields are validated.\n\t\/\/ Trim removes white space at the front and end of the fields.\n\tif(profile.trim instanceof Array){\n\t\tfor(var i = 0; i < profile.trim.length; i++){\n\t\t\tvar elem = form[profile.trim[i]];\n\t\t\tif(dj_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\n\t\t\telem.value = elem.value.replace(\/(^\\s*|\\s*$)\/g, \"\");\n\t\t}\n\t}\n\t\/\/ Convert to uppercase\n\tif(profile.uppercase instanceof Array){\n\t\tfor(var i = 0; i < profile.uppercase.length; i++){\n\t\t\tvar elem = form[profile.uppercase[i]];\n\t\t\tif(dj_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\n\t\t\telem.value = elem.value.toUpperCase();\n\t\t}\n\t}\n\t\/\/ Convert to lowercase\n\tif(profile.lowercase instanceof Array){\n\t\tfor (var i = 0; i < profile.lowercase.length; i++){\n\t\t\tvar elem = form[profile.lowercase[i]];\n\t\t\tif(dj_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\n\t\t\telem.value = elem.value.toLowerCase();\n\t\t}\n\t}\n\t\/\/ Uppercase first letter\n\tif(profile.ucfirst instanceof Array){\n\t\tfor(var i = 0; i < profile.ucfirst.length; i++){\n\t\t\tvar elem = form[profile.ucfirst[i]];\n\t\t\tif(dj_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\n\t\t\telem.value = elem.value.replace(\/\\b\\w+\\b\/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });\n\t\t}\n\t}\n\t\/\/ Remove non digits characters from the input.\n\tif(profile.digit instanceof Array){\n\t\tfor(var i = 0; i < profile.digit.length; i++){\n\t\t\tvar elem = form[profile.digit[i]];\n\t\t\tif(dj_undef(\"type\", elem) || elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; }\n\t\t\telem.value = elem.value.replace(\/\\D\/g, \"\");\n\t\t}\n\t}\n\t\/\/ See if required input fields have values missing.\n\tif(profile.required instanceof Array){\n\t\tfor(var i = 0; i < profile.required.length; i++){ \n\t\t\tif(!dojo.lang.isString(profile.required[i])){ continue; }\n\t\t\tvar elem = form[profile.required[i]];\n\t\t\t\/\/ Are textbox, textarea, or password fields blank.\n\t\t\tif(!dj_undef(\"type\", elem) && (elem.type == \"text\" || elem.type == \"textarea\" || elem.type == \"password\") && \/^\\s*$\/.test(elem.value)){\t\n\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t}\n\t\t\t\/\/ Does drop-down box have option selected.\n\t\t\telse if(!dj_undef(\"type\", elem) && (elem.type == \"select-one\" || elem.type == \"select-multiple\") \n\t\t\t\t\t\t&& (elem.selectedIndex == -1 \n\t\t\t\t\t\t|| \/^\\s*$\/.test(elem.options[elem.selectedIndex].value))){\n\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t}\n\t\t\t\/\/ Does radio button group (or check box group) have option checked.\n\t\t\telse if(elem instanceof Array){\n\t\t\t\tvar checked = false;\n\t\t\t\tfor(var j = 0; j < elem.length; j++){\n\t\t\t\t\tif (elem[j].checked) { checked = true; }\n\t\t\t\t}\n\t\t\t\tif(!checked){\t\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ See if checkbox groups and select boxes have x number of required values.\n\tif(profile.required instanceof Array){\n\t\tfor (var i = 0; i < profile.required.length; i++){ \n\t\t\tif(!dojo.lang.isObject(profile.required[i])){ continue; }\n\t\t\tvar elem, numRequired;\n\t\t\tfor(var name in profile.required[i]){ \n\t\t\t\telem = form[name]; \n\t\t\t\tnumRequired = profile.required[i][name];\n\t\t\t}\n\t\t\t\/\/ case 1: elem is a check box group\n\t\t\tif(elem instanceof Array){\n\t\t\t\tvar checked = 0;\n\t\t\t\tfor(var j = 0; j < elem.length; j++){\n\t\t\t\t\tif(elem[j].checked){ checked++; }\n\t\t\t\t}\n\t\t\t\tif(checked < numRequired){\t\n\t\t\t\t\tmissing[missing.length] = elem[0].name;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ case 2: elem is a select box\n\t\t\telse if(!dj_undef(\"type\", elem) && elem.type == \"select-multiple\" ){\n\t\t\t\tvar selected = 0;\n\t\t\t\tfor(var j = 0; j < elem.options.length; j++){\n\t\t\t\t\tif (elem.options[j].selected && !\/^\\s*$\/.test(elem.options[j].value)) { selected++; }\n\t\t\t\t}\n\t\t\t\tif(selected < numRequired){\t\n\t\t\t\t\tmissing[missing.length] = elem.name;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ Dependent fields are required when the target field is present (not blank).\n\t\/\/ Todo: Support dependent and target fields that are radio button groups, or select drop-down lists.\n\t\/\/ Todo: Make the dependency based on a specific value of the target field.\n\t\/\/ Todo: allow dependent fields to have several required values, like {checkboxgroup: 3}.\n\tif(dojo.lang.isObject(profile.dependencies) || dojo.lang.isObject(profile.dependancies)){\n\t\tif(profile[\"dependancies\"]){\n\t\t\tdojo.deprecated(\"dojo.validate.check\", \"profile 'dependancies' is deprecated, please use \"\n\t\t\t\t\t\t\t+ \"'dependencies'\", \"0.5\");\n\t\t\tprofile.dependencies=profile.dependancies;\n\t\t}\n\t\t\/\/ properties of dependencies object are the names of dependent fields to be checked\n\t\tfor(name in profile.dependencies){\n\t\t\tvar elem = form[name];\t\/\/ the dependent element\n\t\t\tif(dj_undef(\"type\", elem)){continue;}\n\t\t\tif(elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\"){ continue; } \/\/ limited support\n\t\t\tif(\/\\S+\/.test(elem.value)){ continue; }\t\/\/ has a value already\n\t\t\tif(results.isMissing(elem.name)){ continue; }\t\/\/ already listed as missing\n\t\t\tvar target = form[profile.dependencies[name]];\n\t\t\tif(target.type != \"text\" && target.type != \"textarea\" && target.type != \"password\"){ continue; }\t\/\/ limited support\n\t\t\tif(\/^\\s*$\/.test(target.value)){ continue; }\t\/\/ skip if blank\n\t\t\tmissing[missing.length] = elem.name;\t\/\/ ok the dependent field is missing\n\t\t}\n\t}\n\t\/\/ Find invalid input fields.\n\tif(dojo.lang.isObject(profile.constraints)){\n\t\t\/\/ constraint properties are the names of fields to bevalidated\n\t\tfor(name in profile.constraints){\n\t\t\tvar elem = form[name];\n\t\t\tif(!elem) {continue;}\n\t\t\t\/\/ skip if blank - its optional unless required, in which case it\n\t\t\t\/\/ is already listed as missing.\n\t\t\tif(!dj_undef(\"tagName\",elem) \n\t\t\t\t&& (elem.tagName.toLowerCase().indexOf(\"input\") >= 0\n\t\t\t\t\t|| elem.tagName.toLowerCase().indexOf(\"textarea\") >= 0) \n\t\t\t\t&& \/^\\s*$\/.test(elem.value)){ \n\t\t\t\tcontinue; \n\t\t\t}\n\t\t\tvar isValid = true;\n\t\t\t\/\/ case 1: constraint value is validation function\n\t\t\tif(dojo.lang.isFunction(profile.constraints[name])){\n\t\t\t\tisValid = profile.constraints[name](elem.value);\n\t\t\t}else if(dojo.lang.isArray(profile.constraints[name])){\n\t\t\t\t\/\/ handle nested arrays for multiple constraints\n\t\t\t\tif(dojo.lang.isArray(profile.constraints[name][0])){\n\t\t\t\t\tfor (var i=0; i<profile.constraints[name].length; i++){\n\t\t\t\t\t\tisValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name][i], name, elem);\n\t\t\t\t\t\tif(!isValid){ break; }\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\t\/\/ case 2: constraint value is array, first elem is function,\n\t\t\t\t\t\/\/ tail is parameters\n\t\t\t\t\tisValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name], name, elem);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!isValid){\t\n\t\t\t\tinvalid[invalid.length] = elem.name;\n\t\t\t}\n\t\t}\n\t}\n\t\/\/ Find unequal confirm fields and report them as Invalid.\n\tif(dojo.lang.isObject(profile.confirm)){\n\t\tfor(name in profile.confirm){\n\t\t\tvar elem = form[name];\t\/\/ the confirm element\n\t\t\tvar target = form[profile.confirm[name]];\n\t\t\tif (dj_undef(\"type\", elem) || dj_undef(\"type\", target) || (elem.type != \"text\" && elem.type != \"textarea\" && elem.type != \"password\") \n\t\t\t\t||(target.type != elem.type)\n\t\t\t\t||(target.value == elem.value)\t\/\/ it's valid\n\t\t\t\t||(results.isInvalid(elem.name))\/\/ already listed as invalid\n\t\t\t\t||(\/^\\s*$\/.test(target.value)))\t\/\/ skip if blank - only confirm if target has a value\n\t\t\t{\n\t\t\t\tcontinue; \n\t\t\t}\n\t\t\tinvalid[invalid.length] = elem.name;\n\t\t}\n\t}\n\treturn results; \/\/ Object","returns":"Object"},"extra":{"returns":"an object that contains several methods summarizing the results of the validation","parameters":{"form":{"type":"form","summary":"to be validated"},"profile":{"type":"specifies","summary":"how the form fields are to be validated {trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array, required:Array, dependencies:Object, constraints:Object, confirm:Object}"}}}},"dojo.validate.evaluateConstraint":{"meta":{"summary":"Evaluates dojo.validate.check() constraints that are specified as array arguments","parameters":{"profile":{"type":""},"constraint":{"type":"Array"},"fieldName":{"type":""},"elem":{"type":""}},"src":" \tvar isValidSomething = constraint[0];\n\tvar params = constraint.slice(1);\n\tparams.unshift(elem.value);\n\tif(typeof isValidSomething != \"undefined\"){\n\t\treturn isValidSomething.apply(null, params);\n\t}\n\treturn false; \/\/ Boolean","description":"The arrays are expected to be in the format of: constraints:{","returns":"Boolean","call_chain":["isValidSomething"]},"extra":{"parameters":{"fieldName":{"type":"The","summary":"form dom name of the field being validated."},"profile":{"type":"The","summary":"dojo.validate.check() profile that this evaluation is against."},"constraint":{"type":"The","summary":"single [] array of function and arguments for the function."},"elem":{"type":"The","summary":"form element field."}}}}}}},"dojo.validate.common":{"meta":{"requires":{"common":["dojo.regexp"]},"functions":{"dojo.validate.isText":{"meta":{"summary":"Checks if a string has non whitespace characters. Parameters allow you to constrain the length.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tflags = (typeof flags == \"object\") ? flags : {};\n\t\/\/ test for text\n\tif(\/^\\s*$\/.test(value)){ return false; } \/\/ Boolean\n\t\/\/ length tests\n\tif(typeof flags.length == \"number\" && flags.length != value.length){ return false; } \/\/ Boolean\n\tif(typeof flags.minlength == \"number\" && flags.minlength > value.length){ return false; } \/\/ Boolean\n\tif(typeof flags.maxlength == \"number\" && flags.maxlength < value.length){ return false; } \/\/ Boolean\n\treturn true; \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"maxlength","summary":"If set, checks if there are at most flags.maxlength number of characters."}}}},"dojo.validate.isInteger":{"meta":{"summary":"Validates whether a string is in an integer format","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.integer(flags) + \"$\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"separator","summary":"The character used as the thousands separator. Default is no separator. For more than one symbol use an array, e.g. [\",\", \"\"], makes ',' optional."}}}},"dojo.validate.isRealNumber":{"meta":{"summary":"Validates whether a string is a real valued number. Format is the usual exponential notation.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.realNumber(flags) + \"$\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"in","summary":"regexp.integer can be applied."}}}},"dojo.validate.isCurrency":{"meta":{"summary":"Validates whether a string denotes a monetary value.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.currency(flags) + \"$\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"decimal","summary":"The character used for the decimal point. Default is \".\"."}}}},"dojo.validate.isInRange":{"meta":{"summary":"Validates whether a string denoting an integer, real number, or monetary value is between a max and min.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\t\/\/stripping the separator allows NaN to perform as expected, if no separator, we assume ','\n\t\/\/once i18n support is ready for this, instead of assuming, we default to i18n's recommended value\n\tvalue = value.replace(dojo.lang.has(flags,'separator')?flags.separator:',', '', 'g').\n\t\treplace(dojo.lang.has(flags,'symbol')?flags.symbol:'$', '');\n\tif(isNaN(value)){\n\t\treturn false; \/\/ Boolean\n\t}\n\t\/\/ assign default values to missing paramters\n\tflags = (typeof flags == \"object\") ? flags : {};\n\tvar max = (typeof flags.max == \"number\") ? flags.max : Infinity;\n\tvar min = (typeof flags.min == \"number\") ? flags.min : -Infinity;\n\tvar dec = (typeof flags.decimal == \"string\") ? flags.decimal : \".\";\n\t\/\/ splice out anything not part of a number\n\tvar pattern = \"[^\" + dec + \"\\\\deE+-]\";\n\tvalue = value.replace(RegExp(pattern, \"g\"), \"\");\n\t\/\/ trim ends of things like e, E, or the decimal character\n\tvalue = value.replace(\/^([+-]?)(\\D*)\/, \"$1\");\n\tvalue = value.replace(\/(\\D*)$\/, \"\");\n\t\/\/ replace decimal with \".\". The minus sign '-' could be the decimal!\n\tpattern = \"(\\\\d)[\" + dec + \"](\\\\d)\";\n\tvalue = value.replace(RegExp(pattern, \"g\"), \"$1.$2\");\n\tvalue = Number(value);\n\tif ( value < min || value > max ) { return false; } \/\/ Boolean\n\treturn true; \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"decimal","summary":"The character used for the decimal point. Default is \".\"."}}}},"dojo.validate.isNumberFormat":{"meta":{"summary":"Validates any sort of number based format","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.numberFormat(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","description":"Use it for phone numbers, social security numbers, zip-codes, etc. The value can be validated against one format or one of multiple formats. Format # Stands for a digit, 0-9. ? Stands for an optional digit, 0-9 or nothing. All other characters must appear literally in the expression. Example \"(###) ###-####\" -> (510) 542-9742 \"(###) ###-#### x#???\" -> (510) 542-9742 x153 \"###-##-####\" -> 506-82-1089 i.e. social security number \"#####-####\" -> 98225-1649 i.e. zip code","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"format","summary":"A string or an Array of strings for multiple formats."}}}},"dojo.validate.isValidLuhn":{"meta":{"summary":"Compares value against the Luhn algorithm to verify its integrity","parameters":{"value":{"type":"String"}},"src":" var sum, parity, curDigit;\n\tif(typeof value!='string'){\n\t\tvalue = String(value);\n\t}\n\tvalue = value.replace(\/[- ]\/g,''); \/\/ignore dashes and whitespaces\n\tparity = value.length%2;\n\tsum=0;\n\tfor(var i=0;i<value.length;i++){\n\t\tcurDigit = parseInt(value.charAt(i));\n\t\tif(i%2==parity){\n\t\t\tcurDigit*=2;\n\t\t}\n\t\tif(curDigit>9){\n\t\t\tcurDigit-=9;\n\t\t}\n\t\tsum+=curDigit;\n\t}\n\treturn !(sum%10); \/\/Boolean","returns":"Boolean"}}}}},"dojo.validate.creditCard":{"meta":{"requires":{"common":["dojo.lang.common","dojo.validate.common"]},"functions":{"dojo.validate.isValidCreditCard":{"meta":{"summary":"","parameters":{"value":{"type":"String|Int"},"ccType":{"type":"String"}},"src":" if(value&&ccType&&((ccType.toLowerCase()=='er'||dojo.validate.isValidLuhn(value))&&(dojo.validate.isValidCreditCardNumber(value,ccType.toLowerCase())))){\n\t\t\treturn true; \/\/Boolean\n\t}\n\treturn false; \/\/Boolean","returns":"Boolean"}},"dojo.validate.isValidCreditCardNumber":{"meta":{"summary":"","parameters":{"value":{"type":"String|Int"},"ccType":{"type":"String?"}},"src":" if(typeof value!='string'){\n\t\tvalue = String(value);\n\t}\n\tvalue = value.replace(\/[- ]\/g,''); \/\/ignore dashes and whitespaces\n\t\/* \tFIXME: not sure on all the abbreviations for credit cards,below is what each stands for atleast to my knowledge\n\t\tmc: Mastercard\n\t\tec: Eurocard\n\t\tvi: Visa\n\t\tax: American Express\n\t\tdc: Diners Club\n\t\tbl: Carte Blanch\n\t\tdi: Discover\n\t\tjcb: JCB\n\t\ter: Enroute\n\t *\/\n\tvar results=[];\n\tvar cardinfo = {\n\t\t'mc':'5[1-5][0-9]{14}','ec':'5[1-5][0-9]{14}','vi':'4([0-9]{12}|[0-9]{15})',\n\t\t'ax':'3[47][0-9]{13}', 'dc':'3(0[0-5][0-9]{11}|[68][0-9]{12})',\n\t\t'bl':'3(0[0-5][0-9]{11}|[68][0-9]{12})','di':'6011[0-9]{12}',\n\t\t'jcb':'(3[0-9]{15}|(2131|1800)[0-9]{11})','er':'2(014|149)[0-9]{11}'\n\t};\n\tif(ccType&&dojo.lang.has(cardinfo,ccType.toLowerCase())){\n\t\treturn Boolean(value.match(cardinfo[ccType.toLowerCase()])); \/\/ boolean\n\t}else{\n\t\tfor(var p in cardinfo){\n\t\t\tif(value.match('^'+cardinfo[p]+'$')!=null){\n\t\t\t\tresults.push(p);\n\t\t\t}\n\t\t}\n\t\treturn (results.length)?results.join('|'):false; \/\/ string | boolean\n\t}\t","returns":"mixed"},"extra":{"parameters":{"value":{"type":"Summary","summary":"checks if the # matches the pattern for that card or any card types if none is specified CC #, white spaces and dashes are ignored"},"ccType":{"type":"is","summary":"of the values in cardinfo -- if Omitted it it returns a | delimited string of matching card types, or false if no matches found Value: Boolean"}}}},"dojo.validate.isValidCvv":{"meta":{"summary":"","parameters":{"value":{"type":"String|Int"},"ccType":{"type":"String"}},"src":" if(typeof value!='string'){\n\t\tvalue=String(value);\n\t}\n\tvar format;\n\tswitch (ccType.toLowerCase()){\n\t\tcase 'mc':\n\t\tcase 'ec':\n\t\tcase 'vi':\n\t\tcase 'di':\n\t\t\tformat = '###';\n\t\t\tbreak;\n\t\tcase 'ax':\n\t\t\tformat = '####';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false; \/\/Boolean\n\t}\n\tvar flags = {format:format};\n\t\/\/FIXME? Why does isNumberFormat take an object for flags when its only parameter is either a string or an array inside the object?\n\tif ((value.length == format.length)&&(dojo.validate.isNumberFormat(value, flags))){\n\t\treturn true; \/\/Boolean\n\t}\n\treturn false; \/\/Boolean","returns":"Boolean"},"extra":{"returns":"Summary: true if the security code (CCV) matches the correct format for supplied ccType Value: Boolean"}}}}},"dojo.validate.datetime":{"meta":{"requires":{"common":["dojo.validate.common"]},"functions":{"dojo.validate.isValidTime":{"meta":{"summary":"","parameters":{"value":{"type":""},"flags":{"type":""}},"src":" dojo.deprecated(\"dojo.validate.datetime\", \"use dojo.date.parse instead\", \"0.5\");\n\tvar re = new RegExp(\"^\" + dojo.regexp.time(flags) + \"$\", \"i\");\n\treturn re.test(value);"}},"dojo.validate.is12HourTime":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":" dojo.deprecated(\"dojo.validate.datetime\", \"use dojo.date.parse instead\", \"0.5\");\n\treturn dojo.validate.isValidTime(value, {format: [\"h:mm:ss t\", \"h:mm t\"]});"}},"dojo.validate.is24HourTime":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":" dojo.deprecated(\"dojo.validate.datetime\", \"use dojo.date.parse instead\", \"0.5\");\n\treturn dojo.validate.isValidTime(value, {format: [\"HH:mm:ss\", \"HH:mm\"]} );"}},"dojo.validate.isValidDate":{"meta":{"summary":"","parameters":{"dateValue":{"type":""},"format":{"type":""}},"src":" dojo.deprecated(\"dojo.validate.datetime\", \"use dojo.date.parse instead\", \"0.5\");\n\t\/\/ Default is the American format\n\tif (typeof format == \"object\" && typeof format.format == \"string\"){ format = format.format; }\n\tif (typeof format != \"string\") { format = \"MM\/DD\/YYYY\"; }\n\t\/\/ Create a literal regular expression based on format\n\tvar reLiteral = format.replace(\/([$^.*+?=!:|\\\/\\\\\\(\\)\\[\\]\\{\\}])\/g, \"\\\\$1\");\n\t\/\/ Convert all the tokens to RE elements\n\treLiteral = reLiteral.replace( \"YYYY\", \"([0-9]{4})\" );\n\treLiteral = reLiteral.replace( \"MM\", \"(0[1-9]|10|11|12)\" );\n\treLiteral = reLiteral.replace( \"M\", \"([1-9]|10|11|12)\" );\n\treLiteral = reLiteral.replace( \"DDD\", \"(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])\" );\n\treLiteral = reLiteral.replace( \"DD\", \"(0[1-9]|[12][0-9]|30|31)\" );\n\treLiteral = reLiteral.replace( \"D\", \"([1-9]|[12][0-9]|30|31)\" );\n\treLiteral = reLiteral.replace( \"ww\", \"(0[1-9]|[1-4][0-9]|5[0-3])\" );\n\treLiteral = reLiteral.replace( \"d\", \"([1-7])\" );\n\t\/\/ Anchor pattern to begining and end of string\n\treLiteral = \"^\" + reLiteral + \"$\";\n\t\/\/ Dynamic RE that parses the original format given\n\tvar re = new RegExp(reLiteral);\n\t\/\/ Test if date is in a valid format\n\tif (!re.test(dateValue))  return false;\n\t\/\/ Parse date to get elements and check if date is valid\n\t\/\/ Assume valid values for date elements not given.\n\tvar year = 0, month = 1, date = 1, dayofyear = 1, week = 1, day = 1;\n\t\/\/ Capture tokens\n\tvar tokens = format.match( \/(YYYY|MM|M|DDD|DD|D|ww|d)\/g );\n\t\/\/ Capture date values\n\tvar values = re.exec(dateValue);\n\t\/\/ Match up tokens with date values\n\tfor (var i = 0; i < tokens.length; i++) {\n\t\tswitch (tokens[i]) {\n\t\tcase \"YYYY\":\n\t\t\tyear = Number(values[i+1]); break;\n\t\tcase \"M\":\n\t\tcase \"MM\":\n\t\t\tmonth = Number(values[i+1]); break;\n\t\tcase \"D\":\n\t\tcase \"DD\":\n\t\t\tdate = Number(values[i+1]); break;\n\t\tcase \"DDD\":\n\t\t\tdayofyear = Number(values[i+1]); break;\n\t\tcase \"ww\":\n\t\t\tweek = Number(values[i+1]); break;\n\t\tcase \"d\":\n\t\t\tday = Number(values[i+1]); break;\n\t\t}\n\t}\n\t\/\/ Leap years are divisible by 4, but not by 100, unless by 400\n\tvar leapyear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));\n\t\/\/ 31st of a month with 30 days\n\tif (date == 31 && (month == 4 || month == 6 || month == 9 || month == 11)) return false; \n\t\/\/ February 30th or 31st\n\tif (date >= 30 && month == 2) return false; \n\t\/\/ February 29th outside a leap year\n\tif (date == 29 && month == 2 && !leapyear) return false; \n\tif (dayofyear == 366 && !leapyear)  return false;\n\treturn true;"}}}}},"dojo.validate.de":{"meta":{"requires":{"common":["dojo.validate.common"]},"functions":{"dojo.validate.isGermanCurrency":{"meta":{"summary":"checks to see if 'value' is a valid representation of German currency (Euros)","parameters":{"value":{"type":"String"}},"src":" var flags = {\n\t\tsymbol: \"\\u20AC\",\n\t\tplacement: \"after\",\n\t\tsignPlacement: \"begin\", \/\/TODO: this is really locale-dependent.  Will get fixed in v0.5 currency rewrite. \n\t\tdecimal: \",\",\n\t\tseparator: \".\"\n\t};\n\treturn dojo.validate.isCurrency(value, flags); \/\/ Boolean","returns":"Boolean"}}}}},"dojo.validate.jp":{"meta":{"requires":{"common":["dojo.validate.common"]},"functions":{"dojo.validate.isJapaneseCurrency":{"meta":{"summary":"checks to see if 'value' is a valid representation of Japanese currency","parameters":{"value":{"type":"String"}},"src":" var flags = {\n\t\tsymbol: \"\\u00a5\",\n\t\tfractional: false\n\t};\n\treturn dojo.validate.isCurrency(value, flags); \/\/ Boolean","returns":"Boolean"}}}}},"dojo.validate.us":{"meta":{"requires":{"common":["dojo.validate.common"]},"functions":{"dojo.validate.us.isCurrency":{"meta":{"summary":"Validates U.S. currency","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":" return dojo.validate.isCurrency(value, flags); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"the","summary":"representation to check"},"flags":{"type":"flags","summary":"in validate.isCurrency can be applied."}}}},"dojo.validate.us.isState":{"meta":{"summary":"Validates US state and territory abbreviations.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.us.state(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"two character string"},"flags":{"type":"allowMilitary","summary":"Allow military 'states', e.g. Armed Forces Europe (AE). Default is true."}}}},"dojo.validate.us.isPhoneNumber":{"meta":{"summary":"Validates 10 US digit phone number for several common formats","parameters":{"value":{"type":"String"}},"src":"\tvar flags = {\n\t\tformat: [\n\t\t\t\"###-###-####\",\n\t\t\t\"(###) ###-####\",\n\t\t\t\"(###) ### ####\",\n\t\t\t\"###.###.####\",\n\t\t\t\"###\/###-####\",\n\t\t\t\"### ### ####\",\n\t\t\t\"###-###-#### x#???\",\n\t\t\t\"(###) ###-#### x#???\",\n\t\t\t\"(###) ### #### x#???\",\n\t\t\t\"###.###.#### x#???\",\n\t\t\t\"###\/###-#### x#???\",\n\t\t\t\"### ### #### x#???\",\n\t\t\t\"##########\"\n\t\t]\n\t};\n\treturn dojo.validate.isNumberFormat(value, flags); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"The","summary":"telephone number string"}}}},"dojo.validate.us.isSocialSecurityNumber":{"meta":{"summary":"Validates social security number","parameters":{"value":{"type":"String"}},"src":" var flags = {\n\t\tformat: [\n\t\t\t\"###-##-####\",\n\t\t\t\"### ## ####\",\n\t\t\t\"#########\"\n\t\t]\n\t};\n\treturn dojo.validate.isNumberFormat(value, flags); \/\/ Boolean","returns":"Boolean"}},"dojo.validate.us.isZipCode":{"meta":{"summary":"Validates U.S. zip-code","parameters":{"value":{"type":"String"}},"src":" var flags = {\n\t\tformat: [\n\t\t\t\"#####-####\",\n\t\t\t\"##### ####\",\n\t\t\t\"#########\",\n\t\t\t\"#####\"\n\t\t]\n\t};\n\treturn dojo.validate.isNumberFormat(value, flags); \/\/ Boolean","returns":"Boolean"}}}}},"dojo.validate.web":{"meta":{"requires":{"common":["dojo.validate.common"]},"functions":{"dojo.validate.isIpAddress":{"meta":{"summary":"Validates an IP address","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.ipAddress(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","description":"Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal. Supports 2 formats for Ipv6.","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string."},"flags":{"type":"allowHybrid","summary":"IPv6 address written as six groups of four hexadecimal digits followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d"}}}},"dojo.validate.isUrl":{"meta":{"summary":"Checks if a string could be a valid URL","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.url(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.validate.isEmailAddress":{"meta":{"summary":"Checks if a string could be a valid email address","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.emailAddress(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.validate.isEmailAddressList":{"meta":{"summary":"Checks if a string could be a valid email address list.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tvar re = new RegExp(\"^\" + dojo.regexp.emailAddressList(flags) + \"$\", \"i\");\n\treturn re.test(value); \/\/ Boolean","returns":"Boolean"},"extra":{"parameters":{"value":{"type":"A","summary":"string."},"flags":{"type":"in","summary":"regexp.tld can be applied."}}}},"dojo.validate.getEmailAddressList":{"meta":{"summary":"Check if value is an email address list. If an empty list is returned, the value didn't pass the test or it was empty.","parameters":{"value":{"type":"String"},"flags":{"type":"Object?"}},"src":"\tif(!flags) { flags = {}; }\n\tif(!flags.listSeparator) { flags.listSeparator = \"\\\\s;,\"; }\n\tif ( dojo.validate.isEmailAddressList(value, flags) ) {\n\t\treturn value.split(new RegExp(\"\\\\s*[\" + flags.listSeparator + \"]\\\\s*\")); \/\/ Array\n\t}\n\treturn []; \/\/ Array","returns":"Array"},"extra":{"parameters":{"value":{"type":"A","summary":"string"},"flags":{"type":"An","summary":"object (same as dojo.validate.isEmailAddressList)"}}}}}}},"dojo.validate":{"meta":{"requires":{"common":["dojo.validate.common"]}}}}