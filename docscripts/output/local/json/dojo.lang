{"dojo.lang._":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.assert","dojo.lang.array","dojo.lang.type","dojo.lang.func","dojo.lang.extras","dojo.lang.repr","dojo.lang.declare"]}}},"dojo.lang.array":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.has":{"meta":{"summary":"","parameters":{"obj":{"type":"Object"},"name":{"type":"String"}},"src":" \ttry{\n\t\t\treturn typeof obj[name] != \"undefined\";\n\t\t}catch(e){ return false; }"}},"dojo.lang.isEmpty":{"meta":{"summary":"can be used to determine if the passed object is \"empty\". In the case of array-like objects, the length, property is examined, but for other types of objects iteration is used to examine the iterable \"surface area\" to determine if any non-prototypal properties have been assigned. This iteration is prototype-extension safe.","parameters":{"obj":{"type":"Object"}},"src":" \tif(dojo.lang.isObject(obj)){\n\t\t\tvar tmp = {};\n\t\t\tvar count = 0;\n\t\t\tfor(var x in obj){\n\t\t\t\tif(obj[x] && (!tmp[x])){\n\t\t\t\t\tcount++;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t}\n\t\t\treturn count == 0; \/\/ boolean\n\t\t}else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)){\n\t\t\treturn obj.length == 0; \/\/ boolean\n\t\t}","returns":"boolean"}},"dojo.lang.map":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"obj":{"type":"Object|Function"},"unary_func":{"type":"Function?"}},"src":" \tvar isString = dojo.lang.isString(arr);\n\t\tif(isString){\n\t\t\t\/\/ arr: String\n\t\t\tarr = arr.split(\"\");\n\t\t}\n\t\tif(dojo.lang.isFunction(obj)&&(!unary_func)){\n\t\t\tunary_func = obj;\n\t\t\tobj = dj_global;\n\t\t}else if(dojo.lang.isFunction(obj) && unary_func){\n\t\t\t\/\/ ff 1.5 compat\n\t\t\tvar tmpObj = obj;\n\t\t\tobj = unary_func;\n\t\t\tunary_func = tmpObj;\n\t\t}\n\t\tif(Array.map){\n\t\t\tvar outArr = Array.map(arr, unary_func, obj);\n\t\t}else{\n\t\t\tvar outArr = [];\n\t\t\tfor(var i=0;i<arr.length;++i){\n\t\t\t\toutArr.push(unary_func.call(obj, arr[i]));\n\t\t\t}\n\t\t}\n\t\tif(isString) {\n\t\t\treturn outArr.join(\"\"); \/\/ String\n\t\t} else {\n\t\t\treturn outArr; \/\/ Array\n\t\t}","returns":"mixed","call_chain":["unary_func"]}},"dojo.lang.reduce":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"initialValue":{"type":""},"obj":{"type":"Object|null"},"binary_func":{"type":"Function"}},"src":" \tvar reducedValue = initialValue;\n\t\tvar ob = obj ? obj : dj_global;\n\t\tdojo.lang.map(arr, \n\t\t\tfunction(val){\n\t\t\t\treducedValue = binary_func.call(ob, reducedValue, val);\n\t\t\t}\n\t\t);\n\t\treturn reducedValue;","call_chain":["binary_func"]}},"dojo.lang.forEach":{"meta":{"summary":"","parameters":{"anArray":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tif(dojo.lang.isString(anArray)){\n\t\t\t\/\/ anArray: String\n\t\t\tanArray = anArray.split(\"\"); \n\t\t}\n\t\tif(Array.forEach){\n\t\t\tArray.forEach(anArray, callback, thisObject);\n\t\t}else{\n\t\t\t\/\/ FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?\n\t\t\tif(!thisObject){\n\t\t\t\tthisObject=dj_global;\n\t\t\t}\n\t\t\tfor(var i=0,l=anArray.length; i<l; i++){ \n\t\t\t\tcallback.call(thisObject, anArray[i], i, anArray);\n\t\t\t}\n\t\t}","call_chain":["callback"]}},"dojo.lang._everyOrSome":{"meta":{"summary":"","parameters":{"every":{"type":"Boolean"},"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tif(dojo.lang.isString(arr)){ \n\t\t\t\/\/arr: String\n\t\t\tarr = arr.split(\"\"); \n\t\t}\n\t\tif(Array.every){\n\t\t\treturn Array[ every ? \"every\" : \"some\" ](arr, callback, thisObject);\n\t\t}else{\n\t\t\tif(!thisObject){\n\t\t\t\tthisObject = dj_global;\n\t\t\t}\n\t\t\tfor(var i=0,l=arr.length; i<l; i++){\n\t\t\t\tvar result = callback.call(thisObject, arr[i], i, arr);\n\t\t\t\tif(every && !result){\n\t\t\t\t\treturn false; \/\/ Boolean\n\t\t\t\t}else if((!every)&&(result)){\n\t\t\t\t\treturn true; \/\/ Boolean\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Boolean(every); \/\/ Boolean\n\t\t}","returns":"Boolean","call_chain":["callback"]}},"dojo.lang.every":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \treturn this._everyOrSome(true, arr, callback, thisObject); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.some":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \treturn this._everyOrSome(false, arr, callback, thisObject); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.filter":{"meta":{"summary":"","parameters":{"arr":{"type":"Array"},"callback":{"type":"Function"},"thisObject":{"type":"Object?"}},"src":" \tvar isString = dojo.lang.isString(arr);\n\t\tif(isString){ \/*arr: String*\/arr = arr.split(\"\"); }\n\t\tvar outArr;\n\t\tif(Array.filter){\n\t\t\toutArr = Array.filter(arr, callback, thisObject);\n\t\t} else {\n\t\t\tif(!thisObject){\n\t\t\t\tif(arguments.length >= 3){ dojo.raise(\"thisObject doesn't exist!\"); }\n\t\t\t\tthisObject = dj_global;\n\t\t\t}\n\t\t\toutArr = [];\n\t\t\tfor(var i = 0; i < arr.length; i++){\n\t\t\t\tif(callback.call(thisObject, arr[i], i, arr)){\n\t\t\t\t\toutArr.push(arr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(isString){\n\t\t\treturn outArr.join(\"\"); \/\/ String\n\t\t} else {\n\t\t\treturn outArr; \/\/ Array\n\t\t}","returns":"mixed","call_chain":["callback"]}},"dojo.lang.unnest":{"meta":{"summary":"Creates a 1-D array out of all the arguments passed, unravelling any array-like objects in the process usage: unnest(1, 2, 3) ==> [1, 2, 3] unnest(1, [2, [3], [[[4]]]]) ==> [1, 2, 3, 4]","src":"\t\tvar out = [];\n\t\tfor(var i = 0; i < arguments.length; i++){\n\t\t\tif(dojo.lang.isArrayLike(arguments[i])){\n\t\t\t\tvar add = dojo.lang.unnest.apply(this, arguments[i]);\n\t\t\t\tout = out.concat(add);\n\t\t\t}else{\n\t\t\t\tout.push(arguments[i]);\n\t\t\t}\n\t\t}\n\t\treturn out; \/\/ Array","returns":"Array","call_chain":["dojo.lang.unnest"]}},"dojo.lang.toArray":{"meta":{"summary":"Converts an array-like object (i.e. arguments, DOMCollection) to an array","parameters":{"arrayLike":{"type":"Object"},"startOffset":{"type":"Number"}},"src":" \tvar array = [];\n\t\tfor(var i = startOffset||0; i < arrayLike.length; i++){\n\t\t\tarray.push(arrayLike[i]);\n\t\t}\n\t\treturn array; \/\/ Array","returns":"Array"}}}}},"dojo.lang.assert":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.array","dojo.lang.type"]},"functions":{"dojo.lang.assert":{"meta":{"summary":"","parameters":{"booleanValue":{"type":"boolean"},"message":{"type":"string?"}},"src":"\t \/\/ throws: Throws an Error if 'booleanValue' is false.\n\t if(!booleanValue){\n\t\tvar errorMessage = \"An assert statement failed.\\n\" +\n\t\t\t\"The method dojo.lang.assert() was called with a 'false' value.\\n\";\n\t\tif(message){\n\t\t\terrorMessage += \"Here's the assert message:\\n\" + message + \"\\n\";\n\t\t}\n\t\t\/\/ Use throw instead of dojo.raise, until bug #264 is fixed:\n\t\t\/\/ dojo.raise(errorMessage);\n\t\tthrow new Error(errorMessage);\n\t}"}},"dojo.lang.assertType":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"},"type":{"type":"misc."},"keywordParameters":{"type":"object?"}},"src":" if (dojo.lang.isString(keywordParameters)) {\n\t\tdojo.deprecated('dojo.lang.assertType(value, type, \"message\")', 'use dojo.lang.assertType(value, type) instead', \"0.5\");\n\t}\n\tif(!dojo.lang.isOfType(value, type, keywordParameters)){\n\t\tif(!dojo.lang.assertType._errorMessage){\n\t\t\tdojo.lang.assertType._errorMessage = \"Type mismatch: dojo.lang.assertType() failed.\";\n\t\t}\n\t\tdojo.lang.assert(false, dojo.lang.assertType._errorMessage);\n\t}"}},"dojo.lang.assertValidKeywords":{"meta":{"summary":"examples:","parameters":{"object":{"type":"object"},"expectedProperties":{"type":"array"},"message":{"type":"string?"}},"src":" var key;\n\tif(!message){\n\t\tif(!dojo.lang.assertValidKeywords._errorMessage){\n\t\t\tdojo.lang.assertValidKeywords._errorMessage = \"In dojo.lang.assertValidKeywords(), found invalid keyword:\";\n\t\t}\n\t\tmessage = dojo.lang.assertValidKeywords._errorMessage;\n\t}\n\tif(dojo.lang.isArray(expectedProperties)){\n\t\tfor(key in object){\n\t\t\tif(!dojo.lang.inArray(expectedProperties, key)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(key in object){\n\t\t\tif(!(key in expectedProperties)){\n\t\t\t\tdojo.lang.assert(false, message + \" \" + key);\n\t\t\t}\n\t\t}\n\t}"}}}}},"dojo.lang.common":{"meta":{"functions":{"dojo.lang.inherits":{"meta":{"summary":"Set up inheritance between two classes.","parameters":{"subclass":{"type":"Function"},"superclass":{"type":"Function"}},"src":" if(typeof superclass != 'function'){ \n\t\tdojo.raise(\"dojo.inherits: superclass argument [\"+superclass+\"] must be a function (subclass: [\"+subclass+\"']\");\n\t}\n\tsubclass.prototype = new superclass();\n\tsubclass.prototype.constructor = subclass;\n\tsubclass.superclass = superclass.prototype;\n\t\/\/ DEPRECATED: super is a reserved word, use 'superclass'\n\tsubclass['super'] = superclass.prototype;"}},"dojo.lang._mixin":{"meta":{"summary":"Adds all properties and methods of props to obj.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object"}},"src":" var tobj = {};\n\tfor(var x in props){\n\t\t\/\/ the \"tobj\" condition avoid copying properties in \"props\"\n\t\t\/\/ inherited from Object.prototype.  For example, if obj has a custom\n\t\t\/\/ toString() method, don't overwrite it with the toString() method\n\t\t\/\/ that props inherited from Object.protoype\n\t\tif((typeof tobj[x] == \"undefined\") || (tobj[x] != props[x])){\n\t\t\tobj[x] = props[x];\n\t\t}\n\t}\n\t\/\/ IE doesn't recognize custom toStrings in for..in\n\tif(dojo.render.html.ie \n\t\t&& (typeof(props[\"toString\"]) == \"function\")\n\t\t&& (props[\"toString\"] != obj[\"toString\"])\n\t\t&& (props[\"toString\"] != tobj[\"toString\"]))\n\t{\n\t\tobj.toString = props.toString;\n\t}\n\treturn obj; \/\/ Object","returns":"Object"}},"dojo.lang.mixin":{"meta":{"summary":"Adds all properties and methods of props to obj.","parameters":{"obj":{"type":"Object"},"props":{"type":"Object..."}},"src":" for(var i=1, l=arguments.length; i<l; i++){\n\t\tdojo.lang._mixin(obj, arguments[i]);\n\t}\n\treturn obj; \/\/ Object","returns":"Object"}},"dojo.lang.extend":{"meta":{"summary":"Adds all properties and methods of props to constructor's prototype, making them available to all instances created with constructor.","parameters":{"constructor":{"type":"Object"},"props":{"type":"Object..."}},"src":" for(var i=1, l=arguments.length; i<l; i++){\n\t\tdojo.lang._mixin(constructor.prototype, arguments[i]);\n\t}\n\treturn constructor; \/\/ Object","returns":"Object"}},"dojo.lang.find":{"meta":{"summary":"Return the index of value in array, returning -1 if not found.","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"Boolean?"},"findLast":{"type":"Boolean?"}},"src":" if(!dojo.lang.isArrayLike(array) && dojo.lang.isArrayLike(value)) {\n\t\tdojo.deprecated('dojo.lang.find(value, array)', 'use dojo.lang.find(array, value) instead', \"0.5\");\n\t\tvar temp = array;\n\t\tarray = value;\n\t\tvalue = temp;\n\t}\n\tvar isString = dojo.lang.isString(array);\n\tif(isString) { array = array.split(\"\"); }\n\tif(findLast) {\n\t\tvar step = -1;\n\t\tvar i = array.length - 1;\n\t\tvar end = -1;\n\t} else {\n\t\tvar step = 1;\n\t\tvar i = 0;\n\t\tvar end = array.length;\n\t}\n\tif(identity){\n\t\twhile(i != end) {\n\t\t\tif(array[i] === value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}else{\n\t\twhile(i != end) {\n\t\t\tif(array[i] == value){ return i; }\n\t\t\ti += step;\n\t\t}\n\t}\n\treturn -1;\t\/\/ number","returns":"number"},"extra":{"parameters":{"identity":{"type":"If","summary":"true, matches with identity comparison (===). If false, uses normal comparison (==)."},"findLast":{"type":"If","summary":"true, returns index of last instance of value. examples: find(array, value[, identity [findLast]]) \/\/ recommended find(value, array[, identity [findLast]]) \/\/ deprecated support both (array, value) and (value, array)"}}}},"dojo.lang.findLast":{"meta":{"summary":"Return index of last occurance of value in array, returning -1 if not found.","parameters":{"array":{"type":"Array"},"value":{"type":"Object"},"identity":{"type":"boolean?"}},"src":" return dojo.lang.find(array, value, identity, true); \/\/ number","returns":"number"},"extra":{"parameters":{"identity":{"type":"If","summary":"true, matches with identity comparison (===). If false, uses normal comparison (==)."}}}},"dojo.lang.inArray":{"meta":{"summary":"Return true if value is present in array.","parameters":{"array":{"type":"Array"},"value":{"type":"Object"}},"src":" return dojo.lang.find(array, value) > -1; \/\/ boolean","returns":"boolean"}},"dojo.lang.isObject":{"meta":{"summary":"Return true if it is an Object, Array or Function.","parameters":{"it":{"type":"anything"}},"src":" if(typeof it == \"undefined\"){ return false; }\n\treturn (typeof it == \"object\" || it === null || dojo.lang.isArray(it) || dojo.lang.isFunction(it)); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isArray":{"meta":{"summary":"Return true if it is an Array.","parameters":{"it":{"type":"anything"}},"src":" return (it && it instanceof Array || typeof it == \"array\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isArrayLike":{"meta":{"summary":"Return true if it can be used as an array (i.e. is an object with an integer length property).","parameters":{"it":{"type":"anything"}},"src":" if((!it)||(dojo.lang.isUndefined(it))){ return false; }\n\tif(dojo.lang.isString(it)){ return false; }\n\tif(dojo.lang.isFunction(it)){ return false; } \/\/ keeps out built-in constructors (Number, String, ...) which have length properties\n\tif(dojo.lang.isArray(it)){ return true; }\n\t\/\/ form node itself is ArrayLike, but not always iterable. Use form.elements instead.\n\tif((it.tagName)&&(it.tagName.toLowerCase()=='form')){ return false; }\n\tif(dojo.lang.isNumber(it.length) && isFinite(it.length)){ return true; }\n\treturn false; \/\/ Boolean","returns":"mixed"}},"dojo.lang.isFunction":{"meta":{"summary":"Return true if it is a Function.","parameters":{"it":{"type":"anything"}},"src":" if(!it){ return false; }\n\t\/\/ webkit treats NodeList as a function, which is bad\n\tif((typeof(it) == \"function\") && (it == \"[object NodeList]\")) { return false; }\n\treturn (it instanceof Function || typeof it == \"function\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isString":{"meta":{"summary":"Return true if it is a String.","parameters":{"it":{"type":"anything"}},"src":" return (typeof it == \"string\" || it instanceof String);"}},"dojo.lang.isAlien":{"meta":{"summary":"Return true if it is not a built-in function.","parameters":{"it":{"type":"anything"}},"src":" if(!it){ return false; }\n\treturn !dojo.lang.isFunction() && \/\\{\\s*\\[native code\\]\\s*\\}\/.test(String(it)); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isBoolean":{"meta":{"summary":"Return true if it is a Boolean.","parameters":{"it":{"type":"anything"}},"src":" return (it instanceof Boolean || typeof it == \"boolean\"); \/\/ Boolean","returns":"Boolean"}},"dojo.lang.isNumber":{"meta":{"summary":"Return true if it is a number.","parameters":{"it":{"type":"anything"}},"src":" return (it instanceof Number || typeof it == \"number\"); \/\/ Boolean","description":"WARNING - In most cases, isNaN(it) is sufficient to determine whether or not something is a number or can be used as such. For example, a number or string can be used interchangably when accessing array items (array[\"1\"] is the same as array[1]) and isNaN will return false for both values (\"1\" and 1). However, isNumber(\"1\") will return false, which is generally not too useful. Also, isNumber(NaN) returns true, again, this isn't generally useful, but there are corner cases (like when you want to make sure that two things are really the same type of thing). That is really where isNumber \"shines\". Recommendation - Use isNaN(it) when possible","returns":"Boolean"}},"dojo.lang.isUndefined":{"meta":{"summary":"Return true if it is not defined.","parameters":{"it":{"type":"anything"}},"src":"\treturn ((typeof(it) == \"undefined\")&&(it == undefined)); \/\/ Boolean","description":"WARNING - In some cases, isUndefined will not behave as you might expect. If you do isUndefined(foo) and there is no earlier reference to foo, an error will be thrown before isUndefined is called. It behaves correctly if you scope yor object first, i.e. isUndefined(foo.bar) where foo is an object and bar isn't a property of the object. Recommendation - Use typeof foo == \"undefined\" when possible","returns":"Boolean"}}}}},"dojo.lang.declare":{"meta":{"requires":{"common":["dojo.lang.common","dojo.lang.extras"]},"functions":{"dojo.lang.declare":{"meta":{"summary":"","parameters":{"className":{"type":"String"},"superclass":{"type":"Function|Array"},"init":{"type":"Function?"},"props":{"type":"Object|Array"}},"src":" if((dojo.lang.isFunction(props))||((!props)&&(!dojo.lang.isFunction(init)))){ \n\t \/\/ parameter juggling to support omitting init param (also allows reordering init and props arguments)\n\t\tvar temp = props;\n\t\tprops = init;\n\t\tinit = temp;\n\t}\t\n\tvar mixins = [ ];\n\tif(dojo.lang.isArray(superclass)){\n\t\tmixins = superclass;\n\t\tsuperclass = mixins.shift();\n\t}\n\tif(!init){\n\t\tinit = dojo.evalObjPath(className, false);\n\t\tif((init)&&(!dojo.lang.isFunction(init))){ init = null };\n\t}\n\tvar ctor = dojo.lang.declare._makeConstructor();\n\tvar scp = (superclass ? superclass.prototype : null);\n\tif(scp){\n\t\tscp.prototyping = true;\n\t\tctor.prototype = new superclass();\n\t\tscp.prototyping = false; \n\t}\n\tctor.superclass = scp;\n\tctor.mixins = mixins;\n\tfor(var i=0,l=mixins.length; i<l; i++){\n\t\tdojo.lang.extend(ctor, mixins[i].prototype);\n\t}\n\tctor.prototype.initializer = null;\n\tctor.prototype.declaredClass = className;\n\tif(dojo.lang.isArray(props)){\n\t\tdojo.lang.extend.apply(dojo.lang, [ctor].concat(props));\n\t}else{\n\t\tdojo.lang.extend(ctor, (props)||{});\n\t}\n\tdojo.lang.extend(ctor, dojo.lang.declare._common);\n\tctor.prototype.constructor = ctor;\n\tctor.prototype.initializer = (ctor.prototype.initializer)||(init)||(function(){});\n\tdojo.lang.setObjPathValue(className, ctor, null, true);\n\treturn ctor; \/\/ Function","returns":"Function","call_chain":["dojo.lang.extend"]}},"dojo.lang.declare._makeConstructor":{"meta":{"summary":"","src":" return function(){ \n\t\t\/\/ get the generational context (which object [or prototype] should be constructed)\n\t\tvar self = this._getPropContext();\n\t\tvar s = self.constructor.superclass;\n\t\tif((s)&&(s.constructor)){\n\t\t\tif(s.constructor==arguments.callee){\n\t\t\t\t\/\/ if this constructor is invoked directly (my.ancestor.call(this))\n\t\t\t\tthis._inherited(\"constructor\", arguments);\n\t\t\t}else{\n\t\t\t\tthis._contextMethod(s, \"constructor\", arguments);\n\t\t\t}\n\t\t}\n\t\tvar ms = (self.constructor.mixins)||([]);\n\t\tfor(var i=0, m; (m=ms[i]); i++) {\n\t\t\t(((m.prototype)&&(m.prototype.initializer))||(m)).apply(this, arguments);\n\t\t}\n\t\tif((!this.prototyping)&&(self.initializer)){\n\t\t\tself.initializer.apply(this, arguments);\n\t\t}\n\t}","call_chain":["self.initializer"]}},"dojo.lang.declare._common._getPropContext":{"meta":{"summary":"","src":" _getPropContext: function() { return (this.___proto||this);    "}},"dojo.lang.declare._common._contextMethod":{"meta":{"summary":"","parameters":{"ptype":{"type":""},"method":{"type":""},"args":{"type":""}},"src":" \tvar result, stack = this.___proto;\n\t\tthis.___proto = ptype;\n\t\ttry { result = ptype[method].apply(this,(args||[])); }\n\t\tcatch(e) { throw e; }\t\n\t\tfinally { this.___proto = stack; }\n\t\treturn result;","instance_variables":["___proto"]}},"dojo.lang.declare._common._inherited":{"meta":{"summary":"Searches backward thru prototype chain to find nearest ancestral instance of prop. Internal use only.","parameters":{"prop":{"type":""},"args":{"type":""}},"src":" \tvar p = this._getPropContext();\n\t\tdo{\n\t\t\tif((!p.constructor)||(!p.constructor.superclass)){return;}\n\t\t\tp = p.constructor.superclass;\n\t\t}while(!(prop in p));\n\t\treturn (dojo.lang.isFunction(p[prop]) ? this._contextMethod(p, prop, args) : p[prop]);"}},"dojo.lang.declare._common.inherited":{"meta":{"summary":"","parameters":{"prop":{"type":""},"args":{"type":""}},"src":" \tdojo.deprecated(\"'inherited' method is dangerous, do not up-call! 'inherited' is slated for removal in 0.5; name your super class (or use superclass property) instead.\", \"0.5\");\n\t\tthis._inherited(prop, args);"}}}}},"dojo.lang.extras":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.setTimeout":{"meta":{"summary":"Sets a timeout in milliseconds to execute a function in a given context with optional arguments. usage: setTimeout (Object context, function func, number delay[, arg1[, ...]]); setTimeout (function func, number delay[, arg1[, ...]]);","parameters":{"func":{"type":"Function"},"delay":{"type":"int , ..."}},"src":"\tvar context = window, argsStart = 2;\n\tif(!dojo.lang.isFunction(func)){\n\t\tcontext = func;\n\t\tfunc = delay;\n\t\tdelay = arguments[2];\n\t\targsStart++;\n\t}\n\tif(dojo.lang.isString(func)){\n\t\tfunc = context[func];\n\t}\n\tvar args = [];\n\tfor (var i = argsStart; i < arguments.length; i++){\n\t\targs.push(arguments[i]);\n\t}\n\treturn dojo.global().setTimeout(function () { func.apply(context, args); }, delay); \/\/ int","returns":"int","call_chain":["func"]}},"dojo.lang.clearTimeout":{"meta":{"summary":"clears timer by number from the execution queue","parameters":{"timer":{"type":"int"}},"src":" dojo.global().clearTimeout(timer);"}},"dojo.lang.getNameInObj":{"meta":{"summary":"looks for a value in the object ns with a value matching item and returns the property name","parameters":{"ns":{"type":"Object"},"item":{"type":"unknown"}},"src":" if(!ns){ ns = dj_global; }\n\tfor(var x in ns){\n\t\tif(ns[x] === item){\n\t\t\treturn new String(x); \/\/ String\n\t\t}\n\t}\n\treturn null; \/\/ null","returns":"mixed"},"extra":{"parameters":{"ns":{"type":"if","summary":"null, dj_global is used"},"item":{"type":"value","summary":"to match"}}}},"dojo.lang.shallowCopy":{"meta":{"summary":"copies object obj one level deep, or full depth if deep is true","parameters":{"obj":{"type":"Object"},"deep":{"type":"Boolean?"}},"src":" var i, ret;\t\n\tif(obj === null){ \/*obj: null*\/ return null; } \/\/ null\n\tif(dojo.lang.isObject(obj)){\n\t\t\/\/ obj: Object\t\n\t\tret = new obj.constructor();\n\t\tfor(i in obj){\n\t\t\tif(dojo.lang.isUndefined(ret[i])){\n\t\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t\t}\n\t\t}\n\t} else if(dojo.lang.isArray(obj)){\n\t\t\/\/ obj: Array\n\t\tret = [];\n\t\tfor(i=0; i<obj.length; i++){\n\t\t\tret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];\n\t\t}\n\t} else {\n\t\t\/\/ obj: unknown\n\t\tret = obj;\n\t}\n\treturn ret; \/\/ unknown","returns":"mixed"}},"dojo.lang.firstValued":{"meta":{"summary":"Return the first argument that isn't undefined","src":"\tfor(var i = 0; i < arguments.length; i++){\n\t\tif(typeof arguments[i] != \"undefined\"){\n\t\t\treturn arguments[i]; \/\/ unknown\n\t\t}\n\t}\n\treturn undefined; \/\/ undefined","returns":"mixed"}},"dojo.lang.getObjPathValue":{"meta":{"summary":"Gets a value from a reference specified as a string descriptor, (e.g. \"A.B\") in the given context.","parameters":{"objpath":{"type":"String"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"src":"\twith(dojo.parseObjPath(objpath, context, create)){\n\t\treturn dojo.evalProp(prop, obj, create); \/\/ unknown\n\t}","returns":"unknown"},"extra":{"parameters":{"context":{"type":"if","summary":"not specified, dj_global is used"},"create":{"type":"if","summary":"true, undefined objects in the path are created."}}}},"dojo.lang.setObjPathValue":{"meta":{"summary":"Sets a value on a reference specified as a string descriptor. (e.g. \"A.B\") in the given context.","parameters":{"objpath":{"type":"String"},"value":{"type":"unknown"},"context":{"type":"Object?"},"create":{"type":"Boolean?"}},"src":"\tif(arguments.length < 4){\n\t\tcreate = true;\n\t}\n\twith(dojo.parseObjPath(objpath, context, create)){\n\t\tif(obj && (create || (prop in obj))){\n\t\t\tobj[prop] = value;\n\t\t}\n\t}"},"extra":{"parameters":{"context":{"type":"if","summary":"not specified, dj_global is used"},"create":{"type":"if","summary":"true, undefined objects in the path are created."}}}}}}},"dojo.lang.func":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.hitch":{"meta":{"summary":"","parameters":{"thisObject":{"type":""},"method":{"type":""}},"src":" var fcn = (dojo.lang.isString(method) ? thisObject[method] : method) || function(){};\n\treturn function() {\n\t\treturn fcn.apply(thisObject, arguments);\n\t};","call_chain":["fcn"]}},"dojo.lang.nameAnonFunc":{"meta":{"summary":"","parameters":{"anonFuncPtr":{"type":""},"namespaceObj":{"type":""},"searchForNames":{"type":""}},"src":" var nso = (namespaceObj || dojo.lang.anon);\n\tif( (searchForNames) ||\n\t\t((dj_global[\"djConfig\"])&&(djConfig[\"slowAnonFuncLookups\"] == true)) ){\n\t\tfor(var x in nso){\n\t\t\ttry{\n\t\t\t\tif(nso[x] === anonFuncPtr){\n\t\t\t\t\treturn x;\n\t\t\t\t}\n\t\t\t}catch(e){} \/\/ window.external fails in IE embedded in Eclipse (Eclipse bug #151165)\n\t\t}\n\t}\n\tvar ret = \"__\"+dojo.lang.anonCtr++;\n\twhile(typeof nso[ret] != \"undefined\"){\n\t\tret = \"__\"+dojo.lang.anonCtr++;\n\t}\n\tnso[ret] = anonFuncPtr;\n\treturn ret;"}},"dojo.lang.forward":{"meta":{"summary":"","parameters":{"funcName":{"type":""}},"src":" return function(){\n\t\treturn this[funcName].apply(this, arguments);\n\t};"}},"dojo.lang.curry":{"meta":{"summary":"","parameters":{"ns":{"type":""},"func":{"type":"args ..."}},"src":" var outerArgs = [];\n\tns = ns||dj_global;\n\tif(dojo.lang.isString(func)){\n\t\tfunc = ns[func];\n\t}\n\tfor(var x=2; x<arguments.length; x++){\n\t\touterArgs.push(arguments[x]);\n\t}\n\t\/\/ since the event system replaces the original function with a new\n\t\/\/ join-point runner with an arity of 0, we check to see if it's left us\n\t\/\/ any clues about the original arity in lieu of the function's actual\n\t\/\/ length property\n\tvar ecount = (func[\"__preJoinArity\"]||func.length) - outerArgs.length;\n\t\/\/ borrowed from svend tofte\n\tfunction gather(nextArgs, innerArgs, expected){\n\t\tvar texpected = expected;\n\t\tvar totalArgs = innerArgs.slice(0); \/\/ copy\n\t\tfor(var x=0; x<nextArgs.length; x++){\n\t\t\ttotalArgs.push(nextArgs[x]);\n\t\t}\n\t\t\/\/ check the list of provided nextArgs to see if it, plus the\n\t\t\/\/ number of innerArgs already supplied, meets the total\n\t\t\/\/ expected.\n\t\texpected = expected-nextArgs.length;\n\t\tif(expected<=0){\n\t\t\tvar res = func.apply(ns, totalArgs);\n\t\t\texpected = texpected;\n\t\t\treturn res;\n\t\t}else{\n\t\t\treturn function(){\n\t\t\t\treturn gather(arguments,\/\/ check to see if we've been run\n\t\t\t\t\t\t\t\t\t\t\/\/ with enough args\n\t\t\t\t\t\t\ttotalArgs,\t\/\/ a copy\n\t\t\t\t\t\t\texpected);\t\/\/ how many more do we need to run?;\n\t\t\t};\n\t\t}\n\t}\n\treturn gather([], outerArgs, ecount);","returns":"check to see if we've been run","call_chain":["func"]}},"dojo.lang.curryArguments":{"meta":{"summary":"","parameters":{"ns":{"type":""},"func":{"type":""},"args":{"type":""},"offset":{"type":""}},"src":" var targs = [];\n\tvar x = offset||0;\n\tfor(x=offset; x<args.length; x++){\n\t\ttargs.push(args[x]); \/\/ ensure that it's an arr\n\t}\n\treturn dojo.lang.curry.apply(dojo.lang, [ns, func].concat(targs));","call_chain":["dojo.lang.curry"]}},"dojo.lang.tryThese":{"meta":{"summary":"","src":" for(var x=0; x<arguments.length; x++){\n\t\ttry{\n\t\t\tif(typeof arguments[x] == \"function\"){\n\t\t\t\tvar ret = (arguments[x]());\n\t\t\t\tif(ret){\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}catch(e){\n\t\t\tdojo.debug(e);\n\t\t}\n\t}"}},"dojo.lang.delayThese":{"meta":{"summary":"","parameters":{"farr":{"type":""},"cb":{"type":""},"delay":{"type":""},"onend":{"type":""}},"src":" if(!farr.length){ \n\t\tif(typeof onend == \"function\"){\n\t\t\tonend();\n\t\t}\n\t\treturn;\n\t}\n\tif((typeof delay == \"undefined\")&&(typeof cb == \"number\")){\n\t\tdelay = cb;\n\t\tcb = function(){};\n\t}else if(!cb){\n\t\tcb = function(){};\n\t\tif(!delay){ delay = 0; }\n\t}\n\tsetTimeout(function(){\n\t\t(farr.shift())();\n\t\tcb();\n\t\tdojo.lang.delayThese(farr, cb, delay, onend);\n\t}, delay);"}}}}},"dojo.lang.repr":{"meta":{"requires":{"common":["dojo.lang.common","dojo.AdapterRegistry","dojo.string.extras"]},"functions":{"dojo.lang.registerRepr":{"meta":{"summary":"Register a repr function. repr functions should take one argument and return a string representation of it suitable for developers, primarily used when debugging. If override is given, it is used as the highest priority repr, otherwise it will be used as the lowest.","parameters":{"name":{"type":"String"},"check":{"type":"Function"},"wrap":{"type":"Function"},"override":{"type":"Boolean?"}},"src":"\tdojo.lang.reprRegistry.register(name, check, wrap, override);"}},"dojo.lang.repr":{"meta":{"summary":"Return a \"programmer representation\" for an object","parameters":{"obj":{"type":"Object"}},"src":"\tif(typeof(obj) == \"undefined\"){\n\t\t\/\/ obj: undefined\n\t\treturn \"undefined\"; \/\/ String\n\t}else if(obj === null){\n\t\t\/\/ obj: null\n\t\treturn \"null\"; \/\/ String\n\t}\n\ttry{\n\t\tif(typeof(obj[\"__repr__\"]) == 'function'){\n\t\t\treturn obj[\"__repr__\"]();\n\t\t}else if((typeof(obj[\"repr\"]) == 'function')&&(obj.repr != arguments.callee)){\n\t\t\treturn obj[\"repr\"]();\n\t\t}\n\t\treturn dojo.lang.reprRegistry.match(obj);\n\t}catch(e){\n\t\tif(typeof(obj.NAME) == 'string' && (\n\t\t\t\tobj.toString == Function.prototype.toString ||\n\t\t\t\tobj.toString == Object.prototype.toString\n\t\t\t)){\n\t\t\treturn obj.NAME; \/\/ String\n\t\t}\n\t}\n\tif(typeof(obj) == \"function\"){\n\t\t\/\/ obj: Function\n\t\tobj = (obj + \"\").replace(\/^\\s+\/, \"\");\n\t\tvar idx = obj.indexOf(\"{\");\n\t\tif(idx != -1){\n\t\t\tobj = obj.substr(0, idx) + \"{...}\";\n\t\t}\n\t}\n\treturn obj + \"\"; \/\/ String","description":"returns a string representation of an object suitable for developers, primarily used when debugging","returns":"String"}},"dojo.lang.reprArrayLike":{"meta":{"summary":"Maps each element of arr to dojo.lang.repr and provides output in an array-like format","parameters":{"arr":{"type":"Array"}},"src":" try{\n\t\tvar na = dojo.lang.map(arr, dojo.lang.repr);\n\t\treturn \"[\" + na.join(\", \") + \"]\"; \/\/ String\n\t}catch(e){ }","description":"returns an array-like string representation of the provided array suitable for developers, primarily used when debugging","returns":"String"}}}}},"dojo.lang.timing.Streamer":{"meta":{"requires":{"common":["dojo.lang.timing.Timer"]},"functions":{"dojo.lang.timing.Streamer":{"meta":{"summary":"Streamer will take an input function that pushes N datapoints into a queue, and will pass the next point in that queue out to an","parameters":{"input":{"type":"function"},"output":{"type":"function"},"interval":{"type":"int"},"minimum":{"type":"int"},"initialData":{"type":"array"}},"src":"\tvar self = this;\n\tvar queue = [];\n\t\/\/\tpublic properties\n\tthis.interval = interval || 1000;\n\tthis.minimumSize = minimum || 10;\t\/\/\tlatency usually == interval * minimumSize\n\tthis.inputFunction = input || function(q){ };\n\tthis.outputFunction = output || function(point){ };\n\t\/\/\tmore setup\n\tvar timer = new dojo.lang.timing.Timer(this.interval);\n\tvar tick = function(){\n\t\tself.onTick(self);\n\t\tif(queue.length < self.minimumSize){\n\t\t\tself.inputFunction(queue);\n\t\t}\n\t\tvar obj = queue.shift();\n\t\twhile(typeof(obj) == \"undefined\" && queue.length > 0){\n\t\t\tobj = queue.shift();\n\t\t}\n\t\t\/\/\tcheck to see if the input function needs to be fired\n\t\t\/\/\tstop before firing the output function\n\t\t\/\/\tTODO: relegate this to the output function?\n\t\tif(typeof(obj) == \"undefined\"){\n\t\t\tself.stop();\n\t\t\treturn;\n\t\t}\n\t\t\/\/\tcall the output function.\n\t\tself.outputFunction(obj);\n\t};\n\tthis.setInterval = function(\/* int *\/ms){\n\t\t\/\/\tsummary\n\t\t\/\/\tsets the interval in milliseconds of the internal timer\n\t\tthis.interval = ms;\n\t\ttimer.setInterval(ms);\n\t};\n\tthis.onTick = function(\/* dojo.lang.timing.Streamer *\/obj){ };\n\t\/\/ wrap the timer functions so that we can connect to them if needed.\n\tthis.start = function(){\n\t\t\/\/\tsummary\n\t\t\/\/\tstarts the Streamer\n\t\tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\n\t\t\ttimer.start();\n\t\t\treturn;\n\t\t}\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");\n\t};\n\tthis.onStart = function(){ };\n\tthis.stop = function(){\n\t\t\/\/\tsummary\n\t\t\/\/\tstops the Streamer\n\t\ttimer.stop();\n\t};\n\tthis.onStop = function(){ };\n\t\/\/\tfinish initialization\n\ttimer.onTick = this.tick;\n\ttimer.onStart = this.onStart;\n\ttimer.onStop = this.onStop;\n\tif(initialData){\n\t\tqueue.concat(initialData);\n\t}","instance_variables":["interval","minimumSize","inputFunction","outputFunction","setInterval","onTick","start","onStart","stop","onStop"]},"extra":{"parameters":{"output":{"type":"the","summary":"function executed on internal tick"},"input":{"type":"the","summary":"function executed when the internal queue reaches minimumSize"},"minimum":{"type":"the","summary":"minimum number of elements in the internal queue."}},"variables":{"interval":{"type":"the","summary":"interval in ms at which the output function is fired."}}}},"dojo.lang.timing.Streamer.setInterval":{"meta":{"summary":"sets the interval in milliseconds of the internal timer","parameters":{"ms":{"type":"int"}},"src":" \tthis.interval = ms;\n\t\ttimer.setInterval(ms);","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onTick":{"meta":{"summary":"","parameters":{"obj":{"type":"dojo.lang.timing.Streamer"}},"src":"","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.start":{"meta":{"summary":"starts the Streamer","src":" \tif(typeof(this.inputFunction) == \"function\" && typeof(this.outputFunction) == \"function\"){\n\t\t\ttimer.start();\n\t\t\treturn;\n\t\t}\n\t\tdojo.raise(\"You cannot start a Streamer without an input and an output function.\");","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onStart":{"meta":{"summary":"","src":"","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.stop":{"meta":{"summary":"stops the Streamer","src":" \ttimer.stop();","instance":"dojo.lang.timing.Streamer"}},"dojo.lang.timing.Streamer.onStop":{"meta":{"summary":"","src":"","instance":"dojo.lang.timing.Streamer"}}}}},"dojo.lang.timing.Timer":{"meta":{"requires":{"common":["dojo.lang.func"]},"functions":{"dojo.lang.timing.Timer":{"meta":{"summary":"Timer object executes an \"onTick()\" method repeatedly at a specified interval. repeatedly at a given interval.","parameters":{"interval":{"type":"int"}},"src":" this.timer = null;\n\tthis.isRunning = false;\n\tthis.interval = interval;\n\tthis.onStart = null;\n\tthis.onStop = null;","instance_variables":["timer","isRunning","interval","onStart","onStop"]},"extra":{"variables":{"interval":{"type":"Interval","summary":"between function calls, in milliseconds."}}}}}}},"dojo.lang.type":{"meta":{"requires":{"common":["dojo.lang.common"]},"functions":{"dojo.lang.whatAmI":{"meta":{"summary":"","parameters":{"value":{"type":""}},"src":" dojo.deprecated(\"dojo.lang.whatAmI\", \"use dojo.lang.getType instead\", \"0.5\");\n\treturn dojo.lang.getType(value);"}},"dojo.lang.getType":{"meta":{"summary":"","parameters":{"value":{"type":"anything"}},"src":" try {\n\t\tif(dojo.lang.isArray(value)) { \n\t\t\treturn \"array\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isFunction(value)) { \n\t\t\treturn \"function\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isString(value)) { \n\t\t\treturn \"string\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isNumber(value)) { \n\t\t\treturn \"number\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isBoolean(value)) { \n\t\t\treturn \"boolean\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isAlien(value)) { \n\t\t\treturn \"alien\";\t\/\/\tstring \n\t\t}\n\t\tif(dojo.lang.isUndefined(value)) { \n\t\t\treturn \"undefined\";\t\/\/\tstring \n\t\t}\n\t\t\/\/ FIXME: should this go first?\n\t\tfor(var name in dojo.lang.whatAmI.custom) {\n\t\t\tif(dojo.lang.whatAmI.custom[name](value)) {\n\t\t\t\treturn name;\t\/\/\tstring\n\t\t\t}\n\t\t}\n\t\tif(dojo.lang.isObject(value)) { \n\t\t\treturn \"object\";\t\/\/\tstring \n\t\t}\n\t} catch(e) {}\n\treturn \"unknown\";\t\/\/\tstring","returns":"string"}},"dojo.lang.isNumeric":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"}},"src":" return (!isNaN(value) \n\t\t&& isFinite(value) \n\t\t&& (value != null) \n\t\t&& !dojo.lang.isBoolean(value) \n\t\t&& !dojo.lang.isArray(value) \n\t\t&& !\/^\\s*$\/.test(value)\n\t);\t\/\/\tboolean"}},"dojo.lang.isBuiltIn":{"meta":{"summary":"","parameters":{"value":{"type":"anything"}},"src":" return (dojo.lang.isArray(value)\n\t\t|| dojo.lang.isFunction(value)\t\n\t\t|| dojo.lang.isString(value)\n\t\t|| dojo.lang.isNumber(value)\n\t\t|| dojo.lang.isBoolean(value)\n\t\t|| (value == null)\n\t\t|| (value instanceof Error)\n\t\t|| (typeof value == \"error\") \n\t);\t\/\/\tboolean"}},"dojo.lang.isPureObject":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"}},"src":" return ((value != null) \n\t\t&& dojo.lang.isObject(value) \n\t\t&& value.constructor == Object\n\t);\t\/\/\tboolean"}},"dojo.lang.isOfType":{"meta":{"summary":"examples:","parameters":{"value":{"type":"anything"},"type":{"type":"function"},"keywordParameters":{"type":"object?"}},"src":" var optional = false;\n\tif (keywordParameters) {\n\t\toptional = keywordParameters[\"optional\"];\n\t}\n\tif (optional && ((value === null) || dojo.lang.isUndefined(value))) {\n\t\treturn true;\t\/\/\tboolean\n\t}\n\tif(dojo.lang.isArray(type)){\n\t\tvar arrayOfTypes = type;\n\t\tfor(var i in arrayOfTypes){\n\t\t\tvar aType = arrayOfTypes[i];\n\t\t\tif(dojo.lang.isOfType(value, aType)) {\n\t\t\t\treturn true; \t\/\/\tboolean\n\t\t\t}\n\t\t}\n\t\treturn false;\t\/\/\tboolean\n\t}else{\n\t\tif(dojo.lang.isString(type)){\n\t\t\ttype = type.toLowerCase();\n\t\t}\n\t\tswitch (type) {\n\t\t\tcase Array:\n\t\t\tcase \"array\":\n\t\t\t\treturn dojo.lang.isArray(value);\t\/\/\tboolean\n\t\t\tcase Function:\n\t\t\tcase \"function\":\n\t\t\t\treturn dojo.lang.isFunction(value);\t\/\/\tboolean\n\t\t\tcase String:\n\t\t\tcase \"string\":\n\t\t\t\treturn dojo.lang.isString(value);\t\/\/\tboolean\n\t\t\tcase Number:\n\t\t\tcase \"number\":\n\t\t\t\treturn dojo.lang.isNumber(value);\t\/\/\tboolean\n\t\t\tcase \"numeric\":\n\t\t\t\treturn dojo.lang.isNumeric(value);\t\/\/\tboolean\n\t\t\tcase Boolean:\n\t\t\tcase \"boolean\":\n\t\t\t\treturn dojo.lang.isBoolean(value);\t\/\/\tboolean\n\t\t\tcase Object:\n\t\t\tcase \"object\":\n\t\t\t\treturn dojo.lang.isObject(value);\t\/\/\tboolean\n\t\t\tcase \"pureobject\":\n\t\t\t\treturn dojo.lang.isPureObject(value);\t\/\/\tboolean\n\t\t\tcase \"builtin\":\n\t\t\t\treturn dojo.lang.isBuiltIn(value);\t\/\/\tboolean\n\t\t\tcase \"alien\":\n\t\t\t\treturn dojo.lang.isAlien(value);\t\/\/\tboolean\n\t\t\tcase \"undefined\":\n\t\t\t\treturn dojo.lang.isUndefined(value);\t\/\/\tboolean\n\t\t\tcase null:\n\t\t\tcase \"null\":\n\t\t\t\treturn (value === null);\t\/\/\tboolean\n\t\t\tcase \"optional\":\n\t\t\t\tdojo.deprecated('dojo.lang.isOfType(value, [type, \"optional\"])', 'use dojo.lang.isOfType(value, type, {optional: true} ) instead', \"0.5\");\n\t\t\t\treturn ((value === null) || dojo.lang.isUndefined(value));\t\/\/\tboolean\n\t\t\tdefault:\n\t\t\t\tif (dojo.lang.isFunction(type)) {\n\t\t\t\t\treturn (value instanceof type);\t\/\/\tboolean\n\t\t\t\t} else {\n\t\t\t\t\tdojo.raise(\"dojo.lang.isOfType() was passed an invalid type\");\n\t\t\t\t}\n\t\t}\n\t}\n\tdojo.raise(\"If we get here, it means a bug was introduced above.\");","returns":"boolean"}},"dojo.lang.getObject":{"meta":{"summary":"Will return an object, if it exists, based on the name in the passed string.","parameters":{"str":{"type":"String"}},"src":" var parts=str.split(\".\"), i=0, obj=dj_global; \n\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj!=dj_global)?obj:null;\t\/\/\tObject","returns":"Object"}},"dojo.lang.doesObjectExist":{"meta":{"summary":"Check to see if object [str] exists, based on the passed string.","parameters":{"str":{"type":"String"}},"src":" var parts=str.split(\".\"), i=0, obj=dj_global; \n\tdo{ \n\t\tobj=obj[parts[i++]]; \n\t}while(i<parts.length&&obj); \n\treturn (obj&&obj!=dj_global);\t\/\/\tboolean","returns":"boolean"}}}}},"dojo.lang":{"meta":{"requires":{"common":["dojo.lang.common"]}}}}